{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Using dot-prefixed nodes as data segments (ignored by evaluator)"},{"role":"assistant","content":".src:foo\\n.dest\\nset-value:x:@.dest\\n   get-value:x:@.src\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Composing a dynamic node expression from parts"},{"role":"assistant","content":"compose\\n   .:..\\n   .:*\\n   .:.data\\n   .:*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Evaluate a lambda stored in a data node"},{"role":"assistant","content":".res\\n.lambda\\n   set-value:x:@.res\\n      .:Hello\\neval:x:@.lambda\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Evaluate all lambda objects under the current node sequentially (result becomes 'Second')"},{"role":"assistant","content":".res:\\n.lambda\\n   set-value:x:@.res\\n      .:First\\n.lambda\\n   set-value:x:@.res\\n      .:Second\\neval:x:../*/.lambda\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Inline lambda execution by providing the lambda body as children"},{"role":"assistant","content":".res\\neval\\n   set-value:x:@.res\\n      .:Inline\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Invoke a lambda with arguments and capture its return value"},{"role":"assistant","content":".lambda\\n   strings.concat\\n      .:\"Hello \"\\n      get-value:x:@.arguments/*/name\\n   return:x:-\\ninvoke:x:@.lambda\\n   name:World\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Execute a block only if the condition is true"},{"role":"assistant","content":".result\\nif\\n   .:bool:true\\n   .lambda\\n      set-value:x:@.result\\n         .:Yes\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Shorthand if using an expression directly (no explicit .lambda child)"},{"role":"assistant","content":".flag:bool:true\\n.result\\nif:x:@.flag\\n   set-value:x:@.result\\n      .:Yes\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Use else-if after an if to check an alternate condition"},{"role":"assistant","content":".result\\nif\\n   .:bool:false\\n   .lambda\\n      set-value:x:@.result\\n         .:One\\nelse-if\\n   .:bool:true\\n   .lambda\\n      set-value:x:@.result\\n         .:Two\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Conditional execution using [if], [else-if], and [else]"},{"role":"assistant","content":".value:int:10\\nif\\n   eq:x:@.value\\n      .:int:10\\n   .lambda\\n      log.info:Value is 10\\nelse-if\\n   lt:x:@.value\\n      .:int:10\\n   .lambda\\n      log.info:Value is less than 10\\nelse\\n   log.info:Value is greater than 10\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Else-if using an expression shorthand for its condition"},{"role":"assistant","content":".flag:bool:true\\n.result\\nif\\n   .:bool:false\\n   .lambda\\n      set-value:x:@.result\\n         .:First\\nelse-if:x:@.flag\\n   set-value:x:@.result\\n      .:Second\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Fallback else block when prior if/else-if conditions are false"},{"role":"assistant","content":".value:int:3\\n.result\\nif\\n   eq\\n      get-value:x:@.value\\n      .:int:1\\n   .lambda\\n      set-value:x:@.result\\n         .:One\\nelse-if\\n   eq\\n      get-value:x:@.value\\n      .:int:2\\n   .lambda\\n      set-value:x:@.result\\n         .:Two\\nelse\\n   set-value:x:@.result\\n      .:Other\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Switch-case selecting the matching case block"},{"role":"assistant","content":".val:foo\\n.result\\nswitch:x:@.val\\n   case:bar\\n      set-value:x:@.result\\n         .:No\\n   case:foo\\n      set-value:x:@.result\\n         .:Yes\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Switch-case with a default when no case matches"},{"role":"assistant","content":".val:baz\\n.result\\nswitch:x:@.val\\n   case:foo\\n      set-value:x:@.result\\n         .:First\\n   case:bar\\n      set-value:x:@.result\\n         .:Second\\n   default\\n      set-value:x:@.result\\n         .:None\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"eq returns false if values are not equal or types differ"},{"role":"assistant","content":".a:5\\n.b:int:5\\neq\\n   get-value:x:@.a\\n   get-value:x:@.b\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Using eq with an expression as the left-hand side (LHS)"},{"role":"assistant","content":".foo:bar\\neq:x:@.foo\\n   .:bar\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"neq returns true if two values are different"},{"role":"assistant","content":".src:int:5\\nneq\\n   get-value:x:@.src\\n   .:int:10\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"neq returns true if values or types differ (opposite of eq)"},{"role":"assistant","content":".a:5\\n.b:int:5\\nneq\\n   get-value:x:@.a\\n   get-value:x:@.b\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"lt returns true if the left value is less than the right value"},{"role":"assistant","content":".x:int:4\\nlt\\n   get-value:x:@.x\\n   .:int:5\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Looping through a collection with [for-each]"},{"role":"assistant","content":".items\\n   item1:Apple\\n   item2:Banana\\n   item3:Cherry\\nfor-each:x:@.items/*\\n\\n   // Logs each item value\\n   log.info:x:@.dp/#\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"lt returns false if the left value is not less than the right value"},{"role":"assistant","content":".x:int:7\\nlt\\n   get-value:x:@.x\\n   .:int:5\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"lte returns false if the left value is greater than the right"},{"role":"assistant","content":".x:int:6\\nlte\\n   get-value:x:@.x\\n   .:int:5\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"mt returns true if the left value is greater than the right value"},{"role":"assistant","content":".x:int:7\\nmt\\n   get-value:x:@.x\\n   .:int:5\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"mt returns false if the left value is not greater than the right value"},{"role":"assistant","content":".x:int:3\\nmt\\n   get-value:x:@.x\\n   .:int:5\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"mte returns true if the left value is greater than or equal to the right"},{"role":"assistant","content":".x:int:5\\nmte\\n   get-value:x:@.x\\n   .:int:5\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"mte returns false if the left value is less than the right"},{"role":"assistant","content":".x:int:4\\nmte\\n   get-value:x:@.x\\n   .:int:5\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Shorthand mte with an expression as the left-hand side"},{"role":"assistant","content":".val:int:7\\nmte:x:@.val\\n   .:int:5\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"[and] returns false if any argument is false"},{"role":"assistant","content":"and\\n   .:bool:true\\n   .:bool:false\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"A root node with a name and value, containing one child node"},{"role":"assistant","content":"root:value\\n   child\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"[or] returns false if all arguments are false"},{"role":"assistant","content":"or\\n   .:bool:false\\n   .:bool:false\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"[or] returns true if at least one argument is true"},{"role":"assistant","content":"or\\n   .:bool:false\\n   .:bool:true\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"[not] returns false for a true input"},{"role":"assistant","content":"not\\n   .:bool:true\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"[not] returns true for a false input"},{"role":"assistant","content":"not\\n   .:bool:false\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Append multiple new child nodes to a destination node"},{"role":"assistant","content":".dest\\nadd:x:@.dest\\n   .\\n      foo1:hello\\n      foo2:world\\n   .\\n      bar1:hi\\n      bar2:planet\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Add children from a source node into a destination node"},{"role":"assistant","content":".src\\n   a:1\\n   b:2\\n.dest\\nadd:x:@.dest\\n   get-nodes:x:@.src/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Insert a node before a specified existing node"},{"role":"assistant","content":".list\\n   item1\\n   item2\\ninsert-before:x:@.list/*/item1\\n   .\\n      inserted\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Insert a node after a specified existing node"},{"role":"assistant","content":".list\\n   item1\\n   item2\\ninsert-after:x:@.list/*/item1\\n   .\\n      inserted\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Remove all nodes matching the expression (delete item2)"},{"role":"assistant","content":".data\\n   foo1\\n   foo2\\n   foo3\\nremove-nodes:x:@.data/*/foo2\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"A parent node with multiple children and nested sub-children"},{"role":"assistant","content":"parent\\n   child1:foo\\n      subchild:bar\\n   child2\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Include a generated subtree into each node matched by the expression"},{"role":"assistant","content":".data\\n   item1:foo\\n   item2:bar\\ninclude:x:@.data/*\\n   return\\n      child:added\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Set the value of multiple target nodes at once"},{"role":"assistant","content":".foo\\n.foo\\nset-value:x:../*/.foo\\n   .:Done\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Set a node's value based on another node's value"},{"role":"assistant","content":".src:Hello\\n.dest\\nset-value:x:@.dest\\n   get-value:x:@.src\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Unwrap a value so it’s evaluated before use"},{"role":"assistant","content":".src:Hello World\\nunwrap:x:+\\n.dest:x:@.src\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Unwrap a list of nodes into a target node (applying lists)"},{"role":"assistant","content":".src\\n   foo1:bar1\\n   foo2:bar2\\nunwrap:x:+\\n   apply-lists:bool:true\\n.dest:x:@.src/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Retrieve the value of a specified node"},{"role":"assistant","content":".data:Hello World\\nget-value:x:@.data\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Retrieve the name of a specified node"},{"role":"assistant","content":".foo\\nget-name:x:@.foo\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Count the number of child nodes under .list"},{"role":"assistant","content":".list\\n   item1\\n   item2\\nget-count:x:@.list/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Retrieve all nodes matching an expression"},{"role":"assistant","content":".data\\n   foo1\\n   foo2\\nget-nodes:x:@.data/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Using a double-quoted string with an escaped newline character"},{"role":"assistant","content":".message:\"Hello\\nWorld\"\\n\\n// Using a single-quoted string (literal, escapes are not processed)\\n.text:\"Hello\\nWorld\"\\n\\n// Using @ prefix for a multi-line string (preserves line breaks)\\n.multi_line:\"First line\\nSecond line\\nThird line\"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"[exists] returns false if the expression finds no nodes"},{"role":"assistant","content":".empty\\nexists:x:@.empty/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"[not-exists] returns true if the expression yields no nodes"},{"role":"assistant","content":".empty\\nnot-exists:x:@.empty/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"[not-exists] returns false if the expression finds at least one node"},{"role":"assistant","content":".list\\n   item\\nnot-exists:x:@.list/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"[null] returns false if the target node exists and has a value"},{"role":"assistant","content":".src1\\n   foo:bar\\nnull:x:@.src1/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"[null] returns true if the target node has no value"},{"role":"assistant","content":".src2\\n   foo\\nnull:x:@.src2/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"[not-null] returns true if the target node has a value"},{"role":"assistant","content":".src\\n   foo:bar\\nnot-null:x:@.src/*/foo\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"[not-null] returns false if the target node has no value"},{"role":"assistant","content":".src\\n   foo\\nnot-null:x:@.src/*/foo\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Store a value in context and retrieve it inside a nested execution"},{"role":"assistant","content":".result\\ncontext:foo\\n   value:bar\\n   .lambda\\n      set-value:x:@.result\\n         get-context:foo\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Use try with .catch and .finally to handle exceptions"},{"role":"assistant","content":"try\\n   throw:Error occurred\\n.catch\\n   log.info:Caught the error\\n.finally\\n   log.info:Cleanup done\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Throw an exception with a custom message"},{"role":"assistant","content":"throw:Something went wrong\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Throw an exception with additional metadata (HTTP status, visibility, field)"},{"role":"assistant","content":"throw:Not found\\n   status:404\\n   public:true\\n   field:resource-id\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Iterate over each child node and perform an operation"},{"role":"assistant","content":".list\\n   item1\\n   item2\\nfor-each:x:@.list/*\\n   set-value:x:@.dp/#\\n      .:processed\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Loop while a condition is true (increment counter and add items)"},{"role":"assistant","content":".i:int:0\\n.list\\nwhile\\n   lt\\n      get-value:x:@.i\\n      .:int:3\\n   .lambda\\n      add:x:@.list\\n         .\\n            item\\n      math.increment:x:@.i\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Retrieve all supported Hyperlambda data types"},{"role":"assistant","content":"types\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Convert a numeric string to an integer type"},{"role":"assistant","content":".str:42\\nconvert:x:@.str\\n   type:int\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Convert a string to its Base64 representation"},{"role":"assistant","content":".txt:Hello\\nconvert:x:@.txt\\n   type:base64\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Format an integer with leading zeros (width 5)"},{"role":"assistant","content":".num:int:57\\nformat:x:@.num\\n   pattern:\"{0:00000}\"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"This example shows a file-level multi-line comment above code"},{"role":"assistant","content":"foo:bar\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Format a decimal number with two decimals using a specific culture"},{"role":"assistant","content":".num:decimal:57.5\\nformat:x:@.num\\n   pattern:\"{0:0.00}\"\\n   culture:nb-NO\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Convert a large integer to its word representation"},{"role":"assistant","content":"int2words:1200050\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Convert a negative integer to words"},{"role":"assistant","content":"int2words:-42\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"List all slots whose names start with a given prefix"},{"role":"assistant","content":"vocabulary:io.file\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Limit the slots that can be invoked within a code block"},{"role":"assistant","content":".result\\nwhitelist\\n   vocabulary\\n      set-value\\n      return\\n   .lambda\\n\\n      // Allowed: this uses whitelisted [set-value]\\n      set-value:x:@.result\\n         .:foo\\n\\n      // Disallowed if dot is removed: [add] is not whitelisted\\n      .add:x:@.result\\n         .\\n            extra:bar\\n      return\\n         status:success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Demonstrating an indented comment inside a code block"},{"role":"assistant","content":".list\\n   item1\\n   item2\\nfor-each:x:@.list/*\\n\\n   // This comment describes the loop body and is indented correctly\\n   set-value:x:@.dp/#\\n      .:processed\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Adds a bunch of nodes into specified destination expression's children collection."},{"role":"assistant","content":"add:x:@.destination\\n   .\\n      foo:bar\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns minimum, maximum, average or sum from your Album table in your chinook database"},{"role":"assistant","content":".arguments\\n\\n   // Function to aggregate upon. Argument is mandatory and legal values are min, max, sum or avg\\n   aggregate_function:string\\n\\n   // Argument is mandatory and must be in the format of TABLE_NAME.COLUMN_NAME.\\n   aggregate_column:string\\n\\n   // Optional logical operator for filtering arguments, can be either 'or' or 'and'. Defaults to and.\\n   operator:string\\n   Album.AlbumId.mt:long\\n   Album.AlbumId.lt:long\\n   Album.AlbumId.mteq:long\\n   Album.AlbumId.lteq:long\\n   Album.AlbumId.neq:long\\n   Album.AlbumId.eq:long\\n   Album.Title.like:string\\n   Album.Title.mt:string\\n   Album.Title.lt:string\\n   Album.Title.mteq:string\\n   Album.Title.lteq:string\\n   Album.Title.neq:string\\n   Album.Title.eq:string\\n   Album.ArtistId.mt:long\\n   Album.ArtistId.lt:long\\n   Album.ArtistId.mteq:long\\n   Album.ArtistId.lteq:long\\n   Album.ArtistId.neq:long\\n   Album.ArtistId.eq:long\\n   ArtistId.Name.eq:string\\n   ArtistId.Name.like:string\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-aggregate\\n\\n// Sanity checking mandatory arguments.\\nvalidators.mandatory:x:@.arguments/*/aggregate_function\\nvalidators.mandatory:x:@.arguments/*/aggregate_column\\n\\n// Sanity checking name of aggregate function.\\nvalidators.enum:x:@.arguments/*/aggregate_function\\n   .:min\\n   .:max\\n   .:sum\\n   .:avg\\n\\n// Sanity checking agggregate column name.\\nvalidators.enum:x:@.arguments/*/aggregate_column\\n   .:Album.AlbumId\\n   .:Album.Title\\n   .:Album.ArtistId\\n   .:ArtistId.Name\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root,admin\\n\\n// Sanity checking invocation.\\nvalidators.enum:x:@.arguments/*/operator\\n   .:or\\n   .:and\\n\\n/*\\n * Checking if user supplied an [operator] argument, and if so\\n * changing the boolean operator for comparison operations.\\n */\\nif\\n   exists:x:@.arguments/*/operator\\n   .lambda\\n\\n      // User provided a boolean comparison [operator] argument.\\n      set-name:x:../*/data.connect/*/data.read/*/where/0\\n         get-value:x:@.arguments/*/operator\\n      remove-nodes:x:@.arguments/*/operator\\n\\n// Opening up our database connection.\\ndata.connect:[generic|chinook]\\n   database-type:sqlite\\n\\n   // Making sure we're using correct aggregate function.\\n   set-name:x:./*/data.read/*/columns/*/aggregate_functor\\n      strings.concat\\n         get-value:x:@.arguments/*/aggregate_function\\n         .:(\\n         get-value:x:@.arguments/*/aggregate_column\\n         .:)\\n\\n   // Removing aggregate arguments to simplify adding other arguments.\\n   remove-nodes:x:@.arguments/*/[0,2]\\n\\n   // Adding filtering arguments.\\n   add:x:+/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:sqlite\\n      table:Album\\n         join:Artist\\n            as:ArtistId\\n            type:left\\n            on\\n               and\\n                  Album.ArtistId:ArtistId.ArtistId\\n      columns\\n         aggregate_functor\\n            as:result\\n      where\\n         and\\n      limit:long:1\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Count unique and distinct items from your Album table in your chinook database"},{"role":"assistant","content":".arguments\\n\\n   // Argument is mandatory and must be in the format of TABLE_NAME.COLUMN_NAME\\n   distinct_column:string\\n\\n   // Optional logical operator for filtering arguments, can be either 'or' or 'and'. Defaults to and.\\n   operator:string\\n   Album.AlbumId.mt:long\\n   Album.AlbumId.lt:long\\n   Album.AlbumId.mteq:long\\n   Album.AlbumId.lteq:long\\n   Album.AlbumId.neq:long\\n   Album.AlbumId.eq:long\\n   Album.Title.like:string\\n   Album.Title.mt:string\\n   Album.Title.lt:string\\n   Album.Title.mteq:string\\n   Album.Title.lteq:string\\n   Album.Title.neq:string\\n   Album.Title.eq:string\\n   Album.ArtistId.mt:long\\n   Album.ArtistId.lt:long\\n   Album.ArtistId.mteq:long\\n   Album.ArtistId.lteq:long\\n   Album.ArtistId.neq:long\\n   Album.ArtistId.eq:long\\n   ArtistId.Name.eq:string\\n   ArtistId.Name.like:string\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-count-distinct\\n\\n// Sanity checking that distinct column was passed in.\\nvalidators.mandatory:x:@.arguments/*/distinct_column\\n\\n// Sanity checking distinct column's name.\\nvalidators.enum:x:@.arguments/*/distinct_column\\n   .:Album.AlbumId\\n   .:Album.Title\\n   .:Album.ArtistId\\n   .:ArtistId.Name\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root,admin\\n\\n// Sanity checking invocation.\\nvalidators.enum:x:@.arguments/*/operator\\n   .:or\\n   .:and\\n\\n/*\\n * Checking if user supplied an [operator] argument, and if so\\n * changing the boolean operator for comparison operations.\\n */\\nif\\n   exists:x:@.arguments/*/operator\\n   .lambda\\n\\n      // User provided a boolean comparison [operator] argument.\\n      set-name:x:../*/data.connect/*/data.read/*/where/0\\n         get-value:x:@.arguments/*/operator\\n      remove-nodes:x:@.arguments/*/operator\\n\\n// Opening up our database connection.\\ndata.connect:[generic|chinook]\\n   database-type:sqlite\\n\\n   // Making sure we're using correct function.\\n   set-name:x:./*/data.read/*/columns/*/distinct_functor\\n      strings.concat\\n         .:\"count(distinct \"\\n         get-value:x:@.arguments/*/distinct_column\\n         .:)\\n\\n   // Removing distinct argument to simplify adding other arguments.\\n   remove-nodes:x:@.arguments/*/distinct_column\\n\\n   // Adding filtering arguments.\\n   add:x:+/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:sqlite\\n      table:Album\\n         join:Artist\\n            as:ArtistId\\n            type:left\\n            on\\n               and\\n                  Album.ArtistId:ArtistId.ArtistId\\n      columns\\n         distinct_functor\\n            as:count\\n      where\\n         and\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Counts items from your Album table in your chinook database"},{"role":"assistant","content":".arguments\\n\\n   // Optional logical operator for filtering arguments, can be either 'or' or 'and'. Defaults to and.\\n   operator:string\\n   Album.AlbumId.mt:long\\n   Album.AlbumId.lt:long\\n   Album.AlbumId.mteq:long\\n   Album.AlbumId.lteq:long\\n   Album.AlbumId.neq:long\\n   Album.AlbumId.eq:long\\n   Album.Title.like:string\\n   Album.Title.mt:string\\n   Album.Title.lt:string\\n   Album.Title.mteq:string\\n   Album.Title.lteq:string\\n   Album.Title.neq:string\\n   Album.Title.eq:string\\n   Album.ArtistId.mt:long\\n   Album.ArtistId.lt:long\\n   Album.ArtistId.mteq:long\\n   Album.ArtistId.lteq:long\\n   Album.ArtistId.neq:long\\n   Album.ArtistId.eq:long\\n   ArtistId.Name.eq:string\\n   ArtistId.Name.like:string\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-count\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root,admin\\n\\n// Sanity checking invocation.\\nvalidators.enum:x:@.arguments/*/operator\\n   .:or\\n   .:and\\n\\n/*\\n * Checking if user supplied an [operator] argument, and if so\\n * changing the boolean operator for comparison operations.\\n */\\nif\\n   exists:x:@.arguments/*/operator\\n   .lambda\\n\\n      // User provided a boolean comparison [operator] argument.\\n      set-name:x:../*/data.connect/*/data.read/*/where/0\\n         get-value:x:@.arguments/*/operator\\n      remove-nodes:x:@.arguments/*/operator\\n\\n// Opening up our database connection.\\ndata.connect:[generic|chinook]\\n   database-type:sqlite\\n\\n   // Adding filtering arguments.\\n   add:x:+/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:sqlite\\n      table:Album\\n         join:Artist\\n            as:ArtistId\\n            type:left\\n            on\\n               and\\n                  Album.ArtistId:ArtistId.ArtistId\\n      columns\\n         count(*)\\n            as:count\\n      where\\n         and\\n      limit:long:1\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns minimum, maximum, average, sum or count from your Album table in your chinook database grouped by a column"},{"role":"assistant","content":".arguments\\n\\n   // Mandatory argument being column to group by and must be in the format of TABLE_NAME.COLUMN_NAME\\n   group_column:string\\n\\n   // Number of records to return, defaults to 25 if not specified. Pass in -1 to return all records.\\n   limit:long\\n\\n   // Offset into the dataset of where to start retrieving records\\n   offset:long\\n\\n   // Fully qualified name of column to order by, must be in TABLE_NAME.COLUMN_NAME format\\n   order:string\\n\\n   // What direction to order, can be 'asc' or 'desc' implying ascending and descending\\n   direction:string\\n\\n   // Function to aggregate upon. Argument is mandatory and legal values are min, max, sum, avg or count\\n   aggregate_function:string\\n\\n   // Argument is mandatory and must be in the format of TABLE_NAME.COLUMN_NAME.\\n   aggregate_column:string\\n\\n   // Optional logical operator for filtering arguments, can be either 'or' or 'and'. Defaults to and.\\n   operator:string\\n   Album.AlbumId.mt:long\\n   Album.AlbumId.lt:long\\n   Album.AlbumId.mteq:long\\n   Album.AlbumId.lteq:long\\n   Album.AlbumId.neq:long\\n   Album.AlbumId.eq:long\\n   Album.Title.like:string\\n   Album.Title.mt:string\\n   Album.Title.lt:string\\n   Album.Title.mteq:string\\n   Album.Title.lteq:string\\n   Album.Title.neq:string\\n   Album.Title.eq:string\\n   Album.ArtistId.mt:long\\n   Album.ArtistId.lt:long\\n   Album.ArtistId.mteq:long\\n   Album.ArtistId.lteq:long\\n   Album.ArtistId.neq:long\\n   Album.ArtistId.eq:long\\n   ArtistId.Name.eq:string\\n   ArtistId.Name.like:string\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-group\\n\\n// Sanity checking mandatory arguments.\\nvalidators.mandatory:x:@.arguments/*/group_column\\nvalidators.mandatory:x:@.arguments/*/aggregate_function\\nvalidators.mandatory:x:@.arguments/*/aggregate_column\\n\\n// Sanity checking name of aggregate function.\\nvalidators.enum:x:@.arguments/*/aggregate_function\\n   .:min\\n   .:max\\n   .:sum\\n   .:avg\\n   .:count\\n\\n// Sanity checking group column.\\nvalidators.enum:x:@.arguments/*/group_column\\n   .:Album.AlbumId\\n   .:Album.Title\\n   .:Album.ArtistId\\n   .:ArtistId.Name\\n\\n// Sanity checking agggregate column name.\\nvalidators.enum:x:@.arguments/*/aggregate_column\\n   .:Album.AlbumId\\n   .:Album.Title\\n   .:Album.ArtistId\\n   .:ArtistId.Name\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root,admin\\n\\n// Sanity checking invocation.\\nvalidators.enum:x:@.arguments/*/operator\\n   .:or\\n   .:and\\n\\n/*\\n * Checking if user supplied an [operator] argument, and if so\\n * changing the boolean operator for comparison operations.\\n */\\nif\\n   exists:x:@.arguments/*/operator\\n   .lambda\\n\\n      // User provided a boolean comparison [operator] argument.\\n      set-name:x:../*/data.connect/*/data.read/*/where/0\\n         get-value:x:@.arguments/*/operator\\n      remove-nodes:x:@.arguments/*/operator\\n\\n// Opening up our database connection.\\ndata.connect:[generic|chinook]\\n   database-type:sqlite\\n\\n   // Making sure we're using the correct group column\\n   set-name:x:@data.connect/*/data.read/*/group/*/group_column\\n      get-value:x:@.arguments/*/group_column\\n\\n   // Making sure we return group column as a part of the result\\n   set-name:x:+/*/*\\n      get-value:x:@.arguments/*/group_column\\n   insert-before:x:@data.connect/*/data.read/*/columns/0\\n      .\\n         group_column\\n\\n   // Changing name of aggregate column returned to caller.\\n   set-value:x:@data.connect/*/data.read/*/columns/1/*/as\\n      get-value:x:@.arguments/*/aggregate_function\\n\\n   // Removing group column to simplify adding other arguments\\n   remove-nodes:x:@.arguments/*/group_column\\n\\n   // Adding paging arguments\\n   add:x:@data.connect/*/data.read\\n      get-nodes:x:@.arguments/*/limit\\n      get-nodes:x:@.arguments/*/offset\\n   remove-nodes:x:@.arguments/*/limit\\n   remove-nodes:x:@.arguments/*/offset\\n\\n   // Parametrising our read invocation with ordering arguments if specified.\\n   add:x:./*/data.read\\n      get-nodes:x:@.arguments/*/order\\n      get-nodes:x:@.arguments/*/direction\\n   remove-nodes:x:@.arguments/*/order\\n   remove-nodes:x:@.arguments/*/direction\\n\\n   // Making sure we're using correct aggregate function.\\n   set-name:x:./*/data.read/*/columns/*/aggregate_functor\\n      strings.concat\\n         get-value:x:@.arguments/*/aggregate_function\\n         .:(\\n         get-value:x:@.arguments/*/aggregate_column\\n         .:)\\n\\n   // Removing aggregate arguments to simplify adding other arguments.\\n   remove-nodes:x:@.arguments/*/[0,2]\\n\\n   // Adding filtering arguments.\\n   add:x:+/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:sqlite\\n      table:Album\\n         join:Artist\\n            as:ArtistId\\n            type:left\\n            on\\n               and\\n                  Album.ArtistId:ArtistId.ArtistId\\n      columns\\n         aggregate_functor\\n            as:result\\n      where\\n         and\\n      group\\n         group_column\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Distinct Keyword Search from Album table in chinook database.\\n\\nThis endpoint will return only records containing one or more of the keywords from the specified [query],\\nwith rows containing the most distinct matched keywords appearing first."},{"role":"assistant","content":".arguments\\n\\n   // Mandatory query for records to search for\\n   query:string\\n\\n   // Optional number of records to return, defaults to 10 if not specified. Pass in -1 to return all records\\n   limit:long\\n\\n   // Optional offset into the dataset of where to start retrieving records\\n   offset:long\\n\\n// Type of endpoint\\n.type:crud-search\\n\\n// Make sure the user has provided a query.\\nvalidators.mandatory:x:@.arguments/*/query\\n\\n// Apply defaults if not specified.\\nvalidators.default:x:@.arguments\\n   limit:long:10\\n\\n// Split the user's query into individual keywords, separated by spaces.\\n.words\\nadd:x:@.words\\n   strings.split:x:@.arguments/*/query\\n      .:\" \"\\n\\n// Enforce lower characters for each keyword, and guard against SQL injection.\\n.no:int:0\\nfor-each:x:@.words/*\\n   set-value:x:@.dp/#\\n      strings.to-lower:x:@.dp/#\\n\\n// Specify which columns to search against.\\n.columns\\n   .:Title\\n\\n// Connect to the specified database.\\ndata.connect:[generic|chinook]\\n   database-type:sqlite\\n\\n   // Start building our SQL.\\n   .sql:select *, (\\n\\n   // 1) Dynamically create the full text by concatenating all columns we want to search.\\n   .fields\\n   for-each:x:@.columns/*\\n      strings.concat\\n         .:coalesce(\\n         get-value:x:@.dp/#\\n         .:\", '')\"\\n      unwrap:x:+/*/*\\n      add:x:@.fields\\n         .\\n            .:x:@strings.concat\\n   set-value:x:@.fields\\n      strings.join:x:@.fields/*\\n         .:\" || \"\\n   remove-nodes:x:@.fields/*\\n\\n   // 2) Keyword density calculation\\n   .no:int:0\\n   for-each:x:@.words/*\\n\\n      // Adding SQL parameter.\\n      set-name:x:+/+/*/*\\n         strings.concat\\n            .:@p\\n            get-value:x:@.no\\n      unwrap:x:+/*/*\\n      add:x:@data.connect/*/data.select\\n         .\\n            .:x:@.dp/#\\n\\n      // Modifying our SQL.\\n      if\\n         eq:x:@.no\\n            .:int:0\\n         .lambda\\n\\n            // First keyword => no leading plus\\n            set-value:x:@.sql\\n               strings.concat:x:@.sql\\n                  get-value:x:@.sql\\n                  .:\" (length(\"\\n                  get-value:x:@.fields\\n                  .:) - length(replace(lower(\\n                  get-value:x:@.fields\\n                  .:), @p\\n                  get-value:x:@.no\\n                  .:\", ''))) / length(@p\"\\n                  get-value:x:@.no\\n                  .:)\\n      else\\n         set-value:x:@.sql\\n            strings.concat:x:@.sql\\n               get-value:x:@.sql\\n               .:\" + (length(\"\\n               get-value:x:@.fields\\n               .:) - length(replace(lower(\\n               get-value:x:@.fields\\n               .:), @p\\n               get-value:x:@.no\\n               .:\", ''))) / length(@p\"\\n               get-value:x:@.no\\n               .:)\\n      math.increment:x:@.no\\n   set-value:x:@.sql\\n      strings.concat:x:@.sql\\n         get-value:x:@.sql\\n         .:) * 1.0 / length(\\n         get-value:x:@.fields\\n         .:) as keyword_density, (\\n\\n   // 3) Distinct keyword count => For each keyword, 1 if present, 0 if not.\\n   .no:int:0\\n   for-each:x:@.words/*\\n      if\\n         eq:x:@.no\\n            .:int:0\\n         .lambda\\n\\n            // First keyword => no leading plus\\n            set-value:x:@.sql\\n               strings.concat:x:@.sql\\n                  get-value:x:@.sql\\n                  .:\" CASE WHEN ((length(\"\\n                  get-value:x:@.fields\\n                  .:) - length(replace(lower(\\n                  get-value:x:@.fields\\n                  .:), @p\\n                  get-value:x:@.no\\n                  .:\", ''))) / length(@p\"\\n                  get-value:x:@.no\\n                  .:)) > 0 THEN 1 ELSE 0 END\\n      else\\n         set-value:x:@.sql\\n            strings.concat:x:@.sql\\n               get-value:x:@.sql\\n               .:\" + CASE WHEN ((length(\"\\n               get-value:x:@.fields\\n               .:) - length(replace(lower(\\n               get-value:x:@.fields\\n               .:), @p\\n               get-value:x:@.no\\n               .:\", ''))) / length(@p\"\\n               get-value:x:@.no\\n               .:)) > 0 THEN 1 ELSE 0 END\\n      math.increment:x:@.no\\n\\n   // Finalize \"keyword_count\".\\n   set-value:x:@.sql\\n      strings.concat:x:@.sql\\n         get-value:x:@.sql\\n         .:) as keyword_count\\n\\n   // 4) Finish SELECT + WHERE\\n   set-value:x:@.sql\\n      strings.concat:x:@.sql\\n         get-value:x:@.sql\\n         .:\" from \"\\n         .:Album\\n         .:\" where keyword_count > 0\"\\n\\n   // 5) Order by distinct keyword_count (higher means more distinct keywords), then keyword_density.\\n   set-value:x:@.sql\\n      strings.concat:x:@.sql\\n         get-value:x:@.sql\\n         .:\" order by keyword_count desc, keyword_density desc limit \"\\n         get-value:x:@.arguments/*/limit\\n\\n   // (Optional) offset => pagination\\n   if\\n      exists:x:@.arguments/*/offset\\n      .lambda\\n         set-value:x:@.sql\\n            strings.concat:x:@.sql\\n               get-value:x:@.sql\\n               .:\" offset \"\\n               get-value:x:@.arguments/*/offset\\n\\n   // Execute the SQL\\n   data.select:x:@.sql\\n      database-type:sqlite\\n\\n   // Remove helper fields if you don't want them in your final JSON\\n   remove-nodes:x:@data.select/*/*/keyword_density\\n   remove-nodes:x:@data.select/*/*/keyword_count\\n\\n   // Return the final result set\\n   return-nodes:x:@data.select/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Delete one record from your Album table in your chinook database"},{"role":"assistant","content":".arguments\\n\\n   // Primary key of record to delete, mandatory argument\\n   AlbumId:long\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-delete\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root,admin\\nvalidators.mandatory:x:@.arguments/*/AlbumId\\n\\n// Opening up our database connection.\\ndata.connect:[generic|chinook]\\n   database-type:sqlite\\n\\n   // Parametrising our delete invocation.\\n   add:x:./*/data.delete/*/where/*/and\\n      get-nodes:x:@.arguments/*\\n\\n   // Deleting item from database.\\n   data.delete\\n      database-type:sqlite\\n      table:Album\\n      where\\n         and\\n\\n   // Returning result of above invocation to caller.\\n   unwrap:x:+/*\\n   return\\n      affected:x:@data.delete\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Read or list records from your Album table in your chinook database"},{"role":"assistant","content":".arguments\\n\\n   // Number of records to return, defaults to 25 if not specified. Pass in -1 to return all records.\\n   limit:long\\n\\n   // Offset into the dataset of where to start retrieving records\\n   offset:long\\n\\n   // Fully qualified name of column to order by, must be in TABLE_NAME.COLUMN_NAME format\\n   order:string\\n\\n   // What direction to order, can be 'asc' or 'desc' implying ascending and descending\\n   direction:string\\n\\n   // Optional logical operator for filtering arguments, can be either 'or' or 'and'. Defaults to and.\\n   operator:string\\n   Album.AlbumId.mt:long\\n   Album.AlbumId.lt:long\\n   Album.AlbumId.mteq:long\\n   Album.AlbumId.lteq:long\\n   Album.AlbumId.neq:long\\n   Album.AlbumId.eq:long\\n   Album.Title.like:string\\n   Album.Title.mt:string\\n   Album.Title.lt:string\\n   Album.Title.mteq:string\\n   Album.Title.lteq:string\\n   Album.Title.neq:string\\n   Album.Title.eq:string\\n   Album.ArtistId.mt:long\\n   Album.ArtistId.lt:long\\n   Album.ArtistId.mteq:long\\n   Album.ArtistId.lteq:long\\n   Album.ArtistId.neq:long\\n   Album.ArtistId.eq:long\\n   ArtistId.Name.eq:string\\n   ArtistId.Name.like:string\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-read\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root,admin\\n\\n// Sanity checking invocation.\\nvalidators.enum:x:@.arguments/*/operator\\n   .:or\\n   .:and\\n\\n/*\\n * Checking if user supplied an [operator] argument, and if so\\n * changing the boolean operator for comparison operations.\\n */\\nif\\n   exists:x:@.arguments/*/operator\\n   .lambda\\n\\n      // User provided a boolean comparison [operator] argument.\\n      set-name:x:../*/data.connect/*/data.read/*/where/0\\n         get-value:x:@.arguments/*/operator\\n      remove-nodes:x:@.arguments/*/operator\\n\\n// Opening up our database connection.\\ndata.connect:[generic|chinook]\\n   database-type:sqlite\\n\\n   // Parametrising our read invocation with ordering arguments if specified.\\n   add:x:./*/data.read\\n      get-nodes:x:@.arguments/*/order\\n      get-nodes:x:@.arguments/*/direction\\n   remove-nodes:x:@.arguments/*/order\\n   remove-nodes:x:@.arguments/*/direction\\n\\n   // Parametrising our read invocation with paging arguments if specified.\\n   add:x:./*/data.read\\n      get-nodes:x:@.arguments/*/limit\\n      get-nodes:x:@.arguments/*/offset\\n   remove-nodes:x:@.arguments/*/limit\\n   remove-nodes:x:@.arguments/*/offset\\n\\n   // Parametrising our read invocation with filtering arguments.\\n   add:x:./*/data.read/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:sqlite\\n      table:Album\\n         join:Artist\\n            as:ArtistId\\n            type:left\\n            on\\n               and\\n                  Album.ArtistId:ArtistId.ArtistId\\n      columns\\n         Album.AlbumId\\n         Album.Title\\n         Album.ArtistId\\n         ArtistId.Name\\n            as:ArtistId.Name\\n      where\\n         and\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create one record in your Album table in your chinook database"},{"role":"assistant","content":".arguments\\n\\n   // AlbumId column value\\n   AlbumId:long\\n\\n   // Title column value\\n   Title:string\\n\\n   // ArtistId column value\\n   ArtistId:long\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-create\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root,admin\\n.foreign-keys\\n   .\\n      column:ArtistId\\n      table:Artist\\n      foreign_column:ArtistId\\n      foreign_name:Name\\n      long:bool:true\\n\\n// Opening up database connection.\\ndata.connect:[generic|chinook]\\n   database-type:sqlite\\n\\n   // Parametrising our create invocation.\\n   add:x:./*/data.create/*/values\\n      get-nodes:x:@.arguments/*\\n\\n   // Creating our record.\\n   data.create\\n      database-type:sqlite\\n      table:Album\\n      return-id:bool:false\\n      values\\n\\n   // Returning the correct status code.\\n   response.status.set:201\\n\\n   // Returning result of above invocation to caller.\\n   unwrap:x:+/*\\n   return\\n      result:success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Update one record in your Album table in your chinook database"},{"role":"assistant","content":".arguments\\n\\n   // AlbumId column value being primary key of record to update, mandatory argument\\n   AlbumId:long\\n\\n   // Title column's new value\\n   Title:string\\n\\n   // ArtistId column's new value\\n   ArtistId:long\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-update\\n\\n// Sanity checking invocation, making sure primary key(s) are specified.\\nvalidators.mandatory:x:@.arguments/*/AlbumId\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root,admin\\n.foreign-keys\\n   .\\n      column:ArtistId\\n      table:Artist\\n      foreign_column:ArtistId\\n      foreign_name:Name\\n      long:bool:true\\n\\n// Opening up our database connection.\\ndata.connect:[generic|chinook]\\n   database-type:sqlite\\n\\n   // Parametrising our invocation.\\n   add:x:./*/data.update/*/values\\n      get-nodes:x:@.arguments/*/[1,1000]\\n   add:x:./*/data.update/*/where/*/and\\n      get-nodes:x:@.arguments/*/[0,1]\\n\\n   // Invoking our update slot.\\n   data.update\\n      database-type:sqlite\\n      table:Album\\n      values\\n      where\\n         and\\n\\n   // Verifying record exists.\\n   if\\n      eq\\n         get-value:x:@data.update\\n         .:int:0\\n      .lambda\\n         response.status.set:404\\n         return\\n            result:Record not found\\n\\n   // Returning the correct status code.\\n   response.status.set:202\\n\\n   // Returning success to caller.\\n   unwrap:x:+/*\\n   return\\n      affected:x:@data.update\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns minimum, maximum, average or sum from your Artist table in your chinook database"},{"role":"assistant","content":".arguments\\n\\n   // Function to aggregate upon. Argument is mandatory and legal values are min, max, sum or avg\\n   aggregate_function:string\\n\\n   // Argument is mandatory and must be in the format of TABLE_NAME.COLUMN_NAME.\\n   aggregate_column:string\\n\\n   // Optional logical operator for filtering arguments, can be either 'or' or 'and'. Defaults to and.\\n   operator:string\\n   Artist.ArtistId.mt:long\\n   Artist.ArtistId.lt:long\\n   Artist.ArtistId.mteq:long\\n   Artist.ArtistId.lteq:long\\n   Artist.ArtistId.neq:long\\n   Artist.ArtistId.eq:long\\n   Artist.Name.like:string\\n   Artist.Name.mt:string\\n   Artist.Name.lt:string\\n   Artist.Name.mteq:string\\n   Artist.Name.lteq:string\\n   Artist.Name.neq:string\\n   Artist.Name.eq:string\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-aggregate\\n\\n// Sanity checking mandatory arguments.\\nvalidators.mandatory:x:@.arguments/*/aggregate_function\\nvalidators.mandatory:x:@.arguments/*/aggregate_column\\n\\n// Sanity checking name of aggregate function.\\nvalidators.enum:x:@.arguments/*/aggregate_function\\n   .:min\\n   .:max\\n   .:sum\\n   .:avg\\n\\n// Sanity checking agggregate column name.\\nvalidators.enum:x:@.arguments/*/aggregate_column\\n   .:Artist.ArtistId\\n   .:Artist.Name\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root,admin\\n\\n// Sanity checking invocation.\\nvalidators.enum:x:@.arguments/*/operator\\n   .:or\\n   .:and\\n\\n/*\\n * Checking if user supplied an [operator] argument, and if so\\n * changing the boolean operator for comparison operations.\\n */\\nif\\n   exists:x:@.arguments/*/operator\\n   .lambda\\n\\n      // User provided a boolean comparison [operator] argument.\\n      set-name:x:../*/data.connect/*/data.read/*/where/0\\n         get-value:x:@.arguments/*/operator\\n      remove-nodes:x:@.arguments/*/operator\\n\\n// Opening up our database connection.\\ndata.connect:[generic|chinook]\\n   database-type:sqlite\\n\\n   // Making sure we're using correct aggregate function.\\n   set-name:x:./*/data.read/*/columns/*/aggregate_functor\\n      strings.concat\\n         get-value:x:@.arguments/*/aggregate_function\\n         .:(\\n         get-value:x:@.arguments/*/aggregate_column\\n         .:)\\n\\n   // Removing aggregate arguments to simplify adding other arguments.\\n   remove-nodes:x:@.arguments/*/[0,2]\\n\\n   // Adding filtering arguments.\\n   add:x:+/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:sqlite\\n      table:Artist\\n      columns\\n         aggregate_functor\\n            as:result\\n      where\\n         and\\n      limit:long:1\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Counts items from your Artist table in your chinook database"},{"role":"assistant","content":".arguments\\n\\n   // Optional logical operator for filtering arguments, can be either 'or' or 'and'. Defaults to and.\\n   operator:string\\n   Artist.ArtistId.mt:long\\n   Artist.ArtistId.lt:long\\n   Artist.ArtistId.mteq:long\\n   Artist.ArtistId.lteq:long\\n   Artist.ArtistId.neq:long\\n   Artist.ArtistId.eq:long\\n   Artist.Name.like:string\\n   Artist.Name.mt:string\\n   Artist.Name.lt:string\\n   Artist.Name.mteq:string\\n   Artist.Name.lteq:string\\n   Artist.Name.neq:string\\n   Artist.Name.eq:string\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-count\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root,admin\\n\\n// Sanity checking invocation.\\nvalidators.enum:x:@.arguments/*/operator\\n   .:or\\n   .:and\\n\\n/*\\n * Checking if user supplied an [operator] argument, and if so\\n * changing the boolean operator for comparison operations.\\n */\\nif\\n   exists:x:@.arguments/*/operator\\n   .lambda\\n\\n      // User provided a boolean comparison [operator] argument.\\n      set-name:x:../*/data.connect/*/data.read/*/where/0\\n         get-value:x:@.arguments/*/operator\\n      remove-nodes:x:@.arguments/*/operator\\n\\n// Opening up our database connection.\\ndata.connect:[generic|chinook]\\n   database-type:sqlite\\n\\n   // Adding filtering arguments.\\n   add:x:+/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:sqlite\\n      table:Artist\\n      columns\\n         count(*)\\n            as:count\\n      where\\n         and\\n      limit:long:1\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns unique and distinct values from your Artist table in your chinook database"},{"role":"assistant","content":".arguments\\n\\n   // Name of column to return unique and distinct values for. Argument is mandatory and must be in the format of TABLE_NAME.COLUMN_NAME\\n   distinct_column:string\\n\\n   // Number of records to return, defaults to 25 if not specified. Pass in -1 to return all records.\\n   limit:long\\n\\n   // Offset into the dataset of where to start retrieving records\\n   offset:long\\n\\n   // Fully qualified name of column to order by, must be in TABLE_NAME.COLUMN_NAME format\\n   order:string\\n\\n   // What direction to order, can be 'asc' or 'desc' implying ascending and descending\\n   direction:string\\n\\n   // Optional logical operator for filtering arguments, can be either 'or' or 'and'. Defaults to and.\\n   operator:string\\n   Artist.ArtistId.mt:long\\n   Artist.ArtistId.lt:long\\n   Artist.ArtistId.mteq:long\\n   Artist.ArtistId.lteq:long\\n   Artist.ArtistId.neq:long\\n   Artist.ArtistId.eq:long\\n   Artist.Name.like:string\\n   Artist.Name.mt:string\\n   Artist.Name.lt:string\\n   Artist.Name.mteq:string\\n   Artist.Name.lteq:string\\n   Artist.Name.neq:string\\n   Artist.Name.eq:string\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-distinct\\n\\n// Sanity checking that distinct column was passed in.\\nvalidators.mandatory:x:@.arguments/*/distinct_column\\n\\n// Sanity checking distinct column's name.\\nvalidators.enum:x:@.arguments/*/distinct_column\\n   .:Artist.ArtistId\\n   .:Artist.Name\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root,admin\\n\\n// Sanity checking invocation.\\nvalidators.enum:x:@.arguments/*/operator\\n   .:or\\n   .:and\\n\\n/*\\n * Checking if user supplied an [operator] argument, and if so\\n * changing the boolean operator for comparison operations.\\n */\\nif\\n   exists:x:@.arguments/*/operator\\n   .lambda\\n\\n      // User provided a boolean comparison [operator] argument.\\n      set-name:x:../*/data.connect/*/data.read/*/where/0\\n         get-value:x:@.arguments/*/operator\\n      remove-nodes:x:@.arguments/*/operator\\n\\n// Opening up our database connection.\\ndata.connect:[generic|chinook]\\n   database-type:sqlite\\n\\n   // Making sure we're using correct function.\\n   set-name:x:./*/data.read/*/columns/*/distinct_functor\\n      strings.concat\\n         .:distinct(\\n         get-value:x:@.arguments/*/distinct_column\\n         .:)\\n\\n   // Removing distinct argument to simplify adding other arguments.\\n   remove-nodes:x:@.arguments/*/distinct_column\\n\\n   // Adding [limit] and [offset] arguments\\n   add:x:./*/data.read\\n      get-nodes:x:@.arguments/*/limit\\n      get-nodes:x:@.arguments/*/offset\\n      get-nodes:x:@.arguments/*/order\\n      get-nodes:x:@.arguments/*/direction\\n   remove-nodes:x:@.arguments/*/order\\n   remove-nodes:x:@.arguments/*/direction\\n   remove-nodes:x:@.arguments/*/limit\\n   remove-nodes:x:@.arguments/*/offset\\n\\n   // Adding filtering arguments.\\n   add:x:+/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:sqlite\\n      table:Artist\\n      columns\\n         distinct_functor\\n            as:.\\n      where\\n         and\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns minimum, maximum, average, sum or count from your Artist table in your chinook database grouped by a column"},{"role":"assistant","content":".arguments\\n\\n   // Mandatory argument being column to group by and must be in the format of TABLE_NAME.COLUMN_NAME\\n   group_column:string\\n\\n   // Number of records to return, defaults to 25 if not specified. Pass in -1 to return all records.\\n   limit:long\\n\\n   // Offset into the dataset of where to start retrieving records\\n   offset:long\\n\\n   // Fully qualified name of column to order by, must be in TABLE_NAME.COLUMN_NAME format\\n   order:string\\n\\n   // What direction to order, can be 'asc' or 'desc' implying ascending and descending\\n   direction:string\\n\\n   // Function to aggregate upon. Argument is mandatory and legal values are min, max, sum, avg or count\\n   aggregate_function:string\\n\\n   // Argument is mandatory and must be in the format of TABLE_NAME.COLUMN_NAME.\\n   aggregate_column:string\\n\\n   // Optional logical operator for filtering arguments, can be either 'or' or 'and'. Defaults to and.\\n   operator:string\\n   Artist.ArtistId.mt:long\\n   Artist.ArtistId.lt:long\\n   Artist.ArtistId.mteq:long\\n   Artist.ArtistId.lteq:long\\n   Artist.ArtistId.neq:long\\n   Artist.ArtistId.eq:long\\n   Artist.Name.like:string\\n   Artist.Name.mt:string\\n   Artist.Name.lt:string\\n   Artist.Name.mteq:string\\n   Artist.Name.lteq:string\\n   Artist.Name.neq:string\\n   Artist.Name.eq:string\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-group\\n\\n// Sanity checking mandatory arguments.\\nvalidators.mandatory:x:@.arguments/*/group_column\\nvalidators.mandatory:x:@.arguments/*/aggregate_function\\nvalidators.mandatory:x:@.arguments/*/aggregate_column\\n\\n// Sanity checking name of aggregate function.\\nvalidators.enum:x:@.arguments/*/aggregate_function\\n   .:min\\n   .:max\\n   .:sum\\n   .:avg\\n   .:count\\n\\n// Sanity checking group column.\\nvalidators.enum:x:@.arguments/*/group_column\\n   .:Artist.ArtistId\\n   .:Artist.Name\\n\\n// Sanity checking agggregate column name.\\nvalidators.enum:x:@.arguments/*/aggregate_column\\n   .:Artist.ArtistId\\n   .:Artist.Name\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root,admin\\n\\n// Sanity checking invocation.\\nvalidators.enum:x:@.arguments/*/operator\\n   .:or\\n   .:and\\n\\n/*\\n * Checking if user supplied an [operator] argument, and if so\\n * changing the boolean operator for comparison operations.\\n */\\nif\\n   exists:x:@.arguments/*/operator\\n   .lambda\\n\\n      // User provided a boolean comparison [operator] argument.\\n      set-name:x:../*/data.connect/*/data.read/*/where/0\\n         get-value:x:@.arguments/*/operator\\n      remove-nodes:x:@.arguments/*/operator\\n\\n// Opening up our database connection.\\ndata.connect:[generic|chinook]\\n   database-type:sqlite\\n\\n   // Making sure we're using the correct group column\\n   set-name:x:@data.connect/*/data.read/*/group/*/group_column\\n      get-value:x:@.arguments/*/group_column\\n\\n   // Making sure we return group column as a part of the result\\n   set-name:x:+/*/*\\n      get-value:x:@.arguments/*/group_column\\n   insert-before:x:@data.connect/*/data.read/*/columns/0\\n      .\\n         group_column\\n\\n   // Changing name of aggregate column returned to caller.\\n   set-value:x:@data.connect/*/data.read/*/columns/1/*/as\\n      get-value:x:@.arguments/*/aggregate_function\\n\\n   // Removing group column to simplify adding other arguments\\n   remove-nodes:x:@.arguments/*/group_column\\n\\n   // Adding paging arguments\\n   add:x:@data.connect/*/data.read\\n      get-nodes:x:@.arguments/*/limit\\n      get-nodes:x:@.arguments/*/offset\\n   remove-nodes:x:@.arguments/*/limit\\n   remove-nodes:x:@.arguments/*/offset\\n\\n   // Parametrising our read invocation with ordering arguments if specified.\\n   add:x:./*/data.read\\n      get-nodes:x:@.arguments/*/order\\n      get-nodes:x:@.arguments/*/direction\\n   remove-nodes:x:@.arguments/*/order\\n   remove-nodes:x:@.arguments/*/direction\\n\\n   // Making sure we're using correct aggregate function.\\n   set-name:x:./*/data.read/*/columns/*/aggregate_functor\\n      strings.concat\\n         get-value:x:@.arguments/*/aggregate_function\\n         .:(\\n         get-value:x:@.arguments/*/aggregate_column\\n         .:)\\n\\n   // Removing aggregate arguments to simplify adding other arguments.\\n   remove-nodes:x:@.arguments/*/[0,2]\\n\\n   // Adding filtering arguments.\\n   add:x:+/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:sqlite\\n      table:Artist\\n      columns\\n         aggregate_functor\\n            as:result\\n      where\\n         and\\n      group\\n         group_column\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Distinct Keyword Search from Artist table in chinook database.\\n\\nThis endpoint will return only records containing one or more of the keywords from the specified [query],\\nwith rows containing the most distinct matched keywords appearing first."},{"role":"assistant","content":".arguments\\n\\n   // Mandatory query for records to search for\\n   query:string\\n\\n   // Optional number of records to return, defaults to 10 if not specified. Pass in -1 to return all records\\n   limit:long\\n\\n   // Optional offset into the dataset of where to start retrieving records\\n   offset:long\\n\\n// Type of endpoint\\n.type:crud-search\\n\\n// Make sure the user has provided a query.\\nvalidators.mandatory:x:@.arguments/*/query\\n\\n// Apply defaults if not specified.\\nvalidators.default:x:@.arguments\\n   limit:long:10\\n\\n// Split the user's query into individual keywords, separated by spaces.\\n.words\\nadd:x:@.words\\n   strings.split:x:@.arguments/*/query\\n      .:\" \"\\n\\n// Enforce lower characters for each keyword, and guard against SQL injection.\\n.no:int:0\\nfor-each:x:@.words/*\\n   set-value:x:@.dp/#\\n      strings.to-lower:x:@.dp/#\\n\\n// Specify which columns to search against.\\n.columns\\n   .:Name\\n\\n// Connect to the specified database.\\ndata.connect:[generic|chinook]\\n   database-type:sqlite\\n\\n   // Start building our SQL.\\n   .sql:select *, (\\n\\n   // 1) Dynamically create the full text by concatenating all columns we want to search.\\n   .fields\\n   for-each:x:@.columns/*\\n      strings.concat\\n         .:coalesce(\\n         get-value:x:@.dp/#\\n         .:\", '')\"\\n      unwrap:x:+/*/*\\n      add:x:@.fields\\n         .\\n            .:x:@strings.concat\\n   set-value:x:@.fields\\n      strings.join:x:@.fields/*\\n         .:\" || \"\\n   remove-nodes:x:@.fields/*\\n\\n   // 2) Keyword density calculation\\n   .no:int:0\\n   for-each:x:@.words/*\\n\\n      // Adding SQL parameter.\\n      set-name:x:+/+/*/*\\n         strings.concat\\n            .:@p\\n            get-value:x:@.no\\n      unwrap:x:+/*/*\\n      add:x:@data.connect/*/data.select\\n         .\\n            .:x:@.dp/#\\n\\n      // Modifying our SQL.\\n      if\\n         eq:x:@.no\\n            .:int:0\\n         .lambda\\n\\n            // First keyword => no leading plus\\n            set-value:x:@.sql\\n               strings.concat:x:@.sql\\n                  get-value:x:@.sql\\n                  .:\" (length(\"\\n                  get-value:x:@.fields\\n                  .:) - length(replace(lower(\\n                  get-value:x:@.fields\\n                  .:), @p\\n                  get-value:x:@.no\\n                  .:\", ''))) / length(@p\"\\n                  get-value:x:@.no\\n                  .:)\\n      else\\n         set-value:x:@.sql\\n            strings.concat:x:@.sql\\n               get-value:x:@.sql\\n               .:\" + (length(\"\\n               get-value:x:@.fields\\n               .:) - length(replace(lower(\\n               get-value:x:@.fields\\n               .:), @p\\n               get-value:x:@.no\\n               .:\", ''))) / length(@p\"\\n               get-value:x:@.no\\n               .:)\\n      math.increment:x:@.no\\n   set-value:x:@.sql\\n      strings.concat:x:@.sql\\n         get-value:x:@.sql\\n         .:) * 1.0 / length(\\n         get-value:x:@.fields\\n         .:) as keyword_density, (\\n\\n   // 3) Distinct keyword count => For each keyword, 1 if present, 0 if not.\\n   .no:int:0\\n   for-each:x:@.words/*\\n      if\\n         eq:x:@.no\\n            .:int:0\\n         .lambda\\n\\n            // First keyword => no leading plus\\n            set-value:x:@.sql\\n               strings.concat:x:@.sql\\n                  get-value:x:@.sql\\n                  .:\" CASE WHEN ((length(\"\\n                  get-value:x:@.fields\\n                  .:) - length(replace(lower(\\n                  get-value:x:@.fields\\n                  .:), @p\\n                  get-value:x:@.no\\n                  .:\", ''))) / length(@p\"\\n                  get-value:x:@.no\\n                  .:)) > 0 THEN 1 ELSE 0 END\\n      else\\n         set-value:x:@.sql\\n            strings.concat:x:@.sql\\n               get-value:x:@.sql\\n               .:\" + CASE WHEN ((length(\"\\n               get-value:x:@.fields\\n               .:) - length(replace(lower(\\n               get-value:x:@.fields\\n               .:), @p\\n               get-value:x:@.no\\n               .:\", ''))) / length(@p\"\\n               get-value:x:@.no\\n               .:)) > 0 THEN 1 ELSE 0 END\\n      math.increment:x:@.no\\n\\n   // Finalize \"keyword_count\".\\n   set-value:x:@.sql\\n      strings.concat:x:@.sql\\n         get-value:x:@.sql\\n         .:) as keyword_count\\n\\n   // 4) Finish SELECT + WHERE\\n   set-value:x:@.sql\\n      strings.concat:x:@.sql\\n         get-value:x:@.sql\\n         .:\" from \"\\n         .:Artist\\n         .:\" where keyword_count > 0\"\\n\\n   // 5) Order by distinct keyword_count (higher means more distinct keywords), then keyword_density.\\n   set-value:x:@.sql\\n      strings.concat:x:@.sql\\n         get-value:x:@.sql\\n         .:\" order by keyword_count desc, keyword_density desc limit \"\\n         get-value:x:@.arguments/*/limit\\n\\n   // (Optional) offset => pagination\\n   if\\n      exists:x:@.arguments/*/offset\\n      .lambda\\n         set-value:x:@.sql\\n            strings.concat:x:@.sql\\n               get-value:x:@.sql\\n               .:\" offset \"\\n               get-value:x:@.arguments/*/offset\\n\\n   // Execute the SQL\\n   data.select:x:@.sql\\n      database-type:sqlite\\n\\n   // Remove helper fields if you don't want them in your final JSON\\n   remove-nodes:x:@data.select/*/*/keyword_density\\n   remove-nodes:x:@data.select/*/*/keyword_count\\n\\n   // Return the final result set\\n   return-nodes:x:@data.select/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Delete one record from your Artist table in your chinook database"},{"role":"assistant","content":".arguments\\n\\n   // Primary key of record to delete, mandatory argument\\n   ArtistId:long\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-delete\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root,admin\\nvalidators.mandatory:x:@.arguments/*/ArtistId\\n\\n// Opening up our database connection.\\ndata.connect:[generic|chinook]\\n   database-type:sqlite\\n\\n   // Parametrising our delete invocation.\\n   add:x:./*/data.delete/*/where/*/and\\n      get-nodes:x:@.arguments/*\\n\\n   // Deleting item from database.\\n   data.delete\\n      database-type:sqlite\\n      table:Artist\\n      where\\n         and\\n\\n   // Returning result of above invocation to caller.\\n   unwrap:x:+/*\\n   return\\n      affected:x:@data.delete\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Read or list records from your Artist table in your chinook database"},{"role":"assistant","content":".arguments\\n\\n   // Number of records to return, defaults to 25 if not specified. Pass in -1 to return all records.\\n   limit:long\\n\\n   // Offset into the dataset of where to start retrieving records\\n   offset:long\\n\\n   // Fully qualified name of column to order by, must be in TABLE_NAME.COLUMN_NAME format\\n   order:string\\n\\n   // What direction to order, can be 'asc' or 'desc' implying ascending and descending\\n   direction:string\\n\\n   // Optional logical operator for filtering arguments, can be either 'or' or 'and'. Defaults to and.\\n   operator:string\\n   Artist.ArtistId.mt:long\\n   Artist.ArtistId.lt:long\\n   Artist.ArtistId.mteq:long\\n   Artist.ArtistId.lteq:long\\n   Artist.ArtistId.neq:long\\n   Artist.ArtistId.eq:long\\n   Artist.Name.like:string\\n   Artist.Name.mt:string\\n   Artist.Name.lt:string\\n   Artist.Name.mteq:string\\n   Artist.Name.lteq:string\\n   Artist.Name.neq:string\\n   Artist.Name.eq:string\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-read\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root,admin\\n\\n// Sanity checking invocation.\\nvalidators.enum:x:@.arguments/*/operator\\n   .:or\\n   .:and\\n\\n/*\\n * Checking if user supplied an [operator] argument, and if so\\n * changing the boolean operator for comparison operations.\\n */\\nif\\n   exists:x:@.arguments/*/operator\\n   .lambda\\n\\n      // User provided a boolean comparison [operator] argument.\\n      set-name:x:../*/data.connect/*/data.read/*/where/0\\n         get-value:x:@.arguments/*/operator\\n      remove-nodes:x:@.arguments/*/operator\\n\\n// Opening up our database connection.\\ndata.connect:[generic|chinook]\\n   database-type:sqlite\\n\\n   // Parametrising our read invocation with ordering arguments if specified.\\n   add:x:./*/data.read\\n      get-nodes:x:@.arguments/*/order\\n      get-nodes:x:@.arguments/*/direction\\n   remove-nodes:x:@.arguments/*/order\\n   remove-nodes:x:@.arguments/*/direction\\n\\n   // Parametrising our read invocation with paging arguments if specified.\\n   add:x:./*/data.read\\n      get-nodes:x:@.arguments/*/limit\\n      get-nodes:x:@.arguments/*/offset\\n   remove-nodes:x:@.arguments/*/limit\\n   remove-nodes:x:@.arguments/*/offset\\n\\n   // Parametrising our read invocation with filtering arguments.\\n   add:x:./*/data.read/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:sqlite\\n      table:Artist\\n      columns\\n         Artist.ArtistId\\n         Artist.Name\\n      where\\n         and\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create one record in your Artist table in your chinook database"},{"role":"assistant","content":".arguments\\n\\n   // ArtistId column value\\n   ArtistId:long\\n\\n   // Name column value\\n   Name:string\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-create\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root,admin\\n\\n// Opening up database connection.\\ndata.connect:[generic|chinook]\\n   database-type:sqlite\\n\\n   // Parametrising our create invocation.\\n   add:x:./*/data.create/*/values\\n      get-nodes:x:@.arguments/*\\n\\n   // Creating our record.\\n   data.create\\n      database-type:sqlite\\n      table:Artist\\n      return-id:bool:false\\n      values\\n\\n   // Returning the correct status code.\\n   response.status.set:201\\n\\n   // Returning result of above invocation to caller.\\n   unwrap:x:+/*\\n   return\\n      result:success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Subtract multiple values sequentially from a base number"},{"role":"assistant","content":"math.subtract:int:20\\n\\n   // first subtract 5 from 20 -> intermediate result 15\\n   .:int:5\\n\\n   // then subtract 3 from 15 -> final result 12\\n   .:int:3\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Subtract a computed sum and another number from a base value"},{"role":"assistant","content":"math.subtract:int:30\\n\\n   // compute a sum to subtract\\n   math.add\\n\\n      // first addend\\n      .:int:5\\n\\n      // second addend (5 + 3 = 8)\\n      .:int:3\\n\\n   // subtract 2 after subtracting the above sum\\n   .:int:2\\n\\n   // Step-by-step: 30 - 8 = 22, then 22 - 2 = 20\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Compute the remainder of 10 divided by 3"},{"role":"assistant","content":"math.modulo\\n\\n   // base value 10\\n   .:int:10\\n\\n   // 10 mod 3 = 1 (final result)\\n   .:int:3\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Sequential modulus operations"},{"role":"assistant","content":".x:int:14\\nmath.modulo\\n\\n   // 14\\n   get-value:x:@.x\\n\\n   // 14 mod 5 = 4\\n   .:int:5\\n\\n   // then 4 mod 2 = 0 (final result)\\n   .:int:2\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Increment a value by 1 (default step)"},{"role":"assistant","content":".value:int:3\\nmath.increment:x:@.value\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Decrement a value by 1 (default behavior)"},{"role":"assistant","content":".value:int:5\\nmath.decrement:x:@.value\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Decrement a value by a custom step from another node"},{"role":"assistant","content":".value:int:10\\n.step:int:4\\nmath.decrement:x:@.value\\n\\n   // use 4 from .step as the decrement amount\\n   get-value:x:@.step\\n\\n// .value should now be 6\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Multiply a number by the result of a nested addition"},{"role":"assistant","content":"\\n// outer multiplication\\nmath.multiply\\n\\n   // first factor (base) is 5\\n   .:int:5\\n\\n   // nested addition (executes before multiplication)\\n   math.add\\n\\n      // first addend\\n      .:int:1\\n\\n      // second addend (1 + 2 = 3)\\n      .:int:2\\n\\n   // After the inner addition yields 3, we have 5 * 3 = 15 as the final result\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Multiply a variable's value by two factors"},{"role":"assistant","content":".num:int:7\\nmath.multiply\\n\\n   // retrieves 7 from .num\\n   get-value:x:@.num\\n\\n   // multiplies 7 by 2 -> result 14\\n   .:int:2\\n\\n   // multiplies 14 by 3 -> result 42\\n   .:int:3\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Multiply an inline base by a static factor and the result of an addition"},{"role":"assistant","content":"math.multiply:int:4\\n\\n   // multiplies base 4 by 3 -> intermediate result 12\\n   .:int:3\\n\\n   // nested addition as another factor\\n   math.add\\n\\n      // first term of addition\\n      .:int:1\\n\\n      // second term of addition (1 + 1 = 2)\\n      .:int:1\\n\\n   // The intermediate result 12 is then multiplied by 2 (from nested add) -> 24\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Divide a number by a dynamic value and then by a static value"},{"role":"assistant","content":".dividend:int:24\\n.divisor:int:4\\nmath.divide\\n\\n   // fetches 24\\n   get-value:x:@.dividend\\n\\n   // divides 24 by 4 -> result 6\\n   get-value:x:@.divisor\\n\\n   // divides 6 by 2 -> result 3\\n   .:int:2\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Divide a floating-point number by an integer and another float"},{"role":"assistant","content":".total:double:20\\nmath.divide\\n\\n   // 20.0 (double)\\n   get-value:x:@.total\\n\\n   // divide by 2 -> result 10.0\\n   .:int:2\\n\\n   // divide by 1.25 -> result 8.0\\n   .:double:1.25\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Add several integer constants together"},{"role":"assistant","content":"math.add\\n   .:int:1\\n\\n   // 1+2 = 3\\n   .:int:2\\n\\n   // 3+3 = 6\\n   .:int:3\\n\\n   // 6+4 = 10 (final result)\\n   .:int:4\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Subtract one variable's value from another"},{"role":"assistant","content":".x:int:50\\n.y:int:8\\nmath.subtract\\n\\n   // 50 (minuend)\\n   get-value:x:@.x\\n\\n   // subtract 8 -> result 42\\n   get-value:x:@.y\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Replace a substring that exists in the text."},{"role":"assistant","content":".original:Hello world\\nstrings.replace:x:@.original\\n   .:world\\n   .:there\\n\\n// Result: \"Hello there\"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Allowed set includes all characters in the input (no replacements occur)."},{"role":"assistant","content":".input:ABC123\\nstrings.replace-not-of:x:@.input\\n   .:ABC123\\n   .:#\\n\\n// Result: \"ABC123\" (unchanged, since all characters were allowed)\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Extract entire string by using its full length."},{"role":"assistant","content":".subject:Test\\nstrings.substring:x:@.subject\\n   .:0\\n   .:4\\n\\n// Result: \"Test\"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Use variables for the string, start index, and length."},{"role":"assistant","content":".text:Magic\\n.start:int:1\\n.len:int:3\\nstrings.substring:x:@.text\\n   get-value:x:@.start\\n   get-value:x:@.len\\n\\n// Result: \"agi\"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Find all substrings matching a pattern in curly braces."},{"role":"assistant","content":".text:{match1} and {match2} are here\\nstrings.matches:x:@.text\\n   .:\"\\\\{.+?\\\\}\"\\n\\n/*\\n * Resulting matches:\\n * .:{match1}\\n * .:{match2}\\n */\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Find all digit sequences in a string."},{"role":"assistant","content":"strings.matches:abc123xyz45\\n   .:\"\\\\d+\"\\n\\n/*\\n * Resulting matches:\\n * .:123\\n * .:45\\n */\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Find case-insensitive \"foo\" occurrences."},{"role":"assistant","content":"strings.matches:Foo foo FOO\\n   .:(?i)foo\\n\\n/*\\n * Resulting matches:\\n * .:Foo\\n * .:foo\\n * .:FOO\\n */\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Use a variable for the regex pattern."},{"role":"assistant","content":".pattern:[A-Z]+\\nsource:abcDEFghi\\nstrings.matches:x:@.source\\n   get-value:x:@.pattern\\n\\n/*\\n * Resulting matches:\\n * .:DEF\\n */\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Mix in a simple inline expression (2+2 inside curly braces)."},{"role":"assistant","content":"strings.mixin:\"The result is {{\\nmath.add\\n   .:int:2\\n   .:int:2\\nreturn:x:-\\n}}\"\\n\\n// Result: \"The result is 4\"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Mix in a dynamic slot call inside a string."},{"role":"assistant","content":"strings.mixin:\"Current year is {{\\ndate.now\\nreturn:x:-\\n}}\"\\n\\n// Result: \"Current year is 2025\" (assuming year 2025)\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Pass arguments to the inline Hyperlambda code."},{"role":"assistant","content":"strings.mixin:\"2 + val equals {{\\nmath.add\\n   .:int:2\\n   get-value:x:@.arguments/*/val\\nreturn:x:-\\n}}\"\\n   val:int:5\\n\\n// Result: \"2 + val equals 7\"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Allow letters and spaces only (remove punctuation by replacing with empty)."},{"role":"assistant","content":".phrase:Hello, World!\\nstrings.replace-not-of:x:@.phrase\\n   .:\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz \"\\n   .:\\n\\n// Result: \"Hello World\" (comma and '!' removed)\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Embed multiple inline expressions in a single string."},{"role":"assistant","content":"strings.mixin:\"Sum {{\\nmath.add\\n   .:int:1\\n   .:int:2\\nreturn:x:-\\n}} and Product {{\\nmath.multiply\\n   .:int:3\\n   .:int:4\\nreturn:x:-\\n}}\"\\n\\n// Result: \"Sum 3 and Product 12\"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Mix in a slot that returns a string to be inserted."},{"role":"assistant","content":"strings.mixin:\"Hello, {{\\nstrings.to-upper:world\\nreturn:x:-\\n}}!\"\\n\\n// Result: \"Hello, WORLD!\"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Capitalize a word that is already capitalized (no change)."},{"role":"assistant","content":"\\n// Result: \"Hello\"\\nstrings.capitalize:Hello\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Capitalize a string starting with a digit (no alphabetical character to capitalize)."},{"role":"assistant","content":"\\n// Result: \"42hello\"\\nstrings.capitalize:42hello\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Capitalize a string starting with whitespace (no effect on the leading space)."},{"role":"assistant","content":"\\n// Result: \" hello\" (leading space preserved)\\nstrings.capitalize:\" hello\"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Capitalize an empty string (result is still an empty string)."},{"role":"assistant","content":"\\n// Result: \"\" (empty string)\\nstrings.capitalize:\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Capitalize only the very first character of a multi-word string."},{"role":"assistant","content":"\\n// Result: \"Hello world\"\\nstrings.capitalize:hello world\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Concatenate multiple strings without separators."},{"role":"assistant","content":"strings.concat\\n   .:I\\n   .:love\\n   .:Hyperlambda\\n\\n// Result: \"IloveHyperlambda\"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Concatenate multiple strings with spaces included as separate parts."},{"role":"assistant","content":"strings.concat\\n   .:I\\n   .:\" \"\\n   .:love\\n   .:\" \"\\n   .:Hyperlambda\\n\\n// Result: \"I love Hyperlambda\"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Concatenate strings when one part is empty."},{"role":"assistant","content":"strings.concat\\n   .:Hello\\n   .:\\n   .:World\\n\\n// Result: \"HelloWorld\"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Concatenate all strings stored as children of a list node."},{"role":"assistant","content":".items\\n   .:Red\\n   .:Green\\n   .:Blue\\nstrings.concat:x:@.items/*\\n\\n// Result: \"RedGreenBlue\"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Use another slot's output as part of the concatenation."},{"role":"assistant","content":".prefix:\"Value: \"\\nstrings.concat\\n   get-value:x:@.prefix\\n   strings.to-upper:example\\n\\n// Result: \"Value: EXAMPLE\"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Concatenate a string and a number (the number is converted to a string)."},{"role":"assistant","content":".number:int:42\\nstrings.concat\\n   .:\"Answer: \"\\n   get-value:x:@.number\\n\\n// Result: \"Answer: 42\"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Check if a string contains a given substring (present case)."},{"role":"assistant","content":"\\n// Returns true\\nstrings.contains:MagicLambda\\n   .:Lambda\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Check if a string contains a given substring that is not present."},{"role":"assistant","content":"\\n// Returns false\\nstrings.contains:ChatGPT\\n   .:OpenAI\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Contains check is case-sensitive."},{"role":"assistant","content":"\\n// Returns false\\nstrings.contains:MagicLambda\\n   .:lambda\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Check if a string ends with a specific substring (positive case)."},{"role":"assistant","content":"\\n// Returns true\\nstrings.ends-with:WelcomeHome\\n   .:Home\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Check if a string ends with a substring that is not at the end."},{"role":"assistant","content":"\\n// Returns false\\nstrings.ends-with:HelloWorld\\n   .:Universe\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Replace a substring that is not present (no change occurs)."},{"role":"assistant","content":".input:foo bar\\nstrings.replace:x:@.input\\n   .:baz\\n   .:qux\\n\\n// Result: \"foo bar\" (unchanged)\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Ends-with check is case-sensitive."},{"role":"assistant","content":"\\n// Returns false\\nstrings.ends-with:Hello\\n   .:LLO\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Use variables to supply the string and suffix to check."},{"role":"assistant","content":".text:Goodbye\\n.suffix:bye\\n\\n// Returns true\\nstrings.ends-with:x:@.text\\n   get-value:x:@.suffix\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Check if a string ends with itself."},{"role":"assistant","content":"\\n// Returns true\\nstrings.ends-with:Test\\n   .:Test\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Check if a string starts with a specific substring (positive case)."},{"role":"assistant","content":"\\n// Returns true\\nstrings.starts-with:HelloWorld\\n   .:Hello\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Starts-with check is case-sensitive."},{"role":"assistant","content":"\\n// Returns false\\nstrings.starts-with:Hello\\n   .:hello\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Use variables to supply the string and prefix to check."},{"role":"assistant","content":".text:Sample\\n.prefix:Sam\\n\\n// Returns true\\nstrings.starts-with:x:@.text\\n   get-value:x:@.prefix\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Check if a string starts with itself."},{"role":"assistant","content":"\\n// Returns true\\nstrings.starts-with:Test\\n   .:Test\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Join multiple strings with a comma separator."},{"role":"assistant","content":".input\\n   .:A\\n   .:B\\n   .:C\\nstrings.join:x:@.input/*\\n   .:,\\n\\n// Result: \"A,B,C\"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Use a dynamic value from another slot as the replacement.\\nHere, replace a substring with its uppercase version using strings.to-upper."},{"role":"assistant","content":".data:Make it lowercase\\nstrings.replace:x:@.data\\n   .:lowercase\\n   strings.to-upper:lowercase\\n\\n/*\\n * After execution, \"lowercase\" in the original string is replaced with \"LOWERCASE\".\\n * Result: \"Make it LOWERCASE\"\\n */\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Join all strings stored as children of a list node."},{"role":"assistant","content":".words\\n   .:one\\n   .:two\\n   .:three\\nstrings.join:x:@.words/*\\n   .:|\\n\\n// Result: \"one|two|three\"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Get the length of a basic string."},{"role":"assistant","content":"\\n// Returns 6\\nstrings.length:OpenAI\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Spaces and punctuation are counted in the length."},{"role":"assistant","content":"\\n// Returns 12\\nstrings.length:Hello world!\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Get the length of a numeric string."},{"role":"assistant","content":"\\n// Returns 5\\nstrings.length:12345\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Get the length of a string with multi-byte characters."},{"role":"assistant","content":"\\n// Returns 2\\nstrings.length:你好\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Use a variable to provide the input string."},{"role":"assistant","content":".text:Test\\n\\n// Returns 4\\nstrings.length:x:@.text\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Use variables for the target substring and replacement."},{"role":"assistant","content":".target:world\\n.replacement:WORLD!\\n.phrase:Hello world\\nstrings.replace:x:@.phrase\\n   get-value:x:@.target\\n   get-value:x:@.replacement\\n\\n// Result: \"Hello WORLD!\"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Remove all digits from a string using a regex."},{"role":"assistant","content":".original:abc123xyz\\nstrings.regex-replace:x:@.original\\n   .:\"\\\\d+\"\\n   .:\\n\\n// Result: \"abcxyz\"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Replace all digits in a string with asterisks."},{"role":"assistant","content":".text:ID 0987\\nstrings.regex-replace:x:@.text\\n   .:\"\\\\d\"\\n   .:*\\n\\n// Result: \"ID ****\"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Replace only whole word matches using word boundaries."},{"role":"assistant","content":".phrase:apple apples applepie\\nstrings.regex-replace:x:@.phrase\\n   .:\"\\\\bapple\\\\b\"\\n   .:fruit\\n\\n// Result: \"fruit apples applepie\"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Use variables for the regex pattern and replacement string."},{"role":"assistant","content":".pattern:\"\\\\d\"\\n.replacement:X\\n.source:a1b2c3\\nstrings.regex-replace:x:@.source\\n   get-value:x:@.pattern\\n   get-value:x:@.replacement\\n\\n// Result: \"aXbXcX\"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Split a string by spaces."},{"role":"assistant","content":"strings.split:one two three\\n   .:\" \"\\n\\n/*\\n * Resulting parts:\\n * .:one\\n * .:two\\n * .:three\\n */\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Split a comma-separated string."},{"role":"assistant","content":"strings.split:a,b,c\\n   .:,\\n\\n/*\\n * Resulting parts:\\n * .:a\\n * .:b\\n * .:c\\n */\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Split using a multi-character delimiter."},{"role":"assistant","content":"strings.split:foo||bar||baz\\n   .:||\\n\\n/*\\n * Resulting parts:\\n * .:foo\\n * .:bar\\n * .:baz\\n */\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Split on a substring that is not present."},{"role":"assistant","content":"strings.split:hello\\n   .:,\\n\\n// Result: The string remains \"hello\" as a single part (no split)\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Split a string with consecutive delimiters (empty segments)."},{"role":"assistant","content":"strings.split:one,,two\\n   .:,\\n\\n/*\\n * Resulting parts:\\n * .:one\\n * .:two\\n * \\n * Notice, empty strings are ignored\\n */\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Use variables to supply the string and delimiter."},{"role":"assistant","content":".text:x|y|z\\n.delim:|\\nstrings.split:x:@.text\\n   get-value:x:@.delim\\n\\n/*\\n * Resulting parts:\\n * .:x\\n * .:y\\n * .:z\\n */\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Convert an uppercase string to lowercase."},{"role":"assistant","content":"\\n// Result: \"hello\"\\nstrings.to-lower:HELLO\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Convert an already lowercase string (no change)."},{"role":"assistant","content":"\\n// Result: \"hello\"\\nstrings.to-lower:hello\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Convert a mixed-case sentence to lowercase."},{"role":"assistant","content":"\\n// Result: \"hello world!\"\\nstrings.to-lower:Hello World!\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Convert a string with letters and numbers to lowercase."},{"role":"assistant","content":"\\n// Result: \"mixedcase123\"\\nstrings.to-lower:MixedCase123\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Use a variable as the input to lowercase."},{"role":"assistant","content":".text:LOWER ME\\n\\n// Result: \"lower me\"\\nstrings.to-lower:x:@.text\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Convert a lowercase string to uppercase."},{"role":"assistant","content":"\\n// Result: \"HELLO\"\\nstrings.to-upper:hello\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Convert a mixed-case sentence to uppercase."},{"role":"assistant","content":"\\n// Result: \"HELLO WORLD!\"\\nstrings.to-upper:Hello World!\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Convert a string with letters and numbers to uppercase."},{"role":"assistant","content":"\\n// Result: \"MIXEDCASE123\"\\nstrings.to-upper:MixedCase123\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Replace all characters not in the given set (allow only lowercase letters)."},{"role":"assistant","content":".text:abc123!?XYZ\\nstrings.replace-not-of:x:@.text\\n   .:abcdefghijklmnopqrstuvwxyz\\n   .:-\\n\\n/*\\n * Result: \"abc--------\"\\n * (digits, punctuation, and uppercase letters were replaced with '-')\\n */\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Use a variable as the input to uppercase."},{"role":"assistant","content":".text:make me upper\\n\\n// Result: \"MAKE ME UPPER\"\\nstrings.to-upper:x:@.text\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Trim whitespace from both ends of a string."},{"role":"assistant","content":"\\n// Result: \"hello\"\\nstrings.trim:\"   hello   \"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Trim specific characters from both ends."},{"role":"assistant","content":"\\n// The character \"?\" at both ends will be removed\\nstrings.trim:??hello??\\n   .:?\\n\\n// Result: \"hello\"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Trim characters that are not present (no change)."},{"role":"assistant","content":"\\n// Result: \"hello\"\\nstrings.trim:hello\\n   .:?\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Trim any of multiple characters from both ends."},{"role":"assistant","content":"\\n// Remove both \"!\" and \"#\" characters from the ends\\nstrings.trim:!#Hello#!\\n   .:!#\\n\\n// Result: \"Hello\"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Use variables for the string and characters to trim."},{"role":"assistant","content":".text:xyzyx\\n.chars:xy\\n\\n// Result: \"z\"\\nstrings.trim:x:@.text\\n   get-value:x:@.chars\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Trim whitespace from the beginning of a string."},{"role":"assistant","content":"\\n// Result: \"hello   \"\\nstrings.trim-start:\"   hello   \"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Trim specific characters from the beginning of a string."},{"role":"assistant","content":"\\n// The leading \"xyz\" will be removed\\nstrings.trim-start:xyzabcxyz\\n   .:xyz\\n\\n// Result: \"abcxyz\"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Use an empty allowed set (no characters allowed, so every character is replaced)."},{"role":"assistant","content":".original:Hello\\nstrings.replace-not-of:x:@.original\\n   .:\\n   .:*\\n\\n// Result: \"*****\"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: No trim characters at start (string remains unchanged)."},{"role":"assistant","content":"\\n// Result: \"abc\"\\nstrings.trim-start:abc\\n   .:z\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: String consisting entirely of trim characters (result is empty)."},{"role":"assistant","content":"\\n// Result: \"\" (empty string)\\nstrings.trim-start:xxx\\n   .:x\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Trim whitespace from the end of a string."},{"role":"assistant","content":"\\n// Result: \"hello\"\\nstrings.trim-end:\"hello   \"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Trim specific characters from the end of a string."},{"role":"assistant","content":"\\n// The trailing \"xyz\" will be removed\\nstrings.trim-end:abcxyzxyz\\n   .:xyz\\n\\n// Result: \"abc\"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: No trim characters at end (string remains unchanged)."},{"role":"assistant","content":"\\n// Result: \"abc\"\\nstrings.trim-end:abc\\n   .:z\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: String consisting entirely of trim characters (result is empty)."},{"role":"assistant","content":"\\n// Result: \"\" (empty string)\\nstrings.trim-end:xxx\\n   .:x\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Use variables for string and trim characters (end only)."},{"role":"assistant","content":".text:Hello...\\n.trimchars:.\\n\\n// Result: \"Hello\"\\nstrings.trim-end:x:@.text\\n   get-value:x:@.trimchars\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: URL-encode a simple string (space and special characters become % codes)."},{"role":"assistant","content":"strings.url-encode:hello world\\n\\n// Result: \"hello%20world\"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: URL-encode an email address."},{"role":"assistant","content":"strings.url-encode:user@example.com\\n\\n// Result: \"user%40example.com\"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: URL-encode a URL (especially characters like : / and spaces)."},{"role":"assistant","content":"strings.url-encode:\"https://example.com/foo bar\"\\n\\n// Result: \"https%3A%2F%2Fexample.com%2Ffoo%20bar\"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Use a variable for the string to encode."},{"role":"assistant","content":".text:key=value&flag=true\\n\\n// Result: \"key%3Dvalue%26flag%3Dtrue\"\\nstrings.url-encode:x:@.text\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: URL-decode a simple percent-encoded string."},{"role":"assistant","content":"strings.url-decode:hello%20world\\n\\n// Result: \"hello world\"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: URL-decode an email address."},{"role":"assistant","content":"strings.url-decode:user%40example.com\\n\\n// Result: \"user@example.com\"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: URL-decode a fully encoded URL."},{"role":"assistant","content":"strings.url-decode:https%3A%2F%2Fexample.com%2Ffoo%20bar\\n\\n// Result: \"https://example.com/foo bar\"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: URL-decode a string with reserved characters."},{"role":"assistant","content":"strings.url-decode:100%2525%2520free%2520%2526%2520easy\\n\\n// Result: \"100% free & easy\"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Use a variable for the string to decode."},{"role":"assistant","content":".enc:key%3Dvalue%26flag%3Dtrue\\nstrings.url-decode:x:@.enc\\n\\n// Result: \"key=value&flag=true\"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Extract from index 0 (beginning of string)."},{"role":"assistant","content":"strings.substring:HelloWorld\\n   .:0\\n   .:5\\n\\n// Result: \"Hello\"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Extract with length exceeding string bounds (returns till end)."},{"role":"assistant","content":"strings.substring:Hello\\n   .:2\\n   .:10\\n\\n// Result: \"llo\"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Saves a piece of string to the memory cache and retrieves it again."},{"role":"assistant","content":"cache.set:foo\\n   value:some cache value\\ncache.get:foo\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns minimum, maximum, average or sum from your categories table in your cms database"},{"role":"assistant","content":".arguments\\n\\n   // Function to aggregate upon. Argument is mandatory and legal values are min, max, sum or avg\\n   aggregate_function:string\\n\\n   // Argument is mandatory and must be in the format of TABLE_NAME.COLUMN_NAME.\\n   aggregate_column:string\\n\\n   // Number of records to return, defaults to 25 if not specified. Pass in -1 to return all records.\\n\\n   // Offset into the dataset of where to start retrieving records\\n\\n   // Fully qualified name of column to order by, must be in TABLE_NAME.COLUMN_NAME format\\n\\n   // What direction to order, can be 'asc' or 'desc' implying ascending and descending\\n   categories.id.eq:long\\n   categories.name.like:string\\n   categories.name.eq:string\\n   categories.description.like:string\\n   categories.description.eq:string\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-aggregate\\n\\n// Sanity checking mandatory arguments.\\nvalidators.mandatory:x:@.arguments/*/aggregate_function\\nvalidators.mandatory:x:@.arguments/*/aggregate_column\\n\\n// Sanity checking name of aggregate function.\\nvalidators.enum:x:@.arguments/*/aggregate_function\\n   .:min\\n   .:max\\n   .:sum\\n   .:avg\\n\\n// Sanity checking agggregate column name.\\nvalidators.enum:x:@.arguments/*/aggregate_column\\n   .:categories.id\\n   .:categories.name\\n   .:categories.description\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:enterprise,root\\n\\n// Opening up our database connection.\\ndata.connect:[generic|cms]\\n   database-type:sqlite\\n\\n   // Making sure we're using correct aggregate function.\\n   set-name:x:./*/data.read/*/columns/*/aggregate_functor\\n      strings.concat\\n         get-value:x:@.arguments/*/aggregate_function\\n         .:(\\n         get-value:x:@.arguments/*/aggregate_column\\n         .:)\\n\\n   // Removing aggregate arguments to simplify adding other arguments.\\n   remove-nodes:x:@.arguments/*/[0,2]\\n   add:x:+/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:sqlite\\n      table:categories\\n      columns\\n         aggregate_functor\\n            as:result\\n      where\\n         and\\n      limit:long:1\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Count unique and distinct items from your categories table in your cms database"},{"role":"assistant","content":".arguments\\n\\n   // Argument is mandatory and must be in the format of TABLE_NAME.COLUMN_NAME\\n   distinct_column:string\\n\\n   // Number of records to return, defaults to 25 if not specified. Pass in -1 to return all records.\\n\\n   // Offset into the dataset of where to start retrieving records\\n\\n   // Fully qualified name of column to order by, must be in TABLE_NAME.COLUMN_NAME format\\n\\n   // What direction to order, can be 'asc' or 'desc' implying ascending and descending\\n   categories.id.eq:long\\n   categories.name.like:string\\n   categories.name.eq:string\\n   categories.description.like:string\\n   categories.description.eq:string\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-count-distinct\\n\\n// Sanity checking that distinct column was passed in.\\nvalidators.mandatory:x:@.arguments/*/distinct_column\\n\\n// Sanity checking distinct column's name.\\nvalidators.enum:x:@.arguments/*/distinct_column\\n   .:categories.id\\n   .:categories.name\\n   .:categories.description\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:enterprise,root\\n\\n// Opening up our database connection.\\ndata.connect:[generic|cms]\\n   database-type:sqlite\\n\\n   // Making sure we're using correct function.\\n   set-name:x:./*/data.read/*/columns/*/distinct_functor\\n      strings.concat\\n         .:\"count(distinct \"\\n         get-value:x:@.arguments/*/distinct_column\\n         .:)\\n\\n   // Removing distinct argument to simplify adding other arguments.\\n   remove-nodes:x:@.arguments/*/distinct_column\\n   add:x:+/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:sqlite\\n      table:categories\\n      columns\\n         distinct_functor\\n            as:count\\n      where\\n         and\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Counts items from your categories table in your cms database"},{"role":"assistant","content":".arguments\\n\\n   // Number of records to return, defaults to 25 if not specified. Pass in -1 to return all records.\\n\\n   // Offset into the dataset of where to start retrieving records\\n\\n   // Fully qualified name of column to order by, must be in TABLE_NAME.COLUMN_NAME format\\n\\n   // What direction to order, can be 'asc' or 'desc' implying ascending and descending\\n   categories.id.eq:long\\n   categories.name.like:string\\n   categories.name.eq:string\\n   categories.description.like:string\\n   categories.description.eq:string\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-count\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:enterprise,root\\n\\n// Opening up our database connection.\\ndata.connect:[generic|cms]\\n   database-type:sqlite\\n   add:x:+/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:sqlite\\n      table:categories\\n      columns\\n         count(*)\\n            as:count\\n      where\\n         and\\n      limit:long:1\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns unique and distinct values from your categories table in your cms database"},{"role":"assistant","content":".arguments\\n\\n   // Name of column to return unique and distinct values for. Argument is mandatory and must be in the format of TABLE_NAME.COLUMN_NAME\\n   distinct_column:string\\n\\n   // Number of records to return, defaults to 25 if not specified. Pass in -1 to return all records.\\n   limit:long\\n\\n   // Offset into the dataset of where to start retrieving records\\n   offset:long\\n\\n   // Fully qualified name of column to order by, must be in TABLE_NAME.COLUMN_NAME format\\n   order:string\\n\\n   // What direction to order, can be 'asc' or 'desc' implying ascending and descending\\n   direction:string\\n\\n   // Number of records to return, defaults to 25 if not specified. Pass in -1 to return all records.\\n\\n   // Offset into the dataset of where to start retrieving records\\n\\n   // Fully qualified name of column to order by, must be in TABLE_NAME.COLUMN_NAME format\\n\\n   // What direction to order, can be 'asc' or 'desc' implying ascending and descending\\n   categories.id.eq:long\\n   categories.name.like:string\\n   categories.name.eq:string\\n   categories.description.like:string\\n   categories.description.eq:string\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-distinct\\n\\n// Sanity checking that distinct column was passed in.\\nvalidators.mandatory:x:@.arguments/*/distinct_column\\n\\n// Sanity checking distinct column's name.\\nvalidators.enum:x:@.arguments/*/distinct_column\\n   .:categories.id\\n   .:categories.name\\n   .:categories.description\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:enterprise,root\\n\\n// Opening up our database connection.\\ndata.connect:[generic|cms]\\n   database-type:sqlite\\n\\n   // Making sure we're using correct function.\\n   set-name:x:./*/data.read/*/columns/*/distinct_functor\\n      strings.concat\\n         .:distinct(\\n         get-value:x:@.arguments/*/distinct_column\\n         .:)\\n\\n   // Removing distinct argument to simplify adding other arguments.\\n   remove-nodes:x:@.arguments/*/distinct_column\\n\\n   // Adding [limit] and [offset] arguments\\n   add:x:./*/data.read\\n      get-nodes:x:@.arguments/*/limit\\n      get-nodes:x:@.arguments/*/offset\\n      get-nodes:x:@.arguments/*/order\\n      get-nodes:x:@.arguments/*/direction\\n   remove-nodes:x:@.arguments/*/order\\n   remove-nodes:x:@.arguments/*/direction\\n   remove-nodes:x:@.arguments/*/limit\\n   remove-nodes:x:@.arguments/*/offset\\n   add:x:+/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:sqlite\\n      table:categories\\n      columns\\n         distinct_functor\\n            as:.\\n      where\\n         and\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Distinct Keyword Search from categories table in cms database.\\n\\nThis endpoint will return only records containing one or more of the keywords from the specified [query],\\nwith rows containing the most distinct matched keywords appearing first."},{"role":"assistant","content":".arguments\\n\\n   // Mandatory query for records to search for\\n   query:string\\n\\n   // Optional number of records to return, defaults to 10 if not specified. Pass in -1 to return all records\\n   limit:long\\n\\n   // Optional offset into the dataset of where to start retrieving records\\n   offset:long\\n\\n// Type of endpoint\\n.type:crud-search\\n\\n// Make sure the user has provided a query.\\nvalidators.mandatory:x:@.arguments/*/query\\n\\n// Apply defaults if not specified.\\nvalidators.default:x:@.arguments\\n   limit:long:10\\n\\n// Split the user's query into individual keywords, separated by spaces.\\n.words\\nadd:x:@.words\\n   strings.split:x:@.arguments/*/query\\n      .:\" \"\\n\\n// Enforce lower characters for each keyword, and guard against SQL injection.\\n.no:int:0\\nfor-each:x:@.words/*\\n   set-value:x:@.dp/#\\n      strings.to-lower:x:@.dp/#\\n\\n// Specify which columns to search against.\\n.columns\\n   .:name\\n   .:description\\n\\n// Connect to the specified database.\\ndata.connect:[generic|cms]\\n   database-type:sqlite\\n\\n   // Start building our SQL.\\n   .sql:select *, (\\n\\n   // 1) Dynamically create the full text by concatenating all columns we want to search.\\n   .fields\\n   for-each:x:@.columns/*\\n      strings.concat\\n         .:coalesce(\\n         get-value:x:@.dp/#\\n         .:\", '')\"\\n      unwrap:x:+/*/*\\n      add:x:@.fields\\n         .\\n            .:x:@strings.concat\\n   set-value:x:@.fields\\n      strings.join:x:@.fields/*\\n         .:\" || \"\\n   remove-nodes:x:@.fields/*\\n\\n   // 2) Keyword density calculation\\n   .no:int:0\\n   for-each:x:@.words/*\\n\\n      // Adding SQL parameter.\\n      set-name:x:+/+/*/*\\n         strings.concat\\n            .:@p\\n            get-value:x:@.no\\n      unwrap:x:+/*/*\\n      add:x:@data.connect/*/data.select\\n         .\\n            .:x:@.dp/#\\n\\n      // Modifying our SQL.\\n      if\\n         eq:x:@.no\\n            .:int:0\\n         .lambda\\n\\n            // First keyword => no leading plus\\n            set-value:x:@.sql\\n               strings.concat:x:@.sql\\n                  get-value:x:@.sql\\n                  .:\" (length(\"\\n                  get-value:x:@.fields\\n                  .:) - length(replace(lower(\\n                  get-value:x:@.fields\\n                  .:), @p\\n                  get-value:x:@.no\\n                  .:\", ''))) / length(@p\"\\n                  get-value:x:@.no\\n                  .:)\\n      else\\n         set-value:x:@.sql\\n            strings.concat:x:@.sql\\n               get-value:x:@.sql\\n               .:\" + (length(\"\\n               get-value:x:@.fields\\n               .:) - length(replace(lower(\\n               get-value:x:@.fields\\n               .:), @p\\n               get-value:x:@.no\\n               .:\", ''))) / length(@p\"\\n               get-value:x:@.no\\n               .:)\\n      math.increment:x:@.no\\n   set-value:x:@.sql\\n      strings.concat:x:@.sql\\n         get-value:x:@.sql\\n         .:) * 1.0 / length(\\n         get-value:x:@.fields\\n         .:) as keyword_density, (\\n\\n   // 3) Distinct keyword count => For each keyword, 1 if present, 0 if not.\\n   .no:int:0\\n   for-each:x:@.words/*\\n      if\\n         eq:x:@.no\\n            .:int:0\\n         .lambda\\n\\n            // First keyword => no leading plus\\n            set-value:x:@.sql\\n               strings.concat:x:@.sql\\n                  get-value:x:@.sql\\n                  .:\" CASE WHEN ((length(\"\\n                  get-value:x:@.fields\\n                  .:) - length(replace(lower(\\n                  get-value:x:@.fields\\n                  .:), @p\\n                  get-value:x:@.no\\n                  .:\", ''))) / length(@p\"\\n                  get-value:x:@.no\\n                  .:)) > 0 THEN 1 ELSE 0 END\\n      else\\n         set-value:x:@.sql\\n            strings.concat:x:@.sql\\n               get-value:x:@.sql\\n               .:\" + CASE WHEN ((length(\"\\n               get-value:x:@.fields\\n               .:) - length(replace(lower(\\n               get-value:x:@.fields\\n               .:), @p\\n               get-value:x:@.no\\n               .:\", ''))) / length(@p\"\\n               get-value:x:@.no\\n               .:)) > 0 THEN 1 ELSE 0 END\\n      math.increment:x:@.no\\n\\n   // Finalize \"keyword_count\".\\n   set-value:x:@.sql\\n      strings.concat:x:@.sql\\n         get-value:x:@.sql\\n         .:) as keyword_count\\n\\n   // 4) Finish SELECT + WHERE\\n   set-value:x:@.sql\\n      strings.concat:x:@.sql\\n         get-value:x:@.sql\\n         .:\" from \"\\n         .:categories\\n         .:\" where keyword_count > 0\"\\n\\n   // 5) Order by distinct keyword_count (higher means more distinct keywords), then keyword_density.\\n   set-value:x:@.sql\\n      strings.concat:x:@.sql\\n         get-value:x:@.sql\\n         .:\" order by keyword_count desc, keyword_density desc limit \"\\n         get-value:x:@.arguments/*/limit\\n\\n   // (Optional) offset => pagination\\n   if\\n      exists:x:@.arguments/*/offset\\n      .lambda\\n         set-value:x:@.sql\\n            strings.concat:x:@.sql\\n               get-value:x:@.sql\\n               .:\" offset \"\\n               get-value:x:@.arguments/*/offset\\n\\n   // Execute the SQL\\n   data.select:x:@.sql\\n      database-type:sqlite\\n\\n   // Remove helper fields if you don't want them in your final JSON\\n   remove-nodes:x:@data.select/*/*/keyword_density\\n   remove-nodes:x:@data.select/*/*/keyword_count\\n\\n   // Return the final result set\\n   return-nodes:x:@data.select/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Delete one record from your categories table in your cms database"},{"role":"assistant","content":".arguments\\n\\n   // Primary key of record to delete, mandatory argument\\n   id:long\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-delete\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root,admin\\nvalidators.mandatory:x:@.arguments/*/id\\n\\n// Opening up our database connection.\\ndata.connect:[generic|cms]\\n   database-type:sqlite\\n\\n   // Parametrising our delete invocation.\\n   add:x:./*/data.delete/*/where/*/and\\n      get-nodes:x:@.arguments/*\\n\\n   // Deleting item from database.\\n   data.delete\\n      database-type:sqlite\\n      table:categories\\n      where\\n         and\\n\\n   // Publishing socket message.\\n   add:x:./*/sockets.signal/*/args\\n      get-nodes:x:@.arguments/*\\n   add:x:./*/sockets.signal\\n      get-nodes:x:@auth.ticket.verify\\n   set-name:x:./*/sockets.signal/*/auth.ticket.verify\\n      .:roles\\n   sockets.signal:cms.categories.delete\\n      args\\n\\n   // Returning result of above invocation to caller.\\n   unwrap:x:+/*\\n   return\\n      affected:x:@data.delete\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Read or list records from your categories table in your cms database"},{"role":"assistant","content":".arguments\\n\\n   // Number of records to return, defaults to 25 if not specified. Pass in -1 to return all records.\\n\\n   // Offset into the dataset of where to start retrieving records\\n\\n   // Fully qualified name of column to order by, must be in TABLE_NAME.COLUMN_NAME format\\n\\n   // What direction to order, can be 'asc' or 'desc' implying ascending and descending\\n   categories.id.eq:long\\n   categories.name.like:string\\n   categories.name.eq:string\\n   categories.description.like:string\\n   categories.description.eq:string\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-read\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:enterprise,root\\n\\n// Opening up our database connection.\\ndata.connect:[generic|cms]\\n   database-type:sqlite\\n\\n   // Parametrising our read invocation with filtering arguments.\\n   add:x:./*/data.read/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:sqlite\\n      table:categories\\n      columns\\n         categories.id\\n         categories.name\\n         categories.description\\n      where\\n         and\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create one record in your categories table in your cms database"},{"role":"assistant","content":".arguments\\n\\n   // name column value\\n   name:string\\n\\n   // description column value\\n   description:string\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-create\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:enterprise,root\\n\\n// Opening up database connection.\\ndata.connect:[generic|cms]\\n   database-type:sqlite\\n\\n   // Parametrising our create invocation.\\n   add:x:./*/data.create/*/values\\n      get-nodes:x:@.arguments/*\\n\\n   // Creating our record.\\n   data.create\\n      database-type:sqlite\\n      table:categories\\n      return-id:bool:true\\n      values\\n\\n   // Returning the correct status code.\\n   response.status.set:201\\n\\n   // Publishing socket message.\\n   add:x:./*/sockets.signal/*/args\\n      get-nodes:x:@.arguments/*\\n   add:x:./*/sockets.signal\\n      get-nodes:x:@auth.ticket.verify\\n   set-name:x:./*/sockets.signal/*/auth.ticket.verify\\n      .:roles\\n   sockets.signal:cms.categories.post\\n      args\\n\\n   // Returning result of above invocation to caller.\\n   unwrap:x:+/*\\n   return\\n      id:x:@data.create\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Update one record in your categories table in your cms database"},{"role":"assistant","content":".arguments\\n\\n   // id column value being primary key of record to update, mandatory argument\\n   id:long\\n\\n   // name column's new value\\n   name:string\\n\\n   // description column's new value\\n   description:string\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-update\\n\\n// Sanity checking invocation, making sure primary key(s) are specified.\\nvalidators.mandatory:x:@.arguments/*/id\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:enterprise,root\\n\\n// Opening up our database connection.\\ndata.connect:[generic|cms]\\n   database-type:sqlite\\n\\n   // Parametrising our invocation.\\n   add:x:./*/data.update/*/values\\n      get-nodes:x:@.arguments/*/[1,1000]\\n   add:x:./*/data.update/*/where/*/and\\n      get-nodes:x:@.arguments/*/[0,1]\\n\\n   // Invoking our update slot.\\n   data.update\\n      database-type:sqlite\\n      table:categories\\n      values\\n      where\\n         and\\n\\n   // Verifying record exists.\\n   if\\n      eq\\n         get-value:x:@data.update\\n         .:int:0\\n      .lambda\\n         response.status.set:404\\n         return\\n            result:Record not found\\n\\n   // Returning the correct status code.\\n   response.status.set:202\\n\\n   // Publishing socket message.\\n   add:x:./*/sockets.signal/*/args\\n      get-nodes:x:@.arguments/*\\n   add:x:./*/sockets.signal\\n      get-nodes:x:@auth.ticket.verify\\n   set-name:x:./*/sockets.signal/*/auth.ticket.verify\\n      .:roles\\n   sockets.signal:cms.categories.put\\n      args\\n\\n   // Returning success to caller.\\n   unwrap:x:+/*\\n   return\\n      affected:x:@data.update\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"This script counts the number of Hyperlambda files, in addition to the combined\\nnumber of nodes, within the specified folder."},{"role":"assistant","content":".folder:/modules/cms/\\nunwrap:x:+/*\\nsignal:magic.io.file.load-recursively\\n   .:x:@.folder\\nfor-each:x:@signal/*\\n   if\\n      strings.ends-with:x:@.dp/#\\n         .:.hl\\n      .lambda\\n         hyper2lambda:x:@.dp/#/0\\n            comments:true\\n         set-value:x:@hyper2lambda/0\\n            strings.concat\\n               .:\"Generate a Hyperlambda with authorization for 'guest' roles files that \"\\n               get-value:x:@hyper2lambda/0\\n         lambda2hyper:x:@hyper2lambda/*\\n            comments:true\\n         io.file.save:x:@.dp/#\\n            get-value:x:@lambda2hyper\\nremove-nodes:x:@signal/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns minimum, maximum, average or sum from your comments table in your cms database"},{"role":"assistant","content":".arguments\\n\\n   // Function to aggregate upon. Argument is mandatory and legal values are min, max, sum or avg\\n   aggregate_function:string\\n\\n   // Argument is mandatory and must be in the format of TABLE_NAME.COLUMN_NAME.\\n   aggregate_column:string\\n\\n   // Number of records to return, defaults to 25 if not specified. Pass in -1 to return all records.\\n\\n   // Offset into the dataset of where to start retrieving records\\n\\n   // Fully qualified name of column to order by, must be in TABLE_NAME.COLUMN_NAME format\\n\\n   // What direction to order, can be 'asc' or 'desc' implying ascending and descending\\n   comments.id.eq:long\\n   comments.post_id.eq:long\\n   comments.user_id.eq:long\\n   comments.content.like:string\\n   comments.content.eq:string\\n   comments.created_at.eq:date\\n   post_id.title.eq:string\\n   post_id.title.like:string\\n   user_id.username.eq:string\\n   user_id.username.like:string\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-aggregate\\n\\n// Sanity checking mandatory arguments.\\nvalidators.mandatory:x:@.arguments/*/aggregate_function\\nvalidators.mandatory:x:@.arguments/*/aggregate_column\\n\\n// Sanity checking name of aggregate function.\\nvalidators.enum:x:@.arguments/*/aggregate_function\\n   .:min\\n   .:max\\n   .:sum\\n   .:avg\\n\\n// Sanity checking agggregate column name.\\nvalidators.enum:x:@.arguments/*/aggregate_column\\n   .:comments.id\\n   .:comments.post_id\\n   .:comments.user_id\\n   .:comments.content\\n   .:comments.created_at\\n   .:post_id.title\\n   .:user_id.username\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:enterprise,root\\n\\n// Opening up our database connection.\\ndata.connect:[generic|cms]\\n   database-type:sqlite\\n\\n   // Making sure we're using correct aggregate function.\\n   set-name:x:./*/data.read/*/columns/*/aggregate_functor\\n      strings.concat\\n         get-value:x:@.arguments/*/aggregate_function\\n         .:(\\n         get-value:x:@.arguments/*/aggregate_column\\n         .:)\\n\\n   // Removing aggregate arguments to simplify adding other arguments.\\n   remove-nodes:x:@.arguments/*/[0,2]\\n   add:x:+/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:sqlite\\n      table:comments\\n         join:posts\\n            as:post_id\\n            type:left\\n            on\\n               and\\n                  comments.post_id:post_id.id\\n         join:users\\n            as:user_id\\n            type:left\\n            on\\n               and\\n                  comments.user_id:user_id.id\\n      columns\\n         aggregate_functor\\n            as:result\\n      where\\n         and\\n      limit:long:1\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Counts items from your comments table in your cms database"},{"role":"assistant","content":".arguments\\n\\n   // Number of records to return, defaults to 25 if not specified. Pass in -1 to return all records.\\n\\n   // Offset into the dataset of where to start retrieving records\\n\\n   // Fully qualified name of column to order by, must be in TABLE_NAME.COLUMN_NAME format\\n\\n   // What direction to order, can be 'asc' or 'desc' implying ascending and descending\\n   comments.id.eq:long\\n   comments.post_id.eq:long\\n   comments.user_id.eq:long\\n   comments.content.like:string\\n   comments.content.eq:string\\n   comments.created_at.eq:date\\n   post_id.title.eq:string\\n   post_id.title.like:string\\n   user_id.username.eq:string\\n   user_id.username.like:string\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-count\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:enterprise,root\\n\\n// Opening up our database connection.\\ndata.connect:[generic|cms]\\n   database-type:sqlite\\n   add:x:+/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:sqlite\\n      table:comments\\n         join:posts\\n            as:post_id\\n            type:left\\n            on\\n               and\\n                  comments.post_id:post_id.id\\n         join:users\\n            as:user_id\\n            type:left\\n            on\\n               and\\n                  comments.user_id:user_id.id\\n      columns\\n         count(*)\\n            as:count\\n      where\\n         and\\n      limit:long:1\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns unique and distinct values from your comments table in your cms database"},{"role":"assistant","content":".arguments\\n\\n   // Name of column to return unique and distinct values for. Argument is mandatory and must be in the format of TABLE_NAME.COLUMN_NAME\\n   distinct_column:string\\n\\n   // Number of records to return, defaults to 25 if not specified. Pass in -1 to return all records.\\n   limit:long\\n\\n   // Offset into the dataset of where to start retrieving records\\n   offset:long\\n\\n   // Fully qualified name of column to order by, must be in TABLE_NAME.COLUMN_NAME format\\n   order:string\\n\\n   // What direction to order, can be 'asc' or 'desc' implying ascending and descending\\n   direction:string\\n\\n   // Number of records to return, defaults to 25 if not specified. Pass in -1 to return all records.\\n\\n   // Offset into the dataset of where to start retrieving records\\n\\n   // Fully qualified name of column to order by, must be in TABLE_NAME.COLUMN_NAME format\\n\\n   // What direction to order, can be 'asc' or 'desc' implying ascending and descending\\n   comments.id.eq:long\\n   comments.post_id.eq:long\\n   comments.user_id.eq:long\\n   comments.content.like:string\\n   comments.content.eq:string\\n   comments.created_at.eq:date\\n   post_id.title.eq:string\\n   post_id.title.like:string\\n   user_id.username.eq:string\\n   user_id.username.like:string\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-distinct\\n\\n// Sanity checking that distinct column was passed in.\\nvalidators.mandatory:x:@.arguments/*/distinct_column\\n\\n// Sanity checking distinct column's name.\\nvalidators.enum:x:@.arguments/*/distinct_column\\n   .:comments.id\\n   .:comments.post_id\\n   .:comments.user_id\\n   .:comments.content\\n   .:comments.created_at\\n   .:post_id.title\\n   .:user_id.username\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:enterprise,root\\n\\n// Opening up our database connection.\\ndata.connect:[generic|cms]\\n   database-type:sqlite\\n\\n   // Making sure we're using correct function.\\n   set-name:x:./*/data.read/*/columns/*/distinct_functor\\n      strings.concat\\n         .:distinct(\\n         get-value:x:@.arguments/*/distinct_column\\n         .:)\\n\\n   // Removing distinct argument to simplify adding other arguments.\\n   remove-nodes:x:@.arguments/*/distinct_column\\n\\n   // Adding [limit] and [offset] arguments\\n   add:x:./*/data.read\\n      get-nodes:x:@.arguments/*/limit\\n      get-nodes:x:@.arguments/*/offset\\n      get-nodes:x:@.arguments/*/order\\n      get-nodes:x:@.arguments/*/direction\\n   remove-nodes:x:@.arguments/*/order\\n   remove-nodes:x:@.arguments/*/direction\\n   remove-nodes:x:@.arguments/*/limit\\n   remove-nodes:x:@.arguments/*/offset\\n   add:x:+/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:sqlite\\n      table:comments\\n         join:posts\\n            as:post_id\\n            type:left\\n            on\\n               and\\n                  comments.post_id:post_id.id\\n         join:users\\n            as:user_id\\n            type:left\\n            on\\n               and\\n                  comments.user_id:user_id.id\\n      columns\\n         distinct_functor\\n            as:.\\n      where\\n         and\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns minimum, maximum, average, sum or count from your comments table in your cms database grouped by a column"},{"role":"assistant","content":".arguments\\n\\n   // Mandatory argument being column to group by and must be in the format of TABLE_NAME.COLUMN_NAME\\n   group_column:string\\n\\n   // Number of records to return, defaults to 25 if not specified. Pass in -1 to return all records.\\n   limit:long\\n\\n   // Offset into the dataset of where to start retrieving records\\n   offset:long\\n\\n   // Fully qualified name of column to order by, must be in TABLE_NAME.COLUMN_NAME format\\n   order:string\\n\\n   // What direction to order, can be 'asc' or 'desc' implying ascending and descending\\n   direction:string\\n\\n   // Function to aggregate upon. Argument is mandatory and legal values are min, max, sum, avg or count\\n   aggregate_function:string\\n\\n   // Argument is mandatory and must be in the format of TABLE_NAME.COLUMN_NAME.\\n   aggregate_column:string\\n\\n   // Number of records to return, defaults to 25 if not specified. Pass in -1 to return all records.\\n\\n   // Offset into the dataset of where to start retrieving records\\n\\n   // Fully qualified name of column to order by, must be in TABLE_NAME.COLUMN_NAME format\\n\\n   // What direction to order, can be 'asc' or 'desc' implying ascending and descending\\n   comments.id.eq:long\\n   comments.post_id.eq:long\\n   comments.user_id.eq:long\\n   comments.content.like:string\\n   comments.content.eq:string\\n   comments.created_at.eq:date\\n   post_id.title.eq:string\\n   post_id.title.like:string\\n   user_id.username.eq:string\\n   user_id.username.like:string\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-group\\n\\n// Sanity checking mandatory arguments.\\nvalidators.mandatory:x:@.arguments/*/group_column\\nvalidators.mandatory:x:@.arguments/*/aggregate_function\\nvalidators.mandatory:x:@.arguments/*/aggregate_column\\n\\n// Sanity checking name of aggregate function.\\nvalidators.enum:x:@.arguments/*/aggregate_function\\n   .:min\\n   .:max\\n   .:sum\\n   .:avg\\n   .:count\\n\\n// Sanity checking group column.\\nvalidators.enum:x:@.arguments/*/group_column\\n   .:comments.id\\n   .:comments.post_id\\n   .:comments.user_id\\n   .:comments.content\\n   .:comments.created_at\\n   .:post_id.title\\n   .:user_id.username\\n\\n// Sanity checking agggregate column name.\\nvalidators.enum:x:@.arguments/*/aggregate_column\\n   .:comments.id\\n   .:comments.post_id\\n   .:comments.user_id\\n   .:comments.content\\n   .:comments.created_at\\n   .:post_id.title\\n   .:user_id.username\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:enterprise,root\\n\\n// Opening up our database connection.\\ndata.connect:[generic|cms]\\n   database-type:sqlite\\n\\n   // Making sure we're using the correct group column\\n   set-name:x:@data.connect/*/data.read/*/group/*/group_column\\n      get-value:x:@.arguments/*/group_column\\n\\n   // Making sure we return group column as a part of the result\\n   set-name:x:+/*/*\\n      get-value:x:@.arguments/*/group_column\\n   insert-before:x:@data.connect/*/data.read/*/columns/0\\n      .\\n         group_column\\n\\n   // Changing name of aggregate column returned to caller.\\n   set-value:x:@data.connect/*/data.read/*/columns/1/*/as\\n      get-value:x:@.arguments/*/aggregate_function\\n\\n   // Removing group column to simplify adding other arguments\\n   remove-nodes:x:@.arguments/*/group_column\\n\\n   // Adding paging arguments\\n   add:x:@data.connect/*/data.read\\n      get-nodes:x:@.arguments/*/limit\\n      get-nodes:x:@.arguments/*/offset\\n   remove-nodes:x:@.arguments/*/limit\\n   remove-nodes:x:@.arguments/*/offset\\n\\n   // Parametrising our read invocation with ordering arguments if specified.\\n   add:x:./*/data.read\\n      get-nodes:x:@.arguments/*/order\\n      get-nodes:x:@.arguments/*/direction\\n   remove-nodes:x:@.arguments/*/order\\n   remove-nodes:x:@.arguments/*/direction\\n\\n   // Making sure we're using correct aggregate function.\\n   set-name:x:./*/data.read/*/columns/*/aggregate_functor\\n      strings.concat\\n         get-value:x:@.arguments/*/aggregate_function\\n         .:(\\n         get-value:x:@.arguments/*/aggregate_column\\n         .:)\\n\\n   // Removing aggregate arguments to simplify adding other arguments.\\n   remove-nodes:x:@.arguments/*/[0,2]\\n   add:x:+/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:sqlite\\n      table:comments\\n         join:posts\\n            as:post_id\\n            type:left\\n            on\\n               and\\n                  comments.post_id:post_id.id\\n         join:users\\n            as:user_id\\n            type:left\\n            on\\n               and\\n                  comments.user_id:user_id.id\\n      columns\\n         aggregate_functor\\n            as:result\\n      where\\n         and\\n      group\\n         group_column\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Distinct Keyword Search from comments table in cms database.\\n\\nThis endpoint will return only records containing one or more of the keywords from the specified [query],\\nwith rows containing the most distinct matched keywords appearing first."},{"role":"assistant","content":".arguments\\n\\n   // Mandatory query for records to search for\\n   query:string\\n\\n   // Optional number of records to return, defaults to 10 if not specified. Pass in -1 to return all records\\n   limit:long\\n\\n   // Optional offset into the dataset of where to start retrieving records\\n   offset:long\\n\\n// Type of endpoint\\n.type:crud-search\\n\\n// Make sure the user has provided a query.\\nvalidators.mandatory:x:@.arguments/*/query\\n\\n// Apply defaults if not specified.\\nvalidators.default:x:@.arguments\\n   limit:long:10\\n\\n// Split the user's query into individual keywords, separated by spaces.\\n.words\\nadd:x:@.words\\n   strings.split:x:@.arguments/*/query\\n      .:\" \"\\n\\n// Enforce lower characters for each keyword, and guard against SQL injection.\\n.no:int:0\\nfor-each:x:@.words/*\\n   set-value:x:@.dp/#\\n      strings.to-lower:x:@.dp/#\\n\\n// Specify which columns to search against.\\n.columns\\n   .:content\\n\\n// Connect to the specified database.\\ndata.connect:[generic|cms]\\n   database-type:sqlite\\n\\n   // Start building our SQL.\\n   .sql:select *, (\\n\\n   // 1) Dynamically create the full text by concatenating all columns we want to search.\\n   .fields\\n   for-each:x:@.columns/*\\n      strings.concat\\n         .:coalesce(\\n         get-value:x:@.dp/#\\n         .:\", '')\"\\n      unwrap:x:+/*/*\\n      add:x:@.fields\\n         .\\n            .:x:@strings.concat\\n   set-value:x:@.fields\\n      strings.join:x:@.fields/*\\n         .:\" || \"\\n   remove-nodes:x:@.fields/*\\n\\n   // 2) Keyword density calculation\\n   .no:int:0\\n   for-each:x:@.words/*\\n\\n      // Adding SQL parameter.\\n      set-name:x:+/+/*/*\\n         strings.concat\\n            .:@p\\n            get-value:x:@.no\\n      unwrap:x:+/*/*\\n      add:x:@data.connect/*/data.select\\n         .\\n            .:x:@.dp/#\\n\\n      // Modifying our SQL.\\n      if\\n         eq:x:@.no\\n            .:int:0\\n         .lambda\\n\\n            // First keyword => no leading plus\\n            set-value:x:@.sql\\n               strings.concat:x:@.sql\\n                  get-value:x:@.sql\\n                  .:\" (length(\"\\n                  get-value:x:@.fields\\n                  .:) - length(replace(lower(\\n                  get-value:x:@.fields\\n                  .:), @p\\n                  get-value:x:@.no\\n                  .:\", ''))) / length(@p\"\\n                  get-value:x:@.no\\n                  .:)\\n      else\\n         set-value:x:@.sql\\n            strings.concat:x:@.sql\\n               get-value:x:@.sql\\n               .:\" + (length(\"\\n               get-value:x:@.fields\\n               .:) - length(replace(lower(\\n               get-value:x:@.fields\\n               .:), @p\\n               get-value:x:@.no\\n               .:\", ''))) / length(@p\"\\n               get-value:x:@.no\\n               .:)\\n      math.increment:x:@.no\\n   set-value:x:@.sql\\n      strings.concat:x:@.sql\\n         get-value:x:@.sql\\n         .:) * 1.0 / length(\\n         get-value:x:@.fields\\n         .:) as keyword_density, (\\n\\n   // 3) Distinct keyword count => For each keyword, 1 if present, 0 if not.\\n   .no:int:0\\n   for-each:x:@.words/*\\n      if\\n         eq:x:@.no\\n            .:int:0\\n         .lambda\\n\\n            // First keyword => no leading plus\\n            set-value:x:@.sql\\n               strings.concat:x:@.sql\\n                  get-value:x:@.sql\\n                  .:\" CASE WHEN ((length(\"\\n                  get-value:x:@.fields\\n                  .:) - length(replace(lower(\\n                  get-value:x:@.fields\\n                  .:), @p\\n                  get-value:x:@.no\\n                  .:\", ''))) / length(@p\"\\n                  get-value:x:@.no\\n                  .:)) > 0 THEN 1 ELSE 0 END\\n      else\\n         set-value:x:@.sql\\n            strings.concat:x:@.sql\\n               get-value:x:@.sql\\n               .:\" + CASE WHEN ((length(\"\\n               get-value:x:@.fields\\n               .:) - length(replace(lower(\\n               get-value:x:@.fields\\n               .:), @p\\n               get-value:x:@.no\\n               .:\", ''))) / length(@p\"\\n               get-value:x:@.no\\n               .:)) > 0 THEN 1 ELSE 0 END\\n      math.increment:x:@.no\\n\\n   // Finalize \"keyword_count\".\\n   set-value:x:@.sql\\n      strings.concat:x:@.sql\\n         get-value:x:@.sql\\n         .:) as keyword_count\\n\\n   // 4) Finish SELECT + WHERE\\n   set-value:x:@.sql\\n      strings.concat:x:@.sql\\n         get-value:x:@.sql\\n         .:\" from \"\\n         .:comments\\n         .:\" where keyword_count > 0\"\\n\\n   // 5) Order by distinct keyword_count (higher means more distinct keywords), then keyword_density.\\n   set-value:x:@.sql\\n      strings.concat:x:@.sql\\n         get-value:x:@.sql\\n         .:\" order by keyword_count desc, keyword_density desc limit \"\\n         get-value:x:@.arguments/*/limit\\n\\n   // (Optional) offset => pagination\\n   if\\n      exists:x:@.arguments/*/offset\\n      .lambda\\n         set-value:x:@.sql\\n            strings.concat:x:@.sql\\n               get-value:x:@.sql\\n               .:\" offset \"\\n               get-value:x:@.arguments/*/offset\\n\\n   // Execute the SQL\\n   data.select:x:@.sql\\n      database-type:sqlite\\n\\n   // Remove helper fields if you don't want them in your final JSON\\n   remove-nodes:x:@data.select/*/*/keyword_density\\n   remove-nodes:x:@data.select/*/*/keyword_count\\n\\n   // Return the final result set\\n   return-nodes:x:@data.select/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Delete one record from your comments table in your cms database"},{"role":"assistant","content":".arguments\\n\\n   // Primary key of record to delete, mandatory argument\\n   id:long\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-delete\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root,admin\\nvalidators.mandatory:x:@.arguments/*/id\\n\\n// Opening up our database connection.\\ndata.connect:[generic|cms]\\n   database-type:sqlite\\n\\n   // Parametrising our delete invocation.\\n   add:x:./*/data.delete/*/where/*/and\\n      get-nodes:x:@.arguments/*\\n\\n   // Deleting item from database.\\n   data.delete\\n      database-type:sqlite\\n      table:comments\\n      where\\n         and\\n\\n   // Publishing socket message.\\n   add:x:./*/sockets.signal/*/args\\n      get-nodes:x:@.arguments/*\\n   add:x:./*/sockets.signal\\n      get-nodes:x:@auth.ticket.verify\\n   set-name:x:./*/sockets.signal/*/auth.ticket.verify\\n      .:roles\\n   sockets.signal:cms.comments.delete\\n      args\\n\\n   // Returning result of above invocation to caller.\\n   unwrap:x:+/*\\n   return\\n      affected:x:@data.delete\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Read or list records from your comments table in your cms database"},{"role":"assistant","content":".arguments\\n\\n   // Number of records to return, defaults to 25 if not specified. Pass in -1 to return all records.\\n\\n   // Offset into the dataset of where to start retrieving records\\n\\n   // Fully qualified name of column to order by, must be in TABLE_NAME.COLUMN_NAME format\\n\\n   // What direction to order, can be 'asc' or 'desc' implying ascending and descending\\n   comments.id.eq:long\\n   comments.post_id.eq:long\\n   comments.user_id.eq:long\\n   comments.content.like:string\\n   comments.content.eq:string\\n   comments.created_at.eq:date\\n   post_id.title.eq:string\\n   post_id.title.like:string\\n   user_id.username.eq:string\\n   user_id.username.like:string\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-read\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:enterprise,root\\n\\n// Opening up our database connection.\\ndata.connect:[generic|cms]\\n   database-type:sqlite\\n\\n   // Parametrising our read invocation with filtering arguments.\\n   add:x:./*/data.read/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:sqlite\\n      table:comments\\n         join:posts\\n            as:post_id\\n            type:left\\n            on\\n               and\\n                  comments.post_id:post_id.id\\n         join:users\\n            as:user_id\\n            type:left\\n            on\\n               and\\n                  comments.user_id:user_id.id\\n      columns\\n         comments.id\\n         comments.post_id\\n         comments.user_id\\n         comments.content\\n         comments.created_at\\n         post_id.title\\n            as:post_id.title\\n         user_id.username\\n            as:user_id.username\\n      where\\n         and\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create one record in your comments table in your cms database"},{"role":"assistant","content":".arguments\\n\\n   // post_id column value\\n   post_id:long\\n\\n   // user_id column value\\n   user_id:long\\n\\n   // content column value\\n   content:string\\n\\n   // created_at column value\\n   created_at:date\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-create\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:enterprise,root\\n.foreign-keys\\n   .\\n      column:post_id\\n      table:posts\\n      foreign_column:id\\n      foreign_name:title\\n      long:bool:true\\n   .\\n      column:user_id\\n      table:users\\n      foreign_column:id\\n      foreign_name:username\\n      long:bool:true\\n\\n// Opening up database connection.\\ndata.connect:[generic|cms]\\n   database-type:sqlite\\n\\n   // Parametrising our create invocation.\\n   add:x:./*/data.create/*/values\\n      get-nodes:x:@.arguments/*\\n\\n   // Creating our record.\\n   data.create\\n      database-type:sqlite\\n      table:comments\\n      return-id:bool:true\\n      values\\n\\n   // Returning the correct status code.\\n   response.status.set:201\\n\\n   // Publishing socket message.\\n   add:x:./*/sockets.signal/*/args\\n      get-nodes:x:@.arguments/*\\n   add:x:./*/sockets.signal\\n      get-nodes:x:@auth.ticket.verify\\n   set-name:x:./*/sockets.signal/*/auth.ticket.verify\\n      .:roles\\n   sockets.signal:cms.comments.post\\n      args\\n\\n   // Returning result of above invocation to caller.\\n   unwrap:x:+/*\\n   return\\n      id:x:@data.create\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"This script counts the number of Hyperlambda files, in addition to the combined\\nnumber of nodes, within the specified folder."},{"role":"assistant","content":".folder:/\\n.loc:int:0\\n.files:int:0\\nunwrap:x:+/*\\nsignal:magic.io.file.load-recursively\\n   .:x:@.folder\\nfor-each:x:@signal/*\\n   if\\n      strings.ends-with:x:@.dp/#\\n         .:.hl\\n      .lambda\\n         hyper2lambda:x:@.dp/#/0\\n         math.increment:x:@.loc\\n            get-count:x:@hyper2lambda/**\\n         math.increment:x:@.files\\nremove-nodes:x:@signal/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Retrieves all URLs from sitemap on specified website."},{"role":"assistant","content":".url:\"https://ainiro.io\"\\n\\n// will contain all URLs from website\\n.urls\\n\\n// Retrieving main sitemap.\\nstrings.concat\\n   get-value:x:@.url\\n   .:/sitemap.xml\\nhttp.get:x:@strings.concat\\nxml2lambda:x:@http.get/*/content\\n\\n// Iterating through each URL referenced in main sitemap.\\nfor-each:x:\"@xml2lambda/*/sitemapindex/*/sitemap/*/loc/*/\\\\#text\"\\n\\n   // Getting XML from currently iterated sitemap subset.\\n   unwrap:x:+/*/*\\n   http.get:x:@.dp/#\\n   xml2lambda:x:@http.get/*/content\\n   for-each:x:\"@xml2lambda/*/urlset/*/url/*/loc/*/\\\\#text\"\\n      unwrap:x:+/*/*\\n      add:x:@.urls\\n         .\\n            .:x:@.dp/#\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"This script generates training data from Markdown files."},{"role":"assistant","content":"execute:magic.io.file.load-recursively\\n   .:/etc/slett/\\nfor-each:x:@execute/*\\n\\n   // Verifying we're dealing with a Markdown file.\\n   if\\n      strings.ends-with:x:@.dp/#\\n         .:.md\\n      .lambda\\n\\n         // Extracting training data.\\n         markdown2html:x:@.dp/#/0\\n         html2lambda:x:-\\n         for-each:x:@html2lambda/*/pre/*/code\\n            strings.trim:x:\"@.dp/#/*/\\\\#text\"\\n            data.connect:fine-tune\\n               data.create\\n                  table:hyperlambda\\n                  values\\n                     code:x:@strings.trim\\n\\n// House cleanups.\\nremove-nodes:x:@execute/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Counts items from your DATABASE_NAME and TABLE_NAME."},{"role":"assistant","content":"data.connect:DATABASE_NAME\\n   database-type:sqlite\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:sqlite\\n      table:TABLE_NAME\\n      columns\\n         count(*)\\n            as:count\\n      limit:long:1\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Creates a new item in DATABASE_NAME database and its TABLE_NAME table."},{"role":"assistant","content":"data.connect:DATABASE_NAME\\n   database-type:sqlite\\n\\n   // Creating our record.\\n   data.create\\n      database-type:sqlite\\n      table:TABLE_NAME\\n      values\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Deletes one item from your DATABASE_NAME database and TABLE_NAME table with the id of WHATEVER_ID_HERE."},{"role":"assistant","content":"data.connect:DATABASE_NAME\\n   database-type:sqlite\\n\\n   // Deleting item from database.\\n   data.delete\\n      database-type:sqlite\\n      table:TABLE_NAME\\n      where\\n         and\\n            id.eq:x:@WHATEVER_ID_HERE\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns items from your DATABASE_NAME and TABLE_NAME."},{"role":"assistant","content":"data.connect:DATABASE_NAME\\n   database-type:sqlite\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:sqlite\\n      table:TABLE_NAME\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Invokes some dynamic slot and sets the value of [.res] to the result of the invocation"},{"role":"assistant","content":"signal:SOME_DYNAMIC_SLOT\\n.res\\nset-value:x:@.res\\n   get-value:x:@signal\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Loads the /README.md text file and sets the value of [.res] to the content of the file."},{"role":"assistant","content":".res\\nset-value:x:@.res\\n   io.file.load:/README.md\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Sets the value of [.res] to the number of records we've got in our table1 table in our foo database"},{"role":"assistant","content":".res\\ndata.connect:foo\\n   set-value:x:@.res\\n      data.scalar:select count(*) from table1\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Custom endpoint or Hyperlambda file taking mandatory two arguments"},{"role":"assistant","content":".arguments\\n   arg1:string\\n   arg2:date\\nvalidators.mandatory:x:@.arguments/*/arg1\\nvalidators.mandatory:x:@.arguments/*/arg2\\n\\n// If either of the arguments don't exists, the above will throw an exception\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns minimum, maximum, average or sum from your Customer table in your chinook database"},{"role":"assistant","content":".arguments\\n\\n   // Function to aggregate upon. Argument is mandatory and legal values are min, max, sum or avg\\n   aggregate_function:string\\n\\n   // Argument is mandatory and must be in the format of TABLE_NAME.COLUMN_NAME.\\n   aggregate_column:string\\n\\n   // Optional logical operator for filtering arguments, can be either 'or' or 'and'. Defaults to and.\\n   operator:string\\n   Customer.CustomerId.mt:long\\n   Customer.CustomerId.lt:long\\n   Customer.CustomerId.mteq:long\\n   Customer.CustomerId.lteq:long\\n   Customer.CustomerId.neq:long\\n   Customer.CustomerId.eq:long\\n   Customer.FirstName.like:string\\n   Customer.FirstName.mt:string\\n   Customer.FirstName.lt:string\\n   Customer.FirstName.mteq:string\\n   Customer.FirstName.lteq:string\\n   Customer.FirstName.neq:string\\n   Customer.FirstName.eq:string\\n   Customer.LastName.like:string\\n   Customer.LastName.mt:string\\n   Customer.LastName.lt:string\\n   Customer.LastName.mteq:string\\n   Customer.LastName.lteq:string\\n   Customer.LastName.neq:string\\n   Customer.LastName.eq:string\\n   Customer.Company.like:string\\n   Customer.Company.mt:string\\n   Customer.Company.lt:string\\n   Customer.Company.mteq:string\\n   Customer.Company.lteq:string\\n   Customer.Company.neq:string\\n   Customer.Company.eq:string\\n   Customer.Address.like:string\\n   Customer.Address.mt:string\\n   Customer.Address.lt:string\\n   Customer.Address.mteq:string\\n   Customer.Address.lteq:string\\n   Customer.Address.neq:string\\n   Customer.Address.eq:string\\n   Customer.City.like:string\\n   Customer.City.mt:string\\n   Customer.City.lt:string\\n   Customer.City.mteq:string\\n   Customer.City.lteq:string\\n   Customer.City.neq:string\\n   Customer.City.eq:string\\n   Customer.State.like:string\\n   Customer.State.mt:string\\n   Customer.State.lt:string\\n   Customer.State.mteq:string\\n   Customer.State.lteq:string\\n   Customer.State.neq:string\\n   Customer.State.eq:string\\n   Customer.Country.like:string\\n   Customer.Country.mt:string\\n   Customer.Country.lt:string\\n   Customer.Country.mteq:string\\n   Customer.Country.lteq:string\\n   Customer.Country.neq:string\\n   Customer.Country.eq:string\\n   Customer.PostalCode.like:string\\n   Customer.PostalCode.mt:string\\n   Customer.PostalCode.lt:string\\n   Customer.PostalCode.mteq:string\\n   Customer.PostalCode.lteq:string\\n   Customer.PostalCode.neq:string\\n   Customer.PostalCode.eq:string\\n   Customer.Phone.like:string\\n   Customer.Phone.mt:string\\n   Customer.Phone.lt:string\\n   Customer.Phone.mteq:string\\n   Customer.Phone.lteq:string\\n   Customer.Phone.neq:string\\n   Customer.Phone.eq:string\\n   Customer.Fax.like:string\\n   Customer.Fax.mt:string\\n   Customer.Fax.lt:string\\n   Customer.Fax.mteq:string\\n   Customer.Fax.lteq:string\\n   Customer.Fax.neq:string\\n   Customer.Fax.eq:string\\n   Customer.Email.like:string\\n   Customer.Email.mt:string\\n   Customer.Email.lt:string\\n   Customer.Email.mteq:string\\n   Customer.Email.lteq:string\\n   Customer.Email.neq:string\\n   Customer.Email.eq:string\\n   Customer.SupportRepId.mt:long\\n   Customer.SupportRepId.lt:long\\n   Customer.SupportRepId.mteq:long\\n   Customer.SupportRepId.lteq:long\\n   Customer.SupportRepId.neq:long\\n   Customer.SupportRepId.eq:long\\n   SupportRepId.LastName.eq:string\\n   SupportRepId.LastName.like:string\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-aggregate\\n\\n// Sanity checking mandatory arguments.\\nvalidators.mandatory:x:@.arguments/*/aggregate_function\\nvalidators.mandatory:x:@.arguments/*/aggregate_column\\n\\n// Sanity checking name of aggregate function.\\nvalidators.enum:x:@.arguments/*/aggregate_function\\n   .:min\\n   .:max\\n   .:sum\\n   .:avg\\n\\n// Sanity checking agggregate column name.\\nvalidators.enum:x:@.arguments/*/aggregate_column\\n   .:Customer.CustomerId\\n   .:Customer.FirstName\\n   .:Customer.LastName\\n   .:Customer.Company\\n   .:Customer.Address\\n   .:Customer.City\\n   .:Customer.State\\n   .:Customer.Country\\n   .:Customer.PostalCode\\n   .:Customer.Phone\\n   .:Customer.Fax\\n   .:Customer.Email\\n   .:Customer.SupportRepId\\n   .:SupportRepId.LastName\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root,admin\\n\\n// Sanity checking invocation.\\nvalidators.enum:x:@.arguments/*/operator\\n   .:or\\n   .:and\\n\\n/*\\n * Checking if user supplied an [operator] argument, and if so\\n * changing the boolean operator for comparison operations.\\n */\\nif\\n   exists:x:@.arguments/*/operator\\n   .lambda\\n\\n      // User provided a boolean comparison [operator] argument.\\n      set-name:x:../*/data.connect/*/data.read/*/where/0\\n         get-value:x:@.arguments/*/operator\\n      remove-nodes:x:@.arguments/*/operator\\n\\n// Opening up our database connection.\\ndata.connect:[generic|chinook]\\n   database-type:sqlite\\n\\n   // Making sure we're using correct aggregate function.\\n   set-name:x:./*/data.read/*/columns/*/aggregate_functor\\n      strings.concat\\n         get-value:x:@.arguments/*/aggregate_function\\n         .:(\\n         get-value:x:@.arguments/*/aggregate_column\\n         .:)\\n\\n   // Removing aggregate arguments to simplify adding other arguments.\\n   remove-nodes:x:@.arguments/*/[0,2]\\n\\n   // Adding filtering arguments.\\n   add:x:+/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:sqlite\\n      table:Customer\\n         join:Employee\\n            as:SupportRepId\\n            type:left\\n            on\\n               and\\n                  Customer.SupportRepId:SupportRepId.EmployeeId\\n      columns\\n         aggregate_functor\\n            as:result\\n      where\\n         and\\n      limit:long:1\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Count unique and distinct items from your Customer table in your chinook database"},{"role":"assistant","content":".arguments\\n\\n   // Argument is mandatory and must be in the format of TABLE_NAME.COLUMN_NAME\\n   distinct_column:string\\n\\n   // Optional logical operator for filtering arguments, can be either 'or' or 'and'. Defaults to and.\\n   operator:string\\n   Customer.CustomerId.mt:long\\n   Customer.CustomerId.lt:long\\n   Customer.CustomerId.mteq:long\\n   Customer.CustomerId.lteq:long\\n   Customer.CustomerId.neq:long\\n   Customer.CustomerId.eq:long\\n   Customer.FirstName.like:string\\n   Customer.FirstName.mt:string\\n   Customer.FirstName.lt:string\\n   Customer.FirstName.mteq:string\\n   Customer.FirstName.lteq:string\\n   Customer.FirstName.neq:string\\n   Customer.FirstName.eq:string\\n   Customer.LastName.like:string\\n   Customer.LastName.mt:string\\n   Customer.LastName.lt:string\\n   Customer.LastName.mteq:string\\n   Customer.LastName.lteq:string\\n   Customer.LastName.neq:string\\n   Customer.LastName.eq:string\\n   Customer.Company.like:string\\n   Customer.Company.mt:string\\n   Customer.Company.lt:string\\n   Customer.Company.mteq:string\\n   Customer.Company.lteq:string\\n   Customer.Company.neq:string\\n   Customer.Company.eq:string\\n   Customer.Address.like:string\\n   Customer.Address.mt:string\\n   Customer.Address.lt:string\\n   Customer.Address.mteq:string\\n   Customer.Address.lteq:string\\n   Customer.Address.neq:string\\n   Customer.Address.eq:string\\n   Customer.City.like:string\\n   Customer.City.mt:string\\n   Customer.City.lt:string\\n   Customer.City.mteq:string\\n   Customer.City.lteq:string\\n   Customer.City.neq:string\\n   Customer.City.eq:string\\n   Customer.State.like:string\\n   Customer.State.mt:string\\n   Customer.State.lt:string\\n   Customer.State.mteq:string\\n   Customer.State.lteq:string\\n   Customer.State.neq:string\\n   Customer.State.eq:string\\n   Customer.Country.like:string\\n   Customer.Country.mt:string\\n   Customer.Country.lt:string\\n   Customer.Country.mteq:string\\n   Customer.Country.lteq:string\\n   Customer.Country.neq:string\\n   Customer.Country.eq:string\\n   Customer.PostalCode.like:string\\n   Customer.PostalCode.mt:string\\n   Customer.PostalCode.lt:string\\n   Customer.PostalCode.mteq:string\\n   Customer.PostalCode.lteq:string\\n   Customer.PostalCode.neq:string\\n   Customer.PostalCode.eq:string\\n   Customer.Phone.like:string\\n   Customer.Phone.mt:string\\n   Customer.Phone.lt:string\\n   Customer.Phone.mteq:string\\n   Customer.Phone.lteq:string\\n   Customer.Phone.neq:string\\n   Customer.Phone.eq:string\\n   Customer.Fax.like:string\\n   Customer.Fax.mt:string\\n   Customer.Fax.lt:string\\n   Customer.Fax.mteq:string\\n   Customer.Fax.lteq:string\\n   Customer.Fax.neq:string\\n   Customer.Fax.eq:string\\n   Customer.Email.like:string\\n   Customer.Email.mt:string\\n   Customer.Email.lt:string\\n   Customer.Email.mteq:string\\n   Customer.Email.lteq:string\\n   Customer.Email.neq:string\\n   Customer.Email.eq:string\\n   Customer.SupportRepId.mt:long\\n   Customer.SupportRepId.lt:long\\n   Customer.SupportRepId.mteq:long\\n   Customer.SupportRepId.lteq:long\\n   Customer.SupportRepId.neq:long\\n   Customer.SupportRepId.eq:long\\n   SupportRepId.LastName.eq:string\\n   SupportRepId.LastName.like:string\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-count-distinct\\n\\n// Sanity checking that distinct column was passed in.\\nvalidators.mandatory:x:@.arguments/*/distinct_column\\n\\n// Sanity checking distinct column's name.\\nvalidators.enum:x:@.arguments/*/distinct_column\\n   .:Customer.CustomerId\\n   .:Customer.FirstName\\n   .:Customer.LastName\\n   .:Customer.Company\\n   .:Customer.Address\\n   .:Customer.City\\n   .:Customer.State\\n   .:Customer.Country\\n   .:Customer.PostalCode\\n   .:Customer.Phone\\n   .:Customer.Fax\\n   .:Customer.Email\\n   .:Customer.SupportRepId\\n   .:SupportRepId.LastName\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root,admin\\n\\n// Sanity checking invocation.\\nvalidators.enum:x:@.arguments/*/operator\\n   .:or\\n   .:and\\n\\n/*\\n * Checking if user supplied an [operator] argument, and if so\\n * changing the boolean operator for comparison operations.\\n */\\nif\\n   exists:x:@.arguments/*/operator\\n   .lambda\\n\\n      // User provided a boolean comparison [operator] argument.\\n      set-name:x:../*/data.connect/*/data.read/*/where/0\\n         get-value:x:@.arguments/*/operator\\n      remove-nodes:x:@.arguments/*/operator\\n\\n// Opening up our database connection.\\ndata.connect:[generic|chinook]\\n   database-type:sqlite\\n\\n   // Making sure we're using correct function.\\n   set-name:x:./*/data.read/*/columns/*/distinct_functor\\n      strings.concat\\n         .:\"count(distinct \"\\n         get-value:x:@.arguments/*/distinct_column\\n         .:)\\n\\n   // Removing distinct argument to simplify adding other arguments.\\n   remove-nodes:x:@.arguments/*/distinct_column\\n\\n   // Adding filtering arguments.\\n   add:x:+/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:sqlite\\n      table:Customer\\n         join:Employee\\n            as:SupportRepId\\n            type:left\\n            on\\n               and\\n                  Customer.SupportRepId:SupportRepId.EmployeeId\\n      columns\\n         distinct_functor\\n            as:count\\n      where\\n         and\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Counts items from your Customer table in your chinook database"},{"role":"assistant","content":".arguments\\n\\n   // Optional logical operator for filtering arguments, can be either 'or' or 'and'. Defaults to and.\\n   operator:string\\n   Customer.CustomerId.mt:long\\n   Customer.CustomerId.lt:long\\n   Customer.CustomerId.mteq:long\\n   Customer.CustomerId.lteq:long\\n   Customer.CustomerId.neq:long\\n   Customer.CustomerId.eq:long\\n   Customer.FirstName.like:string\\n   Customer.FirstName.mt:string\\n   Customer.FirstName.lt:string\\n   Customer.FirstName.mteq:string\\n   Customer.FirstName.lteq:string\\n   Customer.FirstName.neq:string\\n   Customer.FirstName.eq:string\\n   Customer.LastName.like:string\\n   Customer.LastName.mt:string\\n   Customer.LastName.lt:string\\n   Customer.LastName.mteq:string\\n   Customer.LastName.lteq:string\\n   Customer.LastName.neq:string\\n   Customer.LastName.eq:string\\n   Customer.Company.like:string\\n   Customer.Company.mt:string\\n   Customer.Company.lt:string\\n   Customer.Company.mteq:string\\n   Customer.Company.lteq:string\\n   Customer.Company.neq:string\\n   Customer.Company.eq:string\\n   Customer.Address.like:string\\n   Customer.Address.mt:string\\n   Customer.Address.lt:string\\n   Customer.Address.mteq:string\\n   Customer.Address.lteq:string\\n   Customer.Address.neq:string\\n   Customer.Address.eq:string\\n   Customer.City.like:string\\n   Customer.City.mt:string\\n   Customer.City.lt:string\\n   Customer.City.mteq:string\\n   Customer.City.lteq:string\\n   Customer.City.neq:string\\n   Customer.City.eq:string\\n   Customer.State.like:string\\n   Customer.State.mt:string\\n   Customer.State.lt:string\\n   Customer.State.mteq:string\\n   Customer.State.lteq:string\\n   Customer.State.neq:string\\n   Customer.State.eq:string\\n   Customer.Country.like:string\\n   Customer.Country.mt:string\\n   Customer.Country.lt:string\\n   Customer.Country.mteq:string\\n   Customer.Country.lteq:string\\n   Customer.Country.neq:string\\n   Customer.Country.eq:string\\n   Customer.PostalCode.like:string\\n   Customer.PostalCode.mt:string\\n   Customer.PostalCode.lt:string\\n   Customer.PostalCode.mteq:string\\n   Customer.PostalCode.lteq:string\\n   Customer.PostalCode.neq:string\\n   Customer.PostalCode.eq:string\\n   Customer.Phone.like:string\\n   Customer.Phone.mt:string\\n   Customer.Phone.lt:string\\n   Customer.Phone.mteq:string\\n   Customer.Phone.lteq:string\\n   Customer.Phone.neq:string\\n   Customer.Phone.eq:string\\n   Customer.Fax.like:string\\n   Customer.Fax.mt:string\\n   Customer.Fax.lt:string\\n   Customer.Fax.mteq:string\\n   Customer.Fax.lteq:string\\n   Customer.Fax.neq:string\\n   Customer.Fax.eq:string\\n   Customer.Email.like:string\\n   Customer.Email.mt:string\\n   Customer.Email.lt:string\\n   Customer.Email.mteq:string\\n   Customer.Email.lteq:string\\n   Customer.Email.neq:string\\n   Customer.Email.eq:string\\n   Customer.SupportRepId.mt:long\\n   Customer.SupportRepId.lt:long\\n   Customer.SupportRepId.mteq:long\\n   Customer.SupportRepId.lteq:long\\n   Customer.SupportRepId.neq:long\\n   Customer.SupportRepId.eq:long\\n   SupportRepId.LastName.eq:string\\n   SupportRepId.LastName.like:string\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-count\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root,admin\\n\\n// Sanity checking invocation.\\nvalidators.enum:x:@.arguments/*/operator\\n   .:or\\n   .:and\\n\\n/*\\n * Checking if user supplied an [operator] argument, and if so\\n * changing the boolean operator for comparison operations.\\n */\\nif\\n   exists:x:@.arguments/*/operator\\n   .lambda\\n\\n      // User provided a boolean comparison [operator] argument.\\n      set-name:x:../*/data.connect/*/data.read/*/where/0\\n         get-value:x:@.arguments/*/operator\\n      remove-nodes:x:@.arguments/*/operator\\n\\n// Opening up our database connection.\\ndata.connect:[generic|chinook]\\n   database-type:sqlite\\n\\n   // Adding filtering arguments.\\n   add:x:+/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:sqlite\\n      table:Customer\\n         join:Employee\\n            as:SupportRepId\\n            type:left\\n            on\\n               and\\n                  Customer.SupportRepId:SupportRepId.EmployeeId\\n      columns\\n         count(*)\\n            as:count\\n      where\\n         and\\n      limit:long:1\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns minimum, maximum, average, sum or count from your Customer table in your chinook database grouped by a column"},{"role":"assistant","content":".arguments\\n\\n   // Mandatory argument being column to group by and must be in the format of TABLE_NAME.COLUMN_NAME\\n   group_column:string\\n\\n   // Number of records to return, defaults to 25 if not specified. Pass in -1 to return all records.\\n   limit:long\\n\\n   // Offset into the dataset of where to start retrieving records\\n   offset:long\\n\\n   // Fully qualified name of column to order by, must be in TABLE_NAME.COLUMN_NAME format\\n   order:string\\n\\n   // What direction to order, can be 'asc' or 'desc' implying ascending and descending\\n   direction:string\\n\\n   // Function to aggregate upon. Argument is mandatory and legal values are min, max, sum, avg or count\\n   aggregate_function:string\\n\\n   // Argument is mandatory and must be in the format of TABLE_NAME.COLUMN_NAME.\\n   aggregate_column:string\\n\\n   // Optional logical operator for filtering arguments, can be either 'or' or 'and'. Defaults to and.\\n   operator:string\\n   Customer.CustomerId.mt:long\\n   Customer.CustomerId.lt:long\\n   Customer.CustomerId.mteq:long\\n   Customer.CustomerId.lteq:long\\n   Customer.CustomerId.neq:long\\n   Customer.CustomerId.eq:long\\n   Customer.FirstName.like:string\\n   Customer.FirstName.mt:string\\n   Customer.FirstName.lt:string\\n   Customer.FirstName.mteq:string\\n   Customer.FirstName.lteq:string\\n   Customer.FirstName.neq:string\\n   Customer.FirstName.eq:string\\n   Customer.LastName.like:string\\n   Customer.LastName.mt:string\\n   Customer.LastName.lt:string\\n   Customer.LastName.mteq:string\\n   Customer.LastName.lteq:string\\n   Customer.LastName.neq:string\\n   Customer.LastName.eq:string\\n   Customer.Company.like:string\\n   Customer.Company.mt:string\\n   Customer.Company.lt:string\\n   Customer.Company.mteq:string\\n   Customer.Company.lteq:string\\n   Customer.Company.neq:string\\n   Customer.Company.eq:string\\n   Customer.Address.like:string\\n   Customer.Address.mt:string\\n   Customer.Address.lt:string\\n   Customer.Address.mteq:string\\n   Customer.Address.lteq:string\\n   Customer.Address.neq:string\\n   Customer.Address.eq:string\\n   Customer.City.like:string\\n   Customer.City.mt:string\\n   Customer.City.lt:string\\n   Customer.City.mteq:string\\n   Customer.City.lteq:string\\n   Customer.City.neq:string\\n   Customer.City.eq:string\\n   Customer.State.like:string\\n   Customer.State.mt:string\\n   Customer.State.lt:string\\n   Customer.State.mteq:string\\n   Customer.State.lteq:string\\n   Customer.State.neq:string\\n   Customer.State.eq:string\\n   Customer.Country.like:string\\n   Customer.Country.mt:string\\n   Customer.Country.lt:string\\n   Customer.Country.mteq:string\\n   Customer.Country.lteq:string\\n   Customer.Country.neq:string\\n   Customer.Country.eq:string\\n   Customer.PostalCode.like:string\\n   Customer.PostalCode.mt:string\\n   Customer.PostalCode.lt:string\\n   Customer.PostalCode.mteq:string\\n   Customer.PostalCode.lteq:string\\n   Customer.PostalCode.neq:string\\n   Customer.PostalCode.eq:string\\n   Customer.Phone.like:string\\n   Customer.Phone.mt:string\\n   Customer.Phone.lt:string\\n   Customer.Phone.mteq:string\\n   Customer.Phone.lteq:string\\n   Customer.Phone.neq:string\\n   Customer.Phone.eq:string\\n   Customer.Fax.like:string\\n   Customer.Fax.mt:string\\n   Customer.Fax.lt:string\\n   Customer.Fax.mteq:string\\n   Customer.Fax.lteq:string\\n   Customer.Fax.neq:string\\n   Customer.Fax.eq:string\\n   Customer.Email.like:string\\n   Customer.Email.mt:string\\n   Customer.Email.lt:string\\n   Customer.Email.mteq:string\\n   Customer.Email.lteq:string\\n   Customer.Email.neq:string\\n   Customer.Email.eq:string\\n   Customer.SupportRepId.mt:long\\n   Customer.SupportRepId.lt:long\\n   Customer.SupportRepId.mteq:long\\n   Customer.SupportRepId.lteq:long\\n   Customer.SupportRepId.neq:long\\n   Customer.SupportRepId.eq:long\\n   SupportRepId.LastName.eq:string\\n   SupportRepId.LastName.like:string\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-group\\n\\n// Sanity checking mandatory arguments.\\nvalidators.mandatory:x:@.arguments/*/group_column\\nvalidators.mandatory:x:@.arguments/*/aggregate_function\\nvalidators.mandatory:x:@.arguments/*/aggregate_column\\n\\n// Sanity checking name of aggregate function.\\nvalidators.enum:x:@.arguments/*/aggregate_function\\n   .:min\\n   .:max\\n   .:sum\\n   .:avg\\n   .:count\\n\\n// Sanity checking group column.\\nvalidators.enum:x:@.arguments/*/group_column\\n   .:Customer.CustomerId\\n   .:Customer.FirstName\\n   .:Customer.LastName\\n   .:Customer.Company\\n   .:Customer.Address\\n   .:Customer.City\\n   .:Customer.State\\n   .:Customer.Country\\n   .:Customer.PostalCode\\n   .:Customer.Phone\\n   .:Customer.Fax\\n   .:Customer.Email\\n   .:Customer.SupportRepId\\n   .:SupportRepId.LastName\\n\\n// Sanity checking agggregate column name.\\nvalidators.enum:x:@.arguments/*/aggregate_column\\n   .:Customer.CustomerId\\n   .:Customer.FirstName\\n   .:Customer.LastName\\n   .:Customer.Company\\n   .:Customer.Address\\n   .:Customer.City\\n   .:Customer.State\\n   .:Customer.Country\\n   .:Customer.PostalCode\\n   .:Customer.Phone\\n   .:Customer.Fax\\n   .:Customer.Email\\n   .:Customer.SupportRepId\\n   .:SupportRepId.LastName\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root,admin\\n\\n// Sanity checking invocation.\\nvalidators.enum:x:@.arguments/*/operator\\n   .:or\\n   .:and\\n\\n/*\\n * Checking if user supplied an [operator] argument, and if so\\n * changing the boolean operator for comparison operations.\\n */\\nif\\n   exists:x:@.arguments/*/operator\\n   .lambda\\n\\n      // User provided a boolean comparison [operator] argument.\\n      set-name:x:../*/data.connect/*/data.read/*/where/0\\n         get-value:x:@.arguments/*/operator\\n      remove-nodes:x:@.arguments/*/operator\\n\\n// Opening up our database connection.\\ndata.connect:[generic|chinook]\\n   database-type:sqlite\\n\\n   // Making sure we're using the correct group column\\n   set-name:x:@data.connect/*/data.read/*/group/*/group_column\\n      get-value:x:@.arguments/*/group_column\\n\\n   // Making sure we return group column as a part of the result\\n   set-name:x:+/*/*\\n      get-value:x:@.arguments/*/group_column\\n   insert-before:x:@data.connect/*/data.read/*/columns/0\\n      .\\n         group_column\\n\\n   // Changing name of aggregate column returned to caller.\\n   set-value:x:@data.connect/*/data.read/*/columns/1/*/as\\n      get-value:x:@.arguments/*/aggregate_function\\n\\n   // Removing group column to simplify adding other arguments\\n   remove-nodes:x:@.arguments/*/group_column\\n\\n   // Adding paging arguments\\n   add:x:@data.connect/*/data.read\\n      get-nodes:x:@.arguments/*/limit\\n      get-nodes:x:@.arguments/*/offset\\n   remove-nodes:x:@.arguments/*/limit\\n   remove-nodes:x:@.arguments/*/offset\\n\\n   // Parametrising our read invocation with ordering arguments if specified.\\n   add:x:./*/data.read\\n      get-nodes:x:@.arguments/*/order\\n      get-nodes:x:@.arguments/*/direction\\n   remove-nodes:x:@.arguments/*/order\\n   remove-nodes:x:@.arguments/*/direction\\n\\n   // Making sure we're using correct aggregate function.\\n   set-name:x:./*/data.read/*/columns/*/aggregate_functor\\n      strings.concat\\n         get-value:x:@.arguments/*/aggregate_function\\n         .:(\\n         get-value:x:@.arguments/*/aggregate_column\\n         .:)\\n\\n   // Removing aggregate arguments to simplify adding other arguments.\\n   remove-nodes:x:@.arguments/*/[0,2]\\n\\n   // Adding filtering arguments.\\n   add:x:+/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:sqlite\\n      table:Customer\\n         join:Employee\\n            as:SupportRepId\\n            type:left\\n            on\\n               and\\n                  Customer.SupportRepId:SupportRepId.EmployeeId\\n      columns\\n         aggregate_functor\\n            as:result\\n      where\\n         and\\n      group\\n         group_column\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Distinct Keyword Search from Customer table in chinook database.\\n\\nThis endpoint will return only records containing one or more of the keywords from the specified [query],\\nwith rows containing the most distinct matched keywords appearing first."},{"role":"assistant","content":".arguments\\n\\n   // Mandatory query for records to search for\\n   query:string\\n\\n   // Optional number of records to return, defaults to 10 if not specified. Pass in -1 to return all records\\n   limit:long\\n\\n   // Optional offset into the dataset of where to start retrieving records\\n   offset:long\\n\\n// Type of endpoint\\n.type:crud-search\\n\\n// Make sure the user has provided a query.\\nvalidators.mandatory:x:@.arguments/*/query\\n\\n// Apply defaults if not specified.\\nvalidators.default:x:@.arguments\\n   limit:long:10\\n\\n// Split the user's query into individual keywords, separated by spaces.\\n.words\\nadd:x:@.words\\n   strings.split:x:@.arguments/*/query\\n      .:\" \"\\n\\n// Enforce lower characters for each keyword, and guard against SQL injection.\\n.no:int:0\\nfor-each:x:@.words/*\\n   set-value:x:@.dp/#\\n      strings.to-lower:x:@.dp/#\\n\\n// Specify which columns to search against.\\n.columns\\n   .:FirstName\\n   .:LastName\\n   .:Company\\n   .:Address\\n   .:City\\n   .:State\\n   .:Country\\n   .:PostalCode\\n   .:Phone\\n   .:Fax\\n   .:Email\\n\\n// Connect to the specified database.\\ndata.connect:[generic|chinook]\\n   database-type:sqlite\\n\\n   // Start building our SQL.\\n   .sql:select *, (\\n\\n   // 1) Dynamically create the full text by concatenating all columns we want to search.\\n   .fields\\n   for-each:x:@.columns/*\\n      strings.concat\\n         .:coalesce(\\n         get-value:x:@.dp/#\\n         .:\", '')\"\\n      unwrap:x:+/*/*\\n      add:x:@.fields\\n         .\\n            .:x:@strings.concat\\n   set-value:x:@.fields\\n      strings.join:x:@.fields/*\\n         .:\" || \"\\n   remove-nodes:x:@.fields/*\\n\\n   // 2) Keyword density calculation\\n   .no:int:0\\n   for-each:x:@.words/*\\n\\n      // Adding SQL parameter.\\n      set-name:x:+/+/*/*\\n         strings.concat\\n            .:@p\\n            get-value:x:@.no\\n      unwrap:x:+/*/*\\n      add:x:@data.connect/*/data.select\\n         .\\n            .:x:@.dp/#\\n\\n      // Modifying our SQL.\\n      if\\n         eq:x:@.no\\n            .:int:0\\n         .lambda\\n\\n            // First keyword => no leading plus\\n            set-value:x:@.sql\\n               strings.concat:x:@.sql\\n                  get-value:x:@.sql\\n                  .:\" (length(\"\\n                  get-value:x:@.fields\\n                  .:) - length(replace(lower(\\n                  get-value:x:@.fields\\n                  .:), @p\\n                  get-value:x:@.no\\n                  .:\", ''))) / length(@p\"\\n                  get-value:x:@.no\\n                  .:)\\n      else\\n         set-value:x:@.sql\\n            strings.concat:x:@.sql\\n               get-value:x:@.sql\\n               .:\" + (length(\"\\n               get-value:x:@.fields\\n               .:) - length(replace(lower(\\n               get-value:x:@.fields\\n               .:), @p\\n               get-value:x:@.no\\n               .:\", ''))) / length(@p\"\\n               get-value:x:@.no\\n               .:)\\n      math.increment:x:@.no\\n   set-value:x:@.sql\\n      strings.concat:x:@.sql\\n         get-value:x:@.sql\\n         .:) * 1.0 / length(\\n         get-value:x:@.fields\\n         .:) as keyword_density, (\\n\\n   // 3) Distinct keyword count => For each keyword, 1 if present, 0 if not.\\n   .no:int:0\\n   for-each:x:@.words/*\\n      if\\n         eq:x:@.no\\n            .:int:0\\n         .lambda\\n\\n            // First keyword => no leading plus\\n            set-value:x:@.sql\\n               strings.concat:x:@.sql\\n                  get-value:x:@.sql\\n                  .:\" CASE WHEN ((length(\"\\n                  get-value:x:@.fields\\n                  .:) - length(replace(lower(\\n                  get-value:x:@.fields\\n                  .:), @p\\n                  get-value:x:@.no\\n                  .:\", ''))) / length(@p\"\\n                  get-value:x:@.no\\n                  .:)) > 0 THEN 1 ELSE 0 END\\n      else\\n         set-value:x:@.sql\\n            strings.concat:x:@.sql\\n               get-value:x:@.sql\\n               .:\" + CASE WHEN ((length(\"\\n               get-value:x:@.fields\\n               .:) - length(replace(lower(\\n               get-value:x:@.fields\\n               .:), @p\\n               get-value:x:@.no\\n               .:\", ''))) / length(@p\"\\n               get-value:x:@.no\\n               .:)) > 0 THEN 1 ELSE 0 END\\n      math.increment:x:@.no\\n\\n   // Finalize \"keyword_count\".\\n   set-value:x:@.sql\\n      strings.concat:x:@.sql\\n         get-value:x:@.sql\\n         .:) as keyword_count\\n\\n   // 4) Finish SELECT + WHERE\\n   set-value:x:@.sql\\n      strings.concat:x:@.sql\\n         get-value:x:@.sql\\n         .:\" from \"\\n         .:Customer\\n         .:\" where keyword_count > 0\"\\n\\n   // 5) Order by distinct keyword_count (higher means more distinct keywords), then keyword_density.\\n   set-value:x:@.sql\\n      strings.concat:x:@.sql\\n         get-value:x:@.sql\\n         .:\" order by keyword_count desc, keyword_density desc limit \"\\n         get-value:x:@.arguments/*/limit\\n\\n   // (Optional) offset => pagination\\n   if\\n      exists:x:@.arguments/*/offset\\n      .lambda\\n         set-value:x:@.sql\\n            strings.concat:x:@.sql\\n               get-value:x:@.sql\\n               .:\" offset \"\\n               get-value:x:@.arguments/*/offset\\n\\n   // Execute the SQL\\n   data.select:x:@.sql\\n      database-type:sqlite\\n\\n   // Remove helper fields if you don't want them in your final JSON\\n   remove-nodes:x:@data.select/*/*/keyword_density\\n   remove-nodes:x:@data.select/*/*/keyword_count\\n\\n   // Return the final result set\\n   return-nodes:x:@data.select/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Delete one record from your Customer table in your chinook database"},{"role":"assistant","content":".arguments\\n\\n   // Primary key of record to delete, mandatory argument\\n   CustomerId:long\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-delete\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root,admin\\nvalidators.mandatory:x:@.arguments/*/CustomerId\\n\\n// Opening up our database connection.\\ndata.connect:[generic|chinook]\\n   database-type:sqlite\\n\\n   // Parametrising our delete invocation.\\n   add:x:./*/data.delete/*/where/*/and\\n      get-nodes:x:@.arguments/*\\n\\n   // Deleting item from database.\\n   data.delete\\n      database-type:sqlite\\n      table:Customer\\n      where\\n         and\\n\\n   // Returning result of above invocation to caller.\\n   unwrap:x:+/*\\n   return\\n      affected:x:@data.delete\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Read or list records from your Customer table in your chinook database"},{"role":"assistant","content":".arguments\\n\\n   // Number of records to return, defaults to 25 if not specified. Pass in -1 to return all records.\\n   limit:long\\n\\n   // Offset into the dataset of where to start retrieving records\\n   offset:long\\n\\n   // Fully qualified name of column to order by, must be in TABLE_NAME.COLUMN_NAME format\\n   order:string\\n\\n   // What direction to order, can be 'asc' or 'desc' implying ascending and descending\\n   direction:string\\n\\n   // Optional logical operator for filtering arguments, can be either 'or' or 'and'. Defaults to and.\\n   operator:string\\n   Customer.CustomerId.mt:long\\n   Customer.CustomerId.lt:long\\n   Customer.CustomerId.mteq:long\\n   Customer.CustomerId.lteq:long\\n   Customer.CustomerId.neq:long\\n   Customer.CustomerId.eq:long\\n   Customer.FirstName.like:string\\n   Customer.FirstName.mt:string\\n   Customer.FirstName.lt:string\\n   Customer.FirstName.mteq:string\\n   Customer.FirstName.lteq:string\\n   Customer.FirstName.neq:string\\n   Customer.FirstName.eq:string\\n   Customer.LastName.like:string\\n   Customer.LastName.mt:string\\n   Customer.LastName.lt:string\\n   Customer.LastName.mteq:string\\n   Customer.LastName.lteq:string\\n   Customer.LastName.neq:string\\n   Customer.LastName.eq:string\\n   Customer.Company.like:string\\n   Customer.Company.mt:string\\n   Customer.Company.lt:string\\n   Customer.Company.mteq:string\\n   Customer.Company.lteq:string\\n   Customer.Company.neq:string\\n   Customer.Company.eq:string\\n   Customer.Address.like:string\\n   Customer.Address.mt:string\\n   Customer.Address.lt:string\\n   Customer.Address.mteq:string\\n   Customer.Address.lteq:string\\n   Customer.Address.neq:string\\n   Customer.Address.eq:string\\n   Customer.City.like:string\\n   Customer.City.mt:string\\n   Customer.City.lt:string\\n   Customer.City.mteq:string\\n   Customer.City.lteq:string\\n   Customer.City.neq:string\\n   Customer.City.eq:string\\n   Customer.State.like:string\\n   Customer.State.mt:string\\n   Customer.State.lt:string\\n   Customer.State.mteq:string\\n   Customer.State.lteq:string\\n   Customer.State.neq:string\\n   Customer.State.eq:string\\n   Customer.Country.like:string\\n   Customer.Country.mt:string\\n   Customer.Country.lt:string\\n   Customer.Country.mteq:string\\n   Customer.Country.lteq:string\\n   Customer.Country.neq:string\\n   Customer.Country.eq:string\\n   Customer.PostalCode.like:string\\n   Customer.PostalCode.mt:string\\n   Customer.PostalCode.lt:string\\n   Customer.PostalCode.mteq:string\\n   Customer.PostalCode.lteq:string\\n   Customer.PostalCode.neq:string\\n   Customer.PostalCode.eq:string\\n   Customer.Phone.like:string\\n   Customer.Phone.mt:string\\n   Customer.Phone.lt:string\\n   Customer.Phone.mteq:string\\n   Customer.Phone.lteq:string\\n   Customer.Phone.neq:string\\n   Customer.Phone.eq:string\\n   Customer.Fax.like:string\\n   Customer.Fax.mt:string\\n   Customer.Fax.lt:string\\n   Customer.Fax.mteq:string\\n   Customer.Fax.lteq:string\\n   Customer.Fax.neq:string\\n   Customer.Fax.eq:string\\n   Customer.Email.like:string\\n   Customer.Email.mt:string\\n   Customer.Email.lt:string\\n   Customer.Email.mteq:string\\n   Customer.Email.lteq:string\\n   Customer.Email.neq:string\\n   Customer.Email.eq:string\\n   Customer.SupportRepId.mt:long\\n   Customer.SupportRepId.lt:long\\n   Customer.SupportRepId.mteq:long\\n   Customer.SupportRepId.lteq:long\\n   Customer.SupportRepId.neq:long\\n   Customer.SupportRepId.eq:long\\n   SupportRepId.LastName.eq:string\\n   SupportRepId.LastName.like:string\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-read\\n\\n// Columns with custom handling as frontend is generated.\\n.handling\\n   Customer.Phone:phone\\n   Customer.Email:email\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root,admin\\n\\n// Sanity checking invocation.\\nvalidators.enum:x:@.arguments/*/operator\\n   .:or\\n   .:and\\n\\n/*\\n * Checking if user supplied an [operator] argument, and if so\\n * changing the boolean operator for comparison operations.\\n */\\nif\\n   exists:x:@.arguments/*/operator\\n   .lambda\\n\\n      // User provided a boolean comparison [operator] argument.\\n      set-name:x:../*/data.connect/*/data.read/*/where/0\\n         get-value:x:@.arguments/*/operator\\n      remove-nodes:x:@.arguments/*/operator\\n\\n// Opening up our database connection.\\ndata.connect:[generic|chinook]\\n   database-type:sqlite\\n\\n   // Parametrising our read invocation with ordering arguments if specified.\\n   add:x:./*/data.read\\n      get-nodes:x:@.arguments/*/order\\n      get-nodes:x:@.arguments/*/direction\\n   remove-nodes:x:@.arguments/*/order\\n   remove-nodes:x:@.arguments/*/direction\\n\\n   // Parametrising our read invocation with paging arguments if specified.\\n   add:x:./*/data.read\\n      get-nodes:x:@.arguments/*/limit\\n      get-nodes:x:@.arguments/*/offset\\n   remove-nodes:x:@.arguments/*/limit\\n   remove-nodes:x:@.arguments/*/offset\\n\\n   // Parametrising our read invocation with filtering arguments.\\n   add:x:./*/data.read/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:sqlite\\n      table:Customer\\n         join:Employee\\n            as:SupportRepId\\n            type:left\\n            on\\n               and\\n                  Customer.SupportRepId:SupportRepId.EmployeeId\\n      columns\\n         Customer.CustomerId\\n         Customer.FirstName\\n         Customer.LastName\\n         Customer.Company\\n         Customer.Address\\n         Customer.City\\n         Customer.State\\n         Customer.Country\\n         Customer.PostalCode\\n         Customer.Phone\\n         Customer.Fax\\n         Customer.Email\\n         Customer.SupportRepId\\n         SupportRepId.LastName\\n            as:SupportRepId.LastName\\n      where\\n         and\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create one record in your Customer table in your chinook database"},{"role":"assistant","content":".arguments\\n\\n   // CustomerId column value\\n   CustomerId:long\\n\\n   // FirstName column value\\n   FirstName:string\\n\\n   // LastName column value\\n   LastName:string\\n\\n   // Company column value\\n   Company:string\\n\\n   // Address column value\\n   Address:string\\n\\n   // City column value\\n   City:string\\n\\n   // State column value\\n   State:string\\n\\n   // Country column value\\n   Country:string\\n\\n   // PostalCode column value\\n   PostalCode:string\\n\\n   // Phone column value\\n   Phone:string\\n\\n   // Fax column value\\n   Fax:string\\n\\n   // Email column value\\n   Email:string\\n\\n   // SupportRepId column value\\n   SupportRepId:long\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-create\\n\\n// Columns with custom handling as we generate a frontend\\n.handling\\n   Phone:phone\\n   Email:email\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root,admin\\n.foreign-keys\\n   .\\n      column:SupportRepId\\n      table:Employee\\n      foreign_column:EmployeeId\\n      foreign_name:LastName\\n      long:bool:true\\n\\n// Opening up database connection.\\ndata.connect:[generic|chinook]\\n   database-type:sqlite\\n\\n   // Parametrising our create invocation.\\n   add:x:./*/data.create/*/values\\n      get-nodes:x:@.arguments/*\\n\\n   // Creating our record.\\n   data.create\\n      database-type:sqlite\\n      table:Customer\\n      return-id:bool:false\\n      values\\n\\n   // Returning the correct status code.\\n   response.status.set:201\\n\\n   // Returning result of above invocation to caller.\\n   unwrap:x:+/*\\n   return\\n      result:success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Update one record in your Customer table in your chinook database"},{"role":"assistant","content":".arguments\\n\\n   // CustomerId column value being primary key of record to update, mandatory argument\\n   CustomerId:long\\n\\n   // FirstName column's new value\\n   FirstName:string\\n\\n   // LastName column's new value\\n   LastName:string\\n\\n   // Company column's new value\\n   Company:string\\n\\n   // Address column's new value\\n   Address:string\\n\\n   // City column's new value\\n   City:string\\n\\n   // State column's new value\\n   State:string\\n\\n   // Country column's new value\\n   Country:string\\n\\n   // PostalCode column's new value\\n   PostalCode:string\\n\\n   // Phone column's new value\\n   Phone:string\\n\\n   // Fax column's new value\\n   Fax:string\\n\\n   // Email column's new value\\n   Email:string\\n\\n   // SupportRepId column's new value\\n   SupportRepId:long\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-update\\n\\n// Columns with custom handling as we generate a frontend\\n.handling\\n   Phone:phone\\n   Email:email\\n\\n// Sanity checking invocation, making sure primary key(s) are specified.\\nvalidators.mandatory:x:@.arguments/*/CustomerId\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root,admin\\n.foreign-keys\\n   .\\n      column:SupportRepId\\n      table:Employee\\n      foreign_column:EmployeeId\\n      foreign_name:LastName\\n      long:bool:true\\n\\n// Opening up our database connection.\\ndata.connect:[generic|chinook]\\n   database-type:sqlite\\n\\n   // Parametrising our invocation.\\n   add:x:./*/data.update/*/values\\n      get-nodes:x:@.arguments/*/[1,1000]\\n   add:x:./*/data.update/*/where/*/and\\n      get-nodes:x:@.arguments/*/[0,1]\\n\\n   // Invoking our update slot.\\n   data.update\\n      database-type:sqlite\\n      table:Customer\\n      values\\n      where\\n         and\\n\\n   // Verifying record exists.\\n   if\\n      eq\\n         get-value:x:@data.update\\n         .:int:0\\n      .lambda\\n         response.status.set:404\\n         return\\n            result:Record not found\\n\\n   // Returning the correct status code.\\n   response.status.set:202\\n\\n   // Returning success to caller.\\n   unwrap:x:+/*\\n   return\\n      affected:x:@data.update\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Connect to the \"sakila\" database using the default connection string (SQLite) and retrieve actors (default adapter from config)"},{"role":"assistant","content":"data.connect:sakila\\n   data.read\\n\\n      // Reads from the \"actor\" table (returns first 25 records by default)\\n      table:actor\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"List cities and their country names by joining the city and country tables"},{"role":"assistant","content":"data.connect:sakila\\n   data.read\\n      table:city\\n      join\\n         inner\\n            table:country\\n            on\\n               city.country_id\\n               country.country_id\\n      columns\\n         city.city\\n         country.country\\n      limit:5\\n\\n   // Inner join on country_id returns city-country pairs\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Mark a specific order as shipped"},{"role":"assistant","content":"data.connect:shopDB\\n   data.update\\n      table:orders\\n      values\\n         status:shipped\\n      where\\n\\n         // Only update the order with ID 12345\\n         and\\n            order_id.eq:12345\\n\\n   // Without a WHERE clause, all orders would be updated!\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Discount electronics that are not discontinued"},{"role":"assistant","content":"data.connect:shopDB\\n   data.update\\n      table:products\\n      values\\n         price:9.99\\n         on_sale:bool:true\\n      where\\n\\n         // Both conditions must match for update\\n         and\\n            category.eq:Electronics\\n            discontinued.eq:bool:false\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Delete a single customer record by customer_id"},{"role":"assistant","content":"data.connect:shopDB\\n   data.delete\\n      table:customers\\n      where\\n         and\\n\\n            // Only delete the customer with ID 987\\n            customer_id.eq:987\\n\\n   // WARNING: Without a WHERE clause, this would delete all customers!\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Fetch a few film titles and release years using a raw SQL query"},{"role":"assistant","content":"data.connect:sakila\\n   data.select:SELECT title, release_year FROM film LIMIT 3\\n\\n   // Executes the SQL directly on the database and returns up to 3 rows\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Count the total number of orders"},{"role":"assistant","content":"data.connect:shopDB\\n   data.scalar:SELECT COUNT(*) FROM orders\\n\\n   // Returns a single value (e.g., 42) as the node's value (type long/int)\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Set all inactive users to have NULL last_login"},{"role":"assistant","content":"data.connect:authDB\\n   data.execute:UPDATE users SET last_login = NULL WHERE active = 0\\n\\n   // Executes the UPDATE; number of affected records returned\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Attempt to delete records, then roll back the transaction to abort changes"},{"role":"assistant","content":"data.connect:shopDB\\n   data.transaction.create\\n      data.delete\\n         table:temp_data\\n         where\\n            and\\n               created_at.lt:date:\"2020-01-01T00:00:00.000\"\\n\\n      /*\\n       * Suppose a condition triggers an abort here.\\n       * Roll back the transaction to cancel the deletion.\\n       */\\n\\n      // Abort transaction: all deletions are undone\\n      data.transaction.rollback\\n\\n// After rollback, no changes from the transaction are applied to the database\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Connect using a named connection string \"foo\" and database \"bar\", then count records"},{"role":"assistant","content":"data.connect:[foo|bar]\\n   data.scalar:select count(*) from users\\n\\n   // [foo|bar] uses connection string \"foo\" and database \"bar\" from configuration\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Connect to \"CustomerDB\" explicitly using a PostgreSQL adapter, then fetch data"},{"role":"assistant","content":"data.connect:CustomerDB\\n\\n   // Force use of PostgreSQL adapter for this connection\\n   database-type:pgsql\\n   data.read\\n      table:customer\\n\\n      // Retrieve first 5 customers\\n      limit:5\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Use nested data.connect to interact with two databases in one snippet"},{"role":"assistant","content":"data.connect:MainDB\\n   data.read\\n\\n      // Query orders from MainDB\\n      table:orders\\n\\n   // Insert a log in LogsDB\\n   data.connect:LogsDB\\n      data.create\\n         table:log_storage\\n         values\\n            message:Checked orders\\n   data.read\\n\\n      // Back to MainDB connection (still open) to re-query orders\\n      table:orders\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create a new customer with only a name field"},{"role":"assistant","content":"data.connect:shopDB\\n   data.create\\n      table:customers\\n      values\\n\\n         // Insert \"Alice\" into the name column\\n         name:Alice\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create a new product with name and price fields"},{"role":"assistant","content":"data.connect:shopDB\\n   data.create\\n      table:products\\n      values\\n         name:Coffee Mug\\n\\n         // Use decimale\\n         price:decimal:9.99\\n\\n         // Use bool type for a boolean column\\n         in_stock:bool:true\\n\\n   // After execution, the node's value will contain the new record's ID (if available)\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Select specific columns from the employees table and sort by department ascending"},{"role":"assistant","content":"data.connect:hrDB\\n   data.read\\n      table:employees\\n\\n      // Columns we're interested in\\n      columns\\n         id\\n         name\\n         department\\n\\n      // Sort results by department in ascending order\\n      order:department\\n      direction:asc\\n\\n      // Limit to 10 results\\n      limit:10\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Retrieve orders that are either pending OR processing"},{"role":"assistant","content":"data.connect:shopDB\\n   data.read\\n      table:orders\\n      limit:-1\\n      where\\n\\n         // Either status equals \"pending\" OR \"processing\"\\n         or\\n            status.eq:pending\\n            status.eq:processing\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Opens a database connection and executes some arbitrary SQL,  returning results as a record set"},{"role":"assistant","content":"data.connect:DATABASE_NAME_HERE\\n   database-type:sqlite\\n   data.select:select * from TABLE_NAME_HERE\\n      database-type:sqlite\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Connect to the SQLite 'foo' database using the 'generic' connection string and create a backup as 'foo.backup' filename"},{"role":"assistant","content":"sqlite.connect:[generic|foo]\\n   sqlite.backup:foo.backup\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create HTTP POST invocation as MIME"},{"role":"assistant","content":"http.post:\"http://localhost:5000/magic/modules/foo/foo\"\\n   headers\\n      Content-Type:multipart/form-data\\n   payload\\n      entity:text/plain\\n         headers\\n            Content-Disposition:\"form-data; name=\\\"foo\\\"\"\\n         content:Foo bar\\n      entity:text/plain\\n         headers\\n            Content-Disposition:\"form-data; filename=\\\"README.md\\\"\"\\n         filename:/README.md\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create HTTP GET invocation"},{"role":"assistant","content":"http.get:\"https://docs.ainiro.io\"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create HTTP PUT"},{"role":"assistant","content":"http.put:\"https://some_website.com/your-put-endpoint\"\\n   payload:\"{\\\"foo\\\": \\\"bar\\\"}\"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create a folder"},{"role":"assistant","content":"io.folder.create:/misc/foo/\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Delete a folder"},{"role":"assistant","content":"io.folder.delete:/misc/foo/\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"List folders inside /misc/ folder"},{"role":"assistant","content":"io.folder.list:/misc/\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Move folder"},{"role":"assistant","content":"io.folder.move:/misc/source-folder/\\n   .:/misc/destination-folder/\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Copy folder"},{"role":"assistant","content":"io.folder.copy:/misc/source-folder/\\n   .:/misc/destination-folder/\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Load file"},{"role":"assistant","content":"io.file.load:/misc/README.md\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Save file"},{"role":"assistant","content":"io.file.save:/misc/README2.md\\n   .:This is new content for file\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Create a dynamic slot, then invoke it"},{"role":"assistant","content":"\\n// First we create a dynamic slot.\\nslots.create:foo\\n   return-value:int:57\\n\\n// Then we invoke it.\\nsignal:foo\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Execute Hyperlambda file with arguments"},{"role":"assistant","content":".args\\n   foo1:bar1\\n   foo2:bar2\\nexecute-file:/whatever-file.hl\\n   arg1:x:@.args/*/foo1\\n   arg2:x:@.args/*/foo2\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"List files"},{"role":"assistant","content":"io.file.list:/misc/\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Move file"},{"role":"assistant","content":"io.file.move:/misc/README.md\\n   .:/misc/backup/README-backup.md\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Unzip file"},{"role":"assistant","content":"io.file.unzip:/misc/foo.zip\\n   folder:/misc/backup/\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Create a slot"},{"role":"assistant","content":"slots.create:foo\\n   return-value:int:57\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Generate random string 50 to 100 characters in length"},{"role":"assistant","content":"crypto.random\\n   min:50\\n   max:100\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Generate random number below 1024"},{"role":"assistant","content":"crypto.random.int\\n   max:1024\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Invoke a slot"},{"role":"assistant","content":"signal:foo\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"SHA256 hashing of specified file"},{"role":"assistant","content":"crypto.hash.sha256\\n   filename:/README.md\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Seed crypto library"},{"role":"assistant","content":"crypto.seed:Foo Bar Whatever Some Random Seed\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create an RSA key pair"},{"role":"assistant","content":"crypto.rsa.create-key\\n   strength:2048\\n   seed:some random jibberish text\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Hash password for then to verify it"},{"role":"assistant","content":"crypto.password.hash:SomePasswordHere\\ncrypto.password.verify:SomePasswordHere\\n   hash:x:@crypto.password.hash\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Create two slots, then execute a [whitelist] lambda object only allowing for 'foo1', to illustrate how an exception will be raise if we execute non-whitelisted slots"},{"role":"assistant","content":"slots.create:foo1\\n   return-value:Safe\\nslots.create:foo2\\n   return-value:Unsafe\\nwhitelist\\n   vocabulary\\n      signal\\n      signal:foo1\\n   .lambda\\n\\n      // Assuming you have a [foo1] slot created, this will work\\n      signal:foo1\\n\\n      // This will throw, since [foo2] is not whitelisted\\n      signal:foo2\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Return specified lambda from Hyperlambda file or endpoint"},{"role":"assistant","content":"return\\n   result:Hello from Magic Backend\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create an argument collection with 3 args being arg1 (string), arg2 (date) and arg3 being any type (unknown)"},{"role":"assistant","content":".arguments\\n   arg1:string\\n   arg2:date\\n   arg3:*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Forward all [.args]'s nodes to the slot invocation"},{"role":"assistant","content":".args\\n   foo1:bar1\\n   foo2:bar2\\nexecute:whatever-slot\\n   arg1:x:@.args/*/foo1\\n   arg2:x:@.args/*/foo2\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Change HTTP headers"},{"role":"assistant","content":"response.headers.set\\n   Content-Type:text/plain\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create a lambda object that adds 2 by 3"},{"role":"assistant","content":".calculate\\n   math.add\\n      .:int:2\\n      .:int:3\\n   return:x:-\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Connect to magic database and returns all roles"},{"role":"assistant","content":"data.connect:magic\\n   data.read\\n      table:roles\\n      columns\\n         name\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Publish a socket message for root and admin users"},{"role":"assistant","content":"sockets.signal:foo.bar\\n   roles:root, admin\\n   args\\n      howdy:world\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Publish a socket message for user1, 2, and 3"},{"role":"assistant","content":"sockets.signal:foo.bar\\n   users:user1, user2, user3\\n   args\\n      howdy:world\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Convert from YAML to lambda and back again"},{"role":"assistant","content":"yaml2lambda:x:@.yaml\\nlambda2yaml:x:-/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Convert YAML to JSON and back again"},{"role":"assistant","content":"yaml2json:x:@.yaml\\njson2yaml:x:-\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Show me an example lambda object with 3 nodes, the third node having two children with values. Use random names and values."},{"role":"assistant","content":"foo:bar\\nfoo:int:5\\nfoo\\n   child1:its-value\\n   child2:its-value\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Show me 3 different data segment nodes with different types"},{"role":"assistant","content":".foo1:int:5\\n.foo2:bool:true\\n.foo3:foo\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Try signaling a slot without throwing exception if it doesn't exist"},{"role":"assistant","content":"try-signal:foo\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Show me all different ways we can create a string, with example data"},{"role":"assistant","content":"\\n// Single quotes\\n.foo:howdy world this is a string\\n\\n// Double quotes\\n.foo:\"Howdy world, another string\\nNew line here ...\"\\n\\n// Multiline strings\\n.foo:@\"Notice how the new line doesn't end the string\\n    here!\"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Retrieve a node's value using expressions"},{"role":"assistant","content":".foo:hello world\\nget-value:x:@.foo\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Retrieves the value of foo1 argument using expressions"},{"role":"assistant","content":"get-value:x:@.arguments/*/foo1\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Extrapolated expression example doing value comparison"},{"role":"assistant","content":".arg1:thomas\\n.data\\n   foo1:john\\n   foo2:thomas\\n   foo3:peter\\nget-name:x:@.data/*/={@.arg1}\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Create a slot that returns [return-value] being integer of 57"},{"role":"assistant","content":"slots.create:foo\\n   return-value:int:57\\nslots.get:foo\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Show me the structure of [eq] slot"},{"role":"assistant","content":"eq\\n   .:lhs\\n   .:rhs\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create a while loop for 20 iterations that creates a log entry"},{"role":"assistant","content":".no:int:0\\nwhile\\n   lt\\n      get-value:x:@.no\\n      .:int:20\\n   .lambda\\n\\n      // Your lambda goes here.\\n      log.info:Howdy from while\\n      math.increment:x:@.no\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Create a slot and then delete it"},{"role":"assistant","content":"slots.create:foo\\n   return-value:int:57\\nslots.delete:foo\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Show me different types of comments"},{"role":"assistant","content":"\\n// Multiline comment.\\n\\n// Single line comment.\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Change the value of [.dest] to the value of [.src]"},{"role":"assistant","content":"set-value:x:@.dest\\n   get-value:x:@.src\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Evaluate dynamic lambda object passing in argument using [invoke]"},{"role":"assistant","content":".lambda\\n   strings.concat\\n      .:\"Hello \"\\n      get-value:x:@.arguments/*/name\\n   return:x:-\\ninvoke:x:@.lambda\\n   name:John\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Create a dynamic slot returning 2 nodes, then invoke it"},{"role":"assistant","content":"slots.create:foo\\n   return-nodes\\n      integer-value:int:57\\n      string-value:Foo bar\\nsignal:foo\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"If condition with static \"true\" value"},{"role":"assistant","content":".dest\\nif\\n   .:bool:true\\n   .lambda\\n      set-value:x:@.dest\\n         .:yup!\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"If referencing input argument"},{"role":"assistant","content":".arguments\\n   foo:bool:true\\n.dest\\nif\\n   get-value:x:@.arguments/*/foo\\n   .lambda\\n      set-value:x:@.dest\\n         .:yup!\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Simplified [if] referencing input argument"},{"role":"assistant","content":".arguments\\n   foo:bool:true\\n.dest\\nif:x:@.arguments/*/foo\\n   set-value:x:@.dest\\n      .:yup!\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"If with else-if"},{"role":"assistant","content":".dest\\nif\\n   .:bool:false\\n   .lambda\\n      set-value:x:@.dest\\n         .:yup!\\nelse-if\\n   .:bool:true\\n   .lambda\\n      set-value:x:@.dest\\n         .:yup2.0!\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Switch lambda"},{"role":"assistant","content":".val:foo\\n.result\\nswitch:x:@.val\\n   case:bar\\n      set-value:x:@.result\\n         .:Oops\\n   case:foo\\n      set-value:x:@.result\\n         .:Success!\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Switch lambda"},{"role":"assistant","content":".val:fooXX\\n.result\\nswitch:x:@.val\\n   case:bar\\n      set-value:x:@.result\\n         .:Oops\\n   case:foo\\n      set-value:x:@.result\\n         .:Oops2.0\\n   default\\n      set-value:x:@.result\\n         .:Success!\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"[eq] equality comparison checking [.src]"},{"role":"assistant","content":".src:int:5\\neq\\n   get-value:x:@.src\\n   .:int:5\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Create a slot that returns a single string as its value and invoke it"},{"role":"assistant","content":"slots.create:foo\\n   return-value:This becomes the returned value from your slot\\nsignal:foo\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Not equals checking value of [.src]"},{"role":"assistant","content":".src:int:5\\nneq\\n   get-value:x:@.src\\n   .:int:5\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Less then"},{"role":"assistant","content":".src1:int:4\\nlt\\n   get-value:x:@.src1\\n   .:int:5\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Less then or equal"},{"role":"assistant","content":".src1:int:4\\nlte\\n   get-value:x:@.src1\\n   .:int:4\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"More than or equal to"},{"role":"assistant","content":".src1:int:7\\nmte\\n   get-value:x:@.src1\\n   .:int:5\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"More then or equal to [.src]"},{"role":"assistant","content":".src1:int:7\\nmte:x:@.src1\\n   .:int:5\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Conditionally setting [.result]'s value"},{"role":"assistant","content":".result\\n.arg1:foo\\nif\\n   eq:x:@.arg1\\n      .:foo\\n   .lambda\\n      set-value:x:@.result\\n         .:Yup!\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Create a slot, invoke it, then invokes a non-existing slot (throws!)"},{"role":"assistant","content":"slots.create:foo\\n   return-value:Blah, blah, blah ...\\nslots.exists:foo\\nslots.exists:DOES-NOT-EXISTS\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"[and] slot in [if] slot making sure both conditions must be true"},{"role":"assistant","content":".s1:bool:true\\n.s2:bool:true\\n.res\\nif\\n   and\\n      get-value:x:@.s1\\n      get-value:x:@.s2\\n   .lambda\\n      set-value:x:@.res\\n         .:OK\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Evaluates to false."},{"role":"assistant","content":"or\\n   .:bool:false\\n   .:bool:false\\n\\n// Evaluates to true.\\nor\\n   .:bool:false\\n   .:bool:true\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Not (inverting booleans)"},{"role":"assistant","content":"not\\n   .:bool:true\\nnot\\n   .:bool:false\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Adds the specified list of nodes to [.dest]"},{"role":"assistant","content":".dest\\nadd:x:@.dest\\n   .\\n      foo1:howdy\\n      foo2:world\\n   .\\n      bar1:hello\\n      bar2:world\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Add the [.dest]'s children nodes to [.dest]"},{"role":"assistant","content":".src\\n   foo1:foo\\n   foo2:bar\\n.dest\\nadd:x:@.dest\\n   get-nodes:x:@.src/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Add [.src1] and [.src2]'s children to [.dest]"},{"role":"assistant","content":".dest\\n.dest\\n.src1\\n   foo1:bar1\\n.src2\\n   foo2:bar2\\nadd:x:../*/.dest\\n   get-nodes:x:@.src1/*\\n   get-nodes:x:@.src2/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Insert 'inserted' node before [foo1]"},{"role":"assistant","content":".foo\\n   foo1\\n   foo2\\ninsert-before:x:@.foo/*/foo1\\n   .\\n      inserted\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Insert 'inserted' node after [foo1]"},{"role":"assistant","content":".foo\\n   foo1\\n   foo2\\ninsert-after:x:@.foo/*/foo1\\n   .\\n      inserted\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Return all dynamic slots existing in system"},{"role":"assistant","content":"slots.vocabulary\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Remove [foo2]"},{"role":"assistant","content":"remove-nodes:x:@.data/*/foo2\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Changes the name of the specified node"},{"role":"assistant","content":".foo\\n   old-name\\nset-name:x:@.foo/*\\n   .:new-name\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Demonstrates how [unwrap] works"},{"role":"assistant","content":".src:Hello World\\nunwrap:x:+\\n.dest:x:@.src\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"How to retrieve the value of the previous node"},{"role":"assistant","content":".data:Hello World\\nget-value:x:-\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"How to retrieve the name of the previous node"},{"role":"assistant","content":".foo\\nget-name:x:-\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"counts nodes"},{"role":"assistant","content":".data\\n   foo1\\n   foo2\\nget-count:x:@.data/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Replace [.data]'s 'cool' parts with 'super cool'"},{"role":"assistant","content":".data:Hyperlambda is cool\\nstrings.replace:x:-\\n   .:cool\\n   .:super cool\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns all nodes from some expression"},{"role":"assistant","content":".data\\n   foo1\\n   foo2\\nget-nodes:x:-/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Checks if not exists"},{"role":"assistant","content":".src1\\n   foo\\n.src2\\nnot-exists:x:@.src1/*\\nnot-exists:x:@.src2/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Checks for null values, second invocation will be false"},{"role":"assistant","content":".src1\\n   foo:foo\\n.src2\\n   foo\\nnull:x:@.src1/*\\nnull:x:@.src2/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Checks if some node does not exists. 3rd invocation will be false"},{"role":"assistant","content":".src1\\n   foo:foo\\n.src2\\n   foo\\n.src3\\nnot-null:x:@.src1/*\\nnot-null:x:@.src2/*\\nnot-null:x:@.src3/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create a context object and referencing it in its scope"},{"role":"assistant","content":".result\\ncontext:foo\\n   value:bar\\n   .lambda\\n      set-value:x:@.result\\n         get-context:foo\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example of exception handlers"},{"role":"assistant","content":"try\\n   throw:Whatever\\n.catch\\n   log.info:ERROR HAPPENED!! 42, 42, 42!\\n.finally\\n   log.info:Yup, we are finally there!\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Replace hansen with tjobing hansen"},{"role":"assistant","content":".foo:thomas hansen\\nstrings.replace:x:-\\n   .:hansen\\n   .:tjobing hansen\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Throws the specified exception with the specified HTTP status code, making it public"},{"role":"assistant","content":"throw:Whatever error message here\\n   status:398\\n   public:true\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Loops for 5 iterations, adding a static node each iteration"},{"role":"assistant","content":".no:int:0\\n.res\\nwhile\\n   lt\\n      get-value:x:@.no\\n      .:int:5\\n   .lambda\\n      add:x:@.res\\n         .\\n            foo\\n      math.increment:x:@.no\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Return the type of [.foo]"},{"role":"assistant","content":".foo:int:57\\ntype:x:-\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Convert [.foo]'s value to int"},{"role":"assistant","content":".foo:57\\nconvert:x:-\\n   type:int\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"String format the value of [.foo]"},{"role":"assistant","content":"format:x:@.foo\\n   pattern:\"{0:00000}\"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"String formats the value of [.foo] with the specified culture"},{"role":"assistant","content":".foo:decimal:57\\nformat:x:-\\n   pattern:\"{0:0.00}\"\\n   culture:nb-NO\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Return ALL slots in your system."},{"role":"assistant","content":"vocabulary\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example of [whitelist] execution, where only two slots are legal"},{"role":"assistant","content":".result\\nwhitelist\\n   vocabulary\\n      set-value\\n      return\\n   .lambda\\n\\n      // Inside of this [.lambda] object, we can only invoke [set-value], and no other slots!\\n      set-value:x:@.result\\n         .:foo\\n\\n      // Notice, the next line will throw an exception if you remove its \".\" character,\\n\\n      // because [add] is not whitelisted in our above [vocabulary] declaration!\\n      .add:x:@.result\\n         .\\n            foo:bar\\n      return\\n         result:success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Sort children nodes of [.data] by name"},{"role":"assistant","content":"sort:x:@.data/*\\n   if\\n      lt:x:@.lhs/#/*/name\\n         get-value:x:@.rhs/#/*/name\\n      .lambda\\n         set-value:x:@.result\\n            .:int:-1\\n   else-if\\n      mt:x:@.lhs/#/*/name\\n         get-value:x:@.rhs/#/*/name\\n      .lambda\\n         set-value:x:@.result\\n            .:int:1\\n   else\\n      set-value:x:@.result\\n         .:int:0\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Count OpenAI API tokens"},{"role":"assistant","content":"openai.tokenize:This is some query\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create a cache item"},{"role":"assistant","content":"cache.set:cache-item-key\\n   expiration:5\\n   value:Howdy world\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Remove a cache item (no [value])"},{"role":"assistant","content":"cache.set:cache-item-key\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Return some cache item"},{"role":"assistant","content":"cache.get:cache-item-key\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Return some cache item, setting its default value if not existing"},{"role":"assistant","content":"cache.try-get:cache-key\\n   expiration:5\\n   .lambda\\n      return:Howdy world\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Illustrates how creating a cache item, for then to deleting it, and retrieving it after returns nothing"},{"role":"assistant","content":"cache.set:cache-item-key\\n   expiration:5\\n   value:Howdy world\\ncache.clear\\ncache.get:cache-item-key\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create a cache item and lists all cache items"},{"role":"assistant","content":"cache.set:cache-item-key\\n   expiration:5\\n   value:Howdy world\\ncache.list\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create a cache item and counts items after"},{"role":"assistant","content":"cache.set:cache-item-key\\n   expiration:5\\n   value:Howdy world\\ncache.count\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Divide 100 by 4"},{"role":"assistant","content":"math.divide:int:100\\n   :int:4\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"First add [.one]'value with [.two]'value, then multiply by 3"},{"role":"assistant","content":"math.multiply\\n   .:int:3\\n   math.add\\n      get-value:x:@.one\\n      get-value:x:@.two\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Decrement [.value] by 2"},{"role":"assistant","content":"math.decrement:x:@.NODE_EXPRESSION_HERE\\n   .:int:2\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Increment [.value] by 1"},{"role":"assistant","content":"math.increment:x:../*/foo/*/item\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Multiplies [.arg]'s value by 3"},{"role":"assistant","content":".arg:int:5\\nmath.multiply\\n   get-value:x:@.arg\\n   .:int:3\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Add 2 to [arg]'s value"},{"role":"assistant","content":"math.add\\n   get-value:x:@.arg\\n   .:int:2\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Subtract 2 from [.arg]'s value"},{"role":"assistant","content":"math.subtract\\n   get-value:x:@.arg\\n   .:int:2\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Return the modulo of [.arg]'s value divided by 2"},{"role":"assistant","content":"math.modulo\\n   get-value:x:@.arg\\n   .:int:2\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Decrement [.arg]'s value by 1"},{"role":"assistant","content":"math.decrement:x:@.arg\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Capitalise a string"},{"role":"assistant","content":"strings.capitalize:thomas\\n\\n// Resulting in \"Thomas\" after invocation.\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Decrement [.arg]'s value by 2"},{"role":"assistant","content":"math.decrement:x:@.arg\\n   .:int:2\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Increment [.arg]'s value by 1"},{"role":"assistant","content":".arg:int:5\\nmath.increment:x:@.arg\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Return the smallest number of 5 and 7"},{"role":"assistant","content":"math.min\\n   .:int:5\\n   .:int:7\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Return the largest number of 11 and 12"},{"role":"assistant","content":"math.max\\n   .:int:11\\n   .:int:12\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Calculate the dot product of [.list1] x [.list2]"},{"role":"assistant","content":".list1\\n   .:double:0.5\\n   .:double:0.7\\n   .:double:0.1\\n.list2\\n   .:double:0.56\\n   .:double:0.89\\n   .:double:0.33\\nmath.dot\\n   get-nodes:x:@.list1/*\\n   get-nodes:x:@.list2/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Concatenate 6 strings, one being an expression reference"},{"role":"assistant","content":".bar:Bar\\nstrings.concat\\n   .:Thomas\\n   .:\" \"\\n   .:Hansen\\n   .:\" \"\\n   .:Foo\\n   .:\" \"\\n   get-value:x:@.bar\\n\\n// Resulting in \"Thomas Hansen Foo Bar\" after invocation.\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Convert Markdown to HTML"},{"role":"assistant","content":"markdown2html:x:@.md\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Convert HTML to Markdown"},{"role":"assistant","content":"html2markdown:x:@.html\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Validate [email] argument is a valid email address"},{"role":"assistant","content":"validators.email:x:@.arguments/*/email\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Validate values of [.arg] is a valid email address"},{"role":"assistant","content":"validators.email:x:@.arg\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Validate [enum_value] argument is either 'val1' or 'val2'"},{"role":"assistant","content":"validators.enum:x:@.arguments/*/enum_value\\n   .:val1\\n   .:val2\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Check if string contains Hansen"},{"role":"assistant","content":"strings.contains:Thomas Hansen Is Cool\\n   .:Hansen\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Validate [some-integer-argument] argument is between 50 and 100"},{"role":"assistant","content":"validators.integer:x:@.arguments/*/some-integer-argument\\n   min:50\\n   max:100\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Validate [mandatory_arg] argument was specified"},{"role":"assistant","content":"validators.mandatory:x:@.arguments/*/mandatory_arg\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Use regex to validate [foo] argument contains howdy"},{"role":"assistant","content":"validators.regex:x:@.arguments/*/foo\\n   regex:howdy\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"String validation where length must be between 5 and 15"},{"role":"assistant","content":"validators.string:x:@.some-arg\\n   min:5\\n   max:15\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Validates the [recaptcha_value] argument is a valid reCAPTCHA token"},{"role":"assistant","content":"validators.recaptcha:x:@.arguments/*/recaptcha_value\\n   site-key:xyz\\n   secret:qwerty\\n   min:decimal:0.3\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Injects [foo1] node with 'bar1' value unless [.arguments] already contains a [foo1] node"},{"role":"assistant","content":".arguments\\nvalidators.default:x:@.arguments\\n   foo1:bar1\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Creates a log item"},{"role":"assistant","content":"log.info:Howdy world from magic.lambda.logging\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Creates a log item with some additional fields"},{"role":"assistant","content":"log.info:Some log entry\\n   username:foo\\n   ip:123.123.123.123\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Check if string ends with some specific part"},{"role":"assistant","content":"strings.ends-with:Thomas Hansen Is Cool\\n   .:Cool\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Creates a JWT token"},{"role":"assistant","content":"auth.ticket.create\\n   username:foo\\n   roles\\n      .:howdy\\n      .:world\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Creates a JWT token"},{"role":"assistant","content":"auth.ticket.create\\n   username:foo\\n   roles\\n      .:howdy\\n      .:world\\n   claims\\n      id:578\\n      ssid:xyzqwerty67\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Thiw will throw an exception since the role doesn't exist"},{"role":"assistant","content":"auth.ticket.verify:non-existing-role\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns true if user belongs to foo or root role, for then to retrieve the user's username and roles"},{"role":"assistant","content":"auth.ticket.in-role:foo, root\\nauth.ticket.get\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns the username and role(s) of currently authenticated user"},{"role":"assistant","content":"auth.ticket.get\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Creates a valid JWT ticket with username being 'foo' belonging to howdy and world roles"},{"role":"assistant","content":"auth.ticket.create\\n   username:foo\\n   roles\\n      .:howdy\\n      .:world\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns a new JWT token with expanded expiration date"},{"role":"assistant","content":"auth.ticket.refresh\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Verifies user belongs to root, admin or guest role"},{"role":"assistant","content":"auth.ticket.verify:root,admin,guest\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns true if user belongs to any of the specified roles"},{"role":"assistant","content":"auth.ticket.in-role:root,admin,guest\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Connects to sakila and returns all items from actor"},{"role":"assistant","content":"data.connect:sakila\\n   data.read\\n      table:actor\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Connects to bar database using foo connection string from our configuration"},{"role":"assistant","content":"data.connect:[foo|bar]\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Connects to saklia and executes the specified SQL"},{"role":"assistant","content":"data.connect:sakila\\n   data.select:select first_name, last_name from actor limit 5\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Join all values of children of [.src] by ',' character"},{"role":"assistant","content":".src\\n   .:foo\\n   .:bar\\nstrings.join:x:@.src/*\\n   .:,\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Connects to sakila database and executes the specified SQL"},{"role":"assistant","content":"data.connect:sakila\\n   data.execute:delete from actor\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Connects to sakila with database transactions"},{"role":"assistant","content":"data.connect:sakila\\n   data.transaction.create\\n      data.execute:delete from film_actor\\n\\n      /*\\n       * If you uncomment the line below the\\n       * transaction will be committed, resulting\\n       * in that everything from your film_actor\\n       * table will be deleted.\\n       */\\n\\n      // data.transaction.commit\\ndata.connect:sakila\\n\\n   /*\\n    * Notice, this still returns 5462 items, since\\n    * transaction was implicitly rolled back above.\\n    */\\n   data.scalar:select count(*) from film_actor\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Creates a new record in table1 with field1 and field2 having values"},{"role":"assistant","content":"sql.create\\n   table:table1\\n   values\\n      field1:howdy\\n      field2:world\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Do a regular expression replace of fo+ with FOO"},{"role":"assistant","content":"strings.regex-replace:foo bar hansen\\n   .:fo+\\n   .:FOO\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Connects to sakila and returns items from film, joining on film_actor and actor"},{"role":"assistant","content":"data.connect:sakila\\n   data.read\\n      columns\\n         title\\n         description\\n         last_name\\n         first_name\\n      table:film\\n         join:film_actor\\n            type:inner\\n            on\\n               and\\n                  film.film_id:film_actor.film_id\\n            join:actor\\n               type:inner\\n               on\\n                  and\\n                     film_actor.actor_id:actor.actor_id\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Split the value of [.foo] by ' '"},{"role":"assistant","content":".foo:some input string\\nstrings.split:x:-\\n   .:\" \"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Group by syntax counting items from table1 grouped by col1"},{"role":"assistant","content":"sql.read\\n   table:table1\\n   limit:-1\\n   columns\\n      col1\\n      count(*)\\n         as:count\\n   group\\n      col1\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Updates all records in table1, setting field1 to howdy"},{"role":"assistant","content":"sql.update\\n   table:table1\\n   values\\n      field1.eq:howdy\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Deletes items from table1 with field1 and field2 having value1 and value2 respectively"},{"role":"assistant","content":"sql.delete\\n   table:table1\\n   where\\n      and\\n         field1.eq:value1\\n         field2.eq:value2\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns ALL items (limit is -1) from table1 where field1 equals 'howdy'"},{"role":"assistant","content":"sql.read\\n   table:table1\\n   limit:-1\\n   where\\n      and\\n         field1.eq:howdy\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns ALL items (limit is -1) from table1 where field1 equals 'howdy' or field2 equals 'world'"},{"role":"assistant","content":"sql.read\\n   table:table1\\n   limit:-1\\n   where\\n      or\\n         field1.eq:howdy\\n         field2.eq:world\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Complex condition, where either field1 must be 'howdy' or field2 must be 'world' in addition to field3 being 'dudes'"},{"role":"assistant","content":"sql.read\\n   table:table1\\n   limit:-1\\n   where\\n      or\\n         field1.eq:howdy\\n         and\\n            field2.eq:world\\n            field3.eq:dudes\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns all items where field1 is NOT 'xxx'"},{"role":"assistant","content":"sql.read\\n   table:foo\\n   where\\n      and\\n         field1.neq:xxx\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Turn the [.g] into lowercase"},{"role":"assistant","content":"strings.to-lower:x:@.g\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Adds 2 days to today's date and time and formats as string"},{"role":"assistant","content":"math.add\\n   date.now\\n   time\\n      days:2\\n      second:1\\ndate.format:x:-\\n   format:\"yyyy-MM-dd HH:mm:ss\"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns current date and time"},{"role":"assistant","content":"date.now\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Creates a date from Unix timestamp"},{"role":"assistant","content":"date.from-unix:1674132584\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Formats specified date according to specified pattern"},{"role":"assistant","content":"date.format:date:\"2023-01-19T12:49:44.000Z\"\\n   format:dd. MMMM yyyy\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns a timespan for 5 days"},{"role":"assistant","content":"time\\n   days:5\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Sends an email using specific SMTP settings"},{"role":"assistant","content":"mail.smtp.send\\n   server\\n      host:foo.com\\n      port:123\\n      secure:true\\n      username:xxx\\n      password:yyy\\n   message\\n      to\\n         John Doe:john@doe.com\\n      from\\n         Jane Doe:jane@doe.com\\n      subject:Subject line\\n      entity:text/plain\\n         content:Body content\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Sends an email using SMTP settings from configuration"},{"role":"assistant","content":"mail.smtp.send\\n   message\\n      to\\n         Jane Doe:jane@doe.com\\n      subject:Subject line\\n      entity:text/plain\\n         content:Body content\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Sends a multipart email with file attachment"},{"role":"assistant","content":"mail.smtp.send\\n   message\\n      to\\n         Jane Doe:jane@doe.com\\n      subject:Subject line\\n      entity:multipart/mixed\\n         entity:text/plain\\n            content:Body content\\n         entity:text/plain\\n            filename:/files/foo.txt\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Sends a multipart email with attachment"},{"role":"assistant","content":"mail.smtp.send\\n   message\\n      to\\n         .\\n            email:someemail@whatever.com\\n            name:John Doe\\n      subject:Some subject line\\n      entity:multipart/mixed\\n         entity:text/plain\\n            content:Some text content\\n         entity:text/markdown\\n            headers\\n               Content-Disposition:\"attachment; filename=\\\"README.md\\\"\"\\n            content:Some Markdown content here\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Trim numbers from both ends"},{"role":"assistant","content":"strings.trim:09thomas12\\n   .:1234567890\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Crop the specified image"},{"role":"assistant","content":"image.crop:/modules/test/qr.png\\n   right:50\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Converts the specified image"},{"role":"assistant","content":"image.convert:/some-image.png\\n   type:jpeg\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Generate QR code"},{"role":"assistant","content":"image.generate-qr:\"https://docs.ainiro.io\"\\n   size:8\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create bar chart"},{"role":"assistant","content":"image.chart:bars\\n   filename:/bar-chart.png\\n   width:600\\n   height:300\\n   bars\\n      Spring:int:2\\n      Summer:int:5\\n      Autumn:int:10\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create stacked chart"},{"role":"assistant","content":"image.chart:stacked\\n   filename:/stacked-chart.png\\n   width:600\\n   height:300\\n   bars\\n      Spring\\n         .:int:2\\n         .:int:5\\n         .:int:10\\n      Summer\\n         .:int:4\\n         .:int:7\\n         .:int:10\\n      Autumn\\n         .:int:2\\n         .:int:5\\n         .:int:4\\n   legend\\n      .:Phones\\n      .:Computers\\n      .:Tablets\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create grouped chart"},{"role":"assistant","content":"image.chart:grouped\\n   filename:/grouped-chart.png\\n   width:600\\n   height:300\\n   bars\\n      Spring\\n         .:int:2\\n         .:int:5\\n         .:int:10\\n      Summer\\n         .:int:4\\n         .:int:7\\n         .:int:10\\n      Autumn\\n         .:int:2\\n         .:int:5\\n         .:int:4\\n   legend\\n      .:Phones\\n      .:Computers\\n      .:Tablets\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Converts lambda object to CSV string, preserving types"},{"role":"assistant","content":".data\\n   .\\n      name:Thomas Hansen\\n      age:int:47\\n   .\\n      name:John Doe\\n      age:int:67\\nlambda2csv:x:-/*\\nadd:x:+/*/types\\n   get-nodes:x:@lambda2csv/*\\ncsv2lambda:x:@lambda2csv\\n   types\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"URL encode [.x]"},{"role":"assistant","content":".x:thomas@servergardens.com\\nstrings.url-encode:x:@.x\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Converts lambda object to CSV string"},{"role":"assistant","content":".data\\n   .\\n      name:Thomas Hansen\\n      age:int:47\\n   .\\n      name:John Doe\\n      age:int:67\\nlambda2csv:x:-/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Compiles a piece of C#"},{"role":"assistant","content":"system.compile\\n   assembly-name:foo.dll\\n   references\\n      .:netstandard\\n      .:System.Runtime\\n      .:System.Private.CoreLib\\n      .:magic.node\\n      .:magic.signals.contracts\\n   code:C# CODE HERE\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"The following code compiles the \"/etc/foo.cs\" file and saves it as an assembly\\nin \"/etc/foo.dll\"."},{"role":"assistant","content":"io.file.load:/etc/foo.cs\\nsystem.compile\\n   references\\n      .:netstandard\\n      .:System.Runtime\\n      .:System.Console\\n      .:System.Private.Uri\\n      .:System.ComponentModel\\n      .:System.Private.CoreLib\\n      .:System.Net.Primitives\\n      .:magic.node\\n      .:magic.node.extensions\\n      .:magic.library\\n      .:magic.signals.contracts\\n   code:x:@io.file.load\\n   assembly-name:foo.dll\\n\\n// Saving our compiled CLR assembly to '/etc/foo.dll'.\\nio.file.save.binary:/etc/foo.dll\\n   get-value:x:@system.compile\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Dynamically load a plugin/assembly"},{"role":"assistant","content":"system.plugin.load:/etc/foo.dll\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Compiles a snippet of C# code down to a library,\\nfor then to dynamically load it as a plugin."},{"role":"assistant","content":"system.compile\\n   references\\n      .:netstandard\\n      .:System.Runtime\\n      .:System.Private.CoreLib\\n      .:magic.node\\n      .:magic.node.extensions\\n      .:magic.signals.contracts\\n   code:@\"\\n\\n// Example C# code creating a Hyperlambda slot.\\nusing System;\\nusing magic.node;\\nusing magic.node.extensions;\\nusing magic.signals.contracts;\\n\\n// Our slot class.\\n[Slot(Name = \"\"foo\"\")]\\npublic class Foo : ISlot\\n{\\n   public void Signal(ISignaler signaler, Node input)\\n   {\\n      input.Value = $\"\"Hi {input.GetEx<string>()}, how may I assist you?\"\";\\n   }\\n}\"\\n   assembly-name:foo.dll\\n\\n// Loading assembly from raw bytes now that we've created it.\\nsystem.plugin.load:x:@system.compile\\n\\n// Executing [foo] slot now dynamically injected into AppDomain.\\n.name:John Doe\\nfoo:x:@.name\\n\\n// Unloading plugin.\\nsystem.plugin.unload:foo.dll\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Compiles a snippet of C# code down to a library,\\nfor then to dynamically load it as a plugin.\\n\\nThis particular code creates a slot, but you can create any\\ncode you wish, and it doesn't have to be Hyperlambda related."},{"role":"assistant","content":"system.compile\\n   references\\n      .:netstandard\\n      .:System.Runtime\\n      .:System.Private.CoreLib\\n      .:magic.node\\n      .:magic.signals.contracts\\n   code:@\"\\n\\n// Example C# code creating a Hyperlambda slot.\\nusing System;\\nusing magic.node;\\nusing magic.signals.contracts;\\n\\n// Our slot class.\\n[Slot(Name = \"\"bar\"\")]\\npublic class Bar : ISlot\\n{\\n   public void Signal(ISignaler signaler, Node input)\\n   {\\n      input.Value = \"\"Hello from C#\"\";\\n   }\\n}\"\\n   assembly-name:bar.dll\\n\\n// Loading assembly now that we've created it.\\nsystem.plugin.execute:x:@system.compile\\n\\n   // Invoking dynamically created C# slot.\\n   bar\\n\\n/*\\n * Now the [bar] slot is no longer available\\n * since the assembly has been unloaded due to\\n * having gone out of scope.\\n */\\nsystem.plugin.list\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Logging from a thread"},{"role":"assistant","content":"fork\\n   info.log:I was invoked from another thread\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Creating two threads and waiting for both to finish"},{"role":"assistant","content":"join\\n   fork\\n      http.get:\"https://servergardens.com\"\\n   fork\\n      http.get:\"https://gaiasoul.com\"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Creates a semaphore"},{"role":"assistant","content":"semaphore:foo-bar\\n\\n   /*\\n    * Only one thread will be allowed entrance into this piece of\\n    * code at the same time, ensuring synchronized access, for cases\\n    * where you cannot allow more than one thread to enter at the\\n    * same time.\\n    */\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Sleeps the main thread for 1 second, or 1000 milliseconds."},{"role":"assistant","content":"sleep:1000\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"URL encode [.SOME_NODE]"},{"role":"assistant","content":"strings.url-decode:x:@.SOME_NODE\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Return substring 5 to 7 of [.input]'s value"},{"role":"assistant","content":".input:Foo Bar Howdy World\\nstrings.substring:x:-\\n   .:5\\n   .:7\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Use regular expression matching to look for {match1} and {match2}"},{"role":"assistant","content":".input:Foo Bar Howdy World {match1} and {match2} and that was it\\nstrings.matches:x:-\\n   .:\"\\\\{.+?\\\\}\"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Convert a PDF file to text."},{"role":"assistant","content":"pdf2text:/foo/bar.pdf\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create a MIME message with Markdown"},{"role":"assistant","content":"mime.create:multipart/mixed\\n   entity:text/plain\\n      content:Some text content\\n   entity:text/markdown\\n      headers\\n         Content-Disposition:attachment; filename=README.md\\n      content:Some Markdown content here\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create a multipart MIME message"},{"role":"assistant","content":"mime.create:multipart/mixed\\n   entity:text/plain\\n      content:Some text content\\n   entity:text/markdown\\n      filename:/etc/README.md\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create a task that logs"},{"role":"assistant","content":"tasks.create:foo-bar-task-1\\n   .lambda\\n\\n      // Your task's lambda object goes here\\n      log.info:Executing foo-bar-task-1\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create a task with description."},{"role":"assistant","content":"tasks.create:foo-bar-task-2\\n   description:This task will do a little bit of foo and some bar afterwards.\\n   .lambda\\n      log.info:Executing foo-bar-task-2\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create a task that executes on two specific dates, in addition to repeating every 3 hours and 5 seconds"},{"role":"assistant","content":"tasks.create:foo-bar-task-3\\n   due:date:\"2025-01-01T23:59:27.000\"\\n   repeats:5.seconds\\n   repeats:3.hours\\n   due:date:\"2030-01-01T23:59:27.000\"\\n   .lambda\\n      log.info:Executing foo-bar-task-2\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create and update a task"},{"role":"assistant","content":"tasks.create:foo-bar-task-4\\n   .lambda\\n      log.info:Executing foo-bar-task-1\\ntasks.update:foo-bar-task-4\\n   description:This is the foo bar task\\n   .lambda\\n      log.info:Another log entry now!\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Delete task with 'task-id' as its ID"},{"role":"assistant","content":"tasks.delete:task-id\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Return task named 'task-id'"},{"role":"assistant","content":"tasks.get:task-id\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Return 'foo' task including its schedules"},{"role":"assistant","content":"tasks.get:foo\\n   schedules:true\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"List tasks between 20 and 30"},{"role":"assistant","content":"tasks.list\\n   offset:20\\n   limit:10\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create a task, then schedule it for invocation at a specific date"},{"role":"assistant","content":"tasks.create:foo-bar-task-3\\n   .lambda\\n      log.info:Executing foo-bar-task-3\\ntasks.schedule:foo-bar-task-3\\n   due:date:\"2025-12-24T17:00:00.000\"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create a task, then schedule it"},{"role":"assistant","content":"tasks.create:task-id-qwqw\\n   .lambda\\n      log.info:Executing repeating task\\ntasks.schedule:task-id-qwqw\\n   repeats:50.seconds\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create a task, then schedule it to run once every 3650 days"},{"role":"assistant","content":"tasks.create:task-id-qwerty123\\n   .lambda\\n      log.info:Executing seldomly repeating task once every 10 year\\ntasks.schedule:task-id-qwerty123\\n   repeats:3650.days\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create a task, then schedule it"},{"role":"assistant","content":"tasks.create:task-id\\n   .lambda\\n      log.info:It is the 5th or the 15th of January or February, and the time is 5AM at night.\\ntasks.schedule:task-id\\n   repeats:01|02.5|15.05.00.00\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create a task, then schedule it"},{"role":"assistant","content":"tasks.create:task-id-555\\n   .lambda\\n      log.info:It is the 10PM now.\\ntasks.schedule:task-id-555\\n   repeats:**.**.22.00.00\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create a task, then schedule it"},{"role":"assistant","content":"tasks.create:task-id-567\\n   .lambda\\n      log.info:It is Saturday or Sunday, and the time is 22PM.\\ntasks.schedule:task-id-567\\n   repeats:saturday|SUNDAY.22.00.00\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Execute Hyperlambda from a string that creates a log item"},{"role":"assistant","content":".hl:\"log.info:\\\"This was logged from a piece of text\\\"\"\\nhyper2lambda:x:-\\neval:x:-\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Convert lambda 2 hyperlambda"},{"role":"assistant","content":".hl\\n   log.info:This is some example logging invocation\\nlambda2hyper:x:-/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Load a file, convert it to lambda, and then execute it"},{"role":"assistant","content":"io.file.load:/foo.hl\\nhyper2lambda:x:-\\neval:x:-\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Return configuration key named 'foo:bar'"},{"role":"assistant","content":"config.get:\"foo:bar\"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example: Return the value of the '#text' node, making sure we escape '#' being special character."},{"role":"assistant","content":"get-value:x:\"@xml2lambda/**/PRICE/*/\\\\#text\"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create a random new GUID"},{"role":"assistant","content":"guid.new\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create an HTTP GET example"},{"role":"assistant","content":"http.get:\"https://google.com\"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create HTTP GET example with headers"},{"role":"assistant","content":"http.get:\"https://google.com\"\\n   headers\\n      Accept:text/html\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Generate HTTP GET with query paramaters"},{"role":"assistant","content":".query\\n   foo1:bar1\\n   foo2:bar2\\nhttp.get:\"https://foo.com\"\\n   query:x:@.query/*\\n\\n// Or, alternatively ...\\nhttp.get:\"https://foo.com\"\\n   query\\n      foo1:bar1\\n      foo2:bar2\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Write HTTP POST invocation with payload"},{"role":"assistant","content":"http.post:\"https://some-url.com\"\\n   token:qwerty_secret_JWT_token_goes_here\\n   payload:some mumbo jumbo payload, typically JSON and not text though ...\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create HTTP POST invocation with payload being file"},{"role":"assistant","content":"http.post:\"https://some-url.com\"\\n   filename:/README.md\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Generate HTTP POST Hyperlambda with dynamic arguments"},{"role":"assistant","content":".userId:int:1\\nhttp.post:\"https://jsonplaceholder.typicode.com/posts\"\\n   payload\\n      id:int:1\\n      userId:x:@.userId\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Illustrates how to use a [for-each] loop to iterate some node-set."},{"role":"assistant","content":".data\\n   item1:Hello from Item1\\n   item2:Hello from Item2\\n   item3:Hello from Item3\\nfor-each:x:@.data/*\\n   log.info:x:@.dp/#\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Notice, the whole idea with this Hyperlambda,\\nis to demonstrate how the log invocation inside of\\nthe [fork] is being executed after the outer log\\ninvocation, due to the sleep invocation, and the\\nfact that it runs on a different thread."},{"role":"assistant","content":"fork\\n   sleep:1000\\n   log.info:INSIDE\\nlog.info:OUTSIDE\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Creates a grouped chart"},{"role":"assistant","content":"image.chart:grouped\\n   filename:/chart.png\\n   width:600\\n   height:300\\n   bars\\n      Spring\\n         .:int:2\\n         .:int:5\\n         .:int:10\\n      Summer\\n         .:int:4\\n         .:int:7\\n         .:int:10\\n      Autumn\\n         .:int:2\\n         .:int:5\\n         .:int:4\\n   legend\\n      .:Phones\\n      .:Computers\\n      .:Tablets\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Invokes an HTTP GET endpoint, and returns the result."},{"role":"assistant","content":"http.get:\"https://jsonplaceholder.typicode.com/users/1\"\\n   convert:true\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"This example demonstrates implicit conversion for non-null object to\\nboolean. If an object is not bool, but it is non-null, during boolean\\nconversion it will automatically be defined as \"true\"."},{"role":"assistant","content":".result\\n.foo:whatever\\nif:x:-\\n   set-value:x:@.result\\n      .:Yup!\\nelse\\n   set-value:x:@.result\\n      .:Nope!\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Evaluates specified [.lambda] if condition evaluates to true."},{"role":"assistant","content":"if\\n   and\\n      eq:x:@SOME_EXPRESSION\\n         .:SOME_VALUE\\n      eq:x:@SOME_OTHER_EXPRESSION\\n         .:SOME_OTHER_VALUE\\n   .lambda\\n\\n      // Lambda evaluates if condition is true.\\nelse\\n\\n   // Lambda evaluated if condition is NOT true.\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Evaluates specified [.lambda] if condition evaluates to true."},{"role":"assistant","content":"if:x:@SOME_EXPRESSION\\n\\n   // Lambda evaluates if condition is true.\\nelse\\n\\n   // Lambda evaluated if condition is NOT true.\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Evaluates specified [.lambda] if condition evaluates to true."},{"role":"assistant","content":"if\\n   or\\n      eq:x:@SOME_EXPRESSION\\n         .:SOME_VALUE\\n      eq:x:@SOME_OTHER_EXPRESSION\\n         .:SOME_OTHER_VALUE\\n   .lambda\\n\\n      // Lambda evaluates if condition is true.\\nelse\\n\\n   // Lambda evaluated if condition is NOT true.\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"[include] example illustrating basic usage."},{"role":"assistant","content":".static:JO\\n.data\\n   foo1:bar1\\n   foo2:bar2\\n   foo3:bar3\\ninclude:x:@.data/*\\n   strings.concat\\n      get-value:x:@.dp/#\\n      .:\" howdy \"\\n      get-value:x:@.static\\n   unwrap:x:+/*\\n   return\\n      howdy:x:@strings.concat\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Inserts a bunch of nodes after the specified destination expression's node."},{"role":"assistant","content":".destination\\n   foo1\\ninsert-after:x:@.destination/*/foo1\\n   .\\n      foo2:bar\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Inserts a bunch of nodes before the specified destination expression's node."},{"role":"assistant","content":".destination\\n   foo1\\ninsert-before:x:@.destination/*/foo1\\n   .\\n      foo2:bar\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"An example of waiting for multiple threads to finish parallel execution."},{"role":"assistant","content":"join\\n   fork\\n      http.get:\"https://gaiasoul.com\"\\n   fork\\n      http.get:\"https://servergardens.com\"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example snippet scraping some web page."},{"role":"assistant","content":"signal:magic.http.scrape-url\\n   url:\"https://www.cnn.com/2023/06/18/golf/wyndham-clark-2023-us-open-winner-spt-intl/index.html\"\\n   semantics:bool:true\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example of how to send an email using Hyperlambda."},{"role":"assistant","content":"mail.smtp.send\\n   message\\n      to\\n         Thomas Hansen:thomas@gaiasoul.com\\n      from\\n         Testing Gmail:testing.anarchy@gmail.com\\n      subject:This is subject\\n      entity:text/plain\\n         content:This is body\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns minimum, maximum, average or sum from your media table in your cms database"},{"role":"assistant","content":".arguments\\n\\n   // Function to aggregate upon. Argument is mandatory and legal values are min, max, sum or avg\\n   aggregate_function:string\\n\\n   // Argument is mandatory and must be in the format of TABLE_NAME.COLUMN_NAME.\\n   aggregate_column:string\\n\\n   // Number of records to return, defaults to 25 if not specified. Pass in -1 to return all records.\\n\\n   // Offset into the dataset of where to start retrieving records\\n\\n   // Fully qualified name of column to order by, must be in TABLE_NAME.COLUMN_NAME format\\n\\n   // What direction to order, can be 'asc' or 'desc' implying ascending and descending\\n   media.id.eq:long\\n   media.post_id.eq:long\\n   media.file_path.like:string\\n   media.file_path.eq:string\\n   media.file_type.like:string\\n   media.file_type.eq:string\\n   media.created_at.eq:date\\n   post_id.title.eq:string\\n   post_id.title.like:string\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-aggregate\\n\\n// Sanity checking mandatory arguments.\\nvalidators.mandatory:x:@.arguments/*/aggregate_function\\nvalidators.mandatory:x:@.arguments/*/aggregate_column\\n\\n// Sanity checking name of aggregate function.\\nvalidators.enum:x:@.arguments/*/aggregate_function\\n   .:min\\n   .:max\\n   .:sum\\n   .:avg\\n\\n// Sanity checking agggregate column name.\\nvalidators.enum:x:@.arguments/*/aggregate_column\\n   .:media.id\\n   .:media.post_id\\n   .:media.file_path\\n   .:media.file_type\\n   .:media.created_at\\n   .:post_id.title\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:enterprise,root\\n\\n// Opening up our database connection.\\ndata.connect:[generic|cms]\\n   database-type:sqlite\\n\\n   // Making sure we're using correct aggregate function.\\n   set-name:x:./*/data.read/*/columns/*/aggregate_functor\\n      strings.concat\\n         get-value:x:@.arguments/*/aggregate_function\\n         .:(\\n         get-value:x:@.arguments/*/aggregate_column\\n         .:)\\n\\n   // Removing aggregate arguments to simplify adding other arguments.\\n   remove-nodes:x:@.arguments/*/[0,2]\\n   add:x:+/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:sqlite\\n      table:media\\n         join:posts\\n            as:post_id\\n            type:left\\n            on\\n               and\\n                  media.post_id:post_id.id\\n      columns\\n         aggregate_functor\\n            as:result\\n      where\\n         and\\n      limit:long:1\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Count unique and distinct items from your media table in your cms database"},{"role":"assistant","content":".arguments\\n\\n   // Argument is mandatory and must be in the format of TABLE_NAME.COLUMN_NAME\\n   distinct_column:string\\n\\n   // Number of records to return, defaults to 25 if not specified. Pass in -1 to return all records.\\n\\n   // Offset into the dataset of where to start retrieving records\\n\\n   // Fully qualified name of column to order by, must be in TABLE_NAME.COLUMN_NAME format\\n\\n   // What direction to order, can be 'asc' or 'desc' implying ascending and descending\\n   media.id.eq:long\\n   media.post_id.eq:long\\n   media.file_path.like:string\\n   media.file_path.eq:string\\n   media.file_type.like:string\\n   media.file_type.eq:string\\n   media.created_at.eq:date\\n   post_id.title.eq:string\\n   post_id.title.like:string\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-count-distinct\\n\\n// Sanity checking that distinct column was passed in.\\nvalidators.mandatory:x:@.arguments/*/distinct_column\\n\\n// Sanity checking distinct column's name.\\nvalidators.enum:x:@.arguments/*/distinct_column\\n   .:media.id\\n   .:media.post_id\\n   .:media.file_path\\n   .:media.file_type\\n   .:media.created_at\\n   .:post_id.title\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:enterprise,root\\n\\n// Opening up our database connection.\\ndata.connect:[generic|cms]\\n   database-type:sqlite\\n\\n   // Making sure we're using correct function.\\n   set-name:x:./*/data.read/*/columns/*/distinct_functor\\n      strings.concat\\n         .:\"count(distinct \"\\n         get-value:x:@.arguments/*/distinct_column\\n         .:)\\n\\n   // Removing distinct argument to simplify adding other arguments.\\n   remove-nodes:x:@.arguments/*/distinct_column\\n   add:x:+/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:sqlite\\n      table:media\\n         join:posts\\n            as:post_id\\n            type:left\\n            on\\n               and\\n                  media.post_id:post_id.id\\n      columns\\n         distinct_functor\\n            as:count\\n      where\\n         and\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Counts items from your media table in your cms database"},{"role":"assistant","content":".arguments\\n\\n   // Number of records to return, defaults to 25 if not specified. Pass in -1 to return all records.\\n\\n   // Offset into the dataset of where to start retrieving records\\n\\n   // Fully qualified name of column to order by, must be in TABLE_NAME.COLUMN_NAME format\\n\\n   // What direction to order, can be 'asc' or 'desc' implying ascending and descending\\n   media.id.eq:long\\n   media.post_id.eq:long\\n   media.file_path.like:string\\n   media.file_path.eq:string\\n   media.file_type.like:string\\n   media.file_type.eq:string\\n   media.created_at.eq:date\\n   post_id.title.eq:string\\n   post_id.title.like:string\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-count\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:enterprise,root\\n\\n// Opening up our database connection.\\ndata.connect:[generic|cms]\\n   database-type:sqlite\\n   add:x:+/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:sqlite\\n      table:media\\n         join:posts\\n            as:post_id\\n            type:left\\n            on\\n               and\\n                  media.post_id:post_id.id\\n      columns\\n         count(*)\\n            as:count\\n      where\\n         and\\n      limit:long:1\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns unique and distinct values from your media table in your cms database"},{"role":"assistant","content":".arguments\\n\\n   // Name of column to return unique and distinct values for. Argument is mandatory and must be in the format of TABLE_NAME.COLUMN_NAME\\n   distinct_column:string\\n\\n   // Number of records to return, defaults to 25 if not specified. Pass in -1 to return all records.\\n   limit:long\\n\\n   // Offset into the dataset of where to start retrieving records\\n   offset:long\\n\\n   // Fully qualified name of column to order by, must be in TABLE_NAME.COLUMN_NAME format\\n   order:string\\n\\n   // What direction to order, can be 'asc' or 'desc' implying ascending and descending\\n   direction:string\\n\\n   // Number of records to return, defaults to 25 if not specified. Pass in -1 to return all records.\\n\\n   // Offset into the dataset of where to start retrieving records\\n\\n   // Fully qualified name of column to order by, must be in TABLE_NAME.COLUMN_NAME format\\n\\n   // What direction to order, can be 'asc' or 'desc' implying ascending and descending\\n   media.id.eq:long\\n   media.post_id.eq:long\\n   media.file_path.like:string\\n   media.file_path.eq:string\\n   media.file_type.like:string\\n   media.file_type.eq:string\\n   media.created_at.eq:date\\n   post_id.title.eq:string\\n   post_id.title.like:string\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-distinct\\n\\n// Sanity checking that distinct column was passed in.\\nvalidators.mandatory:x:@.arguments/*/distinct_column\\n\\n// Sanity checking distinct column's name.\\nvalidators.enum:x:@.arguments/*/distinct_column\\n   .:media.id\\n   .:media.post_id\\n   .:media.file_path\\n   .:media.file_type\\n   .:media.created_at\\n   .:post_id.title\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:enterprise,root\\n\\n// Opening up our database connection.\\ndata.connect:[generic|cms]\\n   database-type:sqlite\\n\\n   // Making sure we're using correct function.\\n   set-name:x:./*/data.read/*/columns/*/distinct_functor\\n      strings.concat\\n         .:distinct(\\n         get-value:x:@.arguments/*/distinct_column\\n         .:)\\n\\n   // Removing distinct argument to simplify adding other arguments.\\n   remove-nodes:x:@.arguments/*/distinct_column\\n\\n   // Adding [limit] and [offset] arguments\\n   add:x:./*/data.read\\n      get-nodes:x:@.arguments/*/limit\\n      get-nodes:x:@.arguments/*/offset\\n      get-nodes:x:@.arguments/*/order\\n      get-nodes:x:@.arguments/*/direction\\n   remove-nodes:x:@.arguments/*/order\\n   remove-nodes:x:@.arguments/*/direction\\n   remove-nodes:x:@.arguments/*/limit\\n   remove-nodes:x:@.arguments/*/offset\\n   add:x:+/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:sqlite\\n      table:media\\n         join:posts\\n            as:post_id\\n            type:left\\n            on\\n               and\\n                  media.post_id:post_id.id\\n      columns\\n         distinct_functor\\n            as:.\\n      where\\n         and\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns minimum, maximum, average, sum or count from your media table in your cms database grouped by a column"},{"role":"assistant","content":".arguments\\n\\n   // Mandatory argument being column to group by and must be in the format of TABLE_NAME.COLUMN_NAME\\n   group_column:string\\n\\n   // Number of records to return, defaults to 25 if not specified. Pass in -1 to return all records.\\n   limit:long\\n\\n   // Offset into the dataset of where to start retrieving records\\n   offset:long\\n\\n   // Fully qualified name of column to order by, must be in TABLE_NAME.COLUMN_NAME format\\n   order:string\\n\\n   // What direction to order, can be 'asc' or 'desc' implying ascending and descending\\n   direction:string\\n\\n   // Function to aggregate upon. Argument is mandatory and legal values are min, max, sum, avg or count\\n   aggregate_function:string\\n\\n   // Argument is mandatory and must be in the format of TABLE_NAME.COLUMN_NAME.\\n   aggregate_column:string\\n\\n   // Number of records to return, defaults to 25 if not specified. Pass in -1 to return all records.\\n\\n   // Offset into the dataset of where to start retrieving records\\n\\n   // Fully qualified name of column to order by, must be in TABLE_NAME.COLUMN_NAME format\\n\\n   // What direction to order, can be 'asc' or 'desc' implying ascending and descending\\n   media.id.eq:long\\n   media.post_id.eq:long\\n   media.file_path.like:string\\n   media.file_path.eq:string\\n   media.file_type.like:string\\n   media.file_type.eq:string\\n   media.created_at.eq:date\\n   post_id.title.eq:string\\n   post_id.title.like:string\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-group\\n\\n// Sanity checking mandatory arguments.\\nvalidators.mandatory:x:@.arguments/*/group_column\\nvalidators.mandatory:x:@.arguments/*/aggregate_function\\nvalidators.mandatory:x:@.arguments/*/aggregate_column\\n\\n// Sanity checking name of aggregate function.\\nvalidators.enum:x:@.arguments/*/aggregate_function\\n   .:min\\n   .:max\\n   .:sum\\n   .:avg\\n   .:count\\n\\n// Sanity checking group column.\\nvalidators.enum:x:@.arguments/*/group_column\\n   .:media.id\\n   .:media.post_id\\n   .:media.file_path\\n   .:media.file_type\\n   .:media.created_at\\n   .:post_id.title\\n\\n// Sanity checking agggregate column name.\\nvalidators.enum:x:@.arguments/*/aggregate_column\\n   .:media.id\\n   .:media.post_id\\n   .:media.file_path\\n   .:media.file_type\\n   .:media.created_at\\n   .:post_id.title\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:enterprise,root\\n\\n// Opening up our database connection.\\ndata.connect:[generic|cms]\\n   database-type:sqlite\\n\\n   // Making sure we're using the correct group column\\n   set-name:x:@data.connect/*/data.read/*/group/*/group_column\\n      get-value:x:@.arguments/*/group_column\\n\\n   // Making sure we return group column as a part of the result\\n   set-name:x:+/*/*\\n      get-value:x:@.arguments/*/group_column\\n   insert-before:x:@data.connect/*/data.read/*/columns/0\\n      .\\n         group_column\\n\\n   // Changing name of aggregate column returned to caller.\\n   set-value:x:@data.connect/*/data.read/*/columns/1/*/as\\n      get-value:x:@.arguments/*/aggregate_function\\n\\n   // Removing group column to simplify adding other arguments\\n   remove-nodes:x:@.arguments/*/group_column\\n\\n   // Adding paging arguments\\n   add:x:@data.connect/*/data.read\\n      get-nodes:x:@.arguments/*/limit\\n      get-nodes:x:@.arguments/*/offset\\n   remove-nodes:x:@.arguments/*/limit\\n   remove-nodes:x:@.arguments/*/offset\\n\\n   // Parametrising our read invocation with ordering arguments if specified.\\n   add:x:./*/data.read\\n      get-nodes:x:@.arguments/*/order\\n      get-nodes:x:@.arguments/*/direction\\n   remove-nodes:x:@.arguments/*/order\\n   remove-nodes:x:@.arguments/*/direction\\n\\n   // Making sure we're using correct aggregate function.\\n   set-name:x:./*/data.read/*/columns/*/aggregate_functor\\n      strings.concat\\n         get-value:x:@.arguments/*/aggregate_function\\n         .:(\\n         get-value:x:@.arguments/*/aggregate_column\\n         .:)\\n\\n   // Removing aggregate arguments to simplify adding other arguments.\\n   remove-nodes:x:@.arguments/*/[0,2]\\n   add:x:+/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:sqlite\\n      table:media\\n         join:posts\\n            as:post_id\\n            type:left\\n            on\\n               and\\n                  media.post_id:post_id.id\\n      columns\\n         aggregate_functor\\n            as:result\\n      where\\n         and\\n      group\\n         group_column\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Distinct Keyword Search from media table in cms database.\\n\\nThis endpoint will return only records containing one or more of the keywords from the specified [query],\\nwith rows containing the most distinct matched keywords appearing first."},{"role":"assistant","content":".arguments\\n\\n   // Mandatory query for records to search for\\n   query:string\\n\\n   // Optional number of records to return, defaults to 10 if not specified. Pass in -1 to return all records\\n   limit:long\\n\\n   // Optional offset into the dataset of where to start retrieving records\\n   offset:long\\n\\n// Type of endpoint\\n.type:crud-search\\n\\n// Make sure the user has provided a query.\\nvalidators.mandatory:x:@.arguments/*/query\\n\\n// Apply defaults if not specified.\\nvalidators.default:x:@.arguments\\n   limit:long:10\\n\\n// Split the user's query into individual keywords, separated by spaces.\\n.words\\nadd:x:@.words\\n   strings.split:x:@.arguments/*/query\\n      .:\" \"\\n\\n// Enforce lower characters for each keyword, and guard against SQL injection.\\n.no:int:0\\nfor-each:x:@.words/*\\n   set-value:x:@.dp/#\\n      strings.to-lower:x:@.dp/#\\n\\n// Specify which columns to search against.\\n.columns\\n   .:file_path\\n   .:file_type\\n\\n// Connect to the specified database.\\ndata.connect:[generic|cms]\\n   database-type:sqlite\\n\\n   // Start building our SQL.\\n   .sql:select *, (\\n\\n   // 1) Dynamically create the full text by concatenating all columns we want to search.\\n   .fields\\n   for-each:x:@.columns/*\\n      strings.concat\\n         .:coalesce(\\n         get-value:x:@.dp/#\\n         .:\", '')\"\\n      unwrap:x:+/*/*\\n      add:x:@.fields\\n         .\\n            .:x:@strings.concat\\n   set-value:x:@.fields\\n      strings.join:x:@.fields/*\\n         .:\" || \"\\n   remove-nodes:x:@.fields/*\\n\\n   // 2) Keyword density calculation\\n   .no:int:0\\n   for-each:x:@.words/*\\n\\n      // Adding SQL parameter.\\n      set-name:x:+/+/*/*\\n         strings.concat\\n            .:@p\\n            get-value:x:@.no\\n      unwrap:x:+/*/*\\n      add:x:@data.connect/*/data.select\\n         .\\n            .:x:@.dp/#\\n\\n      // Modifying our SQL.\\n      if\\n         eq:x:@.no\\n            .:int:0\\n         .lambda\\n\\n            // First keyword => no leading plus\\n            set-value:x:@.sql\\n               strings.concat:x:@.sql\\n                  get-value:x:@.sql\\n                  .:\" (length(\"\\n                  get-value:x:@.fields\\n                  .:) - length(replace(lower(\\n                  get-value:x:@.fields\\n                  .:), @p\\n                  get-value:x:@.no\\n                  .:\", ''))) / length(@p\"\\n                  get-value:x:@.no\\n                  .:)\\n      else\\n         set-value:x:@.sql\\n            strings.concat:x:@.sql\\n               get-value:x:@.sql\\n               .:\" + (length(\"\\n               get-value:x:@.fields\\n               .:) - length(replace(lower(\\n               get-value:x:@.fields\\n               .:), @p\\n               get-value:x:@.no\\n               .:\", ''))) / length(@p\"\\n               get-value:x:@.no\\n               .:)\\n      math.increment:x:@.no\\n   set-value:x:@.sql\\n      strings.concat:x:@.sql\\n         get-value:x:@.sql\\n         .:) * 1.0 / length(\\n         get-value:x:@.fields\\n         .:) as keyword_density, (\\n\\n   // 3) Distinct keyword count => For each keyword, 1 if present, 0 if not.\\n   .no:int:0\\n   for-each:x:@.words/*\\n      if\\n         eq:x:@.no\\n            .:int:0\\n         .lambda\\n\\n            // First keyword => no leading plus\\n            set-value:x:@.sql\\n               strings.concat:x:@.sql\\n                  get-value:x:@.sql\\n                  .:\" CASE WHEN ((length(\"\\n                  get-value:x:@.fields\\n                  .:) - length(replace(lower(\\n                  get-value:x:@.fields\\n                  .:), @p\\n                  get-value:x:@.no\\n                  .:\", ''))) / length(@p\"\\n                  get-value:x:@.no\\n                  .:)) > 0 THEN 1 ELSE 0 END\\n      else\\n         set-value:x:@.sql\\n            strings.concat:x:@.sql\\n               get-value:x:@.sql\\n               .:\" + CASE WHEN ((length(\"\\n               get-value:x:@.fields\\n               .:) - length(replace(lower(\\n               get-value:x:@.fields\\n               .:), @p\\n               get-value:x:@.no\\n               .:\", ''))) / length(@p\"\\n               get-value:x:@.no\\n               .:)) > 0 THEN 1 ELSE 0 END\\n      math.increment:x:@.no\\n\\n   // Finalize \"keyword_count\".\\n   set-value:x:@.sql\\n      strings.concat:x:@.sql\\n         get-value:x:@.sql\\n         .:) as keyword_count\\n\\n   // 4) Finish SELECT + WHERE\\n   set-value:x:@.sql\\n      strings.concat:x:@.sql\\n         get-value:x:@.sql\\n         .:\" from \"\\n         .:media\\n         .:\" where keyword_count > 0\"\\n\\n   // 5) Order by distinct keyword_count (higher means more distinct keywords), then keyword_density.\\n   set-value:x:@.sql\\n      strings.concat:x:@.sql\\n         get-value:x:@.sql\\n         .:\" order by keyword_count desc, keyword_density desc limit \"\\n         get-value:x:@.arguments/*/limit\\n\\n   // (Optional) offset => pagination\\n   if\\n      exists:x:@.arguments/*/offset\\n      .lambda\\n         set-value:x:@.sql\\n            strings.concat:x:@.sql\\n               get-value:x:@.sql\\n               .:\" offset \"\\n               get-value:x:@.arguments/*/offset\\n\\n   // Execute the SQL\\n   data.select:x:@.sql\\n      database-type:sqlite\\n\\n   // Remove helper fields if you don't want them in your final JSON\\n   remove-nodes:x:@data.select/*/*/keyword_density\\n   remove-nodes:x:@data.select/*/*/keyword_count\\n\\n   // Return the final result set\\n   return-nodes:x:@data.select/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Read or list records from your media table in your cms database"},{"role":"assistant","content":".arguments\\n\\n   // Number of records to return, defaults to 25 if not specified. Pass in -1 to return all records.\\n\\n   // Offset into the dataset of where to start retrieving records\\n\\n   // Fully qualified name of column to order by, must be in TABLE_NAME.COLUMN_NAME format\\n\\n   // What direction to order, can be 'asc' or 'desc' implying ascending and descending\\n   media.id.eq:long\\n   media.post_id.eq:long\\n   media.file_path.like:string\\n   media.file_path.eq:string\\n   media.file_type.like:string\\n   media.file_type.eq:string\\n   media.created_at.eq:date\\n   post_id.title.eq:string\\n   post_id.title.like:string\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-read\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:enterprise,root\\n\\n// Opening up our database connection.\\ndata.connect:[generic|cms]\\n   database-type:sqlite\\n\\n   // Parametrising our read invocation with filtering arguments.\\n   add:x:./*/data.read/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:sqlite\\n      table:media\\n         join:posts\\n            as:post_id\\n            type:left\\n            on\\n               and\\n                  media.post_id:post_id.id\\n      columns\\n         media.id\\n         media.post_id\\n         media.file_path\\n         media.file_type\\n         media.created_at\\n         post_id.title\\n            as:post_id.title\\n      where\\n         and\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create one record in your media table in your cms database"},{"role":"assistant","content":".arguments\\n\\n   // post_id column value\\n   post_id:long\\n\\n   // file_path column value\\n   file_path:string\\n\\n   // file_type column value\\n   file_type:string\\n\\n   // created_at column value\\n   created_at:date\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-create\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:enterprise,root\\n.foreign-keys\\n   .\\n      column:post_id\\n      table:posts\\n      foreign_column:id\\n      foreign_name:title\\n      long:bool:true\\n\\n// Opening up database connection.\\ndata.connect:[generic|cms]\\n   database-type:sqlite\\n\\n   // Parametrising our create invocation.\\n   add:x:./*/data.create/*/values\\n      get-nodes:x:@.arguments/*\\n\\n   // Creating our record.\\n   data.create\\n      database-type:sqlite\\n      table:media\\n      return-id:bool:true\\n      values\\n\\n   // Returning the correct status code.\\n   response.status.set:201\\n\\n   // Publishing socket message.\\n   add:x:./*/sockets.signal/*/args\\n      get-nodes:x:@.arguments/*\\n   add:x:./*/sockets.signal\\n      get-nodes:x:@auth.ticket.verify\\n   set-name:x:./*/sockets.signal/*/auth.ticket.verify\\n      .:roles\\n   sockets.signal:cms.media.post\\n      args\\n\\n   // Returning result of above invocation to caller.\\n   unwrap:x:+/*\\n   return\\n      id:x:@data.create\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Update one record in your media table in your cms database"},{"role":"assistant","content":".arguments\\n\\n   // id column value being primary key of record to update, mandatory argument\\n   id:long\\n\\n   // post_id column's new value\\n   post_id:long\\n\\n   // file_path column's new value\\n   file_path:string\\n\\n   // file_type column's new value\\n   file_type:string\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-update\\n\\n// Sanity checking invocation, making sure primary key(s) are specified.\\nvalidators.mandatory:x:@.arguments/*/id\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:enterprise,root\\n.foreign-keys\\n   .\\n      column:post_id\\n      table:posts\\n      foreign_column:id\\n      foreign_name:title\\n      long:bool:true\\n\\n// Opening up our database connection.\\ndata.connect:[generic|cms]\\n   database-type:sqlite\\n\\n   // Parametrising our invocation.\\n   add:x:./*/data.update/*/values\\n      get-nodes:x:@.arguments/*/[1,1000]\\n   add:x:./*/data.update/*/where/*/and\\n      get-nodes:x:@.arguments/*/[0,1]\\n\\n   // Invoking our update slot.\\n   data.update\\n      database-type:sqlite\\n      table:media\\n      values\\n      where\\n         and\\n\\n   // Verifying record exists.\\n   if\\n      eq\\n         get-value:x:@data.update\\n         .:int:0\\n      .lambda\\n         response.status.set:404\\n         return\\n            result:Record not found\\n\\n   // Returning the correct status code.\\n   response.status.set:202\\n\\n   // Publishing socket message.\\n   add:x:./*/sockets.signal/*/args\\n      get-nodes:x:@.arguments/*\\n   add:x:./*/sockets.signal\\n      get-nodes:x:@auth.ticket.verify\\n   set-name:x:./*/sockets.signal/*/auth.ticket.verify\\n      .:roles\\n   sockets.signal:cms.media.put\\n      args\\n\\n   // Returning success to caller.\\n   unwrap:x:+/*\\n   return\\n      affected:x:@data.update\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Creates a MIME message from a structured lambda object,\\nand parses it back to lambda again."},{"role":"assistant","content":"mime.create:multipart/mixed\\n   entity:text/plain\\n      filename:/README.md\\n   entity:text/plain\\n      content:Bar\\nmime.parse:x:-\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example of creating a MIME HTTP POST request."},{"role":"assistant","content":"http.post:\"http://localhost:5000/magic/modules/foo/foo\"\\n   headers\\n      Content-Type:multipart/form-data\\n   payload\\n      entity:text/plain\\n         headers\\n            Content-Disposition:\"form-data; name=\\\"foo\\\"\"\\n         content:Foo bar\\n      entity:text/plain\\n         headers\\n            Content-Disposition:\"form-data; filename=\\\"README.md\\\"\"\\n         filename:/README.md\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Illustrates how to create a complex read invocation,\\nthat joins two different tables together, using lambda\\nand semantic SQL.\\n\\nNotice, requires you to have the Sakila database installed\\nfrom Oracle."},{"role":"assistant","content":"mysql.connect:sakila\\n   mysql.read\\n      columns\\n         film.title\\n         film.description\\n         actor.last_name\\n         actor.first_name\\n      table:film\\n         join:film_actor\\n            type:inner\\n            on\\n               and\\n                  film.film_id:film_actor.film_id\\n            join:actor\\n               type:inner\\n               on\\n                  and\\n                     film_actor.actor_id:actor.actor_id\\n      where\\n         and\\n            actor.first_name:NICK\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Opens a database connection and executes some arbitrary SQL,\\nreturning results as a record set."},{"role":"assistant","content":"mysql.connect:magic\\n   mysql.select:select * from roles\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example of endpoint taking two arguments, concatenating them, and returning the result using [return]."},{"role":"assistant","content":".arguments\\n   arg1:string\\n   arg2:string\\nstrings.concat\\n   get-value:x:@.arguments/*/arg1\\n   get-value:x:@.arguments/*/arg2\\n\\n// MUST call [unwrap] otherwise we're simply returning the expression.\\nunwrap:x:+/*\\nreturn\\n   result:x:@strings.concat\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Example of endpoint taking two arguments, concatenating them, and returning the result using yield."},{"role":"assistant","content":".arguments\\n   arg1:string\\n   arg2:string\\nstrings.concat\\n   get-value:x:@.arguments/*/arg1\\n   get-value:x:@.arguments/*/arg2\\n\\n// No need to call [unwrap] since [yield] will do it automatically.\\nunwrap:x:+/*\\nyield\\n   result:x:@strings.concat\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Creates a scatter chart."},{"role":"assistant","content":"image.chart:scatter\\n   filename:/scatter.png\\n   width:400\\n   height:300\\n   data-x\\n      .:1\\n      .:2\\n      .:3\\n      .:4\\n      .:5\\n   data-y\\n      .:1\\n      .:4\\n      .:9\\n      .:16\\n      .:25\\n   line-width:5\\n   marker-size:15\\n   color:#55aa5555\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Changes the name of the specified node(s) to whatever the results of its\\nparameter is."},{"role":"assistant","content":".destination\\nset-name:x:@.destination\\n   .:foo\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Changes the value of the specified node(s) to whatever the results of its\\nparameter is."},{"role":"assistant","content":".destination\\nset-value:x:@.destination\\n   .:value\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Creates a new Hyperlambda slot."},{"role":"assistant","content":"slots.create:meaning-of-life\\n   return-value:int:57\\n\\n// Invoking slot we created above.\\nsignal:meaning-of-life\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Creates a new stacked chart"},{"role":"assistant","content":"image.chart:stacked\\n   filename:/chart.png\\n   width:600\\n   height:300\\n   bars\\n      Spring\\n         .:int:2\\n         .:int:5\\n         .:int:10\\n      Summer\\n         .:int:4\\n         .:int:7\\n         .:int:10\\n      Autumn\\n         .:int:2\\n         .:int:5\\n         .:int:4\\n   ticks\\n      .:Spring\\n      .:Summer\\n      .:Autumn\\n   legend\\n      .:Phones\\n      .:Computers\\n      .:Tablets\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Switch case comparison, evaluating lambda object matching expression."},{"role":"assistant","content":".source:foo\\n.result\\nswitch:x:@.source\\n   case:foo\\n\\n      // Lambda object to evaluate if expression's value equals 'foo'.\\n      set-value:x:@.result\\n         .:Is foo\\n   case:bar\\n\\n      // Lambda object to evaluate if expression's value equals 'bar'.\\n      set-value:x:@.result\\n         .:Is bar\\n   default\\n\\n      /*\\n       * Lambda object to evaluate if expression is not matched to any\\n       * of the above values.\\n       */\\n      set-value:x:@.result\\n         .:None of the above\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Compiles a C# file and creates a library from the compiled result,\\nfor then to dynamically load it as a plugin and invoke a slot\\ncalled [foo] expected to exist within the C# code.\\n\\nNotice, the code assumes there's a C# file called \"foo.cs\"\\nin your '/etc/' folder. Create this file with Hyper IDE\\nusing the \"slot\" template to test the code."},{"role":"assistant","content":"io.file.load:/etc/foo.cs\\nsystem.compile\\n   references\\n      .:netstandard\\n      .:System.Runtime\\n      .:System.ComponentModel\\n      .:System.Private.CoreLib\\n      .:magic.node\\n      .:magic.node.extensions\\n      .:magic.signals.contracts\\n   code:x:@io.file.load\\n   assembly-name:foo.dll\\n\\n// Loading assembly now that we've created it and saved it.\\nsystem.plugin.load:x:@system.compile\\n\\n// Invoking dynamically created C# slot.\\n.name:John Doe\\nfoo:x:@.name\\n\\n// Unloading plugin.\\nsystem.plugin.unload:foo.dll\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Compiles a snippet of C# code down to a library,\\nfor then to dynamically load it as a plugin.\\n\\nThis particular code creates a slot, but you can create any\\ncode you wish, and it doesn't have to be Hyperlambda related."},{"role":"assistant","content":"system.compile\\n   references\\n      .:netstandard\\n      .:System.Runtime\\n      .:System.Private.CoreLib\\n      .:magic.node\\n      .:magic.signals.contracts\\n   code:\"\\n\\n// Example C# code creating a Hyperlambda slot.\\nusing System;\\nusing magic.node;\\nusing magic.signals.contracts;\\n\\n// Our slot class.\\n[Slot(Name = \\\"bar\\\")]\\npublic class Bar : ISlot\\n{\\n   public void Signal(ISignaler signaler, Node input)\\n   {\\n      input.Value = \\\"Hello from C#\\\";\\n   }\\n}\"\\n   assembly-name:bar.dll\\n\\n// Loading assembly now that we've created it.\\nsystem.plugin.execute:x:@system.compile\\n\\n   // Invoking dynamically created C# slot.\\n   bar\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Creates a try/catch/finally block"},{"role":"assistant","content":"try\\n\\n   // Perform your unsafe operation here.\\n   throw:Some error is thrown here\\n.catch\\n\\n   // If an exception is triggered, this lambda will be evaluated.\\n   log.info:x:@.arguments/*/message\\n.finally\\n\\n   // If an exception is triggered, this lambda will be evaluated.\\n   log.info:Try finished evaluating\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Evaluates specified [.lambda] for as long as condition evaluates to true."},{"role":"assistant","content":".no:int:0\\nwhile\\n   lt\\n      get-value:x:@.no\\n      .:int:20\\n   .lambda\\n\\n      // Your lambda goes here.\\n      log.info:Howdy from while\\n\\n      // Incrementing counter.\\n      math.increment:x:@.no\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"This snippet defines a node with a string value (default type)."},{"role":"assistant","content":".message:Hello, World!\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"This snippet defines a node with a single-precision float value."},{"role":"assistant","content":".temperature:float:36.6\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"This snippet defines a node with a boolean value."},{"role":"assistant","content":".isActive:bool:true\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"This snippet defines a node with a date/time value (UTC DateTime)."},{"role":"assistant","content":".timestamp:date:\"2025-03-17T18:00:00.000Z\"\\n\\n// Notice, dates must always be wrapped in quotes since they contain : characters\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"This snippet defines a node with a GUID value."},{"role":"assistant","content":".recordId:guid:123e4567-e89b-12d3-a456-426614174000\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"This snippet defines a node with a single character value."},{"role":"assistant","content":".initial:char:Z\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"This snippet defines a node with a byte (8-bit unsigned int) value."},{"role":"assistant","content":".flags:byte:255\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"This snippet defines a node with an sbyte (8-bit signed int) value."},{"role":"assistant","content":".offset:sbyte:-42\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"This snippet uses the 'x' type to store a Hyperlambda expression as a value, in addition to extrapolating the expression containing an inner expression."},{"role":"assistant","content":".target\\n   item1:foo\\n.ref:item1\\nget-value:x:@.target/*/{@.ref}\\n\\n// The Inner expression will be evaluated, and the value of the single node it points to will be used as a part of the outer expression.\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"This snippet uses the '*' iterator to retrieve all children of a node, in addition to the # reference iterator."},{"role":"assistant","content":".data\\n   item1:one\\n   item2:two\\nfor-each:x:@.data/*\\n   set-value:x:@.dp/#\\n      :processed\\n\\n// The expression @.data/* selects both item1 and item2 nodes, and the for-each loop sets each of their values to \"processed\" since it's using the [.dp] node by reference which is injected by the [for-each] slot.\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"This snippet uses the '-' iterator to get the previous sibling of a given node."},{"role":"assistant","content":".sequence\\n   first:A\\n   second:B\\n   third:C\\nget-value:x:@.sequence/*/second/-\\n\\n// The expression finds \"second\" under .sequence, then '-' returns its previous sibling (\"first\"), so the get-value yields \"A\".\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"This snippet uses the '+' iterator to get the next sibling of a given node."},{"role":"assistant","content":".sequence\\n   alpha:X\\n   beta:Y\\n   gamma:Z\\nget-value:x:@.sequence/*/beta/+\\n\\n// The expression finds \"beta\" under .sequence, then '+' returns its next sibling (\"gamma\"), so the get-value yields \"Z\".\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"This snippet uses the '.' iterator to retrieve the parent of a node."},{"role":"assistant","content":".parent\\n   child:value\\nget-name:x:@.parent/*/child/.\\n\\n// The expression @.parent/*/child finds the 'child' node, then '.' gets its parent node. get-name returns \".parent\".\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"This snippet uses the '^xxx' iterator to find an ancestor by name."},{"role":"assistant","content":".grandparent\\n   parent\\n      target:found me\\nget-name:x:@.grandparent/*/*/target/^.grandparent\\n\\n// Starting from 'target', '^grandparent' climbs up to the nearest ancestor named \"grandparent\". get-name then returns \".grandparent\".\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"This snippet uses the '..' iterator to navigate to the root node."},{"role":"assistant","content":".top1\\n   node:hello\\n.top2:world\\nget-value:x:@.top1/*/node/../*/.top2\\n\\n// The expression @.top1/*/node selects the 'node' under .top1, then '..' goes to the root. '*/top2' then finds the sibling .top2 at root level. get-value yields \"world\".\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"This snippet uses the '**' iterator to retrieve all descendant nodes."},{"role":"assistant","content":".tree\\n   branch1\\n      leaf1:A\\n   branch2\\n      leaf2:B\\nfor-each:x:@.tree/**\\n   set-value:x:@.dp/#\\n      :visited\\n\\n// The expression @.tree/** selects all descendants of .tree (branch1, leaf1, branch2, leaf2). The loop marks each found node by setting its value to \"visited\".\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"This snippet uses the '!xxx' iterator to get all descendants except those of a certain name."},{"role":"assistant","content":".root\\n   include1:A\\n   remove:B\\n   include2\\n      nested:C\\n      remove:D\\nfor-each:x:@.root/!remove\\n   set-value:x:@.dp/#\\n      :kept\\n\\n// The expression @.root/!remove traverses all descendants of .root but skips any node named \"remove\" (and its subtree). The loop sets the remaining nodes' values to \"kept\".\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"This snippet defines a node with an unsigned short (UInt16) value."},{"role":"assistant","content":".maxCount:ushort:123\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"This snippet uses the '{x}' iterator to extrapolate a sub-expression within an expression."},{"role":"assistant","content":".key:targetName\\n.container\\n   targetName:Hello\\n   other:World\\nget-value:x:@.container/*/{@.key}\\n\\n// The inner expression {@.key} evaluates to [.key]'s value which is 'targetName', so the outer expression becomes @.container/*/targetName, retrieving the \"Hello\" value.\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"This snippet uses the '=xxx' iterator to filter nodes by their value."},{"role":"assistant","content":".list\\n   item1:match\\n   item2:no\\n   item3:match\\nfor-each:x:@.list/*/=match\\n   set-value:x:@.dp/#\\n      :found\\n\\n// The expression @.list/*/=match finds all children of .list whose value equals \"match\" (item1 and item3). The loop sets those nodes' values to \"found\".\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"This snippet uses the '[n,n]' iterator to select a range of child nodes."},{"role":"assistant","content":".items\\n   item0:A\\n   item1:B\\n   item2:C\\nfor-each:x:@.items/*/[0,2]\\n   set-value:x:@.dp/#\\n      :selected\\n\\n// The expression @.items/*/[0,2] selects children from index 0 up to 2 (exclusive) – i.e., the first and second children (item0 and item1). The loop marks them as \"selected\".\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"This snippet uses a numeric iterator to select the nth child of a node."},{"role":"assistant","content":".numbers\\n   zero:0th\\n   one:1st\\n   two:2nd\\nget-value:x:@.numbers/1\\n\\n// The numeric iterator '1' selects the second child of .numbers (index 1, node \"one\"), so get-value returns \"1st\".\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"This snippet uses the '[x|y]' iterator to filter by multiple node names."},{"role":"assistant","content":".set\\n   apple:red\\n   banana:yellow\\n   cherry:red\\n   date:brown\\nfor-each:x:@.set/*/[apple|cherry]\\n   set-value:x:@.dp/#\\n      :picked\\n\\n// The expression @.set/*/[apple|cherry] selects all children of .set whose name is \"apple\" or \"cherry\". The loop sets those nodes' values to \"picked\".\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"This snippet defines a node with an unsigned int (UInt32) value."},{"role":"assistant","content":".uAmount:uint:1000\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"This snippet defines a node with a long (Int64) integer value."},{"role":"assistant","content":".bigNumber:long:9007199254740992\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"This snippet defines a node with an unsigned long (UInt64) value."},{"role":"assistant","content":".veryBigNumber:ulong:1234567890123456789\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"This snippet defines a node with a decimal value (high precision)."},{"role":"assistant","content":".price:decimal:123.45\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"This snippet defines a node with a double (floating-point) value."},{"role":"assistant","content":".ratio:double:0.000123\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Creates the magic database, applies all migration SQL scripts, and\\ncreates a scheduled task that creates a backup of the database once every day at 1AM UTC time."},{"role":"assistant","content":"\\n// Figuring out what our default database type is.\\n.db-type\\nset-value:x:@.db-type\\n   config.get:\"magic:databases:default\"\\n\\n/*\\n * This one is true if database was corrupt, at which point we do not create a backup of\\n * database further down in this file by executing backup task immediately.\\n */\\n.corrupt:bool:false\\n\\n// Checking if magic db exists, and if not, creating it.\\n.slot\\nset-value:x:@.slot\\n   strings.concat\\n      .:magic.db.\\n      get-value:x:@.db-type\\n      .:.databases\\nsignal:x:@.slot\\nif\\n   not\\n      exists:x:@signal/*/*/=magic\\n   .lambda\\n\\n      /*\\n       * Database does not exist.\\n       * \\n       * Executing SQL script that creates database, but first we must dynamically\\n       * determine which script to execute, which differs according to what database\\n       * type Magic is configured to use as default database type.\\n       */\\n      strings.concat\\n         .:/misc/\\n         get-value:x:@.db-type\\n         .:/magic.sql\\n\\n      // Loading create database SQL script file.\\n      io.file.load:x:@strings.concat\\n\\n      /*\\n       * Notice, for MS SQL we need to explicitly invoke [mssql.execute-batch] to\\n       * accommodate for \"go\" statements.\\n       * \\n       * For PG SQL we'll need to first create the database in a separate [pgsql.connect] invocation,\\n       * then run the execute script with the created database as our selected database.\\n       */\\n      console.log:Trying to create Magic database\\n      switch:x:@.db-type\\n\\n         // Special case for MS SQL to use [mssql.execute-batch].\\n         case:mssql\\n            mssql.connect\\n               mssql.execute-batch:x:@io.file.load\\n\\n         // Special case for PG SQL to create database in a different connection.\\n         case:pgsql\\n            pgsql.connect:[generic|postgres]\\n               pgsql.execute:create database magic\\n            pgsql.connect:[generic|magic]\\n               pgsql.execute:x:@io.file.load\\n\\n         // MySQL version, simply doing everything as normal and plain as possible.\\n         case:mysql\\n\\n            // Executing create database SQL script without any special cases.\\n            mysql.connect\\n               mysql.execute:x:@io.file.load\\n\\n         // SQLite version.\\n         case:sqlite\\n\\n            // Executing create database SQL script without any special cases.\\n            sqlite.connect:[generic|magic]\\n               sqlite.execute:x:@io.file.load\\n\\n      // Magic database successfully created\\n      console.log:Magic databases was successfully created\\nelse-if\\n   eq:x:@.db-type\\n      .:sqlite\\n   .lambda\\n\\n      /*\\n       * Default database is SQLite.\\n       * \\n       * Verifying magic database is not corrupted, and if database is corrupt,\\n       * we revert to backup version.\\n       */\\n      try\\n\\n         /*\\n          * The next two lines of Hyperlambda will throw an exception\\n          * if the magic database is corrupted.\\n          */\\n         data.connect:[generic|magic]\\n            data.select:select count(*) from log_entries\\n\\n         // Logging to console.\\n         console.log:Successfully connected to magic database\\n      .catch\\n\\n         // Logging to console.\\n         console.log:Magic database is corrupted\\n\\n         /*\\n          * Could not connect to database, so we revert back to backup,\\n          * but only if backup exists.\\n          */\\n         if\\n            io.file.exists:/data/magic.backup\\n            .lambda\\n\\n               // Flushing cached connections.\\n               sqlite.connections.flush\\n\\n               // Deleting magic.db file.\\n               io.file.delete:/data/magic.db\\n\\n               // Copying magic.backup to magic.db.\\n               io.file.copy:/data/magic.backup\\n                  .:/data/magic.db\\n\\n               // Logging to console.\\n               console.log:Reverted to backup of magic database\\n\\n               // Making sure code further down understands we had to revert to backup.\\n               set-value:x:@.corrupt\\n                  .:bool:true\\n\\n/*\\n * Listing all SQL migration scripts, and executing these sequentially,\\n * making sure we're using the correct folder, according to what database\\n * type Magic has been configured with.\\n */\\nstrings.concat\\n   .:/misc/\\n   get-value:x:@.db-type\\n   .:/migrations/\\nio.file.list:x:@strings.concat\\n\\n// Connecting to Magic database.\\ndata.connect:[generic|magic]\\n\\n   // Iterating through each file in folder.\\n   for-each:x:@io.file.list/*\\n\\n      // Verifying file ends with \".sql\".\\n      if\\n         strings.ends-with:x:@.dp/#\\n            .:.sql\\n         .lambda\\n\\n            // This is an SQL file, hence loading it and executing it.\\n            io.file.load:x:@.dp/#\\n\\n            /*\\n             * Notice, to avoid having ONE failing migration script\\n             * aborting the entire migration job, we need to do a try/catch/ignore\\n             * here. This might occur if for instance some of the migration scripts\\n             * has executed successfully previously.\\n             */\\n            try\\n\\n               // Ensuring we're doing the \"batch execute\" thing in case we're in MS SQL land.\\n               if\\n                  eq\\n                     get-value:x:@.db-type\\n                     .:mssql\\n                  .lambda\\n                     set-name:x:@if/./*/data.execute\\n                        .:mssql.execute-batch\\n\\n               // Executing migration script and logging result.\\n               data.execute:x:@io.file.load\\n               strings.concat\\n                  .:\"Script '\"\\n                  get-value:x:@.dp/#\\n                  .:\"' succeeded\"\\n               console.log:x:@strings.concat\\n            .catch\\n\\n               // We might end up here if migration script has been previously executed ...\\n               strings.concat\\n                  .:\"Script '\"\\n                  get-value:x:@.dp/#\\n                  .:\"' failed\"\\n               console.log:x:@strings.concat\\n               console.log:x:@.arguments/*/message\\n\\n// Applying all common Hyperlambda files.\\nio.file.list-recursively:/misc/common-startup-files/\\nfor-each:x:@io.file.list-recursively/*\\n\\n   // Verifying file is a Hyperlambda file.\\n   if\\n      strings.ends-with:x:@.dp/#\\n         .:.hl\\n      .lambda\\n\\n         // Executes file.\\n         io.file.execute:x:@.dp/#\\n         strings.concat\\n            .:\"Hyperlambda file '\"\\n            get-value:x:@.dp/#\\n            .:\"' successfully executed\"\\n         console.log:x:@strings.concat\\n\\n/*\\n * Creates a scheduled task that periodically creates a backup of SQLite database,\\n * but only if default database is SQLite.\\n */\\nif\\n   eq\\n      config.get:\"magic:databases:default\"\\n      .:sqlite\\n   .lambda\\n\\n      // Deleting previously created scheduled task with same name.\\n      tasks.list:sqlite.create-backup\\n      if\\n         exists:x:@tasks.list/*\\n         .lambda\\n\\n            // Deleting previously created task.\\n            tasks.delete:sqlite.create-backup\\n\\n      // Creating a new task that creates a backup of database, and scheduling it to execute 1AM UTC every day.\\n      tasks.create:sqlite.create-backup\\n         description:Creates a backup of your magic database 1AM UTC time every day.\\n         repeats:**.**.01.00.00\\n         .lambda\\n\\n            // Connecting to database to create our backup.\\n            data.connect:[generic|magic]\\n\\n               // Checking if old backup exists.\\n               if\\n                  io.file.exists:/data/magic.backup\\n                  .lambda\\n\\n                     // Deleting old backup.\\n                     io.file.delete:/data/magic.backup\\n\\n               // This ensures transaction is executed, since transactions are lazy in Magic.\\n               sqlite.backup:magic.backup\\n\\n               /*\\n                * Flushing connections will remove cached connection to avoid connection\\n                * issues the next time we create a backup.\\n                */\\n               sqlite.connections.flush\\n\\n               // Logging.\\n               log.info:Created backup of magic database\\n\\n      // Logging success to console.\\n      console.log:Successfully created database backup task that creates a backup of magic.db 1AM UTC every day\\n\\n      // Invoking task to make sure we've got one backup immediately.\\n      if\\n         eq:x:@.corrupt\\n            .:bool:false\\n         .lambda\\n\\n            // Since database was not corrupt we create an immediate backup now.\\n            tasks.execute:sqlite.create-backup\\n\\n            // Logging to console.\\n            console.log:Executed task that creates backup of magic database\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Pings backend, allowing the client side to verify the\\nbackend is up running."},{"role":"assistant","content":".type:public\\nreturn-nodes\\n   result:success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns the version of the backend to the caller."},{"role":"assistant","content":".type:internal\\n\\n// Ensures user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Retrieves backend version, and returns to client.\\neval:x:+\\nreturn-nodes\\n   version\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns a Magic CAPTCHA challenge to caller according to arguments specified that can be used to\\nsolve a Proof of Work CAPTCHA puzzle."},{"role":"assistant","content":".arguments\\n.type:public\\n\\n// Generating cryptographically secure random text.\\ncrypto.random\\nstrings.concat\\n   .:c_\\n   get-value:x:@crypto.random\\ncache.set:x:@strings.concat\\n   expiration:long:30\\n   value:valid\\n\\n// Generating gibberish text.\\nunwrap:x:+/*\\nreturn\\n   result:x:@strings.concat\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns Cryptographically Secure random text (gibberish) to caller according to arguments specified."},{"role":"assistant","content":".arguments\\n   min:long\\n   max:long\\n.type:public\\n\\n// Generating gibberish text.\\nadd:x:./*/crypto.random\\n   get-nodes:x:@.arguments/*\\ncrypto.random\\n\\n// Generating gibberish text.\\nunwrap:x:+/*\\nreturn\\n   result:x:@crypto.random\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns the Magic CAPTCHA JavaScript library to caller."},{"role":"assistant","content":".arguments\\n   v:string\\n.type:public\\n\\n// Getting server auth secret.\\nconfig.get:\"magic:auth:secret\"\\n\\n// Double hashing auth secret using SHA256 to avoid predictable hash values.\\ncrypto.hash.sha256:x:@config.get\\ncrypto.hash.sha256:x:-\\n\\n// Loading JavaScript file.\\n.file\\nif\\n   io.file.exists:/system/misc/magic-captcha-challenge.min.js\\n   .lambda\\n\\n      // We have a minified file.\\n      set-value:x:@.file\\n         load-file:/system/misc/magic-captcha-challenge.min.js\\nelse\\n\\n   // We don't have a minified file.\\n   set-value:x:@.file\\n      load-file:/system/misc/magic-captcha-challenge.js\\n\\n/*\\n * Dynamically substituting public key in file with public key that was generated\\n * specifically for current server.\\n */\\nset-value:x:@.file\\n   strings.replace:x:@.file\\n      .:[[public-key]]\\n      get-value:x:@crypto.hash.sha256\\n\\n// Figuring out API URL.\\n.scheme\\nrequest.host\\nif\\n   strings.contains:x:@request.host\\n      .:localhost\\n   .lambda\\n      set-value:x:@.scheme\\n         .:http\\nelse\\n   set-value:x:@.scheme\\n      .:https\\n.url\\nset-value:x:@.url\\n   strings.concat\\n      get-value:x:@.scheme\\n      .:\"://\"\\n      request.host\\nset-value:x:@.file\\n   strings.replace:x:@.file\\n      .:[[url]]\\n      get-value:x:@.url\\n\\n// Applying correct HTTP headers.\\nresponse.headers.set\\n   Content-Type:text/javascript\\n\\n// Returning result to caller.\\nreturn:x:@.file\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Verifies the specified [token] as a valid CAPTCHA token."},{"role":"assistant","content":".arguments\\n   token:string\\n.type:public\\n\\n// Invoking method responsible for verifying CAPTCHA token, which will throw if not valid.\\nexecute:magic.auth.captcha-verify\\n   token:x:@.arguments/*/token\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns the Magic CAPTCHA JavaScript library to caller."},{"role":"assistant","content":".arguments\\n   v:string\\nadd:x:./*/execute-file\\n   get-nodes:x:@.arguments/*\\nexecute-file:/system/misc/magic-captcha.js.get.hl\\nreturn:x:-\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns the Magic CAPTCHA JavaScript library to caller."},{"role":"assistant","content":".arguments\\n   v:string\\n.type:public\\n\\n// Getting server auth secret.\\nconfig.get:\"magic:auth:secret\"\\n\\n// Double hashing auth secret using SHA256 to avoid predictable hash values.\\ncrypto.hash.sha256:x:@config.get\\ncrypto.hash.sha256:x:-\\n\\n// Loading JavaScript file.\\n.file\\nif\\n   io.file.exists:/system/misc/magic-captcha.min.js\\n   .lambda\\n\\n      // We have a minified file.\\n      set-value:x:@.file\\n         load-file:/system/misc/magic-captcha.min.js\\nelse\\n\\n   // We don't have a minified file.\\n   set-value:x:@.file\\n      load-file:/system/misc/magic-captcha.js\\n\\n/*\\n * Dynamically substituting public key in file with public key that was generated\\n * specifically for current server.\\n */\\nstrings.replace:x:@.file\\n   .:[[public-key]]\\n   get-value:x:@crypto.hash.sha256\\n\\n// Applying correct HTTP headers.\\nresponse.headers.set\\n   Content-Type:text/javascript\\n\\n// Returning result to caller.\\nreturn:x:@strings.replace\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"List all functions\\n\\nThis function lists all functions for the specified [type]. Notice, [type] is mandatory and should always be 'YOUR_TYPE_NAME_HERE'."},{"role":"assistant","content":".arguments\\n\\n   // Mandatory argument and the type name for which to return functions for.\\n   _type:string\\n.type:public\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/_type\\n\\n// Opening up a database connection to retrieve all FUNCTION_INVOCATIONS we can find in type.\\ndata.connect:[generic|magic]\\n\\n   // Retrieving all training snippets having a meta value starting with \"FUNCTION_INVOCATION ==> \"\\n   data.select:\"select prompt from ml_training_snippets where type = @type and meta like '%FUNCTION_INVOCATION ==> %'\"\\n      @type:x:@.arguments/*/_type\\n\\n   // Iterating through result from above invocation.\\n   for-each:x:@data.select/*\\n\\n      // Adding prompt to [return] below.\\n      unwrap:x:+/*/*\\n      add:x:@data.connect/*/yield/*/rag_functions\\n         .\\n            .:x:@.dp/#/*/prompt\\n\\n   // Retrieving system message functions.\\n   data.read\\n      table:ml_types\\n      columns\\n         system_message\\n      where\\n         and\\n            type.eq:x:@.arguments/*/_type\\n   strings.split:x:@data.read/*/*/system_message\\n      .:\"# \"\\n   for-each:x:@strings.split/*\\n      if\\n         and\\n            strings.contains:x:@.dp/#\\n               .:FUNCTION_INVOCATION[/\\n            not\\n               strings.contains:x:@.dp/#\\n                  .:\"FUNCTION_INVOCATION[/FOLDER/FILENAME.hl]:\"\\n            not\\n               strings.contains:x:@.dp/#\\n                  .:\"FUNCTION_INVOCATION[/system/misc/workflows/list-functions.hl]:\"\\n         .lambda\\n            strings.split:x:@.dp/#\\n               .:\"\\n\"\\n            strings.trim:x:@strings.split/0\\n               .:@\"# \\n\"\\n            unwrap:x:+/*/*\\n            add:x:@data.connect/*/yield/*/system_functions\\n               .\\n                  .:x:@strings.trim\\n\\n   // Returning result to caller.\\n   yield\\n      rag_functions\\n      system_functions\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Sends an email\\n\\nThis function will send an email. [reply-to] and [reply-to-email] is the name and email address of the sender. Always display the email to the user before sending it, and have the user confirm that you should send it."},{"role":"assistant","content":".arguments\\n\\n   // Mandatory argument being the name of person to send the email to.\\n   name:string\\n\\n   // Mandatory argument being the email address to send the email to.\\n   email:string\\n\\n   // Mandatory argument being reply to name if the recipient of the email choses to reply.\\n   reply-to:string\\n\\n   // Mandatory argument being email address to reply to if the recipient of the email choses to reply.\\n   reply-to-email:string\\n\\n   // Mandatory argument being the subject line of the email to send.\\n   subject:string\\n\\n   // Mandatory argument being the body of the email. This can be Markdown at which point it will be automatically transformed to HTML before the email is sent.\\n   body:string\\n.type:public\\n\\n// HTML encodes the specified [html] and returns to caller.\\nexecute:magic.workflows.actions.execute\\n   name:html-encode-body\\n   filename:/misc/workflows/actions/misc/html-encode.hl\\n   arguments\\n      html:x:@.arguments/*/body\\n\\n// HTML encodes the specified [html] and returns to caller.\\nexecute:magic.workflows.actions.execute\\n   name:html-encode-subject\\n   filename:/misc/workflows/actions/misc/html-encode.hl\\n   arguments\\n      html:x:@.arguments/*/subject\\n\\n// Transforms the specified [markdown] to HTML and returns to caller.\\nexecute:magic.workflows.actions.execute\\n   name:markdown2html\\n   filename:/misc/workflows/actions/misc/markdown2html.hl\\n   arguments\\n      markdown:x:--/execute/=html-encode-body/*/content\\n\\n/*\\n * Returns the specified [key] configuration setting.\\n * \\n * Notice, to traverse into for instance magic.foo.bar, you'll have to colon separate\\n * your path as follows \"magic:foo:bar\".\\n */\\nexecute:magic.workflows.actions.execute\\n   name:config-name\\n   filename:/misc/workflows/actions/misc/config.hl\\n   arguments\\n      key:\"magic:smtp:from:name\"\\n\\n/*\\n * Returns the specified [key] configuration setting.\\n * \\n * Notice, to traverse into for instance magic.foo.bar, you'll have to colon separate\\n * your path as follows \"magic:foo:bar\".\\n */\\nexecute:magic.workflows.actions.execute\\n   name:config-email\\n   filename:/misc/workflows/actions/misc/config.hl\\n   arguments\\n      key:\"magic:smtp:from:address\"\\n\\n/*\\n * Sends an email to the specified [name]/[email] recipient, with the specified [subject] and [body].\\n * \\n * Optionally supply [from] and [from-email] as name/email sender, and/or [reply-to] and [reply-to-email]\\n * as the email to reply to. If you don't supply [from] or [from-email] then this action will use the\\n * default sender settings from your configuration.\\n */\\nexecute:magic.workflows.actions.execute\\n   name:email\\n   filename:/misc/workflows/actions/misc/email.hl\\n   arguments\\n      reply-to:x:@.arguments/*/reply-to\\n      subject:x:--/execute/=html-encode-subject/*/content\\n      body:x:--/execute/=markdown2html/*/html\\n      html:bool:true\\n      name:x:@.arguments/*/name\\n      email:x:@.arguments/*/email\\n      reply-to-email:x:@.arguments/*/reply-to-email\\nreturn\\n   result:success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Sends an email to owner\\n\\nThis function will send the owner of the cloudlet an email, with the specified [reply-to], [reply-to-email], [subject], and [body]."},{"role":"assistant","content":".arguments\\n\\n   // Mandatory argument being the reply to name of the person sending the email.\\n   reply-to:string\\n\\n   // Mandatory argument being the email address of the person sending the email.\\n   reply-to-email:string\\n\\n   // Mandatory argument being the subject line of the email.\\n   subject:string\\n\\n   // Mandatory argument being the body of the email to send. This argument can be Markdown at which point it will be automatically transformed into HTML.\\n   body:string\\n.type:public\\n\\n// HTML encodes the specified [html] and returns to caller.\\nexecute:magic.workflows.actions.execute\\n   name:html-encode-body\\n   filename:/misc/workflows/actions/misc/html-encode.hl\\n   arguments\\n      html:x:@.arguments/*/body\\n\\n// HTML encodes the specified [html] and returns to caller.\\nexecute:magic.workflows.actions.execute\\n   name:html-encode-subject\\n   filename:/misc/workflows/actions/misc/html-encode.hl\\n   arguments\\n      html:x:@.arguments/*/subject\\n\\n// Transforms the specified [markdown] to HTML and returns to caller.\\nexecute:magic.workflows.actions.execute\\n   name:markdown2html\\n   filename:/misc/workflows/actions/misc/markdown2html.hl\\n   arguments\\n      markdown:x:--/execute/=html-encode-body/*/content\\n\\n/*\\n * Returns the specified [key] configuration setting.\\n * \\n * Notice, to traverse into for instance magic.foo.bar, you'll have to colon separate\\n * your path as follows \"magic:foo:bar\".\\n */\\nexecute:magic.workflows.actions.execute\\n   name:config-name\\n   filename:/misc/workflows/actions/misc/config.hl\\n   arguments\\n      key:\"magic:smtp:from:name\"\\n\\n/*\\n * Returns the specified [key] configuration setting.\\n * \\n * Notice, to traverse into for instance magic.foo.bar, you'll have to colon separate\\n * your path as follows \"magic:foo:bar\".\\n */\\nexecute:magic.workflows.actions.execute\\n   name:config-email\\n   filename:/misc/workflows/actions/misc/config.hl\\n   arguments\\n      key:\"magic:smtp:from:address\"\\n\\n/*\\n * Send an email to the specified [name]/[email] recipient, with the specified [subject] and [body].\\n * \\n * Optionally supply [from] and [from-email] as name/email sender, and/or [reply-to] and [reply-to-email]\\n * as the email to reply to. If you don't supply [from] or [from-email] then this action will use the\\n * default sender settings from your configuration.\\n */\\nexecute:magic.workflows.actions.execute\\n   name:email\\n   filename:/misc/workflows/actions/misc/email.hl\\n   arguments\\n      reply-to:x:@.arguments/*/reply-to\\n      subject:x:--/execute/=html-encode-subject/*/content\\n      body:x:--/execute/=markdown2html/*/html\\n      html:bool:true\\n      name:x:--/execute/=config-name/*/value\\n      email:x:--/execute/=config-email/*/value\\n      reply-to-email:x:@.arguments/*/reply-to-email\\nreturn\\n   result:success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Send an email to owner of cloudlet\\n\\nThis function will send the owner of the cloudlet an email, with the specified [body].  The workflow will send an email from the owner of the cloudlet to the owner of the cloudlet, allowing the system to send generic emails without having an explicit reply to email address, which is useful for notifications, etc."},{"role":"assistant","content":".arguments\\n\\n   // Mandatory argument being the body of the email. This can be Markdown at which point it will be automatically transformed to HTML before the email is sent.\\n   body:string\\n.type:public\\n\\n// HTML encodes the specified [html] and returns to caller.\\nexecute:magic.workflows.actions.execute\\n   name:html-encode-body\\n   filename:/misc/workflows/actions/misc/html-encode.hl\\n   arguments\\n      html:x:@.arguments/*/body\\n\\n// HTML encodes the specified [html] and returns to caller.\\nexecute:magic.workflows.actions.execute\\n   name:html-encode-subject\\n   filename:/misc/workflows/actions/misc/html-encode.hl\\n   arguments\\n      html:x:@.arguments/*/subject\\n\\n// Transforms the specified [markdown] to HTML and returns to caller.\\nexecute:magic.workflows.actions.execute\\n   name:markdown2html\\n   filename:/misc/workflows/actions/misc/markdown2html.hl\\n   arguments\\n      markdown:x:--/execute/=html-encode-body/*/content\\n\\n/*\\n * Returns the specified [key] configuration setting.\\n * \\n * Notice, to traverse into for instance magic.foo.bar, you'll have to colon separate\\n * your path as follows \"magic:foo:bar\".\\n */\\nexecute:magic.workflows.actions.execute\\n   name:config-name\\n   filename:/misc/workflows/actions/misc/config.hl\\n   arguments\\n      key:\"magic:smtp:from:name\"\\n\\n/*\\n * Returns the specified [key] configuration setting.\\n * \\n * Notice, to traverse into for instance magic.foo.bar, you'll have to colon separate\\n * your path as follows \"magic:foo:bar\".\\n */\\nexecute:magic.workflows.actions.execute\\n   name:config-email\\n   filename:/misc/workflows/actions/misc/config.hl\\n   arguments\\n      key:\"magic:smtp:from:address\"\\n\\n/*\\n * Send an email to the specified [name]/[email] recipient, with the specified [subject] and [body].\\n * \\n * Optionally supply [from] and [from-email] as name/email sender, and/or [reply-to] and [reply-to-email]\\n * as the email to reply to. If you don't supply [from] or [from-email] then this action will use the\\n * default sender settings from your configuration.\\n */\\nexecute:magic.workflows.actions.execute\\n   name:email\\n   filename:/misc/workflows/actions/misc/email.hl\\n   arguments\\n      subject:Email from Magic Cloudlet\\n      html:bool:true\\n      body:x:--/execute/=markdown2html/*/html\\n      reply-to:x:--/execute/=config-name/*/value\\n      name:x:--/execute/=config-name/*/value\\n      email:x:--/execute/=config-email/*/value\\n      reply-to-email:x:--/execute/=config-email/*/value\\nreturn\\n   result:success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Evaluates the given [hyperlambda], and returns\\nthe results of the evaluation."},{"role":"assistant","content":".arguments\\n   hyperlambda:string\\n   args:*\\n.type:internal\\n\\n// Ensures user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Transforms Hyperlambda 2 lambda object.\\nhyper2lambda:x:@.arguments/*/hyperlambda\\n\\n// Converts all input arguments to their expected type.\\nfor-each:x:@.arguments/*/args/*\\n\\n   // Getting name of currently iterated argument.\\n   get-name:x:@.dp/#\\n\\n   // Checking if this is a workflow type of argument declaration or an endpoint type of declaration.\\n   if\\n      exists:x:@hyper2lambda/*/.arguments/*/{@get-name}/*/type\\n      .lambda\\n\\n         // Workflow type of argument declaration, converting argument value accordingly.\\n         set-value:x:@.dp/#\\n            convert:x:@.dp/#\\n               type:x:@hyper2lambda/*/.arguments/*/{@get-name}/*/type\\n   else\\n\\n      // Endpoint type of argument declaration, converting argument value accordingly.\\n      set-value:x:@.dp/#\\n         convert:x:@.dp/#\\n            type:x:@hyper2lambda/*/.arguments/*/{@get-name}\\n\\n/*\\n * Removing [.arguments] declaration from Hyperlambda we're about to execute,\\n * such that we can add the input arguments to the Hyperlambda file correctly.\\n */\\nremove-nodes:x:@hyper2lambda/*/.arguments/*\\n\\n// Adding input arguments specified by caller.\\nadd:x:./*/invoke\\n   get-nodes:x:@.arguments/*/args/*\\n\\n// Evaluating Hyperlambda, now with the correct root node.\\ninvoke:x:@hyper2lambda\\n\\n// Returning the results of the evaluation to caller.\\nreturn-nodes:x:@invoke/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Evaluates the given [hyperlambda], and returns\\nthe results of the evaluation."},{"role":"assistant","content":".arguments\\n   hyperlambda:string\\n   args:*\\n.type:internal\\n\\n// Ensures user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n/*\\n * To be able to return intelligent error messages to caller,\\n * we catch all exceptions, and returns the exception message\\n * publicly back to caller.\\n */\\ntry\\n\\n   /*\\n    * Transforms the specified [hyperlambda] to a lambda object,\\n    * making sure we correctly set the root node for the execution\\n    * in the process. This looks a bit cheezy, but to make sure\\n    * the root node for the execution object is the node containing\\n    * the Hyperlambda as children, it is necessary.\\n    * \\n    * It basically \"unties\" the execution object from the rest of this\\n    * particular file, preventing caller to interfer with the file itself,\\n    * as a consequence of his Hyperlambda.\\n    */\\n   .x:node:\"\"\\n   hyper2lambda:x:@.arguments/*/hyperlambda\\n   remove-nodes:x:@hyper2lambda/*/.arguments/*\\n   add:x:@hyper2lambda/*/.arguments\\n      get-nodes:x:@.arguments/*/args/*\\n   add:x:@.x/#\\n      get-nodes:x:@hyper2lambda/*\\n\\n   // Evaluating Hyperlambda, now with the correct root node.\\n   eval:x:@.x/#\\n\\n   // Returning the results of the evaluation to caller.\\n   lambda2hyper:x:@.x/#/*\\n   unwrap:x:+/*\\n   return-nodes\\n      result:x:@lambda2hyper\\n.catch\\n\\n   /*\\n    * Throwing a new exception, wrapping message,\\n    * this time as a publicly visible exception.\\n    */\\n   throw:x:@.arguments/*/message\\n      status:400\\n      public:true\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns arguments the specified Hyperlambda require if any."},{"role":"assistant","content":".arguments\\n   hyperlambda:string\\n.type:internal\\n\\n// Ensures user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Transforming Hyperlambda to lambda object.\\nhyper2lambda:x:@.arguments/*/hyperlambda\\n\\n// Making sure we \"normalize\" arguments.\\nfor-each:x:@hyper2lambda/*/.arguments/*\\n   if\\n      and\\n         not-exists:x:@.dp/#/*/type\\n         not-null:x:@.dp/#\\n      .lambda\\n         unwrap:x:+/*/*\\n         add:x:@.dp/#\\n            .\\n               type:x:@.dp/#\\n         set-value:x:@.dp/#\\n\\n// Returning arguments Hyperlambda requires to caller.\\nreturn-nodes:x:@hyper2lambda/*/.arguments/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns all slots registered in the system."},{"role":"assistant","content":".type:internal\\n\\n// Ensures user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Retrieving all system slots.\\nvocabulary\\n\\n// Returning results of the above to caller.\\nreturn-nodes:x:@vocabulary/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Counts number of tasks in system given specified optional filter."},{"role":"assistant","content":".arguments\\n   filter:string\\n.type:internal\\n\\n// Ensures user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Retrieves all scheduled tasks in the system.\\ntasks.count:x:@.arguments/*/filter\\n\\n// Returning the results of the evaluation to caller.\\nunwrap:x:+/*\\nreturn-nodes\\n   count:x:@tasks.count\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Creates a new scheduled task according to the arguments specified."},{"role":"assistant","content":".arguments\\n   id:string\\n   description:string\\n   hyperlambda:string\\n.type:internal\\n\\n// Ensures user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Converting Hyperlambda to lambda.\\nhyper2lambda:x:@.arguments/*/hyperlambda\\n\\n// Creates task.\\nadd:x:../*/tasks.create/*/.lambda\\n   get-nodes:x:@hyper2lambda/*\\ntasks.create:x:@.arguments/*/id\\n   description:x:@.arguments/*/description\\n   .lambda\\n\\n// Returning success to caller.\\nreturn\\n   result:success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Deletes the named task from the task scheduler."},{"role":"assistant","content":".arguments\\n   id:string\\n.type:internal\\n\\n// Ensures user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Deletes task.\\ntasks.delete:x:@.arguments/*/id\\n\\n// Returns success to caller.\\nreturn-nodes\\n   result:Success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Override exception handler to make sure we return information to root users\\nas they're using Magic to develop or modify things."},{"role":"assistant","content":"log.error:x:@.arguments/*/message\\n   url:x:@.arguments/*/path\\n   exception:x:@.arguments/*/stack\\nadd:x:+\\n   get-nodes:x:@.arguments/*/status\\n   get-nodes:x:@.arguments/*/field\\n   get-nodes:x:@.arguments/*/message\\nreturn\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Executes an existing task."},{"role":"assistant","content":".arguments\\n   id:string\\n.type:internal\\n\\n// Ensures user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Executing task on a different thread in case it takes a lot of time to execute.\\ninsert-before:x:./*/fork/0\\n   get-nodes:x:@.arguments\\nfork\\n\\n   // Executing task.\\n   tasks.execute:x:@.arguments/*/id\\n\\n// Returning success to caller.\\nreturn\\n   result:success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns the named task to caller."},{"role":"assistant","content":".arguments\\n   name:string\\n.type:internal\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/name\\n\\n// Ensures user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Retrieves the specified task from the task scheduler.\\ntasks.get:x:@.arguments/*/name\\n   schedules:true\\n\\n// Returning the results of the evaluation to caller.\\nreturn-nodes:x:@tasks.get/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Updates an existing task."},{"role":"assistant","content":".arguments\\n   id:string\\n   description:string\\n   hyperlambda:string\\n.type:internal\\n\\n// Ensures user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Converting Hyperlambda to lambda.\\n.lambda\\nif\\n   and\\n      exists:x:@.arguments/*/hyperlambda\\n      not\\n         eq\\n            get-value:x:@.arguments/*/hyperlambda\\n            .\\n      not\\n         eq\\n            get-value:x:@.arguments/*/hyperlambda\\n            .:\\n   .lambda\\n      add:x:@.lambda/@.lambda\\n         hyper2lambda:x:@.arguments/*/hyperlambda\\n      add:x:../*/tasks.update\\n         get-nodes:x:@.lambda/@.lambda\\ntasks.update:x:@.arguments/*/id\\n   description:x:@.arguments/*/description\\n\\n// Returning success to caller.\\nreturn\\n   result:success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Schedules the task with the specified [id] for execution according to the specified parameters."},{"role":"assistant","content":".arguments\\n   id:string\\n   due:date\\n   repeats:string\\n.type:internal\\n\\n// Ensures user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n/*\\n * Adds either a [repeats] or [due] argument to invocation below,\\n * depending upon what argument was supplied by caller.\\n */\\nif\\n   not\\n      eq\\n         get-value:x:@.arguments/*/repeats\\n         .\\n   .lambda\\n      add:x:../*/tasks.schedule\\n         get-nodes:x:@.arguments/*/repeats\\nelse\\n   add:x:../*/tasks.schedule\\n      get-nodes:x:@.arguments/*/due\\n\\n// Performs actual scheduling of task.\\ntasks.schedule:x:@.arguments/*/id\\n\\n// Returns success to caller.\\nreturn-nodes\\n   result:success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Deletes the specified due date instance."},{"role":"assistant","content":".arguments\\n   id:long\\n.type:internal\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/id\\n\\n// Ensures user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Deletes task due instance.\\ntasks.schedule.delete:x:@.arguments/*/id\\n\\n// Returns success to caller.\\nreturn-nodes\\n   result:Success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Generate an HTTP REST generic SQL endpoint according to the given [.arguments]."},{"role":"assistant","content":".arguments\\n   databaseType:string\\n   authorization:string\\n   moduleName:string\\n   database:string\\n   arguments:string\\n   verb:string\\n   endpointName:string\\n   sql:string\\n   overwrite:bool\\n.type:internal\\n\\n// Sanity checks invocation.\\nvalidators.mandatory:x:@.arguments/*/databaseType\\nvalidators.mandatory:x:@.arguments/*/moduleName\\nvalidators.mandatory:x:@.arguments/*/database\\nvalidators.mandatory:x:@.arguments/*/verb\\nvalidators.mandatory:x:@.arguments/*/endpointName\\nvalidators.mandatory:x:@.arguments/*/sql\\nvalidators.enum:x:@.arguments/*/databaseType\\n   .:mysql\\n   .:pgsql\\n   .:mssql\\n   .:sqlite\\nvalidators.enum:x:@.arguments/*/verb\\n   .:post\\n   .:get\\n   .:put\\n   .:delete\\n   .:patch\\n\\n// Ensures user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Creating a log entry explaining roughly what we're about to do.\\nlog.info:Generating SQL endpoint\\n   module:x:@.arguments/*/moduleName\\n   databaseType:x:@.arguments/*/databaseType\\n   database:x:@.arguments/*/database\\n   verb:x:@.arguments/*/verb\\n   endpointName:x:@.arguments/*/endpointName\\n\\n// Normalising sql argument.\\nstrings.replace:x:@.arguments/*/sql\\n   .:\"\\r\"\\n   .:\\nset-value:x:@.arguments/*/sql\\n   strings.replace:x:@.arguments/*/sql\\n      .:\"\\n\"\\n      .:@\"\\n\"\\n\\n// Loading template file used to generate endpoint.\\nio.file.load:/system/crudifier/templates/sql.template.hl\\nhyper2lambda:x:@io.file.load\\n   comments:bool:true\\n\\n// Applying database, database-type and sql arguments to template file.\\nunwrap:x:+/*\\napply:x:@hyper2lambda\\n   database-type:x:@.arguments/*/databaseType\\n   database:x:@.arguments/*/database\\n   sql:x:@.arguments/*/sql\\n\\n// Making sure we add arguments to the above lambda.\\nif\\n   and\\n      exists:x:@.arguments/*/arguments\\n      not\\n         eq\\n            get-value:x:@.arguments/*/arguments\\n            .:\\n      not\\n         eq\\n            get-value:x:@.arguments/*/arguments\\n            .\\n   .lambda\\n\\n      // Argument collection was specified, hence applying arguments to lambda.\\n      add:x:@apply/*/.arguments\\n         hyper2lambda:x:@.arguments/*/arguments\\n\\n      // Making sure endpoint applied arguments to [data.select] invocation.\\n      insert-before:x:@apply/*/data.connect/*/data.select/-\\n         .\\n\\n            // Parametrizing [data.select].\\n            add:x:./*/data.select\\n               get-nodes:x:@.arguments/*\\n\\n      // Looping through all arguments to endpoint and concatenating to our comment.\\n      .tmp\\n      for-each:x:@apply/*/.arguments/*\\n\\n         // Appending argument name to comment.\\n         if\\n            null:x:@.tmp\\n            .lambda\\n               set-value:x:@.tmp\\n                  strings.concat\\n                     .:\" with argument \"\\n                     get-name:x:@.dp/#\\n         else\\n            set-value:x:@.tmp\\n               strings.concat\\n                  get-value:x:@.tmp\\n                  .:\", \"\\n                  get-name:x:@.dp/#\\n      set-value:x:@apply/0\\n         strings.concat\\n            get-value:x:@apply/0\\n            get-value:x:@.tmp\\n\\n/*\\n * Checking if caller provided specific authorization for us to use,\\n * and if so, applying it to lambda.\\n */\\nif\\n   and\\n      not\\n         eq\\n            get-value:x:@.arguments/*/authorization\\n            .:\\n      not\\n         eq\\n            get-value:x:@.arguments/*/authorization\\n            .\\n   .lambda\\n\\n      // Adding authorization to endpoint's lambda.\\n      unwrap:x:+/*/*\\n      insert-after:x:@apply/*/.arguments\\n         .\\n\\n            // Making sure user is authorized to invoke endpoint.\\n            auth.ticket.verify:x:@.arguments/*/authorization\\n\\n// Appending description to endpoint\\nunwrap:x:+/*/*\\ninsert-after:x:@apply/1\\n   .\\n      .description:x:@apply/0\\n\\n// Creating our folder if necessary.\\n.folder:/modules/\\nset-value:x:@.folder\\n   strings.concat\\n      get-value:x:@.folder\\n      get-value:x:@.arguments/*/moduleName\\n      .:/\\nio.folder.create:x:@.folder\\n\\n// Creating our descriptive comment by invoking OpenAI.\\n.token\\nset-value:x:@.token\\n   strings.concat\\n      .:\"Bearer \"\\n      get-first-value\\n         get-value:x:@.arguments/*/api_key\\n         config.get:\"magic:openai:key\"\\nlambda2hyper:x:@apply/*\\nhttp.post:\"https://api.openai.com/v1/chat/completions\"\\n   convert:bool:true\\n   headers\\n      Authorization:x:@.token\\n      Content-Type:application/json\\n   payload\\n      model:gpt-4o\\n      max_tokens:int:1000\\n      temperature:decimal:0.3\\n      messages\\n         .\\n            role:system\\n            content:\"Shortly describe what the SQL inside the following code does with a single line of text, for then to add two carriage return characters, and a more elaborate description. The purpose of the result is to being used as the content for a file level comment describing what the SQL does. The comment needs to be high quality containing specific VSS keywords, since it will be used later to match training data using RAG according to the user's instructions. Do not return // characters or /**/ characters, only the text describing the code.\"\\n         .\\n            role:user\\n            content:x:@lambda2hyper\\n\\n// Sanity checking above invocation.\\nif\\n   and\\n      mte:x:@http.post\\n         .:int:200\\n      lt:x:@http.post\\n         .:int:300\\n   .lambda\\n      set-value:x:@apply/0\\n         get-value:x:@http.post/*/content/*/choices/0/*/message/*/content\\n      set-value:x:@apply/0\\n         strings.concat:x:@apply/0\\n            get-value:x:@apply/0\\n            .:@\"\\n\\n All arguments are mandatory.\"\\n\\n// Transforming above lambda to Hyperlambda, and figuring out filename.\\nlambda2hyper:x:@apply/*\\n   comments:bool:true\\n.filename\\nset-value:x:@.filename\\n   strings.concat\\n      get-value:x:@.folder\\n      get-value:x:@.arguments/*/endpointName\\n      .:.\\n      get-value:x:@.arguments/*/verb\\n      .:.hl\\n\\n// Making sure file does not exist from before, unless [.argument][overwrite] is true.\\nif\\n   and\\n      not\\n         get-value:x:@.arguments/*/overwrite\\n      io.file.exists:x:@.filename\\n   .lambda\\n\\n      // Endpoint already exists and caller didn't specify he or she wanted to overwrite existing endpoint.\\n      throw:Endpoint already exists, choose a new name or enable overwrite\\n         status:400\\n         public:true\\n\\n// Saving file.\\nio.file.save:x:@.filename\\n   get-value:x:@lambda2hyper\\n\\n// Returns success to caller.\\nreturn-nodes\\n   result:success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Override exception handler to make sure we return information to root users\\nas they're using Magic to develop or modify things."},{"role":"assistant","content":"log.error:x:@.arguments/*/message\\n   url:x:@.arguments/*/path\\n   exception:x:@.arguments/*/stack\\nadd:x:+\\n   get-nodes:x:@.arguments/*/status\\n   get-nodes:x:@.arguments/*/message\\n   get-nodes:x:@.arguments/*/field\\nreturn\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Creates a BlowFish hash of the first argument given, with an individual salt,\\nand returns the hashed value to the caller with the same name."},{"role":"assistant","content":"slots.create:transformers.hash-password\\n   get-value:x:@.arguments/0/#\\n   crypto.password.hash:x:-\\n   if\\n      not\\n         eq\\n            get-value:x:@crypto.password.hash\\n            .\\n      .lambda\\n         set-value:x:@.arguments/0/#\\n            get-value:x:@crypto.password.hash\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"dynamically populated"},{"role":"assistant","content":".arguments\\n\\n   // Number of records to return, defaults to 25 if not specified. Pass in -1 to return all records.\\n   limit:long\\n\\n   // Offset into the dataset of where to start retrieving records\\n   offset:long\\n\\n   // Fully qualified name of column to order by, must be in TABLE_NAME.COLUMN_NAME format\\n   order:string\\n\\n   // What direction to order, can be 'asc' or 'desc' implying ascending and descending\\n   direction:string\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-read\\n.foreign-keys\\n\\n// Opening up our database connection.\\ndata.connect:{database}\\n   database-type:{database-type}\\n\\n   // Parametrising our read invocation with filtering arguments.\\n   add:x:./*/data.read/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:{database-type}\\n      table:{table}\\n      columns\\n      where\\n         and\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"dynamically populated"},{"role":"assistant","content":".arguments\\n\\n   // Number of records to return, defaults to 25 if not specified. Pass in -1 to return all records.\\n   limit:long\\n\\n   // Offset into the dataset of where to start retrieving records\\n   offset:long\\n\\n   // Fully qualified name of column to order by, must be in TABLE_NAME.COLUMN_NAME format\\n   order:string\\n\\n   // What direction to order, can be 'asc' or 'desc' implying ascending and descending\\n   direction:string\\n\\n   // Optional logical operator for filtering arguments, can be either 'or' or 'and'. Defaults to and.\\n   operator:string\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-read\\n.foreign-keys\\n\\n// Sanity checking invocation.\\nvalidators.enum:x:@.arguments/*/operator\\n   .:or\\n   .:and\\n\\n/*\\n * Checking if user supplied an [operator] argument, and if so\\n * changing the boolean operator for comparison operations.\\n */\\nif\\n   exists:x:@.arguments/*/operator\\n   .lambda\\n\\n      // User provided a boolean comparison [operator] argument.\\n      set-name:x:../*/data.connect/*/data.read/*/where/0\\n         get-value:x:@.arguments/*/operator\\n      remove-nodes:x:@.arguments/*/operator\\n\\n// Opening up our database connection.\\ndata.connect:{database}\\n   database-type:{database-type}\\n\\n   // Parametrising our read invocation with filtering arguments.\\n   add:x:./*/data.read/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:{database-type}\\n      table:{table}\\n      columns\\n      where\\n         and\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"dynamically populated"},{"role":"assistant","content":".arguments\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-create\\n.foreign-keys\\n\\n// Opening up database connection.\\ndata.connect:{database}\\n   database-type:{database-type}\\n\\n   // Parametrising our create invocation.\\n   add:x:./*/data.create/*/values\\n      get-nodes:x:@.arguments/*\\n\\n   // Creating our record.\\n   data.create\\n      database-type:{database-type}\\n      table:{table}\\n      return-id:{return-id}\\n      values\\n\\n   // Returning the correct status code.\\n   response.status.set:201\\n\\n   // Returning result of above invocation to caller.\\n   unwrap:x:+/*\\n   return\\n      id:x:@data.create\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"dynamically populated"},{"role":"assistant","content":".arguments\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-update\\n.foreign-keys\\n\\n// Opening up our database connection.\\ndata.connect:{database}\\n   database-type:{database-type}\\n\\n   // Invoking our update slot.\\n   data.update\\n      database-type:{database-type}\\n      table:{table}\\n      values\\n      where\\n         and\\n\\n   // Verifying record exists.\\n   if\\n      eq\\n         get-value:x:@data.update\\n         .:int:0\\n      .lambda\\n         response.status.set:404\\n         return\\n            result:Record not found\\n\\n   // Returning the correct status code.\\n   response.status.set:202\\n\\n   // Returning success to caller.\\n   unwrap:x:+/*\\n   return\\n      affected:x:@data.update\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"dynamically populated"},{"role":"assistant","content":".arguments\\n\\n// Type of endpoint\\n.type:openapi\\n\\n// URL of endpoint.\\n.url:URL\\n\\n// Exchanging dynamic parts of URL.\\n.args\\nfor-each:x:@.arguments/*\\n   .tmp\\n   set-value:x:@.tmp\\n      strings.concat\\n         .:{\\n         get-name:x:@.dp/#\\n         .:}\\n   if\\n      strings.contains:x:@.url\\n         get-value:x:@.tmp\\n      .lambda\\n\\n         // Replacing dynamic parts of URL.\\n         set-value:x:@.url\\n            strings.replace:x:@.url\\n               get-value:x:@.tmp\\n               get-value:x:@.dp/#\\n   else\\n\\n      // Not a dynamic argument.\\n      add:x:@.args\\n         get-nodes:x:@.dp/#\\n\\n// Parametrising invocation.\\nadd:x:../*/http.delete/*/query\\n   get-nodes:x:@.args/*\\n\\n// Invoking HTTP endpoint.\\nhttp.delete:x:@.url\\n   convert:true\\n   query\\n\\n// Making sure invocation was a success.\\nif\\n   and\\n      not\\n         mte:x:@http.delete\\n            .:int:200\\n      not\\n         lt:x:@http.delete\\n            .:int:300\\n   .lambda\\n\\n      // Oops ...!!\\n      lambda2hyper:x:@http.delete\\n      throw:Could not invoke 3rd party HTTP endpoint\\n         status:int:500\\n         public:bool:true\\n         url:x:@.url\\n         response:x:@lambda2hyper\\n\\n// Returning result to caller.\\nreturn-nodes:x:@http.delete/*/content/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"dynamically populated"},{"role":"assistant","content":".arguments\\n\\n// Type of endpoint\\n.type:openapi\\n\\n// Creating our URL.\\n.url:URL\\n\\n// Exchanging dynamic parts of URL.\\n.args\\nfor-each:x:@.arguments/*\\n   .tmp\\n   set-value:x:@.tmp\\n      strings.concat\\n         .:{\\n         get-name:x:@.dp/#\\n         .:}\\n   if\\n      strings.contains:x:@.url\\n         get-value:x:@.tmp\\n      .lambda\\n\\n         // Replacing dynamic parts of URL.\\n         set-value:x:@.url\\n            strings.replace:x:@.url\\n               get-value:x:@.tmp\\n               get-value:x:@.dp/#\\n   else\\n\\n      // Not a dynamic argument.\\n      add:x:@.args\\n         get-nodes:x:@.dp/#\\n\\n// Parametrising invocation.\\nadd:x:../*/http.get/*/query\\n   get-nodes:x:@.args/*\\n\\n// Invoking HTTP endpoint.\\nhttp.get:x:@.url\\n   convert:true\\n   query\\n\\n// Making sure invocation was a success.\\nif\\n   and\\n      not\\n         mte:x:@http.get\\n            .:int:200\\n      not\\n         lt:x:@http.get\\n            .:int:300\\n   .lambda\\n\\n      // Oops ...!!\\n      lambda2hyper:x:@http.get\\n      throw:Could not invoke 3rd party HTTP endpoint\\n         status:int:500\\n         public:bool:true\\n         url:x:@.url\\n         response:x:@lambda2hyper\\n\\n// Returning result to caller.\\nreturn-nodes:x:@http.get/*/content/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"dynamically populated"},{"role":"assistant","content":".arguments\\n\\n// Type of endpoint\\n.type:openapi\\n\\n// URL of endpoint.\\n.url:URL\\n\\n// Exchanging dynamic parts of URL.\\n.args\\nfor-each:x:@.arguments/*\\n   .tmp\\n   set-value:x:@.tmp\\n      strings.concat\\n         .:{\\n         get-name:x:@.dp/#\\n         .:}\\n   if\\n      strings.contains:x:@.url\\n         get-value:x:@.tmp\\n      .lambda\\n\\n         // Replacing dynamic parts of URL.\\n         set-value:x:@.url\\n            strings.replace:x:@.url\\n               get-value:x:@.tmp\\n               get-value:x:@.dp/#\\n   else\\n\\n      // Not a dynamic argument.\\n      add:x:@.args\\n         get-nodes:x:@.dp/#\\n\\n// Invoking HTTP endpoint.\\nhttp.patch:x:@.url\\n   convert:true\\n   payload\\n   query\\n\\n// Making sure invocation was a success.\\nif\\n   and\\n      not\\n         mte:x:@http.patch\\n            .:int:200\\n      not\\n         lt:x:@http.patch\\n            .:int:300\\n   .lambda\\n\\n      // Oops ...!!\\n      lambda2hyper:x:@http.patch\\n      throw:Could not invoke 3rd party HTTP endpoint\\n         status:int:500\\n         public:bool:true\\n         url:x:@.url\\n         response:x:@lambda2hyper\\n\\n// Returning result to caller.\\nreturn-nodes:x:@http.patch/*/content/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"dynamically populated"},{"role":"assistant","content":".arguments\\n\\n// Type of endpoint\\n.type:openapi\\n\\n// URL of endpoint.\\n.url:URL\\n\\n// Exchanging dynamic parts of URL.\\n.args\\nfor-each:x:@.arguments/*\\n   .tmp\\n   set-value:x:@.tmp\\n      strings.concat\\n         .:{\\n         get-name:x:@.dp/#\\n         .:}\\n   if\\n      strings.contains:x:@.url\\n         get-value:x:@.tmp\\n      .lambda\\n\\n         // Replacing dynamic parts of URL.\\n         set-value:x:@.url\\n            strings.replace:x:@.url\\n               get-value:x:@.tmp\\n               get-value:x:@.dp/#\\n   else\\n\\n      // Not a dynamic argument.\\n      add:x:@.args\\n         get-nodes:x:@.dp/#\\n\\n// Invoking HTTP endpoint.\\nhttp.post:x:@.url\\n   convert:true\\n   payload\\n   query\\n\\n// Making sure invocation was a success.\\nif\\n   and\\n      not\\n         mte:x:@http.post\\n            .:int:200\\n      not\\n         lt:x:@http.post\\n            .:int:300\\n   .lambda\\n\\n      // Oops ...!!\\n      lambda2hyper:x:@http.post\\n      throw:Could not invoke 3rd party HTTP endpoint\\n         status:int:500\\n         public:bool:true\\n         url:x:@.url\\n         response:x:@lambda2hyper\\n\\n// Returning result to caller.\\nreturn-nodes:x:@http.post/*/content/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Distinct Keyword Search from {table} table in {database} database.\\n\\nThis endpoint will return only records containing one or more of the keywords from the specified [query],\\nwith rows containing the most distinct matched keywords appearing first."},{"role":"assistant","content":".arguments\\n\\n   // Mandatory query for records to search for\\n   query:string\\n\\n   // Optional number of records to return, defaults to 10 if not specified. Pass in -1 to return all records\\n   limit:long\\n\\n   // Optional offset into the dataset of where to start retrieving records\\n   offset:long\\n\\n// Type of endpoint\\n.type:crud-search\\n\\n// Make sure the user has provided a query.\\nvalidators.mandatory:x:@.arguments/*/query\\n\\n// Apply defaults if not specified.\\nvalidators.default:x:@.arguments\\n   limit:long:10\\n\\n// Split the user's query into individual keywords, separated by spaces.\\n.words\\nadd:x:@.words\\n   strings.split:x:@.arguments/*/query\\n      .:\" \"\\n\\n// Enforce lower characters for each keyword, and guard against SQL injection.\\n.no:int:0\\nfor-each:x:@.words/*\\n   set-value:x:@.dp/#\\n      strings.to-lower:x:@.dp/#\\n\\n// Specify which columns to search against.\\n.columns\\n\\n// Connect to the specified database.\\ndata.connect:{database}\\n   database-type:{database-type}\\n\\n   // Start building our SQL.\\n   .sql:select *, (\\n\\n   // 1) Dynamically create the full text by concatenating all columns we want to search.\\n   .fields\\n   for-each:x:@.columns/*\\n      strings.concat\\n         .:coalesce(\\n         get-value:x:@.dp/#\\n         .:\", '')\"\\n      unwrap:x:+/*/*\\n      add:x:@.fields\\n         .\\n            .:x:@strings.concat\\n   set-value:x:@.fields\\n      strings.join:x:@.fields/*\\n         .:\" || \"\\n   remove-nodes:x:@.fields/*\\n\\n   // 2) Keyword density calculation\\n   .no:int:0\\n   for-each:x:@.words/*\\n\\n      // Adding SQL parameter.\\n      set-name:x:+/+/*/*\\n         strings.concat\\n            .:@p\\n            get-value:x:@.no\\n      unwrap:x:+/*/*\\n      add:x:@data.connect/*/data.select\\n         .\\n            .:x:@.dp/#\\n\\n      // Modifying our SQL.\\n      if\\n         eq:x:@.no\\n            .:int:0\\n         .lambda\\n\\n            // First keyword => no leading plus\\n            set-value:x:@.sql\\n               strings.concat:x:@.sql\\n                  get-value:x:@.sql\\n                  .:\" (length(\"\\n                  get-value:x:@.fields\\n                  .:) - length(replace(lower(\\n                  get-value:x:@.fields\\n                  .:), @p\\n                  get-value:x:@.no\\n                  .:\", ''))) / length(@p\"\\n                  get-value:x:@.no\\n                  .:)\\n      else\\n         set-value:x:@.sql\\n            strings.concat:x:@.sql\\n               get-value:x:@.sql\\n               .:\" + (length(\"\\n               get-value:x:@.fields\\n               .:) - length(replace(lower(\\n               get-value:x:@.fields\\n               .:), @p\\n               get-value:x:@.no\\n               .:\", ''))) / length(@p\"\\n               get-value:x:@.no\\n               .:)\\n      math.increment:x:@.no\\n   set-value:x:@.sql\\n      strings.concat:x:@.sql\\n         get-value:x:@.sql\\n         .:) * 1.0 / length(\\n         get-value:x:@.fields\\n         .:) as keyword_density, (\\n\\n   // 3) Distinct keyword count => For each keyword, 1 if present, 0 if not.\\n   .no:int:0\\n   for-each:x:@.words/*\\n      if\\n         eq:x:@.no\\n            .:int:0\\n         .lambda\\n\\n            // First keyword => no leading plus\\n            set-value:x:@.sql\\n               strings.concat:x:@.sql\\n                  get-value:x:@.sql\\n                  .:\" CASE WHEN ((length(\"\\n                  get-value:x:@.fields\\n                  .:) - length(replace(lower(\\n                  get-value:x:@.fields\\n                  .:), @p\\n                  get-value:x:@.no\\n                  .:\", ''))) / length(@p\"\\n                  get-value:x:@.no\\n                  .:)) > 0 THEN 1 ELSE 0 END\\n      else\\n         set-value:x:@.sql\\n            strings.concat:x:@.sql\\n               get-value:x:@.sql\\n               .:\" + CASE WHEN ((length(\"\\n               get-value:x:@.fields\\n               .:) - length(replace(lower(\\n               get-value:x:@.fields\\n               .:), @p\\n               get-value:x:@.no\\n               .:\", ''))) / length(@p\"\\n               get-value:x:@.no\\n               .:)) > 0 THEN 1 ELSE 0 END\\n      math.increment:x:@.no\\n\\n   // Finalize \"keyword_count\".\\n   set-value:x:@.sql\\n      strings.concat:x:@.sql\\n         get-value:x:@.sql\\n         .:) as keyword_count\\n\\n   // 4) Finish SELECT + WHERE\\n   set-value:x:@.sql\\n      strings.concat:x:@.sql\\n         get-value:x:@.sql\\n         .:\" from \"\\n         .:{table}\\n         .:\" where keyword_count > 0\"\\n\\n   // 5) Order by distinct keyword_count (higher means more distinct keywords), then keyword_density.\\n   set-value:x:@.sql\\n      strings.concat:x:@.sql\\n         get-value:x:@.sql\\n         .:\" order by keyword_count desc, keyword_density desc limit \"\\n         get-value:x:@.arguments/*/limit\\n\\n   // (Optional) offset => pagination\\n   if\\n      exists:x:@.arguments/*/offset\\n      .lambda\\n         set-value:x:@.sql\\n            strings.concat:x:@.sql\\n               get-value:x:@.sql\\n               .:\" offset \"\\n               get-value:x:@.arguments/*/offset\\n\\n   // Execute the SQL\\n   data.select:x:@.sql\\n      database-type:{database-type}\\n\\n   // Remove helper fields if you don't want them in your final JSON\\n   remove-nodes:x:@data.select/*/*/keyword_density\\n   remove-nodes:x:@data.select/*/*/keyword_count\\n\\n   // Return the final result set\\n   return-nodes:x:@data.select/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Endpoint executing SQL and returns result of invocation to caller"},{"role":"assistant","content":".arguments\\n\\n// Connecting to database.\\ndata.connect:{database}\\n   database-type:{database-type}\\n\\n   // Executing [data.select] slot with our SQL.\\n   data.select:{sql}\\n      database-type:{database-type}\\n\\n   // Returning a result of above invocation to caller.\\n   return-nodes:x:@data.select/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns all endpoints in the system."},{"role":"assistant","content":".type:internal\\n\\n// Ensures user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Returns all endpoints to caller.\\nendpoints.list\\nreturn-nodes:x:@endpoints.list/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Deletes the cache item with the specified id."},{"role":"assistant","content":".arguments\\n   id:string\\n.type:internal\\n\\n// Ensures user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/id\\n\\n// Checking if caller wants to delete multiple cache items simultaneously.\\nif\\n   strings.ends-with:x:@.arguments/*/id\\n      .:*\\n   .lambda\\n\\n      // Deletes all cache items starting with specified string.\\n      strings.split:x:@.arguments/*/id\\n         .:*\\n      cache.clear\\n         filter:x:@strings.split/0\\nelse\\n\\n   // Deletes a single cache item.\\n   cache.set:x:@.arguments/*/id\\n\\n// Returning success to caller.\\nreturn\\n   result:success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Exports all questionnaire data from training requests for the specified type and returns as a CSV file."},{"role":"assistant","content":".arguments\\n   type:string\\n.type:internal\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/type\\n\\n// Opening up our database connection.\\ndata.connect:[generic|magic]\\n\\n   // Selecting data.\\n   data.select:select distinct(user_id) from ml_requests where type = @type and questionnaire != 1\\n      @type:x:@.arguments/*/type\\n\\n   // Buffer for data\\n   .data\\n\\n   // Iterating through above result to create our CSV file.\\n   for-each:x:@data.select/*\\n\\n      // Finding all prompts and answers for currently iterated user.\\n      data.select:select prompt, completion from ml_requests where type = @type and user_id = @user_id and questionnaire != 1\\n         @type:x:@.arguments/*/type\\n         @user_id:x:@.dp/#/*/user_id\\n\\n      // Temporary buffer for all questions and answers for currently iterated user.\\n      .tmp:\\n\\n      // Looping through all questions/answers.\\n      for-each:x:@data.select/*\\n\\n         // Appending currently iterated question answer to above [.tmp] variable.\\n         set-value:x:@.tmp\\n            strings.concat\\n               get-value:x:@.tmp\\n               get-value:x:@.dp/#/*/prompt\\n               .:\"\\n\"\\n               .:\"\\n\"\\n               get-value:x:@.dp/#/*/completion\\n               .:\"\\n\"\\n               .:\"\\n\"\\n\\n      // Adding currently iterated conversation to above [.data]\\n      unwrap:x:+/*/*/*\\n      add:x:@.data\\n         .\\n            .\\n               conversation:x:@.tmp\\n\\n   // Converting result to CSV.\\n   lambda2csv:x:@.data/*\\n\\n   // Applying correct HTTP header.\\n   response.headers.set\\n      Content-Type:text/csv\\n      Access-Control-Expose-Headers:Content-Disposition\\n      Content-Disposition:\"attachment; filename=\\\"conversations.csv\\\"\"\\n\\n   // Returning content to caller.\\n   return:x:@lambda2csv\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Exports all leads from training requests and returns as a CSV file."},{"role":"assistant","content":".arguments\\n   type:string\\n.type:internal\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Opening up our database connection.\\ndata.connect:[generic|magic]\\n\\n   // Parametrising our read invocation with filtering arguments.\\n   if\\n      exists:x:@.arguments/*/type\\n      .lambda\\n         unwrap:x:+/*/*\\n         add:x:@data.connect/*/data.read/*/where/*/and\\n            .\\n               type.eq:x:@.arguments/*/type\\n\\n   // Invoking our read slot.\\n   data.read\\n      table:ml_requests\\n      columns\\n         prompt\\n            as:lead\\n      where\\n         and\\n            finish_reason.eq:lead\\n      limit:-1\\n\\n   // Verifying records exists.\\n   if\\n      not-exists:x:@data.read/*\\n      .lambda\\n         response.status.set:404\\n         return\\n            result:No records found\\n\\n   // Converting result to CSV.\\n   lambda2csv:x:@data.read/*\\n\\n   // Applying correct HTTP header.\\n   response.headers.set\\n      Content-Type:text/csv\\n      Access-Control-Expose-Headers:Content-Disposition\\n      Content-Disposition:\"attachment; filename=\\\"leads.csv\\\"\"\\n\\n   // Returning content to caller.\\n   return:x:@lambda2csv\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Exports all questionnaire data from training requests for the specified type and returns as a CSV file."},{"role":"assistant","content":".arguments\\n   type:string\\n.type:internal\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/type\\n\\n// Opening up our database connection.\\ndata.connect:[generic|magic]\\n\\n   // Selecting data.\\n   data.select:select distinct(user_id) from ml_requests where type = @type and questionnaire = 1\\n      @type:x:@.arguments/*/type\\n\\n   // Buffer for data\\n   .data\\n\\n   // Iterating through above result to create our CSV file.\\n   for-each:x:@data.select/*\\n\\n      // Adding record for user to above [.data] buffer.\\n      add:x:@.data\\n         .\\n            .\\n\\n      // Selecting questionnaire data for each above user_id.\\n      data.select:\"select prompt, completion from ml_requests where user_id = @user_id and questionnaire = 1 and finish_reason = 'questionnaire'\"\\n         @user_id:x:@.dp/#/*/user_id\\n\\n      // Iterating through above result and adding to [.data].\\n      for-each:x:@data.select/*\\n         set-name:x:./*/add/[0,1]/*/*\\n            get-value:x:@.dp/#/*/prompt\\n         unwrap:x:+/*/*\\n         add:x:@.data/0/-\\n            .\\n               foo:x:@.dp/#/*/completion\\n\\n      // Selecting conversation for user and adding to above [.data].\\n      .conv:\\n      data.select:select prompt, completion from ml_requests where user_id = @user_id and questionnaire = 0\\n         @user_id:x:@.dp/#/*/user_id\\n      for-each:x:@data.select/*\\n\\n         // Concatenating prompt/completion to above [.conv].\\n         set-value:x:@.conv\\n            strings.concat\\n               get-value:x:@.conv\\n               get-value:x:@.dp/#/*/prompt\\n               .:\"\\n\"\\n               .:\"\\n\"\\n               get-value:x:@.dp/#/*/completion\\n               .:\"\\n\"\\n               .:\"\\n\"\\n\\n      // Adding conversation to above [.data].\\n      set-value:x:@.conv\\n         strings.trim:x:@.conv\\n      unwrap:x:+/*/*\\n      add:x:@.data/0/-\\n         .\\n            conversation:x:@.conv\\n\\n   // Sanity checking that we've got any data at all.\\n   if\\n      not-exists:x:@.data/*\\n      .lambda\\n\\n         // Nothing here ...\\n         response.status.set:404\\n         return\\n            result:No questionnaires found\\n\\n   // Converting result to CSV.\\n   lambda2csv:x:@.data/*\\n\\n   // Applying correct HTTP header.\\n   response.headers.set\\n      Content-Type:text/csv\\n      Access-Control-Expose-Headers:Content-Disposition\\n      Content-Disposition:\"attachment; filename=\\\"questionnaires.csv\\\"\"\\n\\n   // Returning content to caller.\\n   return:x:@lambda2csv\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"CRUD delete endpoint deleting one record from your ml_requests table in your magic database with id matching argument with authentication and authorisation for root roles"},{"role":"assistant","content":".arguments\\n   id:long\\n.type:crud-delete\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Sanity checking invocation, making sure primary key(s) are specified.\\nvalidators.mandatory:x:@.arguments/*/id\\n\\n// Opening up our database connection.\\ndata.connect:[generic|magic]\\n\\n   // Parametrising our delete invocation.\\n   add:x:./*/data.delete/*/where/*/and\\n      get-nodes:x:@.arguments/*\\n\\n   // Deleting item from database.\\n   data.delete\\n      table:ml_requests\\n      where\\n         and\\n\\n   // Returning result of above invocation to caller.\\n   unwrap:x:+/*\\n   return\\n      affected:x:@data.delete\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"CRUD read endpoint with paging, sorting, filtering selecting records from your ml_requests table in your magic database returning id, created, type, prompt, completion, finish_reason filtering on id, created, type, prompt, completion, finish_reason with authentication and authorisation for root roles"},{"role":"assistant","content":".arguments\\n   limit:long\\n   offset:long\\n   order:string\\n   direction:string\\n   filter:string\\n   ml_requests.id.eq:long\\n   ml_requests.id.mt:long\\n   ml_requests.id.lt:long\\n   ml_requests.created.eq:date\\n   ml_requests.type.like:string\\n   ml_requests.type.eq:string\\n   ml_requests.prompt.like:string\\n   ml_requests.prompt.eq:string\\n   ml_requests.completion.like:string\\n   ml_requests.completion.eq:string\\n   ml_requests.finish_reason.like:string\\n   ml_requests.finish_reason.eq:string\\n.type:crud-read\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Opening up our database connection.\\ndata.connect:[generic|magic]\\n\\n   // Parametrising our read invocation with ordering arguments if specified.\\n   add:x:./*/data.read\\n      get-nodes:x:@.arguments/*/order\\n      get-nodes:x:@.arguments/*/direction\\n   remove-nodes:x:@.arguments/*/order\\n   remove-nodes:x:@.arguments/*/direction\\n\\n   // Parametrising our read invocation with paging arguments if specified.\\n   add:x:./*/data.read\\n      get-nodes:x:@.arguments/*/limit\\n      get-nodes:x:@.arguments/*/offset\\n   remove-nodes:x:@.arguments/*/limit\\n   remove-nodes:x:@.arguments/*/offset\\n\\n   // Checking if user provided a [filter]\\n   if\\n      exists:x:@.arguments/*/filter\\n      .lambda\\n\\n         // Adding filter and removing it from arguments collection.\\n         strings.concat\\n            .:%\\n            get-value:x:@.arguments/*/filter\\n            .:%\\n         unwrap:x:+/*/*/*\\n         add:x:@data.connect/*/data.read/*/where/*/and\\n            .\\n               or\\n                  ml_requests.prompt.like:x:@strings.concat\\n                  ml_requests.completion.like:x:@strings.concat\\n                  ml_requests.user_id.eq:x:@.arguments/*/filter\\n         remove-nodes:x:@.arguments/*/filter\\n\\n   // Parametrising our read invocation with filtering arguments.\\n   add:x:./*/data.read/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      table:ml_requests\\n      columns\\n         ml_requests.id\\n         ml_requests.created\\n         ml_requests.type\\n         ml_requests.prompt\\n         ml_requests.completion\\n         ml_requests.finish_reason\\n         ml_requests.cached\\n         ml_requests.questionnaire\\n         ml_requests.session\\n         ml_requests.user_id\\n         ml_requests.referrer\\n      where\\n         and\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"CRUD create endpoint inserting one record into your ml_requests table in your magic database taking type, prompt, completion, finish_reason with authentication and authorisation for root roles"},{"role":"assistant","content":".arguments\\n   type:string\\n   prompt:string\\n   completion:string\\n   finish_reason:string\\n   cached:int\\n.type:crud-create\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Opening up database connection.\\ndata.connect:[generic|magic]\\n\\n   // Parametrising our create invocation.\\n   add:x:./*/data.create/*/values\\n      get-nodes:x:@.arguments/*\\n\\n   // Creating our record.\\n   data.create\\n      table:ml_requests\\n      return-id:bool:true\\n      values\\n\\n   // Returning the correct status code.\\n   response.status.set:201\\n\\n   // Returning result of above invocation to caller.\\n   unwrap:x:+/*\\n   return\\n      id:x:@data.create\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"CRUD update endpoint updating one record in your ml_requests table in your magic database filtering which item to update with id updating type, prompt, completion, finish_reason fields with authentication and authorisation for root roles"},{"role":"assistant","content":".arguments\\n   id:long\\n   type:string\\n   prompt:string\\n   completion:string\\n   finish_reason:string\\n   cached:int\\n.type:crud-update\\n\\n// Sanity checking invocation, making sure primary key(s) are specified.\\nvalidators.mandatory:x:@.arguments/*/id\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Opening up our database connection.\\ndata.connect:[generic|magic]\\n\\n   // Parametrising our invocation.\\n   add:x:./*/data.update/*/values\\n      get-nodes:x:@.arguments/*/[1,1000]\\n   add:x:./*/data.update/*/where/*/and\\n      get-nodes:x:@.arguments/*/[0,1]\\n\\n   // Invoking our update slot.\\n   data.update\\n      table:ml_requests\\n      values\\n      where\\n         and\\n\\n   // Verifying record exists.\\n   if\\n      eq\\n         get-value:x:@data.update\\n         .:int:0\\n      .lambda\\n         response.status.set:404\\n         return\\n            result:Record not found\\n\\n   // Returning the correct status code.\\n   response.status.set:202\\n\\n   // Returning success to caller.\\n   unwrap:x:+/*\\n   return\\n      affected:x:@data.update\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"CRUD delete endpoint deleting multiple records from your ml_training_snippets table in your magic database matching filter authentication and authorisation for root roles"},{"role":"assistant","content":".arguments\\n   ml_training_snippets.prompt.like:string\\n   ml_training_snippets.completion.like:string\\n   ml_training_snippets.uri.like:string\\n   ml_training_snippets.type.eq:string\\n.type:crud-delete\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Opening up our database connection.\\ndata.connect:[generic|magic]\\n\\n   // Parametrising our delete and read invocation with filtering arguments.\\n   add:x:./*/data.read/*/where/*/*/or\\n      get-nodes:x:@.arguments/*/ml_training_snippets.prompt.like\\n      get-nodes:x:@.arguments/*/ml_training_snippets.completion.like\\n      get-nodes:x:@.arguments/*/ml_training_snippets.uri.like\\n   add:x:./*/data.delete/*/where/*/*/or\\n      get-nodes:x:@.arguments/*/ml_training_snippets.prompt.like\\n      get-nodes:x:@.arguments/*/ml_training_snippets.completion.like\\n      get-nodes:x:@.arguments/*/ml_training_snippets.uri.like\\n   remove-nodes:x:@.arguments/*/ml_training_snippets.prompt.like\\n   remove-nodes:x:@.arguments/*/ml_training_snippets.completion.like\\n   remove-nodes:x:@.arguments/*/ml_training_snippets.uri.like\\n   add:x:./*/data.read/*/where/*\\n      get-nodes:x:@.arguments/*\\n   add:x:./*/data.delete/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Removing [or] parts unless we've got something to actually or.\\n   if\\n      not-exists:x:@data.connect/*/data.read/*/where/*/and/*/or/*\\n      .lambda\\n         remove-nodes:x:@data.connect/*/data.read/*/where/*/and/*/or\\n         remove-nodes:x:@data.connect/*/data.delete/*/where/*/and/*/or\\n\\n   // Reading items from database such that we can delete files associated with items.\\n   data.read\\n      table:ml_training_snippets\\n      columns\\n         filename\\n      where\\n         and\\n            filename.neq\\n            or\\n      limit:-1\\n   for-each:x:@data.read/*\\n      if\\n         and\\n            not-null:x:@.dp/#/*/filename\\n            io.file.exists:x:@.dp/#/*/filename\\n         .lambda\\n            io.file.delete:x:@.dp/#/*/filename\\n\\n   /*\\n    * Generating select statement for records we're deleting since we need\\n    * to use it as input to deletion from vss shadow table.\\n    */\\n   data.read\\n      generate:true\\n      table:ml_training_snippets\\n      columns\\n         id\\n            as:rowid\\n      where\\n         and\\n            or\\n      limit:-1\\n   .sql\\n\\n   // Deleting records from vss shadow table.\\n   set-value:x:@.sql\\n      strings.concat\\n         .:delete from vss_ml_training_snippets where rowid in(\\n         get-value:x:@data.read\\n         .:)\\n   add:x:./*/data.execute\\n      get-nodes:x:@data.read/*\\n   data.execute:x:@.sql\\n\\n   // Finally, deleting ml_training_snippets item from database.\\n   data.delete\\n      table:ml_training_snippets\\n      where\\n         and\\n            or\\n\\n   // Returning result of above invocation to caller.\\n   unwrap:x:+/*\\n   return\\n      affected:x:@data.delete\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"CRUD update endpoint updating all filtered records in your ml_training_snippets table in your magic database with authentication and authorisation for root roles"},{"role":"assistant","content":".arguments\\n   filter\\n      ml_training_snippets.prompt.like:string\\n      ml_training_snippets.uri.like:string\\n      ml_training_snippets.type.eq:string\\n   values\\n      type:string\\n      pushed:long\\n.type:crud-update\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Opening up our database connection.\\ndata.connect:[generic|magic]\\n\\n   // Parametrising our read invocation with filtering arguments.\\n   add:x:./*/data.update/*/where/*/*/or\\n      get-nodes:x:@.arguments/*/filter/*/ml_training_snippets.prompt.like\\n      get-nodes:x:@.arguments/*/filter/*/ml_training_snippets.uri.like\\n   remove-nodes:x:@.arguments/*/filter/*/ml_training_snippets.prompt.like\\n   remove-nodes:x:@.arguments/*/filter/*/ml_training_snippets.uri.like\\n   add:x:./*/data.update/*/where/*\\n      get-nodes:x:@.arguments/*/filter/*\\n   add:x:./*/data.update/*/values\\n      get-nodes:x:@.arguments/*/values/*\\n\\n   // Removing [or] parts unless we've got something to actually or.\\n   if\\n      not-exists:x:@data.connect/*/data.update/*/where/*/and/*/or/*\\n      .lambda\\n         remove-nodes:x:@data.connect/*/data.update/*/where/*/and/*/or\\n\\n   // Invoking our update slot.\\n   data.update\\n      table:ml_training_snippets\\n      values\\n      where\\n         and\\n            or\\n\\n   // Verifying record exists.\\n   if\\n      eq\\n         get-value:x:@data.update\\n         .:int:0\\n      .lambda\\n         response.status.set:404\\n         return\\n            result:Record not found\\n\\n   // Returning the correct status code.\\n   response.status.set:202\\n\\n   // Returning success to caller.\\n   unwrap:x:+/*\\n   return\\n      affected:x:@data.update\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns all filtered training snippets as a CSV file."},{"role":"assistant","content":".arguments\\n   ml_training_snippets.completion.like:string\\n   ml_training_snippets.prompt.like:string\\n   ml_training_snippets.uri.like:string\\n   ml_training_snippets.type.eq:string\\n.type:internal\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Opening up our database connection.\\ndata.connect:[generic|magic]\\n\\n   // Parametrising our read invocation with filtering arguments.\\n   add:x:./*/data.read/*/where/*/*/or\\n      get-nodes:x:@.arguments/*/ml_training_snippets.completion.like\\n      get-nodes:x:@.arguments/*/ml_training_snippets.prompt.like\\n      get-nodes:x:@.arguments/*/ml_training_snippets.uri.like\\n   remove-nodes:x:@.arguments/*/ml_training_snippets.completion.like\\n   remove-nodes:x:@.arguments/*/ml_training_snippets.prompt.like\\n   remove-nodes:x:@.arguments/*/ml_training_snippets.uri.like\\n   add:x:./*/data.read/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Removing [or] parts unless we've got something to actually or.\\n   if\\n      not-exists:x:@data.connect/*/data.read/*/where/*/and/*/or/*\\n      .lambda\\n         remove-nodes:x:@data.connect/*/data.read/*/where/*/and/*/or\\n\\n   // Invoking our read slot.\\n   data.read\\n      table:ml_training_snippets\\n      columns\\n         type\\n         uri\\n         prompt\\n         completion\\n      where\\n         and\\n            or\\n      limit:-1\\n\\n   // Verifying records exists.\\n   if\\n      not-exists:x:@data.read/*\\n      .lambda\\n         response.status.set:404\\n         return\\n            result:No records found\\n\\n   // Converting result to CSV.\\n   lambda2csv:x:@data.read/*\\n\\n   // Applying correct HTTP header.\\n   response.headers.set\\n      Content-Type:text/csv\\n      Access-Control-Expose-Headers:Content-Disposition\\n      Content-Disposition:\"attachment; filename=\\\"training-snippets.csv\\\"\"\\n\\n   // Returning content to caller.\\n   return:x:@lambda2csv\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"CRUD read endpoint with paging, and VSS filtering selecting records from your ml_training_snippets table in your magic database returning id, created, type, pushed, uri, prompt, completion filtering on id, created, type, pushed, uri, prompt, completion with authentication and authorisation for root roles"},{"role":"assistant","content":".arguments\\n   limit:long\\n   offset:long\\n   filter:string\\n   type:string\\n.type:crud-read\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/filter\\nvalidators.string:x:@.arguments/*/filter\\n   min:1\\n   max:1000\\n\\n// Applying defaults.\\nvalidators.default:x:@.arguments\\n   limit:int:10\\n\\n// Retrieving embeddings.\\n.token\\nset-value:x:@.token\\n   strings.concat\\n      .:\"Bearer \"\\n      config.get:\"magic:openai:key\"\\n\\n// Figuring out embeddings model to use.\\n.embeddings-model\\ndata.connect:[generic|magic]\\n   data.read\\n      table:ml_types\\n      columns\\n         vector_model\\n      where\\n         and\\n            type.eq:x:@.arguments/*/type\\n   set-value:x:@.embeddings-model\\n      get-value:x:@data.read/*/*/vector_model\\n\\n// Retrieving embedding for prompt.\\nhttp.post:\"https://api.openai.com/v1/embeddings\"\\n   headers\\n      Authorization:x:@.token\\n      Content-Type:application/json\\n   payload\\n      input:x:@.arguments/*/filter\\n      model:x:@.embeddings-model\\n   convert:true\\n\\n// Sanity checking above invocation.\\nif\\n   not\\n      and\\n         mte:x:@http.post\\n            .:int:200\\n         lt:x:@http.post\\n            .:int:300\\n   .lambda\\n\\n      // Oops, error - Logging error and returning OpenAI's HTTP status code to caller.\\n      lambda2hyper:x:@http.post\\n      log.error:Something went wrong while invoking OpenAI\\n         message:x:@http.post/*/content/*/error/*/message\\n         error:x:@lambda2hyper\\n      throw:x:@http.post/*/content/*/error/*/message\\n         public:bool:true\\n         status:x:@http.post\\n\\n// Converting from JSON string to byte array.\\nfloatArray2bytes:x:@http.post/*/content/*/data/0/*/embedding/*\\n\\n// Opening up our database connection.\\ndata.connect:[generic|magic]\\n   .sql:\"\\nselect vss.distance, id, created, type, pushed, uri, prompt, completion, filename, cached, meta, embedding as embedding_vss\\n   from vss_ml_training_snippets as vss\\n    \\tinner join ml_training_snippets ts on ts.id = vss.rowid\\n   where\\n      vss_search(vss.embedding_vss, @embedding)\"\\n\\n   // Further parametrising invocation if we should.\\n   if\\n      exists:x:@.arguments/*/type\\n      .lambda\\n         set-value:x:@.sql\\n            strings.concat\\n               get-value:x:@.sql\\n               .:\" and type = @type\"\\n         unwrap:x:+/*/*\\n         add:x:@if/./*/data.select\\n            .\\n               @type:x:@.arguments/*/type\\n   if\\n      exists:x:@.arguments/*/limit\\n      .lambda\\n         set-value:x:@.sql\\n            strings.concat\\n               get-value:x:@.sql\\n               .:\" limit \"\\n               get-value:x:@.arguments/*/limit\\n   if\\n      exists:x:@.arguments/*/offset\\n      .lambda\\n         set-value:x:@.sql\\n            strings.concat\\n               get-value:x:@.sql\\n               .:\" offset \"\\n               get-value:x:@.arguments/*/offset\\n\\n   // Executing SQL towards database.\\n   data.select:x:@.sql\\n      @embedding:x:@floatArray2bytes\\n\\n   // Changing embedding to a boolean value to preserve bandwidth, and returning token count.\\n   for-each:x:@data.select/*\\n\\n      // Changing embedding to boolean to preserve bandwidth.\\n      if\\n         not-null:x:@.dp/#/*/embedding_vss\\n         .lambda\\n            set-value:x:@.dp/#/*/embedding_vss\\n               .:bool:true\\n      else\\n         set-value:x:@.dp/#/*/embedding_vss\\n            .:bool:false\\n\\n      // Adding token count for each snippet.\\n      strings.concat\\n         get-value:x:@.dp/#/*/prompt\\n         .:@\"\\n\\n\"\\n         get-value:x:@.dp/#/*/completion\\n      openai.tokenize:x:@strings.concat\\n      unwrap:x:+/*/*\\n      add:x:@.dp/#\\n         .\\n            tokens:x:@openai.tokenize\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.select/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"CRUD delete endpoint deleting one record from your ml_training_snippets table in your magic database with id matching argument with authentication and authorisation for root roles"},{"role":"assistant","content":".arguments\\n   id:long\\n.type:crud-delete\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Sanity checking invocation, making sure primary key(s) are specified.\\nvalidators.mandatory:x:@.arguments/*/id\\n\\n// Opening up our database connection.\\ndata.connect:[generic|magic]\\n\\n   // Parametrising our read invocation.\\n   add:x:./*/data.read/*/where/*/and\\n      get-nodes:x:@.arguments/*\\n\\n   // Checking if snippet has a filename value\\n   data.read\\n      table:ml_training_snippets\\n      columns\\n         filename\\n      where\\n         and\\n   if\\n      and\\n         exists:x:@data.read/*\\n         not-null:x:@data.read/*/*/filename\\n         io.file.exists:x:@data.read/*/*/filename\\n      .lambda\\n         io.file.delete:x:@data.read/*/*/filename\\n\\n   // Parametrising our delete invocation.\\n   add:x:./*/data.delete/*/where/*/and\\n      get-nodes:x:@.arguments/*\\n\\n   // Deleting item from database.\\n   data.delete\\n      table:ml_training_snippets\\n      where\\n         and\\n   data.execute:delete from vss_ml_training_snippets where rowid = @id\\n      id:x:@.arguments/*/id\\n\\n   // Returning result of above invocation to caller.\\n   unwrap:x:+/*\\n   return\\n      affected:x:@data.delete\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"CRUD read endpoint with paging, sorting, filtering selecting records from your ml_training_snippets table in your magic database returning id, created, type, pushed, uri, prompt, completion filtering on id, created, type, pushed, uri, prompt, completion with authentication and authorisation for root roles"},{"role":"assistant","content":".arguments\\n   limit:long\\n   offset:long\\n   order:string\\n   direction:string\\n   ml_training_snippets.id.eq:long\\n   ml_training_snippets.id.mt:long\\n   ml_training_snippets.id.lt:long\\n   ml_training_snippets.type.like:string\\n   ml_training_snippets.type.eq:string\\n   ml_training_snippets.pushed.eq:long\\n   ml_training_snippets.uri.like:string\\n   ml_training_snippets.uri.eq:string\\n   ml_training_snippets.prompt.like:string\\n   ml_training_snippets.prompt.eq:string\\n   ml_training_snippets.completion.like:string\\n   ml_training_snippets.completion.eq:string\\n.type:crud-read\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Opening up our database connection.\\ndata.connect:[generic|magic]\\n\\n   // Checking if order exists and if it is 'tokens', at which point we order by length of prompt + completion.\\n   if\\n      and\\n         exists:x:@.arguments/*/order\\n         eq:x:@.arguments/*/order\\n            .:tokens\\n      .lambda\\n         set-value:x:@.arguments/*/order\\n            .:length(prompt || completion)\\n\\n   // Parametrising our read invocation with ordering arguments if specified.\\n   add:x:./*/data.read\\n      get-nodes:x:@.arguments/*/order\\n      get-nodes:x:@.arguments/*/direction\\n   remove-nodes:x:@.arguments/*/order\\n   remove-nodes:x:@.arguments/*/direction\\n\\n   // Parametrising our read invocation with paging arguments if specified.\\n   add:x:./*/data.read\\n      get-nodes:x:@.arguments/*/limit\\n      get-nodes:x:@.arguments/*/offset\\n   remove-nodes:x:@.arguments/*/limit\\n   remove-nodes:x:@.arguments/*/offset\\n\\n   // Parametrising our read invocation with filtering arguments.\\n   add:x:./*/data.read/*/where/*/*/or\\n      get-nodes:x:@.arguments/*/ml_training_snippets.completion.like\\n      get-nodes:x:@.arguments/*/ml_training_snippets.prompt.like\\n      get-nodes:x:@.arguments/*/ml_training_snippets.uri.like\\n      get-nodes:x:@.arguments/*/ml_training_snippets.completion.eq\\n      get-nodes:x:@.arguments/*/ml_training_snippets.prompt.eq\\n      get-nodes:x:@.arguments/*/ml_training_snippets.uri.eq\\n      get-nodes:x:@.arguments/*/ml_training_snippets.id.eq\\n      get-nodes:x:@.arguments/*/ml_training_snippets.id.lt\\n      get-nodes:x:@.arguments/*/ml_training_snippets.id.mt\\n   remove-nodes:x:@.arguments/*/ml_training_snippets.completion.like\\n   remove-nodes:x:@.arguments/*/ml_training_snippets.prompt.like\\n   remove-nodes:x:@.arguments/*/ml_training_snippets.uri.like\\n   remove-nodes:x:@.arguments/*/ml_training_snippets.prompt.eq\\n   remove-nodes:x:@.arguments/*/ml_training_snippets.completion.eq\\n   remove-nodes:x:@.arguments/*/ml_training_snippets.uri.eq\\n   remove-nodes:x:@.arguments/*/ml_training_snippets.id.eq\\n   remove-nodes:x:@.arguments/*/ml_training_snippets.id.lt\\n   remove-nodes:x:@.arguments/*/ml_training_snippets.id.mt\\n   add:x:./*/data.read/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Removing [or] parts unless we've got something to actually or.\\n   if\\n      not-exists:x:@data.connect/*/data.read/*/where/*/and/*/or/*\\n      .lambda\\n         remove-nodes:x:@data.connect/*/data.read/*/where/*/and/*/or\\n\\n   // Reading data from database.\\n   data.read\\n      table:ml_training_snippets\\n      columns\\n         ml_training_snippets.id\\n         ml_training_snippets.created\\n         ml_training_snippets.type\\n         ml_training_snippets.pushed\\n         ml_training_snippets.uri\\n         ml_training_snippets.prompt\\n         ml_training_snippets.completion\\n         ml_training_snippets.embedding\\n            as:embedding_vss\\n         ml_training_snippets.cached\\n         ml_training_snippets.meta\\n      where\\n         and\\n            or\\n\\n   // Changing embedding to a boolean value to preserve bandwidth, and returning token count.\\n   for-each:x:@data.read/*\\n\\n      // Changing embedding to boolean to preserve bandwidth.\\n      if\\n         not-null:x:@.dp/#/*/embedding_vss\\n         .lambda\\n            set-value:x:@.dp/#/*/embedding_vss\\n               .:bool:true\\n      else\\n         set-value:x:@.dp/#/*/embedding_vss\\n            .:bool:false\\n\\n      // Adding token count for each snippet.\\n      strings.concat\\n         get-value:x:@.dp/#/*/prompt\\n         .:@\"\\n\\n\"\\n         get-value:x:@.dp/#/*/completion\\n      openai.tokenize:x:@strings.concat\\n      unwrap:x:+/*/*\\n      add:x:@.dp/#\\n         .\\n            tokens:x:@openai.tokenize\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"CRUD create endpoint inserting one record into your ml_training_snippets table in your magic database taking type, pushed, uri, prompt, completion with authentication and authorisation for root roles"},{"role":"assistant","content":".arguments\\n   pushed:long\\n   uri:string\\n   prompt:string\\n   completion:string\\n   meta:string\\n   type:string\\n   cached:int\\n.type:crud-create\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Opening up database connection.\\ndata.connect:[generic|magic]\\n\\n   // Verifying user can create more snippets.\\n   add:x:+\\n      get-nodes:x:@.arguments/*/type\\n   try-signal:magic.ai.can-create-snippet\\n\\n   // Parametrising our create invocation.\\n   add:x:./*/data.create/*/values\\n      get-nodes:x:@.arguments/*\\n\\n   // Creating our record.\\n   data.create\\n      table:ml_training_snippets\\n      return-id:bool:true\\n      values\\n\\n   // Returning the correct status code.\\n   response.status.set:201\\n\\n   // Returning result of above invocation to caller.\\n   unwrap:x:+/*\\n   return\\n      id:x:@data.create\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"CRUD update endpoint updating one record in your ml_training_snippets table in your magic database filtering which item to update with id updating uri, prompt, completion fields with authentication and authorisation for root roles"},{"role":"assistant","content":".arguments\\n   id:long\\n   uri:string\\n   prompt:string\\n   completion:string\\n   meta:string\\n   type:string\\n   pushed:long\\n   cached:int\\n.type:crud-update\\n\\n// Sanity checking invocation, making sure primary key(s) are specified.\\nvalidators.mandatory:x:@.arguments/*/id\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Opening up our database connection.\\ndata.connect:[generic|magic]\\n\\n   // Parametrising our invocation.\\n   add:x:./*/data.update/*/values\\n      get-nodes:x:@.arguments/*/[1,1000]\\n   add:x:./*/data.update/*/where/*/and\\n      get-nodes:x:@.arguments/*/[0,1]\\n\\n   // Invoking our update slot.\\n   data.update\\n      table:ml_training_snippets\\n      values\\n      where\\n         and\\n\\n   // Verifying record exists.\\n   if\\n      eq\\n         get-value:x:@data.update\\n         .:int:0\\n      .lambda\\n         response.status.set:404\\n         return\\n            result:Record not found\\n\\n   // Returning the correct status code.\\n   response.status.set:202\\n\\n   // Returning success to caller.\\n   unwrap:x:+/*\\n   return\\n      affected:x:@data.update\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Endpoint counting items in your ml_types table in your magic database"},{"role":"assistant","content":".arguments\\n   ml_types.type.like:string\\n   ml_types.type.eq:string\\n   ml_types.model.like:string\\n   ml_types.model.eq:string\\n   ml_types.greeting.like:string\\n   ml_types.greeting.eq:string\\n   ml_types.max_tokens.eq:long\\n   ml_types.max_context_tokens.eq:long\\n   ml_types.max_request_tokens.eq:long\\n   ml_types.temperature.eq:double\\n   ml_types.base_url.like:string\\n   ml_types.base_url.eq:string\\n   ml_types.contact_us.like:string\\n   ml_types.contact_us.eq:string\\n   ml_types.lead_email.like:string\\n   ml_types.lead_email.eq:string\\n   ml_types.api_key.like:string\\n   ml_types.api_key.eq:string\\n   ml_type.twilio_account_sid.like:string\\n   ml_type.twilio_account_sid.eq:string\\n   ml_types.webhook_incoming.like:string\\n   ml_types.webhook_incoming.eq:string\\n   ml_types.webhook_outgoing.like:string\\n   ml_types.webhook_outgoing.eq:string\\n   ml_types.webhook_incoming_url.like:string\\n   ml_types.webhook_incoming_url.eq:string\\n   ml_types.initial_questionnaire.like:string\\n   ml_types.initial_questionnaire.eq:string\\n   ml_types.webhook_outgoing_url.like:string\\n   ml_types.webhook_outgoing_url.eq:string\\n   ml_types.system_message.like:string\\n   ml_types.system_message.eq:string\\n.type:crud-count\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Opening up our database connection.\\ndata.connect:[generic|magic]\\n   add:x:+/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      table:ml_types\\n      columns\\n         count(*)\\n            as:count\\n      where\\n         and\\n      limit:long:1\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"CRUD delete endpoint deleting one record from your ml_types table in your magic database with type matching argument with authentication and authorisation for root roles"},{"role":"assistant","content":".arguments\\n   type:string\\n.type:crud-delete\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Sanity checking invocation, making sure primary key(s) are specified.\\nvalidators.mandatory:x:@.arguments/*/type\\n\\n// Opening up our database connection.\\ndata.connect:[generic|magic]\\n\\n   // Deleting referenced rows in vss_ml_training_snippets\\n   data.execute:\"delete from vss_ml_training_snippets where rowid in\\n   (select id as rowid from ml_training_snippets where type = @type)\"\\n      type:x:@.arguments/*/type\\n\\n   // Parametrising our delete invocation.\\n   add:x:./*/data.delete/*/where/*/and\\n      get-nodes:x:@.arguments/*\\n\\n   // Deleting item from database.\\n   data.delete\\n      table:ml_types\\n      where\\n         and\\n\\n   // Returning result of above invocation to caller.\\n   unwrap:x:+/*\\n   return\\n      affected:x:@data.delete\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"CRUD create endpoint inserting one record into your ml_types table in your magic database taking type, model, max_tokens, temperature with authentication and authorisation for root roles"},{"role":"assistant","content":".arguments\\n   type:string\\n   model:string\\n   max_tokens:long\\n   max_context_tokens:long\\n   max_request_tokens:long\\n   temperature:double\\n   recaptcha:decimal\\n   auth:string\\n   supervised:int\\n   cached:int\\n   prefix:string\\n   use_embeddings:int\\n   threshold:decimal\\n   vector_model:string\\n   greeting:string\\n   base_url:string\\n   contact_us:string\\n   lead_email:string\\n   api_key:string\\n   twilio_account_id:string\\n   twilio_account_sid:string\\n   webhook_incoming:string\\n   webhook_outgoing:string\\n   webhook_incoming_url:string\\n   webhook_outgoing_url:string\\n   system_message:string\\n   conversation_starters:string\\n   initial_questionnaire:string\\n   no_requests:int\\n   max_requests:int\\n   search_postfix:string\\n   max_function_invocations:int\\n   max_session_items:int\\n   completion_slot:string\\n.type:crud-create\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Sanity checking invocation.\\nvalidators.integer:x:@.arguments/*/max_context_tokens\\n   min:500\\n   max:40000\\nvalidators.integer:x:@.arguments/*/max_request_tokens\\n   min:100\\n   max:25000\\nvalidators.integer:x:@.arguments/*/max_tokens\\n   min:500\\n   max:4000\\n\\n// Applying sane defaults.\\nvalidators.default:x:@.arguments\\n   vector_model:text-embedding-ada-002\\n   model:gpt-4o\\n   threshold:decimal:0.3\\n\\n// Opening up database connection.\\ndata.connect:[generic|magic]\\n\\n   // Verifying user can create a-(nother) machine learning model.\\n   try-signal:magic.ai.can-create-machine-learning-model\\n\\n   // Parametrising our create invocation.\\n   add:x:./*/data.create/[0,1]/*/values\\n      get-nodes:x:@.arguments/*\\n\\n   // Making sure we default twilio_account_id token to model name unless explicitly specified.\\n   if\\n      or\\n         not-exists:x:@.arguments/*/twilio_account_id\\n         null:x:@.arguments/*/twilio_account_id\\n         eq:x:@.arguments/*/twilio_account_id\\n            .:\\n      .lambda\\n         remove-nodes:x:@data.connect/*/data.create/*/values/*/twilio_account_id\\n         unwrap:x:+/*/*\\n         add:x:@data.connect/*/data.create/[0,1]/*/values\\n            .\\n               twilio_account_id:x:@.arguments/*/type\\n\\n   // Creating our record.\\n   data.create\\n      table:ml_types\\n      return-id:bool:false\\n      values\\n\\n   // Creating our default training snippets.\\n   data.create\\n      table:ml_training_snippets\\n      values\\n         type:x:@.arguments/*/type\\n         prompt:Who created this AI chatbot?\\n         completion:\"This chatbot is a custom AI chatbot powered by OpenAI allowing you to use natural language to ask questions related to the website you're currently visiting. It was created by [AINIRO.IO](https://ainiro.io). AINIRO.io have AI chatbot solutions allowing you to scrape your website, upload documents, and create publicly available AI chatbots and AI-based search similar to Bing, in addition to tools helping you build custom GPTs.\"\\n         uri:\"https://ainiro.io\"\\n\\n   // Returning the correct status code.\\n   response.status.set:201\\n\\n   // Returning result of above invocation to caller.\\n   unwrap:x:+/*\\n   return\\n      result:success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"CRUD update endpoint updating one record in your ml_types table in your magic database filtering which item to update with type updating model, max_tokens, temperature fields with authentication and authorisation for root roles"},{"role":"assistant","content":".arguments\\n   type:string\\n   model:string\\n   max_tokens:long\\n   max_context_tokens:long\\n   max_request_tokens:long\\n   temperature:double\\n   recaptcha:decimal\\n   auth:string\\n   supervised:int\\n   cached:int\\n   prefix:string\\n   use_embeddings:int\\n   threshold:decimal\\n   vector_model:string\\n   greeting:string\\n   base_url:string\\n   contact_us:string\\n   lead_email:string\\n   api_key:string\\n   twilio_account_id:string\\n   twilio_account_sid:string\\n   webhook_incoming:string\\n   webhook_outgoing:string\\n   webhook_incoming_url:string\\n   webhook_outgoing_url:string\\n   system_message:string\\n   conversation_starters:string\\n   initial_questionnaire:string\\n   no_requests:int\\n   max_requests:int\\n   search_postfix:string\\n   max_function_invocations:int\\n   max_session_items:int\\n   completion_slot:string\\n.type:crud-update\\n\\n// Sanity checking invocation, making sure primary key(s) are specified.\\nvalidators.mandatory:x:@.arguments/*/type\\n\\n// Sanity checking invocation.\\nvalidators.integer:x:@.arguments/*/max_context_tokens\\n   min:500\\n   max:40000\\nvalidators.integer:x:@.arguments/*/max_request_tokens\\n   min:100\\n   max:25000\\nvalidators.integer:x:@.arguments/*/max_tokens\\n   min:500\\n   max:4000\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Opening up our database connection.\\ndata.connect:[generic|magic]\\n\\n   // Parametrising our invocation.\\n   add:x:./*/data.update/*/values\\n      get-nodes:x:@.arguments/*/[1,1000]\\n   add:x:./*/data.update/*/where/*/and\\n      get-nodes:x:@.arguments/*/[0,1]\\n\\n   // Making sure we default twilio_account_id token to model name unless explicitly specified.\\n   if\\n      or\\n         not-exists:x:@.arguments/*/twilio_account_id\\n         null:x:@.arguments/*/twilio_account_id\\n         eq:x:@.arguments/*/twilio_account_id\\n            .:\\n      .lambda\\n         remove-nodes:x:@data.connect/*/data.create/*/values/*/twilio_account_id\\n         unwrap:x:+/*/*\\n         add:x:@data.connect/*/data.update/*/values\\n            .\\n               twilio_account_id:x:@.arguments/*/type\\n\\n   // Invoking our update slot.\\n   data.update\\n      table:ml_types\\n      values\\n      where\\n         and\\n\\n   // Verifying record exists.\\n   if\\n      eq\\n         get-value:x:@data.update\\n         .:int:0\\n      .lambda\\n         response.status.set:404\\n         return\\n            result:Record not found\\n\\n   // Returning the correct status code.\\n   response.status.set:202\\n\\n   // Returning success to caller.\\n   unwrap:x:+/*\\n   return\\n      affected:x:@data.update\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Endpoint counting items in your questionnaires table in your magic database"},{"role":"assistant","content":".arguments\\n   questionnaires.name.like:string\\n   questionnaires.name.eq:string\\n   questionnaires.type.like:string\\n   questionnaires.type.eq:string\\n.type:crud-count\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Opening up our database connection.\\ndata.connect:[generic|magic]\\n   database-type:sqlite\\n   add:x:+/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:sqlite\\n      table:questionnaires\\n      columns\\n         count(*)\\n            as:count\\n      where\\n         and\\n      limit:long:1\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"CRUD delete endpoint deleting one record from your questionnaires table in your magic database with name matching argument with authentication and authorisation for root,admin roles"},{"role":"assistant","content":".arguments\\n   name:string\\n.type:crud-delete\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Sanity checking invocation, making sure primary key(s) are specified.\\nvalidators.mandatory:x:@.arguments/*/name\\n\\n// Opening up our database connection.\\ndata.connect:[generic|magic]\\n   database-type:sqlite\\n\\n   // Parametrising our delete invocation.\\n   add:x:./*/data.delete/*/where/*/and\\n      get-nodes:x:@.arguments/*\\n\\n   // Deleting item from database.\\n   data.delete\\n      database-type:sqlite\\n      table:questionnaires\\n      where\\n         and\\n\\n   // Returning result of above invocation to caller.\\n   unwrap:x:+/*\\n   return\\n      affected:x:@data.delete\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"CRUD read endpoint with paging, sorting, filtering selecting records from your questionnaires table in your magic database returning name filtering on name with authentication and authorisation for root,admin roles"},{"role":"assistant","content":".arguments\\n   limit:long\\n   offset:long\\n   order:string\\n   direction:string\\n   questionnaires.name.like:string\\n   questionnaires.name.eq:string\\n   questionnaires.type.like:string\\n   questionnaires.type.eq:string\\n.type:crud-read\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Opening up our database connection.\\ndata.connect:[generic|magic]\\n   database-type:sqlite\\n\\n   // Parametrising our read invocation with ordering arguments if specified.\\n   add:x:./*/data.read\\n      get-nodes:x:@.arguments/*/order\\n      get-nodes:x:@.arguments/*/direction\\n   remove-nodes:x:@.arguments/*/order\\n   remove-nodes:x:@.arguments/*/direction\\n\\n   // Parametrising our read invocation with paging arguments if specified.\\n   add:x:./*/data.read\\n      get-nodes:x:@.arguments/*/limit\\n      get-nodes:x:@.arguments/*/offset\\n   remove-nodes:x:@.arguments/*/limit\\n   remove-nodes:x:@.arguments/*/offset\\n\\n   // Parametrising our read invocation with filtering arguments.\\n   add:x:./*/data.read/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:sqlite\\n      table:questionnaires\\n      columns\\n         questionnaires.name\\n         questionnaires.type\\n         questionnaires.action\\n      where\\n         and\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"CRUD create endpoint inserting one record into your questionnaires table in your magic database taking name with authentication and authorisation for root,admin roles"},{"role":"assistant","content":".arguments\\n   name:string\\n   type:string\\n   action:string\\n.type:crud-create\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Sanity checking name.\\nvalidators.regex:x:@.arguments/*/name\\n   regex:^[a-z0-9_-]{2,20}$\\n\\n// Opening up database connection.\\ndata.connect:[generic|magic]\\n   database-type:sqlite\\n\\n   // Parametrising our create invocation.\\n   add:x:./*/data.create/*/values\\n      get-nodes:x:@.arguments/*\\n\\n   // Creating our record.\\n   data.create\\n      database-type:sqlite\\n      table:questionnaires\\n      return-id:bool:false\\n      values\\n\\n   // Returning the correct status code.\\n   response.status.set:201\\n\\n   // Returning result of above invocation to caller.\\n   unwrap:x:+/*\\n   return\\n      result:success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"CRUD update endpoint updating one record in your questionnaires table in your magic database filtering which item to update with name updating type fields with authentication and authorisation for root roles"},{"role":"assistant","content":".arguments\\n   name:string\\n   type:string\\n   action:string\\n.type:crud-update\\n\\n// Sanity checking invocation, making sure primary key(s) are specified.\\nvalidators.mandatory:x:@.arguments/*/name\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Opening up our database connection.\\ndata.connect:[generic|magic]\\n   database-type:sqlite\\n\\n   // Parametrising our invocation.\\n   add:x:./*/data.update/*/values\\n      get-nodes:x:@.arguments/*/[1,1000]\\n   add:x:./*/data.update/*/where/*/and\\n      get-nodes:x:@.arguments/*/[0,1]\\n\\n   // Invoking our update slot.\\n   data.update\\n      database-type:sqlite\\n      table:questionnaires\\n      values\\n      where\\n         and\\n\\n   // Verifying record exists.\\n   if\\n      eq\\n         get-value:x:@data.update\\n         .:int:0\\n      .lambda\\n         response.status.set:404\\n         return\\n            result:Record not found\\n\\n   // Returning the correct status code.\\n   response.status.set:202\\n\\n   // Returning success to caller.\\n   unwrap:x:+/*\\n   return\\n      affected:x:@data.update\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Upsert endpoint upserting questions for questionnaire, assumes [questions] is Markdown with list items."},{"role":"assistant","content":".arguments\\n   name:string\\n   questions:string\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/name\\nvalidators.mandatory:x:@.arguments/*/questions\\n\\n// Connecting to database.\\ndata.connect:[generic|magic]\\n\\n   // Deleting all old questions.\\n   data.delete\\n      table:questions\\n      where\\n         and\\n            questionnaire.eq:x:@.arguments/*/name\\n\\n   /*\\n    * Turning questions string into individual questions by transforming\\n    * to HTML and then semantically traversing.\\n    */\\n   markdown2html:x:@.arguments/*/questions\\n   html2lambda:x:-\\n\\n   // Iterating all li elements in HTML.\\n   for-each:x:@html2lambda/**/li\\n\\n      // Semantically parsing question.\\n      strings.split:x:\"@.dp/#/*/\\\\#text\"\\n         .:=>\\n      .question\\n      set-value:x:@.question\\n         strings.trim:x:@strings.split/0\\n\\n      // Checking if question contains meta information.\\n      if\\n         mt\\n            get-count:x:@strings.split/*\\n            .:int:1\\n         .lambda\\n\\n            // Question contain meta information.\\n            strings.trim:x:@strings.split/1\\n            strings.split:x:-\\n               .:,\\n            for-each:x:@strings.split/*\\n               strings.split:x:@.dp/#\\n                  .:=\\n               set-value:x:./*/add/*/*/name\\n                  strings.trim:x:@strings.split/1\\n               set-name:x:./*/add/*/*/name\\n                  strings.trim:x:@strings.split/0\\n               add:x:@for-each/@for-each/*/data.create/*/values\\n                  .\\n                     name:value\\n\\n      // Inserting currently iterated question and associating it with specified questionnaire.\\n      data.create\\n         table:questions\\n         values\\n            questionnaire:x:@.arguments/*/name\\n            question:x:@.question\\n\\n   // Returning success to caller.\\n   return\\n      result:success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"CRUD delete endpoint deleting one record from your questions table in your magic database with question_id matching argument with authentication and authorisation for root,admin roles"},{"role":"assistant","content":".arguments\\n   question_id:long\\n.type:crud-delete\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Sanity checking invocation, making sure primary key(s) are specified.\\nvalidators.mandatory:x:@.arguments/*/question_id\\n\\n// Opening up our database connection.\\ndata.connect:[generic|magic]\\n   database-type:sqlite\\n\\n   // Parametrising our delete invocation.\\n   add:x:./*/data.delete/*/where/*/and\\n      get-nodes:x:@.arguments/*\\n\\n   // Deleting item from database.\\n   data.delete\\n      database-type:sqlite\\n      table:questions\\n      where\\n         and\\n\\n   // Returning result of above invocation to caller.\\n   unwrap:x:+/*\\n   return\\n      affected:x:@data.delete\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"CRUD read endpoint with paging, sorting, filtering selecting records from your questions table in your magic database returning question_id, question, questionnaire filtering on question_id, question, questionnaire with authentication and authorisation for root,admin roles"},{"role":"assistant","content":".arguments\\n   limit:long\\n   offset:long\\n   order:string\\n   direction:string\\n   questions.question_id.eq:long\\n   questions.question.like:string\\n   questions.question.eq:string\\n   questions.questionnaire.like:string\\n   questions.questionnaire.eq:string\\n.type:crud-read\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Opening up our database connection.\\ndata.connect:[generic|magic]\\n   database-type:sqlite\\n\\n   // Parametrising our read invocation with ordering arguments if specified.\\n   add:x:./*/data.read\\n      get-nodes:x:@.arguments/*/order\\n      get-nodes:x:@.arguments/*/direction\\n   remove-nodes:x:@.arguments/*/order\\n   remove-nodes:x:@.arguments/*/direction\\n\\n   // Parametrising our read invocation with paging arguments if specified.\\n   add:x:./*/data.read\\n      get-nodes:x:@.arguments/*/limit\\n      get-nodes:x:@.arguments/*/offset\\n   remove-nodes:x:@.arguments/*/limit\\n   remove-nodes:x:@.arguments/*/offset\\n\\n   // Parametrising our read invocation with filtering arguments.\\n   add:x:./*/data.read/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:sqlite\\n      table:questions\\n      columns\\n         questions.question_id\\n         questions.question\\n         questions.questionnaire\\n         questions.type\\n         questions.context\\n         questions.name\\n      where\\n         and\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"CRUD create endpoint inserting one record into your questions table in your magic database taking question, questionnaire with authentication and authorisation for root,admin roles"},{"role":"assistant","content":".arguments\\n   question:string\\n   questionnaire:string\\n   type:string\\n   name:string\\n.type:crud-create\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root\\n.foreign-keys\\n   .\\n      column:questionnaire\\n      table:questionnaires\\n      foreign_column:name\\n      foreign_name:name\\n      long:bool:true\\n\\n// Opening up database connection.\\ndata.connect:[generic|magic]\\n   database-type:sqlite\\n\\n   // Parametrising our create invocation.\\n   add:x:./*/data.create/*/values\\n      get-nodes:x:@.arguments/*\\n\\n   // Creating our record.\\n   data.create\\n      database-type:sqlite\\n      table:questions\\n      return-id:bool:true\\n      values\\n\\n   // Returning the correct status code.\\n   response.status.set:201\\n\\n   // Returning result of above invocation to caller.\\n   unwrap:x:+/*\\n   return\\n      id:x:@data.create\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"CRUD update endpoint updating one record in your questions table in your magic database filtering which item to update with question_id updating question, questionnaire fields with authentication and authorisation for root,admin roles"},{"role":"assistant","content":".arguments\\n   question_id:long\\n   question:string\\n   questionnaire:string\\n   type:string\\n   name:string\\n.type:crud-update\\n\\n// Sanity checking invocation, making sure primary key(s) are specified.\\nvalidators.mandatory:x:@.arguments/*/question_id\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root\\n.foreign-keys\\n   .\\n      column:questionnaire\\n      table:questionnaires\\n      foreign_column:name\\n      foreign_name:name\\n      long:bool:true\\n\\n// Opening up our database connection.\\ndata.connect:[generic|magic]\\n   database-type:sqlite\\n\\n   // Parametrising our invocation.\\n   add:x:./*/data.update/*/values\\n      get-nodes:x:@.arguments/*/[1,1000]\\n   add:x:./*/data.update/*/where/*/and\\n      get-nodes:x:@.arguments/*/[0,1]\\n\\n   // Invoking our update slot.\\n   data.update\\n      database-type:sqlite\\n      table:questions\\n      values\\n      where\\n         and\\n\\n   // Verifying record exists.\\n   if\\n      eq\\n         get-value:x:@data.update\\n         .:int:0\\n      .lambda\\n         response.status.set:404\\n         return\\n            result:Record not found\\n\\n   // Returning the correct status code.\\n   response.status.set:202\\n\\n   // Returning success to caller.\\n   unwrap:x:+/*\\n   return\\n      affected:x:@data.update\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Template for HTTP GET CRUD requests.\\nThis file was automatically generated using Magic's CRUDifier."},{"role":"assistant","content":".arguments\\n   operator:string\\n   name.eq:string\\n   name.like:string\\n   description.like:string\\n.type:crud-count\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Sanity checking invocation.\\nvalidators.enum:x:@.arguments/*/operator\\n   .:or\\n   .:and\\n\\n/*\\n * Checking if user supplied an [operator] argument, and if so\\n * changing the boolean operator for comparison operations.\\n */\\nif\\n   exists:x:@.arguments/*/operator\\n   .lambda\\n\\n      // User provided a boolean comparison [operator] argument.\\n      set-name:x:../*/data.connect/*/data.read/*/where/0\\n         get-value:x:@.arguments/*/operator\\n\\n// Opening up our database connection.\\ndata.connect:[generic|magic]\\n\\n   // Parametrising our read invocation.\\n   add:x:./*/data.read\\n      get-nodes:x:@.arguments/*/operator\\n   remove-nodes:x:@.arguments/*/operator\\n   add:x:+/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      table:roles\\n      columns\\n         count(*)\\n            as:count\\n      where\\n         and\\n      limit:long:1\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Template for HTTP DELETE CRUD requests.\\nThis file was automatically generated using Magic's CRUDifier."},{"role":"assistant","content":".arguments\\n   name:string\\n.type:crud-delete\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root\\nvalidators.mandatory:x:@.arguments/*/name\\n\\n// Opening up our database connection.\\ndata.connect:[generic|magic]\\n\\n   // Parametrising our delete invocation.\\n   add:x:./*/data.delete/*/where/*/and\\n      get-nodes:x:@.arguments/*\\n\\n   // Deleting item from database.\\n   data.delete\\n      table:roles\\n      where\\n         and\\n\\n   // Returning result of above invocation to caller.\\n   unwrap:x:+/*\\n   return\\n      affected:x:@data.delete\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Template for HTTP POST CRUD requests.\\nThis file was automatically generated using Magic's CRUDifier."},{"role":"assistant","content":".arguments\\n   name:string\\n   description:string\\n.type:crud-create\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Sanity checking invocation\\nvalidators.regex:x:@.arguments/*/name\\n   regex:\"^[A-Za-z0-9\\\\-_]*$\"\\n\\n// Opening up database connection.\\ndata.connect:[generic|magic]\\n\\n   // Parametrising our create invocation.\\n   add:x:./*/data.create/*/values\\n      get-nodes:x:@.arguments/*\\n\\n   // Creating our record.\\n   data.create\\n      table:roles\\n      return-id:bool:false\\n      values\\n\\n   // Returning result of above invoction to caller.\\n   response.status.set:201\\n   unwrap:x:+/*\\n   return\\n      result:success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Template for HTTP PUT CRUD requests.\\nThis file was automatically generated using Magic's CRUDifier."},{"role":"assistant","content":".arguments\\n   name:string\\n   description:string\\n.type:crud-update\\n\\n// Verifying user is authorized to access endpoint.\\nvalidators.mandatory:x:@.arguments/*/name\\nauth.ticket.verify:root\\n\\n// Opening up our database connection.\\ndata.connect:[generic|magic]\\n\\n   // Parametrising our invocation.\\n   add:x:./*/data.update/*/values\\n      get-nodes:x:@.arguments/*/[1,1000]\\n   add:x:./*/data.update/*/where/*/and\\n      get-nodes:x:@.arguments/*/[0,1]\\n\\n   // Invoking our update slot.\\n   data.update\\n      table:roles\\n      values\\n      where\\n         and\\n\\n   // Verifying record exists.\\n   if\\n      eq\\n         get-value:x:@data.update\\n         .:int:0\\n      .lambda\\n         response.status.set:404\\n         return\\n            result:Record not found\\n\\n   // Returning success to caller.\\n   response.status.set:202\\n   unwrap:x:+/*\\n   return\\n      affected:x:@data.update\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Template for HTTP GET CRUD requests.\\nThis file was automatically generated using Magic's CRUDifier."},{"role":"assistant","content":".arguments\\n   operator:string\\n   type.eq:string\\n   value.like:string\\n   user.eq:string\\n.type:crud-count\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Sanity checking invocation.\\nvalidators.enum:x:@.arguments/*/operator\\n   .:or\\n   .:and\\n\\n/*\\n * Checking if user supplied an [operator] argument, and if so\\n * changing the boolean operator for comparison operations.\\n */\\nif\\n   exists:x:@.arguments/*/operator\\n   .lambda\\n\\n      // User provided a boolean comparison [operator] argument.\\n      set-name:x:../*/data.connect/*/data.read/*/where/0\\n         get-value:x:@.arguments/*/operator\\n\\n// Opening up our database connection.\\ndata.connect:[generic|magic]\\n\\n   // Parametrising our read invocation.\\n   add:x:./*/data.read\\n      get-nodes:x:@.arguments/*/operator\\n   remove-nodes:x:@.arguments/*/operator\\n   add:x:+/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      table:users_extra\\n      columns\\n         count(*)\\n            as:count\\n      where\\n         and\\n      limit:long:1\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Template for HTTP DELETE CRUD requests.\\nThis file was automatically generated using Magic's CRUDifier."},{"role":"assistant","content":".arguments\\n   type:string\\n   user:string\\n.type:crud-delete\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root\\nvalidators.mandatory:x:@.arguments/*/type\\nvalidators.mandatory:x:@.arguments/*/user\\n\\n// Opening up our database connection.\\ndata.connect:[generic|magic]\\n\\n   // Parametrising our delete invocation.\\n   add:x:./*/data.delete/*/where/*/and\\n      get-nodes:x:@.arguments/*\\n\\n   // Deleting item from database.\\n   data.delete\\n      table:users_extra\\n      where\\n         and\\n\\n   // Returning result of above invocation to caller.\\n   unwrap:x:+/*\\n   return\\n      affected:x:@data.delete\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Template for HTTP GET CRUD requests.\\nThis file was automatically generated using Magic's CRUDifier."},{"role":"assistant","content":".arguments\\n   limit:long\\n   offset:long\\n   order:string\\n   direction:string\\n   operator:string\\n   type.eq:string\\n   value.like:string\\n   user.eq:string\\n.type:crud-read\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Sanity checking invocation.\\nvalidators.enum:x:@.arguments/*/operator\\n   .:or\\n   .:and\\n\\n/*\\n * Checking if user supplied an [operator] argument, and if so\\n * changing the boolean operator for comparison operations.\\n */\\nif\\n   exists:x:@.arguments/*/operator\\n   .lambda\\n\\n      // User provided a boolean comparison [operator] argument.\\n      set-name:x:../*/data.connect/*/data.read/*/where/0\\n         get-value:x:@.arguments/*/operator\\n\\n// Opening up our database connection.\\ndata.connect:[generic|magic]\\n\\n   // Parametrising our read invocation.\\n   add:x:./*/data.read\\n      get-nodes:x:@.arguments/*/limit\\n      get-nodes:x:@.arguments/*/offset\\n      get-nodes:x:@.arguments/*/order\\n      get-nodes:x:@.arguments/*/direction\\n   remove-nodes:x:@.arguments/*/operator\\n   remove-nodes:x:@.arguments/*/limit\\n   remove-nodes:x:@.arguments/*/offset\\n   remove-nodes:x:@.arguments/*/order\\n   remove-nodes:x:@.arguments/*/direction\\n   add:x:./*/data.read/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      table:users_extra\\n      columns\\n         users_extra.type\\n         users_extra.value\\n         users_extra.user\\n      where\\n         and\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Template for HTTP POST CRUD requests.\\nThis file was automatically generated using Magic's CRUDifier."},{"role":"assistant","content":".arguments\\n   type:string\\n   value:string\\n   user:string\\n.type:crud-create\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Sanity checking invocation.\\nvalidators.regex:x:@.arguments/*/type\\n   regex:^[a-zA-Z0-9-_]+$\\n\\n// Opening up database connection.\\ndata.connect:[generic|magic]\\n\\n   // Parametrising our create invocation.\\n   add:x:./*/data.create/*/values\\n      get-nodes:x:@.arguments/*\\n\\n   // Creating our record.\\n   data.create\\n      table:users_extra\\n      return-id:bool:false\\n      values\\n\\n   // Returning result of above invoction to caller.\\n   response.status.set:201\\n   unwrap:x:+/*\\n   return\\n      result:success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Template for HTTP PUT CRUD requests.\\nThis file was automatically generated using Magic's CRUDifier."},{"role":"assistant","content":".arguments\\n   user:string\\n   type:string\\n   value:string\\n.type:crud-update\\n\\n// Verifying user is authorized to access endpoint.\\nvalidators.mandatory:x:@.arguments/*/type\\nvalidators.mandatory:x:@.arguments/*/user\\nauth.ticket.verify:root\\n\\n// Opening up our database connection.\\ndata.connect:[generic|magic]\\n\\n   // Parametrising our invocation.\\n   add:x:./*/data.update/*/values\\n      get-nodes:x:@.arguments/*/[2,1000]\\n   add:x:./*/data.update/*/where/*/and\\n      get-nodes:x:@.arguments/*/[0,2]\\n\\n   // Invoking our update slot.\\n   data.update\\n      table:users_extra\\n      values\\n      where\\n         and\\n\\n   // Verifying record exists.\\n   if\\n      eq\\n         get-value:x:@data.update\\n         .:int:0\\n      .lambda\\n         response.status.set:404\\n         return\\n            result:Record not found\\n\\n   // Returning success to caller.\\n   response.status.set:202\\n   unwrap:x:+/*\\n   return\\n      affected:x:@data.update\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Template for HTTP DELETE CRUD requests.\\nThis file was automatically generated using Magic's CRUDifier."},{"role":"assistant","content":".arguments\\n   role:string\\n   user:string\\n.type:crud-delete\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root\\nvalidators.mandatory:x:@.arguments/*/role\\nvalidators.mandatory:x:@.arguments/*/user\\n\\n// Opening up our database connection.\\ndata.connect:[generic|magic]\\n\\n   // Parametrising our delete invocation.\\n   add:x:./*/data.delete/*/where/*/and\\n      get-nodes:x:@.arguments/*\\n\\n   // Deleting item from database.\\n   data.delete\\n      table:users_roles\\n      where\\n         and\\n\\n   // Returning result of above invocation to caller.\\n   unwrap:x:+/*\\n   return\\n      affected:x:@data.delete\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Template for HTTP GET CRUD requests.\\nThis file was automatically generated using Magic's CRUDifier."},{"role":"assistant","content":".arguments\\n   limit:long\\n   offset:long\\n   order:string\\n   direction:string\\n   operator:string\\n   role.eq:string\\n   user.eq:string\\n.type:crud-read\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Sanity checking invocation.\\nvalidators.enum:x:@.arguments/*/operator\\n   .:or\\n   .:and\\n\\n/*\\n * Checking if user supplied an [operator] argument, and if so\\n * changing the boolean operator for comparison operations.\\n */\\nif\\n   exists:x:@.arguments/*/operator\\n   .lambda\\n\\n      // User provided a boolean comparison [operator] argument.\\n      set-name:x:../*/data.connect/*/data.read/*/where/0\\n         get-value:x:@.arguments/*/operator\\n\\n// Opening up our database connection.\\ndata.connect:[generic|magic]\\n\\n   // Parametrising our read invocation.\\n   add:x:./*/data.read\\n      get-nodes:x:@.arguments/*/limit\\n      get-nodes:x:@.arguments/*/offset\\n      get-nodes:x:@.arguments/*/order\\n      get-nodes:x:@.arguments/*/direction\\n   remove-nodes:x:@.arguments/*/operator\\n   remove-nodes:x:@.arguments/*/limit\\n   remove-nodes:x:@.arguments/*/offset\\n   remove-nodes:x:@.arguments/*/order\\n   remove-nodes:x:@.arguments/*/direction\\n   add:x:./*/data.read/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      table:users_roles\\n      columns\\n         users_roles.role\\n         users_roles.user\\n      where\\n         and\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Template for HTTP POST CRUD requests.\\nThis file was automatically generated using Magic's CRUDifier."},{"role":"assistant","content":".arguments\\n   role:string\\n   user:string\\n.type:crud-create\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Opening up database connection.\\ndata.connect:[generic|magic]\\n\\n   // Parametrising our create invocation.\\n   add:x:./*/data.create/*/values\\n      get-nodes:x:@.arguments/*\\n\\n   // Creating our record.\\n   data.create\\n      table:users_roles\\n      return-id:bool:false\\n      values\\n\\n   // Returning result of above invoction to caller.\\n   response.status.set:201\\n   unwrap:x:+/*\\n   return\\n      result:success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Template for HTTP GET CRUD requests.\\nThis file was automatically generated using Magic's CRUDifier."},{"role":"assistant","content":".arguments\\n   operator:string\\n   username.eq:string\\n   username.like:string\\n   created.mt:date\\n   created.lt:date\\n   created.mteq:date\\n   created.lteq:date\\n.type:crud-count\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Sanity checking invocation.\\nvalidators.enum:x:@.arguments/*/operator\\n   .:or\\n   .:and\\n\\n/*\\n * Checking if user supplied an [operator] argument, and if so\\n * changing the boolean operator for comparison operations.\\n */\\nif\\n   exists:x:@.arguments/*/operator\\n   .lambda\\n\\n      // User provided a boolean comparison [operator] argument.\\n      set-name:x:../*/data.connect/*/data.read/*/where/0\\n         get-value:x:@.arguments/*/operator\\n\\n// Opening up our database connection.\\ndata.connect:[generic|magic]\\n\\n   // Parametrising our read invocation.\\n   add:x:./*/data.read\\n      get-nodes:x:@.arguments/*/operator\\n   remove-nodes:x:@.arguments/*/operator\\n   add:x:+/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      table:users\\n      columns\\n         count(*)\\n            as:count\\n      where\\n         and\\n      limit:long:1\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Template for HTTP DELETE CRUD requests.\\nThis file was automatically generated using Magic's CRUDifier."},{"role":"assistant","content":".arguments\\n   username:string\\n.type:crud-delete\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root\\nvalidators.mandatory:x:@.arguments/*/username\\n\\n// Opening up our database connection.\\ndata.connect:[generic|magic]\\n\\n   // Parametrising our delete invocation.\\n   add:x:./*/data.delete/*/where/*/and\\n      get-nodes:x:@.arguments/*\\n\\n   // Deleting item from database.\\n   data.delete\\n      table:users\\n      where\\n         and\\n\\n   // Returning result of above invocation to caller.\\n   unwrap:x:+/*\\n   return\\n      affected:x:@data.delete\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Template for HTTP GET CRUD requests.\\nThis file was automatically generated using Magic's CRUDifier."},{"role":"assistant","content":".arguments\\n   limit:long\\n   offset:long\\n   order:string\\n   direction:string\\n   username.eq:string\\n   username.like:string\\n   created.mt:date\\n   created.lt:date\\n   created.mteq:date\\n   created.lteq:date\\n.type:crud-read\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Opening up our database connection.\\ndata.connect:[generic|magic]\\n\\n   // Parametrising our read invocation.\\n   add:x:./*/data.read\\n      get-nodes:x:@.arguments/*/limit\\n      get-nodes:x:@.arguments/*/offset\\n      get-nodes:x:@.arguments/*/order\\n      get-nodes:x:@.arguments/*/direction\\n   remove-nodes:x:@.arguments/*/limit\\n   remove-nodes:x:@.arguments/*/offset\\n   remove-nodes:x:@.arguments/*/order\\n   remove-nodes:x:@.arguments/*/direction\\n   add:x:./*/data.read/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      table:users\\n      columns\\n         users.username\\n         users.created\\n      where\\n         and\\n\\n   // Mixing in roles.\\n   include:x:@data.read/*\\n      data.read\\n         table:users_roles\\n         columns\\n            role\\n         where\\n            and\\n               user.eq:x:@.dp/#/*/username\\n      for-each:x:@data.read/*\\n         unwrap:x:+/*/*\\n         add:x:././*/return/*/roles\\n            .\\n               .:x:@.dp/#/*/role\\n      return\\n         roles\\n\\n   // Mixing in users extra fields.\\n   include:x:@data.read/*\\n      data.read\\n         table:users_extra\\n         columns\\n            type\\n            value\\n         where\\n            and\\n               user.eq:x:@.dp/#/*/username\\n      for-each:x:@data.read/*\\n         unwrap:x:+/*/*/*\\n         add:x:././*/return/*/extra\\n            .\\n               .\\n                  type:x:@.dp/#/*/type\\n                  value:x:@.dp/#/*/value\\n      return\\n         extra\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Template for HTTP POST CRUD requests.\\nThis file was automatically generated using Magic's CRUDifier."},{"role":"assistant","content":".arguments\\n   username:string\\n   password:string\\n.type:crud-create\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Sanity checking invocation\\nvalidators.mandatory:x:@.arguments/*/username\\nvalidators.mandatory:x:@.arguments/*/password\\neval:x:+\\nsignal:transformers.hash-password\\n   reference:x:@.arguments/*/password\\n\\n// Opening up database connection.\\ndata.connect:[generic|magic]\\n\\n   // Parametrising our create invocation.\\n   add:x:./*/data.create/*/values\\n      get-nodes:x:@.arguments/*\\n\\n   // Creating our record.\\n   data.create\\n      table:users\\n      return-id:bool:false\\n      values\\n\\n   // Returning result of above invoction to caller.\\n   response.status.set:201\\n   unwrap:x:+/*\\n   return\\n      result:success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Override exception handler to make sure we return information to root users\\nas they're using Magic to develop or modify things."},{"role":"assistant","content":"log.error:x:@.arguments/*/message\\n   url:x:@.arguments/*/path\\n   exception:x:@.arguments/*/stack\\nadd:x:+\\n   get-nodes:x:@.arguments/*/status\\n   get-nodes:x:@.arguments/*/field\\n   get-nodes:x:@.arguments/*/message\\nreturn\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Loads appsettings.json, and returns its content to caller."},{"role":"assistant","content":".type:internal\\n\\n// Ensuring user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Loading the 'appsettings.json' file.\\nconfig.load\\n\\n// Returning file to caller.\\nreturn-value:x:@config.load\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Saves the specified configuration object to appsettings.json."},{"role":"assistant","content":".type:internal\\n\\n// Ensuring user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Converting input arguments to JSON.\\nlambda2json:x:@.arguments/*\\n   format:true\\n\\n// Saving the specified config object to the 'appsettings.json' file.\\nconfig.save:x:@lambda2json\\n\\n// Returning success to caller.\\nreturn\\n   result:success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"This file will setup your system, changing its default JWT secret, create the magic database,\\nand insert a root user - Unless the database, and/or root user exists from before.\\n\\nNotice, if the root user exists from before, this file will change its password.\\nHowever, you cannot setup the system twice, unless you manually change the JWT secret to a value\\nthat's less than 50 characters in length.\\n\\nSince the setup process always create a JWT secret that's longer than 50 character, this allows you\\nto \"reset\" your root password by removing the JWT secret, at which point you can login with\\nroot/root again to your backend."},{"role":"assistant","content":".arguments\\n   username:string\\n   password:string\\n   is_hashed:bool\\n   name:string\\n   email:string\\n.type:internal\\n\\n// Ensures user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Defaulting [is_hashed] to false and [username] to root.\\nvalidators.default:x:@.arguments\\n   is_hashed:bool:false\\n   username:root\\n\\n/*\\n * Checking if JWT secret has been changed, and if is has, we throw an exception, to prevent the\\n * system from being setup again, overriding the default setup configuration.\\n */\\nconfig.get:\"magic:auth:secret\"\\nif\\n   and\\n      not-null:x:@config.get\\n      mte\\n         strings.length:x:@config.get\\n         .:int:50\\n   .lambda\\n\\n      // System has been setup before\\n      throw:Your system has already been setup\\n         status:401\\n         public:true\\n\\n// Loading our appsettings.json file now.\\nconfig.load\\njson2lambda:x:@config.load\\n\\n// Updating auth secret to some relatively CSRNG safe value.\\nset-value:x:@json2lambda/*/magic/*/auth/*/secret\\n   crypto.random\\n      min:100\\n      max:200\\n\\n// Saving changed configuration now.\\nlambda2json:x:@json2lambda/*\\nconfig.save:x:-\\n\\n/*\\n * Sleeping for 2 seconds to allow configuration to kick\\n * in on thread pools threads.\\n * \\n * Notice, even though this is bananas, it is necessary since we're using the appsettings\\n * connection string to connect to database further down in this file and the configuration\\n * object is stale unless we sleep the thread for a couple of seconds.\\n */\\nsleep:2000\\n\\n// Ensuring our magic database is correctly created.\\nio.file.execute:/system/ensure-magic-database.hl\\n\\n/*\\n * We can start the setup process, inserting a root user, etc ...\\n * \\n * We only insert a new root user if no root user exists in users table though.\\n * If root user already exists, we change its password instead.\\n * \\n * This allows users to \"reset\" their Magic backend by changing the JWT\\n * secret to anything less than 50 characters in length, and such re-configure\\n * their backend with a new root password.\\n */\\ndata.connect:[generic|magic]\\n   data.read\\n      table:users\\n      where\\n         and\\n            username.eq:x:@.arguments/*/username\\n\\n   // Checking if root user already exists.\\n   if\\n      exists:x:@data.read/*/*\\n      .lambda\\n\\n         // Root user already exists, hence simply changing its password.\\n         execute:magic.auth.change-password\\n            password:x:@.arguments/*/password\\n            is_hashed:x:@.arguments/*/is_hashed\\n   else\\n\\n      // Inserting root user.\\n      execute:magic.auth.create-user\\n         username:x:@.arguments/*/username\\n         password:x:@.arguments/*/password\\n         is_hashed:x:@.arguments/*/is_hashed\\n         roles\\n            .:root\\n         extra\\n            email:x:@.arguments/*/email\\n            name:x:@.arguments/*/name\\n\\n   // Authenticating user and returning new JWT token to client.\\n   auth.ticket.create\\n      username:x:@.arguments/*/username\\n      roles\\n         .:root\\n   yield\\n      ticket:x:@auth.ticket.create\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns the status of the setup process back to caller."},{"role":"assistant","content":".type:internal\\n\\n// Ensures user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Checking if JWT secret has been changed.\\nconfig.get:\"magic:auth:secret\"\\nif\\n   or\\n      null:x:@config.get\\n      lt\\n         strings.length:x:@config.get\\n         .:int:50\\n   .lambda\\n\\n      // System has not been setup.\\n      return\\n         result:bool:false\\n\\n// Returns results of above invocations to caller.\\nreturn\\n   result:bool:true\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Authenticates a user returning a JWT token if successful.\\n\\nNotice, if Magic is not already setup, implying the auth secret is less than 50\\ncharacters in length, then the default username and password is root/root and is\\nhard coded.\\n\\nThe JWT token returned will contain the roles the user belongs to. This endpoint\\nwill also return extra information associated with the user."},{"role":"assistant","content":".arguments\\n   username:string\\n   password:string\\n.type:public\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/username\\nvalidators.mandatory:x:@.arguments/*/password\\n\\n/*\\n * Checking if JWT secret has been changed, and if not, simply checking if username/password is\\n * root/root, and if so returning a valid token allowing the user to setup his or her cloudlet.\\n * \\n * This is necessary to allow for configuring a new cloudlet where the user haven't selected a root\\n * password yet.\\n */\\nconfig.get:\"magic:auth:secret\"\\nif\\n   or\\n      null:x:@config.get\\n      lt\\n         strings.length:x:@config.get\\n         .:int:50\\n   .lambda\\n\\n      // System has not been setup.\\n      if\\n         and\\n            eq\\n               get-value:x:@.arguments/*/username\\n               .:root\\n            eq\\n               get-value:x:@.arguments/*/password\\n               .:root\\n         .lambda\\n\\n            // Success!\\n            auth.ticket.create\\n               username:root\\n               roles\\n                  .:root\\n            yield\\n               ticket:x:@auth.ticket.create\\n\\n/*\\n * Invokes [magic.auth.authenticate] that does the heavy lifting, and creates our JWT token,\\n * making sure we return that token to caller.\\n */\\nexecute:magic.auth.authenticate\\n   username:x:@.arguments/*/username\\n   password:x:@.arguments/*/password\\n\\n// Buffer for extra information.\\n.extra\\ndata.connect:magic\\n   data.read\\n      table:users_extra\\n      where\\n         and\\n            user.eq:x:@.arguments/*/username\\n            or\\n               type.eq:name\\n               type.eq:email\\n   for-each:x:@data.read/*\\n      set-name:x:./*/add/*/*\\n         get-value:x:@.dp/#/*/type\\n      set-value:x:./*/add/*/*\\n         get-value:x:@.dp/#/*/value\\n      add:x:@.extra\\n         .\\n            .\\n\\n// Returns the authentication JWT ticket created above to caller.\\nyield\\n   ticket:x:@execute/*/ticket\\n   extra:x:@.extra/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Changes the password of the currently authenticated user.\\n\\nThis endpoint will fail unless the caller is already successfully authenticated.\\nThe password argument will become the new password for the user."},{"role":"assistant","content":".arguments\\n   password:string\\n.type:public\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/password\\nvalidators.string:x:@.arguments/*/password\\n   min:12\\n\\n// Ensures user is authorized to access endpoint.\\nauth.ticket.verify\\n\\n/*\\n * Invokes the slot that does the heavy lifting, and updates the user's current password.\\n * \\n * This slot will change the password of the currently logged in user.\\n */\\nunwrap:x:+/*\\nsignal:magic.auth.change-password\\n   password:x:@.arguments/*/password\\n\\n// Returns success to caller.\\nreturn-nodes\\n   result:success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Generates a long lasting JWT token with the specified username and the specified role,\\nexpiring on the specified date."},{"role":"assistant","content":".arguments\\n\\n   // Mandatory username for token we should generate. Does not need to be an existing user from the database.\\n   username:string\\n\\n   // Mandatory argument being the role the returned JWT token should be associated with.\\n   role:string\\n\\n   // Mandatory expiration date for the token. Can be any future date and time.\\n   expires:date\\n.type:internal\\n\\n// Ensures user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/username\\nvalidators.mandatory:x:@.arguments/*/role\\nvalidators.mandatory:x:@.arguments/*/expires\\n\\n/*\\n * Invokes [auth.ticket.create] to create our JWT token,\\n * making sure we return the token to the caller.\\n */\\nauth.ticket.create\\n   username:x:@.arguments/*/username\\n   expires:x:@.arguments/*/expires\\n   roles\\n      .:x:@.arguments/*/role\\n\\n// Returns the authentication JWT ticket created above to caller.\\nunwrap:x:+/*\\nreturn\\n   ticket:x:@auth.ticket.create\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Verifies the specified OpenID Connect JWT Token and returns a valid application JWT token accordingly.\\n\\nThis will automatically find the issuer from the JWT token, download any public keys to verify the\\nsignature, and return the email, name and issuer from the token.\\n\\nIf it succeeds it will return a new application specific JWT token.\\nIf it fails it will throw an exception.\\n\\nNotice, the endpoint will only return valid JWT tokens for OIDC providers that are\\nregistered in the system with existing configurations. See the \"openid-providers.get.hl\" file for\\ndetails about how to register a new OIDC provider in the app."},{"role":"assistant","content":".arguments\\n   token:string\\n\\n/*\\n * Verifying token.\\n * \\n * Notice, this will throw an exception if token is not valid.\\n */\\nauth.token.verify\\n   token:x:@.arguments/*/token\\n\\n// Verifying nonce from token to avoid replay attacks.\\ncache.get:x:@auth.token.verify/*/nonce\\nif\\n   neq:x:@cache.get\\n      get-value:x:@auth.token.verify/*/issuer\\n   .lambda\\n\\n      // Oops ...!!\\n      throw:Nonce is not valid!\\n         status:int:400\\n         public:bool:true\\n\\n// Removing nonce from cache to avoid replay attacks.\\ncache.set:x:@auth.token.verify/*/nonce\\n\\n// Verifying issuer is active.\\n.active:bool:false\\nexecute-file:/system/auth/openid-providers.get.hl\\n   createNonce:bool:false\\nfor-each:x:@execute-file/*\\n   if\\n      eq:x:@.dp/#/*/issuer\\n         get-value:x:@auth.token.verify/*/issuer\\n      .lambda\\n         set-value:x:@.active\\n            .:bool:true\\nif\\n   eq:x:@.issuer\\n      .:bool:false\\n   .lambda\\n\\n      // Oops ...!\\n      throw:Not a recognized OpenID provider\\n         status:400\\n         public:bool:true\\n\\n// Buffer for extra information.\\n.extra\\n\\n// External OpenID provider has been verified, now we need to check to see if user exists in local database.\\ndata.connect:magic\\n\\n   // Checking if user exists.\\n   data.read\\n      table:users\\n      where\\n         and\\n            username.eq:x:@auth.token.verify/*/email\\n   if\\n      exists:x:@data.read/*\\n      .lambda\\n\\n         /*\\n          * User has been previously created.\\n          * \\n          * Invoking [magic.auth.authenticate] that does the heavy lifting, and creates our JWT token,\\n          * making sure we return that token to caller.\\n          * \\n          * Notice, we ignore the password!\\n          */\\n         execute:magic.auth.authenticate\\n            password-check:bool:false\\n            username:x:@auth.token.verify/*/email\\n\\n         // Retrieving extra information.\\n         data.connect:magic\\n            data.read\\n               table:users_extra\\n               where\\n                  and\\n                     user.eq:x:@auth.token.verify/*/email\\n                     or\\n                        type.eq:name\\n                        type.eq:email\\n            for-each:x:@data.read/*\\n               set-name:x:./*/add/*/*\\n                  get-value:x:@.dp/#/*/type\\n               set-value:x:./*/add/*/*\\n                  get-value:x:@.dp/#/*/value\\n               add:x:@.extra\\n                  .\\n                     .\\n\\n         // Returns the authentication JWT ticket created above to caller.\\n         yield\\n            ticket:x:@execute/*/ticket\\n            extra:x:@.extra/*\\n\\n   // First time login, creating a new user with username being email address.\\n   data.create\\n      table:users\\n      values\\n         username:x:@auth.token.verify/*/email\\n         password:openid-connect\\n\\n   // Associating user with \"guest\" role.\\n   data.create\\n      table:users_roles\\n      values\\n         user:x:@auth.token.verify/*/email\\n         role:guest\\n\\n   // Storing email as extra field.\\n   data.create\\n      table:users_extra\\n      values\\n         user:x:@auth.token.verify/*/email\\n         type:email\\n         value:x:@auth.token.verify/*/email\\n\\n   // Checking to see if we've got a name value, and if we do we associate it with the user we create.\\n   if\\n      exists:x:@auth.token.verify/*/name\\n      .lambda\\n\\n         // We've got name, storing it.\\n         data.create\\n            table:users_extra\\n            values\\n               user:x:@auth.token.verify/*/email\\n               type:name\\n               value:x:@auth.token.verify/*/name\\n\\n   // Retrieving extra information.\\n   data.connect:magic\\n      data.read\\n         table:users_extra\\n         where\\n            and\\n               user.eq:x:@auth.token.verify/*/email\\n               or\\n                  type.eq:name\\n                  type.eq:email\\n      for-each:x:@data.read/*\\n         set-name:x:./*/add/*/*\\n            get-value:x:@.dp/#/*/type\\n         set-value:x:./*/add/*/*\\n            get-value:x:@.dp/#/*/value\\n         add:x:@.extra\\n            .\\n               .\\n\\n/*\\n * Invoking [magic.auth.authenticate] that does the heavy lifting, and creates our JWT token,\\n * making sure we return that token to caller.\\n */\\nexecute:magic.auth.authenticate\\n   username:x:@auth.token.verify/*/email\\n   password-check:bool:false\\n\\n// Returns the authentication JWT ticket created above to caller.\\nyield\\n   ticket:x:@execute/*/ticket\\n   extra:x:@.extra/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns all supported OpenID Connect providers the system supports, if any.\\n\\nNotice, this endpoint can be extended by creating a slot named [magic.openid.providers-XYZ]\\nthat returns additional OpenID providers, which will inject new providers into the core of the system.\\n\\nSee the code for the slot named [magic.openid.providers.google] for an example."},{"role":"assistant","content":".arguments\\n   createNonce:bool\\n\\n// Finding all slots declaring OpenID Providers.\\nslots.vocabulary:magic.openid.providers.\\n\\n// Looping through each slot returned above and executing it.\\nfor-each:x:@slots.vocabulary/*\\n\\n   // Changing slot invocation name.\\n   set-value:x:./*/execute\\n      get-value:x:@.dp/#\\n\\n   /*\\n    * Executing slot to retrieve supported providers.\\n    * \\n    * Notice, name of slot (value of node) is dynamically created above.\\n    */\\n   execute\\n      createNonce:x:@.arguments/*/createNonce\\n\\n   // Looping through all providers returned above to return them to client.\\n   for-each:x:@execute/*\\n\\n      // Sanity checking OpenID provider.\\n      if\\n         or\\n            not-exists:x:@.dp/#/*/issuer\\n            not-exists:x:@.dp/#/*/name\\n         .lambda\\n\\n            // Oops, bogus provider ...!!\\n            throw:Bogus OpenID provider\\n               status:int:500\\n               public:bool:true\\n\\n      /*\\n       * Checking that this particular provider was not registered\\n       * by some other slot invocation perviously.\\n       * \\n       * This prevents having two different slots in two different modules\\n       * registering the same OpenID Connect provider twice.\\n       */\\n      .exists:bool:false\\n      for-each:x:../*/return/*\\n         if\\n            eq:x:@.dp/#/*/issuer\\n               get-value:x:@for-each/@.dp/#/*/issuer\\n            .lambda\\n\\n               // OpenID provider already exists.\\n               set-value:x:@.exists\\n                  .:bool:true\\n\\n      // Adding provider unless it was registered by another slot invoction.\\n      if\\n         eq:x:@.exists\\n            .:bool:false\\n         .lambda\\n\\n            // Adding currently iterated provider to [return] invocation below.\\n            add:x:../*/return\\n               get-nodes:x:@.dp/#\\n\\n// Returning providers to client.\\nreturn\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns reCAPTCHA key."},{"role":"assistant","content":".type:public\\n\\n// Retrieving key configuration setting and returning to caller.\\nconfig.get:\"magic:auth:recaptcha:key\"\\nunwrap:x:+/*\\nreturn-nodes\\n   result:x:@config.get\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns reCAPTCHA secret and key."},{"role":"assistant","content":".type:internal\\n\\n// Making sure user is allowed to invoke endpoint\\nauth.ticket.verify:root\\n\\n// Retrieving key configuration setting and returning to caller.\\nconfig.get:\"magic:auth:recaptcha:secret\"\\nconfig.get:\"magic:auth:recaptcha:key\"\\nunwrap:x:+/*\\nreturn-nodes\\n   key:x:@config.get\\n   secret:x:@config.get/@config.get\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Sets the reCAPTCHA key and secret to the specified values."},{"role":"assistant","content":".arguments\\n   key:string\\n   secret:string\\n.type:internal\\n\\n// Making sure user is allowed to invoke endpoint\\nauth.ticket.verify:root\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/key\\nvalidators.mandatory:x:@.arguments/*/secret\\n\\n// Updating settings.\\nconfig.load\\njson2lambda:x:-\\nremove-nodes:x:@json2lambda/*/magic/*/auth/*/recaptcha\\nunwrap:x:+/*/*/*\\nadd:x:@json2lambda/*/magic/*/auth\\n   .\\n      recaptcha\\n         key:x:@.arguments/*/key\\n         secret:x:@.arguments/*/secret\\n\\n// Saving updated settings.\\nlambda2json:x:@json2lambda/*\\nconfig.save:x:-\\n\\n// Retrieving key configuration setting and returning to caller.\\nreturn-nodes\\n   result:success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Will refresh the currently authenticated user's token, and return a new JWT token with a new expiration date."},{"role":"assistant","content":".type:public\\n\\n// Ensures user is authorized to access endpoint.\\nauth.ticket.verify\\n\\n/*\\n * Invokes [auth.ticket.refresh] that does the heavy lifting, and creates our JWT token,\\n * making sure we return that token to caller.\\n */\\nauth.ticket.refresh\\n\\n// Returns the authentication JWT ticket created above to caller.\\nyield\\n   ticket:x:@auth.ticket.refresh\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Authenticates the user with the specified [username] and [password] combination.\\n\\nReturns a JWT token that can be used for consecutive access to the backend."},{"role":"assistant","content":"slots.create:magic.auth.authenticate\\n\\n   // Opens up our database connection.\\n   data.connect:magic\\n\\n      // Selects password from our users table belonging to specified [username].\\n      data.read\\n         table:users\\n         columns\\n            password\\n         where\\n            and\\n               username.eq:x:@.arguments/*/username\\n\\n      // Checking if user with specified [username] exists.\\n      if\\n         not-exists:x:@data.read/*\\n         .lambda\\n\\n            // No such user.\\n            throw:Access denied\\n               status:int:401\\n               public:bool:true\\n\\n      // Verifying that the password is a match.\\n      if\\n         or\\n            eq:x:@.arguments/*/password-check\\n               .:bool:false\\n            crypto.password.verify:x:@.arguments/*/password\\n               hash:x:@data.read/*/*/password\\n         .lambda\\n\\n            // Logging the fact that user successfully logged in.\\n            log.info:User successfully authenticated\\n               username:x:@.arguments/*/username\\n\\n            // Now we need to select all roles user belongs to.\\n            data.read\\n               table:users_roles\\n               columns\\n                  role\\n               where\\n                  and\\n                     user.eq:x:@.arguments/*/username\\n\\n            // Parametrizing [auth.ticket.create] with roles user belongs to.\\n            add:x:./*/auth.ticket.create/*/roles\\n               get-nodes:x:@data.read/*/*\\n\\n            // Now we can create our JWT token/ticket.\\n            auth.ticket.create\\n               username:x:@.arguments/*/username\\n               expires:x:@.arguments/*/expires\\n               roles\\n\\n            // Returning JWT token to caller.\\n            yield\\n               ticket:x:@auth.ticket.create\\n\\n      // Hash version of password didn't match.\\n      throw:Access denied\\n         status:int:401\\n         public:bool:true\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Changes the password of the currently authenticated user.\\n\\nRequires the user to be successfully authenticated, and an [.arguments]/[password]\\nbeing the new password to use for authenticated user."},{"role":"assistant","content":"slots.create:magic.auth.change-password\\n\\n   // Ensuring a password was actually provided.\\n   validators.mandatory:x:@.arguments/*/password\\n\\n   /*\\n    * Retrieving currently authenticated user's username, and sanity checking to make sure\\n    * client actually is authenticated.\\n    */\\n   auth.ticket.get\\n   if\\n      null:x:@auth.ticket.get\\n      .lambda\\n\\n         // Oops ...!!\\n         throw:Access denied\\n            status:int:401\\n            public:bool:true\\n\\n   // Hashing password.\\n   .password\\n   set-value:x:@.password\\n      crypto.password.hash:x:@.arguments/*/password\\n\\n   // Opens up our database connection.\\n   data.connect:magic\\n      database-type:sqlite\\n\\n      /*\\n       * Changes the password of the currently logged in user\\n       * to whatever new password user provided.\\n       */\\n      data.update\\n         table:users\\n         values\\n            password:x:@.password\\n         where\\n            and\\n               username.eq:x:@auth.ticket.get\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Creates a user and inserts into the \"magic\" database,\\nwith the username/password specified in the [.arguments] collection,\\nand belonging to the specified [roles] from the [.arguments] collection.\\n\\nPassword is cryptographically hashed using the blow fish hashing algorithm,\\nand cryptographically and securely stored with a per-record based salt in the\\n\"users\" table."},{"role":"assistant","content":"slots.create:magic.auth.create-user\\n\\n   // Hashing password if we should.\\n   .password\\n   if\\n      get-value:x:@.arguments/*/is_hashed\\n      .lambda\\n\\n         // Password is already hashed.\\n         set-value:x:@.password\\n            get-value:x:@.arguments/*/password\\n   else\\n\\n      // Password is not hashed, hashing it.\\n      set-value:x:@.password\\n         crypto.password.hash:x:@.arguments/*/password\\n\\n   // Opening up a database connection to magic.\\n   data.connect:magic\\n\\n      // Inserting user.\\n      data.create\\n         table:users\\n         values\\n            username:x:@.arguments/*/username\\n            password:x:@.password\\n\\n      // Inserting all roles.\\n      for-each:x:@.arguments/*/roles/*\\n\\n         // Then inserting into users_roles an association between user and role.\\n         data.create\\n            table:users_roles\\n            values\\n               role:x:@.dp/#\\n               user:x:@.arguments/*/username\\n\\n      // Inserting optionally supplied extra information.\\n      if\\n         exists:x:@.arguments/*/extra/*\\n         .lambda\\n\\n            // Looping through each extra child specified.\\n            for-each:x:@.arguments/*/extra/*\\n\\n               // Temporary variables.\\n               .type\\n               .value\\n               set-value:x:@.type\\n                  get-name:x:@.dp/#\\n               set-value:x:@.value\\n                  get-value:x:@.dp/#\\n\\n               // Then inserting into users_extra an association between user and extra value.\\n               data.create\\n                  table:users_extra\\n                  values\\n                     user:x:@.arguments/*/username\\n                     type:x:@.type\\n                     value:x:@.value\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"This slot returns the Google OpenID provider.\\n\\nThis slot will be invoked by the framework whenever the system needs to know which OIDC providers\\nare supported by the system due to its name. Any slot named [magic.openid.providers.XYZ] will be invoked\\nwhen the system needs to know which OIDC providers are supported.\\n\\nThis allows you to extend the system with additional OIDC providers according to your requirements.\\nNotice, the system only supports \"id_token\" types of providers at the moment, so any additional provider\\nyou want to register must be of type \"id_token\"."},{"role":"assistant","content":"slots.create:magic.openid.providers.google\\n\\n   // Sanity checking invocation.\\n   validators.mandatory:x:@.arguments/*/createNonce\\n\\n   // Getting client ID for Google from configuration.\\n   .client-id\\n   set-value:x:@.client-id\\n      config.get:\"magic:oidc:google:client-id\"\\n\\n   // Checking to see if we've got Google provider configured.\\n   if\\n      not-null:x:@.client-id\\n      .lambda\\n\\n         // Buffer for nonce.\\n         .nonce\\n\\n         // Checking if caller wants us to generate a nonce.\\n         if\\n            eq:x:@.arguments/*/createNonce\\n               .:bool:true\\n            .lambda\\n\\n               // Creating a unique nonce.\\n               set-value:x:@.nonce\\n                  crypto.random\\n                     min:20\\n                     max:30\\n\\n               /*\\n                * Storing nonce to avoid replay attacks.\\n                * \\n                * Notice, nonce is only stored for 60 minutes, implying the configuration\\n                * returned below can only be used within 60 minutes of having been generated.\\n                * \\n                * And we store the issuer value in cache such that we can verify later that the id_token\\n                * was created by the correct issuer.\\n                */\\n               cache.set:x:@.nonce\\n                  value:\"https://accounts.google.com\"\\n                  expiration:3600\\n\\n               // Making sure we return nonce to caller.\\n               add:x:@.lambda/@.lambda/*/add/*/*\\n                  .\\n                     nonce:x:@.nonce\\n                     url:\"https://accounts.google.com/o/oauth2/v2/auth\"\\n                     client_id:x:@.client-id\\n                     response_type:id_token\\n                     scope:openid email profile\\n\\n         // Returning providers to caller.\\n         unwrap:x:+/*/*/*\\n         add:x:../*/return\\n            .\\n               .\\n                  name:Google\\n                  issuer:\"https://accounts.google.com\"\\n\\n   // Returning result to caller.\\n   return\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns the manifests for all installed apps."},{"role":"assistant","content":".type:internal\\n\\n// Ensures user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n/*\\n * Listing all folders in the modules folders, traveres each folder,\\n * checking for a manifest file, and if existing returning the manifest\\n * to caller.\\n */\\nio.folder.list:/modules/\\nfor-each:x:@io.folder.list/*\\n\\n   // Retrieving manifest.hl file's information, if existing.\\n   strings.concat\\n      get-value:x:@.dp/#\\n      .:manifest.hl\\n   if\\n      io.file.exists:x:@strings.concat\\n      .lambda\\n\\n         // Loading file, transforming to lambda, and returning to caller.\\n         io.file.load:x:@strings.concat\\n         hyper2lambda:x:@io.file.load\\n         add:x:+/*/*\\n            get-nodes:x:@hyper2lambda/*\\n         add:x:../*/return\\n            .\\n               .\\n\\n// Returning result to caller.\\nreturn\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Installs the specified Bazar module into the local server.\\n\\nNotice, this will download the specified ZIP file, extract\\nit, and correctly rename it - For then to install the plugin."},{"role":"assistant","content":".arguments\\n   url:string\\n   name:string\\n   type:string\\n.type:internal\\n\\n// Ensures user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Defaulting type to \"module\".\\nvalidators.default:x:@.arguments\\n   type:module\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/url\\nvalidators.mandatory:x:@.arguments/*/name\\n\\n// Running actual installation on a different thread.\\ninsert-before:x:./*/fork/0\\n   get-nodes:x:@.arguments\\nfork\\n\\n   // Making sure we catch exceptions such that we can log errors.\\n   try\\n\\n      // Checking what type of plugin this is.\\n      switch:x:@.arguments/*/type\\n         case:module\\n\\n            /*\\n             * Verifying that folder doesn't already exist, as in that plugin\\n             * is already installed - And if plugin is already installed, we\\n             * delete the folder first which will uninstall the plugin.\\n             */\\n            strings.concat\\n               .:/modules/\\n               get-value:x:@.arguments/*/name\\n               .:/uninstall.hl\\n            if\\n               io.file.exists:x:@strings.concat\\n               .lambda\\n\\n                  // Uninstall file exists\\n                  log.info:Uninstalling module\\n                     module:x:@strings.concat\\n                  io.file.execute:x:@strings.concat\\n\\n            // Downloading zip file as binary content from specified URL.\\n            http.get:x:@.arguments/*/url\\n\\n            /*\\n             * Saving file to modules folder using the 'filename' argument specified\\n             * by its HTTP Content-Disposition header.\\n             */\\n            strings.split:x:@http.get/*/headers/*/Content-Disposition\\n               .:=\\n            strings.trim:x:@strings.split/1\\n               .:\"\\\"\"\\n            strings.concat\\n               .:/modules/\\n               get-value:x:@strings.trim\\n            io.file.save.binary:x:@strings.concat\\n               get-value:x:@http.get/*/content\\n\\n            // Unzipping downloaded ZIP file.\\n            .folder\\n            set-value:x:@.folder\\n               strings.concat\\n                  .:/modules/\\n                  get-value:x:@.arguments/*/name\\n                  .:/\\n\\n            // Checking if folder already exists, at which point we delete it.\\n            if\\n               io.folder.exists:x:@.folder\\n               .lambda\\n                  io.folder.delete:x:@.folder\\n\\n            // Creating folder and unzipping file.\\n            io.folder.create:x:@.folder\\n            io.file.unzip:x:@strings.concat\\n               folder:x:@.folder\\n\\n            // Deleting ZIP file.\\n            io.file.delete:x:@strings.concat\\n\\n            /*\\n             * Checking if the ZIP file resulted in creating the module folder,\\n             * otherwise renaming folder accordingly.\\n             */\\n            .module-folder\\n            set-value:x:@.module-folder\\n               strings.concat\\n                  .:/modules/\\n                  get-value:x:@.arguments/*/name\\n                  .:/\\n            if\\n               not\\n                  io.folder.exists:x:@.module-folder\\n               .lambda\\n\\n                  // Renaming the folder to the name specified by caller.\\n                  strings.split:x:@strings.concat\\n                     .:.zip\\n                  io.folder.move:x:@strings.split/0\\n                     get-value:x:@.module-folder\\n\\n            // Running through installation process of plugin.\\n            strings.split:x:@.module-folder\\n               .:/\\n            execute:magic.modules.install-module\\n               module:x:@strings.split/0/-\\n\\n            // Notifying client that installation is done.\\n            sockets.signal:magic.backend.message\\n               roles:root\\n               args\\n                  message:Plugin was successfully installed\\n                  type:success\\n         case:frontend\\n\\n            // Downloading zip file as binary content from specified URL.\\n            strings.concat\\n               get-value:x:@.arguments/*/url\\n               .:&type=frontend\\n            http.get:x:@strings.concat\\n\\n            /*\\n             * Saving file to modules folder using the 'filename' argument specified\\n             * by its HTTP Content-Disposition header.\\n             */\\n            strings.split:x:@http.get/*/headers/*/Content-Disposition\\n               .:=\\n            strings.trim:x:@strings.split/1\\n               .:\"\\\"\"\\n            strings.concat\\n               .:/modules/\\n               get-value:x:@strings.trim\\n            io.file.save.binary:x:@strings.concat\\n               get-value:x:@http.get/*/content\\n\\n            // Unzipping downloaded ZIP file into www folder.\\n            io.file.unzip:x:@strings.concat\\n               folder:/etc/www/\\n               overwrite:true\\n\\n            // Deleting ZIP file.\\n            io.file.delete:x:@strings.concat\\n\\n            // Notifying client that installation is done.\\n            sockets.signal:magic.backend.message\\n               roles:root\\n               args\\n                  message:Frontend was successfully installed\\n                  type:success\\n   .catch\\n\\n      // Oops ...!!\\n      log.error:Could not install plugin\\n         message:x:@.arguments/*/message\\n\\n      // Notifying client that some error occurred.\\n      sockets.signal:magic.backend.message\\n         roles:root\\n         args\\n            message:Plugin could not be installed, check your log for details\\n            type:error\\n\\n// Returning success to caller.\\nreturn\\n   result:success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns all workflow actions to caller."},{"role":"assistant","content":"\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Buffer for all actions in the system.\\n.result\\n\\n// Retrieving all system actions.\\nadd:x:@.result\\n   io.file.list-recursively:/misc/workflows/actions/\\n\\n// Retrieving all custom actions.\\nif\\n   io.folder.exists:/etc/workflows/actions/\\n   .lambda\\n      add:x:@.result\\n         io.file.list-recursively:/etc/workflows/actions/\\n\\n// Then iterating through each installed module, and retrieving all module actions.\\nio.folder.list:/modules/\\nfor-each:x:@io.folder.list/*\\n   strings.concat\\n      get-value:x:@.dp/#\\n      .:workflows/actions/\\n   if\\n      io.folder.exists:x:@strings.concat\\n      .lambda\\n\\n         // Module has custom actions.\\n         insert-before:x:@.result/0\\n            io.file.list-recursively:x:@strings.concat\\n\\n// Filtering out everything not ending with '.hl'.\\nfor-each:x:@.result/*\\n   if\\n      strings.ends-with:x:@.dp/#\\n         .:.hl\\n      .lambda\\n\\n         // Loading file to add meta data.\\n         load-file:x:@.dp/#\\n         hyper2lambda:x:-\\n            comments:true\\n         if\\n            eq\\n               get-name:x:@hyper2lambda/0\\n               .:..\\n            .lambda\\n               unwrap:x:+/*/*\\n               add:x:@.lambda/@.lambda/0/-/*/*\\n                  .\\n                     description:x:@hyper2lambda/0\\n\\n         // Decorating return value.\\n         unwrap:x:+/*/*\\n         add:x:@.lambda/0/-/*/*\\n            .\\n               icon:x:@hyper2lambda/*/.icon\\n\\n         // Creating a name for action by using filename.\\n         strings.split:x:@.dp/#\\n            .:/\\n         strings.split:x:-/0/-\\n            .:.\\n         remove-nodes:x:@strings.split/0/-\\n         strings.join:x:@strings.split/0\\n            .:.\\n\\n         // Returning result to caller.\\n         unwrap:x:+/*/*/*\\n         add:x:../*/return\\n            .\\n               .\\n                  name:x:@strings.join\\n                  filename:x:@.dp/#\\n\\n// Returning result to caller.\\nreturn\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns arguments the specified file can handle."},{"role":"assistant","content":".arguments\\n   file:string\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n/*\\n * Loading action file and transforming Hyperlambda to lambda and making sure\\n * we return [.arguments] collection as [input].\\n * \\n * This becomes our input arguments to our action.\\n */\\nload-file:x:@.arguments/*/file\\nhyper2lambda:x:@load-file\\nadd:x:./*/return\\n   get-nodes:x:@hyper2lambda/*/.arguments/*\\n\\n// Returning arguments to caller.\\nreturn\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns the arguments the specified Hyperlambda can handle."},{"role":"assistant","content":".arguments\\n   hyperlambda:string\\n   path:string\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Checking if caller provided a [path] argument instead of a [hyperlambda] argument.\\nif\\n   and\\n      not-exists:x:@.arguments/*/hyperlambda\\n      exists:x:@.arguments/*/path\\n      not-null:x:@.arguments/*/path\\n   .lambda\\n\\n      // Loading file.\\n      load-file:x:@.arguments/*/path\\n      unwrap:x:+/*/*\\n      add:x:@.arguments\\n         .\\n            hyperlambda:x:@load-file\\n\\n// Converting Hyperlambda to lambda.\\nhyper2lambda:x:@.arguments/*/hyperlambda\\n   comments:true\\n\\n// Verifying that file is possible to invoke, as in the file has an [.arguments] collection.\\nif\\n   and\\n      exists:x:@.arguments/*/path\\n      exists:x:@hyper2lambda/*/.arguments\\n   .lambda\\n\\n      // Signaling to frontend that file has an [.arguments] collection.\\n      add:x:../*/return-nodes\\n         .\\n            function:bool:true\\n\\n      /*\\n       * Removing [session], [user-id] and [type], since these are\\n       * dynamically added to the function invocation by the framework.\\n       */\\n      if\\n         exists:x:@.arguments/*/path\\n         .lambda\\n            remove-nodes:x:@hyper2lambda/*/.arguments/*/_session\\n            remove-nodes:x:@hyper2lambda/*/.arguments/*/_user-id\\n            remove-nodes:x:@hyper2lambda/*/.arguments/*/_type\\nelse\\n\\n   // Signaling to frontend that file does not have an [.arguments] collection.\\n   add:x:../*/return-nodes\\n      .\\n         function:bool:false\\n\\n/*\\n * Iterating through each argument Hyperlambda can handle.\\n * \\n * Notice, we ONLY return the first 100 arguments to avoid context overflow.\\n */\\nfor-each:x:@hyper2lambda/*/.arguments/*/[0,100]\\n   if\\n      neq\\n         get-name:x:@.dp/#\\n         .:..\\n      .lambda\\n\\n         // Checking if user provided a [path], at which point we return more data.\\n         if\\n            exists:x:@.arguments/*/path\\n            .lambda\\n\\n               // User provided a [path].\\n               set-value:x:+/+/*/*/*/name\\n                  get-name:x:@.dp/#\\n               set-value:x:+/*/*/*/type\\n                  get-value:x:@.dp/#\\n               add:x:../*/return-nodes/*/args\\n                  .\\n                     .\\n                        name\\n                        type\\n\\n               // Checking if we've got an argument description / comment.\\n               if\\n                  eq\\n                     get-name:x:@.dp/#/-\\n                     .:..\\n                  .lambda\\n                     unwrap:x:+/*/*\\n                     add:x:../*/return-nodes/*/args/0/-\\n                        .\\n                           description:x:@.dp/#/-\\n         else\\n\\n            // User provided [hyperlambda] argument.\\n            set-name:x:+/+/*/*\\n               get-name:x:@.dp/#\\n            unwrap:x:+/*/*\\n            add:x:../*/return-nodes/*/args\\n               .\\n                  name:x:@.dp/#\\n\\n// Fetching description if existing.\\n.desc\\nif\\n   eq\\n      get-name:x:@hyper2lambda/0\\n      .:..\\n   .lambda\\n      set-value:x:@.desc\\n         get-value:x:@hyper2lambda/0\\n\\n// Returning arguments to caller, together with their type information.\\nunwrap:x:+/*\\nreturn-nodes\\n   args\\n   description:x:@.desc\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns Hyperlambda required to execute action or snippet."},{"role":"assistant","content":".arguments\\n   filename:string\\n   args:*\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Loading action/snippet Hyperlambda file and transforming to lambda object.\\nload-file:x:@.arguments/*/filename\\n\\n// Checking if this is a action template.\\nif\\n   strings.contains:x:@.arguments/*/filename\\n      .:/workflows/actions/\\n   .lambda\\n\\n      /*\\n       * This is an action template type of snippet.\\n       * Parametrizing accordingly.\\n       */\\n      .action\\n      add:x:@.action\\n         hyper2lambda:x:@load-file\\n            comments:true\\n\\n      // Creating our action invocation.\\n      .invocation\\n         execute:magic.workflows.actions.execute\\n            name\\n            filename\\n            arguments\\n      set-value:x:@.invocation/*/execute/*/name\\n         get-value:x:@.arguments/*/args/*/action_name\\n      remove-nodes:x:@.arguments/*/args/*/action_name\\n      set-value:x:@.invocation/*/execute/*/filename\\n         get-value:x:@.arguments/*/filename\\n\\n      // Creating our action comment.\\n      if\\n         eq\\n            get-name:x:@.action/0\\n            .:..\\n         .lambda\\n            unwrap:x:+/*/*\\n            insert-before:x:@.invocation/0\\n               .\\n                  ..:x:@.action/0\\n\\n      // Making sure we correctly convert arguments according to type declaration.\\n      for-each:x:@.arguments/*/args/**\\n         if\\n            strings.starts-with:x:@.dp/#\\n               .:\":x:\"\\n            .lambda\\n               strings.substring:x:@.dp/#\\n                  .:int:3\\n               set-x:x:@.dp/#\\n                  convert:x:@strings.substring\\n                     type:x\\n         else\\n            get-name:x:@.dp/#\\n            switch:x:@.action/*/.arguments/*/{@get-name}/*/type\\n               case:long\\n               case:decimal\\n               case:int\\n               case:float\\n               case:double\\n                  set-value:x:@.dp/#\\n                     convert:x:@.dp/#\\n                        type:x:@.action/*/.arguments/*/{@get-name}/*/type\\n               case:hyperlambda\\n                  add:x:@.dp/#\\n                     hyper2lambda:x:@.dp/#\\n                        comments:true\\n                  set-value:x:@.dp/#\\n\\n      // Decorating action arguments according to [.arguments]/[args].\\n      add:x:@.invocation/*/execute/*/arguments\\n         get-nodes:x:@.arguments/*/args/*\\n\\n      // Returning result to caller as Hyperlambda.\\n      lambda2hyper:x:@.invocation/*\\n         comments:true\\n      yield\\n         result:x:@lambda2hyper\\nelse\\n\\n   // This is a template snippet, returning as is.\\n   unwrap:x:+/*\\n   return\\n      result:x:@load-file\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns all workflow snippets to caller."},{"role":"assistant","content":"\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Buffer for all snippets in the system.\\n.result\\n\\n// Retrieving all system snippets.\\nadd:x:@.result\\n   io.file.list-recursively:/misc/workflows/snippets/\\n\\n// Retrieving all custom snippets.\\nif\\n   io.folder.exists:/etc/workflows/snippets/\\n   .lambda\\n      add:x:@.result\\n         io.file.list-recursively:/etc/workflows/snippets/\\n\\n// Then iterating through each installed module, and retrieving all module snippets.\\nio.folder.list:/modules/\\nfor-each:x:@io.folder.list/*\\n   strings.concat\\n      get-value:x:@.dp/#\\n      .:workflows/snippets/\\n   if\\n      io.folder.exists:x:@strings.concat\\n      .lambda\\n\\n         // Module has custom snippets.\\n         insert-before:x:@.result/0\\n            io.file.list-recursively:x:@strings.concat\\n\\n// Filtering out everything not ending with '.hl'.\\nfor-each:x:@.result/*\\n   if\\n      strings.ends-with:x:@.dp/#\\n         .:.hl\\n      .lambda\\n\\n         // Loading file to add meta data.\\n         load-file:x:@.dp/#\\n         hyper2lambda:x:-\\n            comments:true\\n         if\\n            eq\\n               get-name:x:@hyper2lambda/0\\n               .:..\\n            .lambda\\n               unwrap:x:+/*/*\\n               add:x:@.lambda/@.lambda/0/-/*/*\\n                  .\\n                     description:x:@hyper2lambda/0\\n                     content:x:@load-file\\n\\n         // Creating a name for snippet by using filename.\\n         strings.split:x:@.dp/#\\n            .:/\\n         strings.split:x:-/0/-\\n            .:.\\n         remove-nodes:x:@strings.split/0/-\\n         strings.join:x:@strings.split/0\\n            .:.\\n\\n         // Returning result to caller.\\n         unwrap:x:+/*/*/*\\n         add:x:../*/return\\n            .\\n               .\\n                  name:x:@strings.join\\n                  filename:x:@.dp/#\\n\\n// Returning result to caller.\\nreturn\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns all workflows to caller."},{"role":"assistant","content":"\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Buffer for all workflows in the system.\\n.result\\n\\n// Retrieving all system workflows.\\nadd:x:@.result\\n   io.file.list-recursively:/misc/workflows/workflows/\\n\\n// Retrieving all custom workflows.\\nif\\n   io.folder.exists:/etc/workflows/workflows/\\n   .lambda\\n      add:x:@.result\\n         io.file.list-recursively:/etc/workflows/workflows/\\n\\n// Then iterating through each installed module, and retrieving all module workflows.\\nio.folder.list:/modules/\\nfor-each:x:@io.folder.list/*\\n   strings.concat\\n      get-value:x:@.dp/#\\n      .:workflows/workflows/\\n   if\\n      io.folder.exists:x:@strings.concat\\n      .lambda\\n\\n         // Module has custom actions.\\n         add:x:@.result\\n            io.file.list-recursively:x:@strings.concat\\n\\n// Filtering out everything not ending with '.hl'.\\nfor-each:x:@.result/*\\n   if\\n      strings.ends-with:x:@.dp/#\\n         .:.hl\\n      .lambda\\n\\n         // Returning workflows file to caller.\\n         unwrap:x:+/*/*\\n         add:x:../*/return\\n            .\\n               .:x:@.dp/#\\n\\n// Returning result to caller.\\nreturn\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Slot that executes a single workflow action."},{"role":"assistant","content":"slots.create:magic.workflows.actions.execute\\n\\n   // Sanity checking invocation.\\n   validators.mandatory:x:@.arguments/*/name\\n   validators.mandatory:x:@.arguments/*/filename\\n\\n   /*\\n    * Checking if we're authenticated as root user, and if so,\\n    * publishing a socket message as \"debug info\" back to caller.\\n    */\\n   .time\\n   if\\n      auth.ticket.in-role:root\\n      .lambda\\n\\n         // Publishing socket debug message to client.\\n         add:x:./*/sockets.signal/*/args/*/input\\n            get-nodes:x:@.arguments/*/arguments/*\\n         unwrap:x:+/**\\n         sockets.signal:magic.workflows.action\\n            roles:root\\n            args\\n               type:action\\n               name:x:@.arguments/*/name\\n               input\\n         set-value:x:@.time\\n            date.now\\n\\n   // Making sure we're able to catch exceptions.\\n   try\\n\\n      // Parametrising [execute-file].\\n      add:x:./*/execute-file\\n         get-nodes:x:@.arguments/*/arguments/*\\n\\n      // Executing action.\\n      execute-file:x:@.arguments/*/filename\\n\\n      /*\\n       * Checking if we're authenticated as root user, and if so,\\n       * publishing a socket message as \"debug info\" back to caller.\\n       */\\n      if\\n         auth.ticket.in-role:root\\n         .lambda\\n\\n            // Publishing socket debug message to client.\\n            add:x:./*/sockets.signal/*/args/*/output\\n               get-nodes:x:@execute-file/*\\n            math.subtract\\n               date.now\\n               get-value:x:@.time\\n            unwrap:x:+/**\\n            sockets.signal:magic.workflows.action\\n               roles:root\\n               args\\n                  type:result\\n                  time:x:@math.subtract\\n                  output\\n\\n      // Decorating [result] node.\\n      set-value:x:./*/return\\n         get-value:x:@.arguments/*/name\\n      add:x:./*/return\\n         get-nodes:x:@execute-file/*\\n\\n      // Returning result of invocation to caller.\\n      return\\n   .catch\\n\\n      /*\\n       * Checking if we're authenticated as root user, and if so,\\n       * publishing a socket message as \"debug info\" back to caller.\\n       */\\n      if\\n         auth.ticket.in-role:root\\n         .lambda\\n\\n            // Publishing socket debug message to client.\\n            unwrap:x:+/**\\n            sockets.signal:magic.workflows.action\\n               roles:root\\n               args\\n                  type:error\\n                  message:x:@.arguments/*/message\\n\\n      // Rethrowing exception\\n      throw:x:@.arguments/*/message\\n         status:x:@.arguments/*/status\\n         public:x:@.arguments/*/public\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Verifies the specified CAPTCHA, and throws an exception if it's not valid.\\n\\nThis logic relies upon Proof of Work, which implies a SHA256 hash value with [workload]\\namount of trailing zeros, which can only be created by brute force until a valid hash\\nhas been generated.\\n\\nThe slot handles two different versions of a token, one that relies upon it being\\ngenerated less than [age] milliseconds ago. The other being based upon a challenge.\\n\\nThe challenge logic is more verbose since it relies upon another HTTP invocation having\\ngenerated the challenge, while the age logic relies upon the UNIX timestamp on the client\\nand the server being synchronised. Generally the challenge-based version is more stable,\\nsince it doesn't require the client and the server being perfectly synchronised towards\\ntheir time servers, which might happen every once in a while.\\n\\nThe [age] argument is the how old the token can maximumly be before it's considered invalid.\\n[age] is measured in milliseconds, implying 5,000 in age implies the token needs to be\\ncreated less than 5 seconds ago on the client. The default value for [age] is 10,000, implying\\n10 seconds, and the default value for [workload] is 3, implying it requires up to 4,096\\nhashing iterations on average, while the client has 10 seconds to generate a valid token.\\n\\nThe magic-captcha.js file will generate a valid [age] token, assuming the [workload] argument to\\nthis slot was the same or less than the workload argument to the `mcaptcha.token` function\\ninvocation on the client.\\n\\nThe magic-captcha-challenge.js file will generate a challenge-based token and automatically\\ninvoke the server to create a new challenge before trying to solve the token. If the challenge\\nhas not been previously created on the server less than 5 minutes ago, the challenge-based\\ntoken will not be accepted."},{"role":"assistant","content":"slots.create:magic.auth.captcha-verify\\n\\n   // Sanity checking invocation.\\n   validators.mandatory:x:@.arguments/*/token\\n   validators.integer:x:@.arguments/*/workload\\n   validators.integer:x:@.arguments/*/age\\n   validators.default:x:@.arguments\\n      workload:int:3\\n      age:int:10000\\n\\n   /*\\n    * Splitting token string into entities,\\n    * being hash + Unix timestamp when generated + seed value leading to enough trailing zeros.\\n    */\\n   .token\\n   .time-challenge\\n   .seed\\n   strings.split:x:@.arguments/*/token\\n      .:;\\n   if\\n      neq\\n         get-count:x:@strings.split/*\\n         .:int:3\\n      .lambda\\n\\n         // Token does not contain 3 parts.\\n         throw:Invalid CAPTCHA token, token did not have 3 parts. A valid Magic CAPTCHA token requires 3 parts; actual token, UNIX time and seed value used to generate token.\\n            status:int:400\\n            public:bool:true\\n   set-value:x:@.token\\n      strings.to-lower:x:@strings.split/0\\n   set-value:x:@.time-challenge\\n      get-value:x:@strings.split/1\\n   set-value:x:@.seed\\n      convert:x:@strings.split/2\\n         type:long\\n\\n   // Checking what type of token we've got, options are age-based and challenge based.\\n   if\\n      strings.starts-with:x:@.time-challenge\\n         .:c_\\n      .lambda\\n\\n         // Challenge-based token, making sure challenge exists in cache.\\n         if\\n            neq\\n               cache.get:x:@.time-challenge\\n               .:valid\\n            .lambda\\n\\n               // Challenge for token was not valid\\n               throw:Invalid CAPTCHA token. Challenge for token was not valid.\\n                  status:int:400\\n                  public:bool:true\\n\\n         // Removing challenge from cache to avoid user using it twice.\\n         cache.set:x:@.time-challenge\\n   else\\n\\n      // Verifying token was generated on client less than [age] seconds ago.\\n      set-value:x:@.time-challenge\\n         convert:x:@.time-challenge\\n            type:long\\n      if\\n         or\\n            lt\\n               math.add\\n                  get-value:x:@.time-challenge\\n                  get-value:x:@.arguments/*/age\\n               date.unix\\n            mt\\n               get-value:x:@.time-challenge\\n               date.unix\\n         .lambda\\n\\n            // Token is either older than [age] seconds or created in \"the future\".\\n            throw:\"Invalid CAPTCHA token. Please check your computer's BIOS time if you suspect this is a mistake.\"\\n               status:int:400\\n               public:bool:true\\n\\n   // Verifying CAPTCHA token ends with enough trailing zeros.\\n   .endswith:\\n   while\\n      lt\\n         strings.length:x:@.endswith\\n         get-value:x:@.arguments/*/workload\\n      .lambda\\n         set-value:x:@.endswith\\n            strings.concat\\n               get-value:x:@.endswith\\n               .:0\\n   if\\n      not\\n         strings.ends-with:x:@.token\\n            get-value:x:@.endswith\\n      .lambda\\n\\n         // Token does not have enough trailing zeros to be considered valid.\\n         throw:Invalid CAPTCHA token. Workload requirements of endpoint was not met.\\n            status:int:400\\n            public:bool:true\\n\\n   /*\\n    * Verifying token was generated by server.\\n    * \\n    * Notice, to avoid predictable hash values, we double hash, which kind of\\n    * creates an HMAC token for us making it impossible to guess a valid hash.\\n    */\\n   config.get:\"magic:auth:secret\"\\n   crypto.hash.sha256:x:@config.get\\n   crypto.hash.sha256:x:-\\n\\n   /*\\n    * Concatenating server's auth secret with timestamp for when token was created,\\n    * in addition to seed used to generate valid token with enough trailing zeros.\\n    */\\n   strings.concat\\n      get-value:x:@crypto.hash.sha256\\n      .:;\\n      get-value:x:@.time-challenge\\n      .:;\\n      get-value:x:@.seed\\n\\n   // Verifying hash is valid.\\n   if\\n      neq\\n         crypto.hash.sha256:x:@strings.concat\\n         get-value:x:@.token\\n      .lambda\\n\\n         // Token is not valid.\\n         throw:Invalid CAPTCHA token. Please verify that public key was generated by server token was submitted to.\\n            status:int:400\\n            public:bool:true\\n\\n   // If we come this far, the token was valid, and we can allow the client to continue.\\n   return:bool:true\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Slot that searches DuckDuckGo for [max] URLs matching the [query],\\nfor then to scrape each URL, and aggregating the result\\nreturning it back to caller as a single Markdown."},{"role":"assistant","content":"slots.create:magic.http.duckduckgo-and-scrape\\n\\n   // Sanity checking invocation.\\n   validators.mandatory:x:@.arguments/*/query\\n   validators.string:x:@.arguments/*/query\\n      min:3\\n      max:250\\n   validators.integer:x:@.arguments/*/max\\n      min:1\\n      max:10\\n\\n   // Searching DuckDuckGo for matches.\\n   add:x:+\\n      get-nodes:x:@.arguments/*\\n   signal:magic.http.duckduckgo-search\\n\\n   // Checking if we've got a session, and if so, notifying user using web sockets.\\n   if\\n      exists:x:@.arguments/*/session\\n      .lambda\\n         for-each:x:@signal/*/result/*\\n            strings.concat\\n               .:\"Scraping: \"\\n               get-value:x:@.dp/#/*/url\\n            unwrap:x:+/**\\n            sockets.signal:x:@.arguments/*/session\\n               args\\n                  message:x:@strings.concat\\n                  type:system\\n            sleep:100\\n\\n   // Building our execution object that fetches all URLs simultaneously in parallel.\\n   .exe\\n\\n      // Waiting for all scraping operations to return.\\n      join\\n   for-each:x:@signal/*/result/*\\n\\n      // Dynamically contructing our lambda object.\\n      .cur\\n         fork\\n            .reference\\n            try\\n               unwrap:x:+/*\\n               signal:magic.http.scrape-url\\n                  url:x:@.reference/*/url\\n                  semantics:bool:true\\n               if\\n                  exists:x:@.reference/*/session\\n                  .lambda\\n                     strings.concat\\n                        .:\"Done scraping \"\\n                        get-value:x:@.reference/*/url\\n                     unwrap:x:+/**\\n                     sockets.signal:x:@.reference/*/session\\n                        args\\n                           message:x:@strings.concat\\n                           type:system\\n            .catch\\n               log.error:Could not scrape URL\\n                  url:x:@.reference/*/url\\n                  message:x:@.arguments/*/message\\n\\n      // Adding URL and title as reference to currently iterated [fork].\\n      add:x:+/+/*\\n         get-nodes:x:@.arguments/*/session\\n      unwrap:x:+/*/*\\n      add:x:@.cur/*/fork/*/.reference\\n         .\\n            url:x:@.dp/#/*/url\\n            title:x:@.dp/#/*/title\\n\\n      // Adding current thread to above [join].\\n      add:x:@.exe/*/join\\n         get-nodes:x:@.cur/*\\n\\n   // Executing [.exe] retrieving all URLs in parallel.\\n   eval:x:@.exe\\n   remove-nodes:x:@.exe/**/session\\n\\n   // Signaling caller on sockets.\\n   if\\n      exists:x:@.arguments/*/session\\n      .lambda\\n         sockets.signal:x:@.arguments/*/session\\n            args\\n               message:Building context\\n               type:system\\n         sleep:100\\n\\n   /*\\n    * Iterating through each above result,\\n    * returning result to caller.\\n    * \\n    * Notice, we only iterate through invocations that have result, and\\n    * did not timeout by verifying [signal] slot has children.\\n    */\\n   for-each:x:@.exe/*/join/*/fork\\n\\n      // Verifying currently iterated node has result, containing both prompt and completion.\\n      if\\n         exists:x:@.dp/#/*/try/*/signal/*/*/prompt/./*/completion\\n         .lambda\\n\\n            // Adding primary return lambda to [return] below.\\n            unwrap:x:+/*/*/*\\n            add:x:../*/return\\n               .\\n                  .\\n                     url:x:@.dp/#/*/.reference/*/url\\n                     title:x:@.dp/#/*/.reference/*/title\\n                     snippets\\n\\n            // Adding [snippets] to return below.\\n            add:x:../*/return/0/-/*/snippets\\n               get-nodes:x:@.dp/#/*/try/*/signal/*\\n\\n   // Returning result of invocation to caller.\\n   return\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Uses DuckDuckGo to search for the specified [query]\\nreturning an optional [max] results to caller."},{"role":"assistant","content":"slots.create:magic.http.duckduckgo-search\\n\\n   // Result we return to caller.\\n   .result\\n      result\\n\\n   // Sanity checking invocation.\\n   validators.mandatory:x:@.arguments/*/query\\n   validators.integer:x:@.arguments/*/max\\n      min:1\\n\\n   // Creating our search URL.\\n   .url\\n   set-value:x:@.url\\n      strings.concat\\n         .:\"https://html.duckduckgo.com/html/?q=\"\\n         strings.url-encode:x:@.arguments/*/query\\n\\n   // Checking if caller provided a session argument, and if so, signaling client using web sockets.\\n   if\\n      exists:x:@.arguments/*/session\\n      .lambda\\n         strings.concat\\n            .:\"Invoking DuckDuckGo at: \"\\n            get-value:x:@.url\\n         unwrap:x:+/**\\n         sockets.signal:x:@.arguments/*/session\\n            args\\n               message:x:@strings.concat\\n               type:system\\n\\n   // Invoking slot responsible for retrieving search results.\\n   unwrap:x:+/*\\n   signal:magic.http.get-with-cache\\n      url:x:@.url\\n\\n   // Making sure we return refernce to caller.\\n   unwrap:x:+/*/*\\n   insert-before:x:@.result/0\\n      .\\n         reference:x:@.url\\n\\n   // Semantically traversing HTML for result.\\n   html2lambda:x:@signal\\n   for-each:x:\"@html2lambda/*/html/*/body/**/a/*/\\\\@class/=result__a/.\"\\n\\n      // Making sure we're not past any specified [max] argument.\\n      if\\n         or\\n            not-exists:x:@.arguments/*/max\\n            mt:x:@.arguments/*/max\\n               .:int:0\\n         .lambda\\n\\n            // Not beyond [max] argument.\\n            .cur\\n            set-value:x:@.cur\\n               strings.concat\\n                  .:\"http:\"\\n                  get-value:x:\"@.dp/#/*/\\\\@href\"\\n\\n            // Retrieving raw URL from QUERY parameters returned from DuckDuckGo.\\n            strings.split:x:@.cur\\n               .:?\\n            if\\n               mt\\n                  get-count:x:@strings.split/*\\n                  .:int:1\\n               .lambda\\n\\n                  // URL has query parameters, splitting all query parameters.\\n                  strings.split:x:@strings.split/1\\n                     .:&\\n\\n                  // Used to track if we find query parameter.\\n                  .found:bool:false\\n\\n                  // Finding the correct query parameter.\\n                  for-each:x:@strings.split/*\\n\\n                     // Checking if currently iterated query parameter is the correct query parameter.\\n                     if\\n                        strings.starts-with:x:@.dp/#\\n                           strings.concat\\n                              .:uddg\\n                              .:=\\n                        .lambda\\n\\n                           // This is our query parameter.\\n                           set-value:x:@.found\\n                              .:bool:true\\n                           strings.split:x:@.dp/#\\n                              .:=\\n                           set-value:x:@.cur\\n                              strings.url-decode:x:@strings.split/1\\n\\n                  /*\\n                   * Verifying we found query parameter in URL, and if not,\\n                   * ignoring currently iterated link.\\n                   */\\n                  if\\n                     not\\n                        get-value:x:@.found\\n                     .lambda\\n\\n                        // Query parameter wasn't found.\\n                        set-value:x:@.url\\n            else\\n\\n               // No query parameters in URL at all.\\n               set-value:x:@.url\\n\\n            // Decrementing [max] argument.\\n            math.decrement:x:@.arguments/*/max\\n\\n            // Adding currently iterated URL to [.result].\\n            strings.join:x:\"@.dp/#/././**/a/*/\\\\@class/=result__snippet/./**/\\\\#text\"\\n               .:\\n            unwrap:x:+/*/*/*\\n            add:x:@.result/*/result\\n               .\\n                  .\\n                     url:x:@.cur\\n                     title:x:\"@.dp/#/*/\\\\#text\"\\n                     description:x:@strings.join\\n\\n   // Returing result to caller.\\n   return-nodes:x:@.result/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Slots that returns the specified [url] to caller\\nwith a 5 minute server-side cache to avoid re-fetching URL\\ntoo frequently."},{"role":"assistant","content":"slots.create:magic.http.get-with-cache\\n\\n   // Sanity checking invocation.\\n   validators.mandatory:x:@.arguments/*/url\\n   validators.url:x:@.arguments/*/url\\n\\n   // Checking cache.\\n   unwrap:x:+/*/.lambda/*/.url\\n   cache.try-get:x:@.arguments/*/url\\n      expiration:300\\n      .lambda\\n\\n         // Forward evaluated above.\\n         .url:x:@.arguments/*/url\\n         http.get:x:@.url\\n            headers\\n               User-Agent:Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36\\n               Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\\n               Accept-Language:en-GB,en-US;q=0.9,en;q=0.8,no;q=0.7\\n         return:x:-/*/content\\n\\n   // Returning result of above invocation to caller.\\n   return:x:@cache.try-get\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"HTTP POST invoke slot that invokes an HTTP endpoint passing in everything\\nspecified as arguments as payload, except [url] which is the invocation URL."},{"role":"assistant","content":"slots.create:magic.http.post\\n\\n   // Sanity checking invocation.\\n   validators.mandatory:x:@.arguments/*/url\\n   validators.url:x:@.arguments/*/url\\n\\n   // Retrieving URL.\\n   .url:x:@.arguments/*/url\\n   unwrap:x:@.url\\n   remove-nodes:x:@.arguments/*/url\\n\\n   // Decorating invocation.\\n   unwrap:x:./*/http.post\\n   add:x:./*/http.post/*/payload\\n      get-nodes:x:@.arguments/*\\n\\n   // Invoking endpoint.\\n   http.post:x:@.url\\n      payload\\n\\n   // Verifying invocation was a success.\\n   if\\n      and\\n         mte:x:@http.post\\n            .:int:200\\n         lt:x:@http.post\\n            .:int:300\\n      .lambda\\n\\n         // Success!\\n         add:x:./*/log.info\\n            get-nodes:x:@.arguments/*\\n         log.info:Webhook successfull invoked\\n            url:x:@.url\\n   else\\n\\n      // Failure!\\n      add:x:./*/log.info\\n         get-nodes:x:@.arguments/*\\n      lambda2hyper:x:@http.post/*/content\\n      log.error:Webhook failed\\n         url:x:@.url\\n         content:x:@lambda2hyper\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Loads all files recursively from the specified folder.\\n\\nThis slot is used as we scaffold a frontend, since we'll need to\\nrecursively load all files in the template folder, before we start\\ntransforming the template to an actual result.\\n\\nArguments\\n\\n- 1st argument. Folder from where to load all files recursively from."},{"role":"assistant","content":"slots.create:magic.io.file.load-recursively\\n\\n   // In case we've got a \"slot\" type of argument.\\n   eval:x:@.arguments\\n\\n   // Lists all files in current [folder], and adds up the result to return value.\\n   io.file.list-recursively:x:@.arguments/0\\n      show-hidden:x:@.arguments/*/.hidden-files\\n\\n   /*\\n    * Iterating through all files listed above, and loads them,\\n    * for then to add their contents as a child node of iterated file.\\n    */\\n   for-each:x:@io.file.list-recursively/*\\n      io.file.load:x:@.dp/#\\n      add:x:@.dp/#\\n         get-nodes:x:@io.file.load\\n      set-name:x:@.dp/#/*\\n         .:\\n\\n   // Returning to caller all files in folder, and sub folder(s).\\n   return-nodes:x:@io.file.list-recursively/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Executes all slots starting with the speicified [namespace] value, passing in\\nall [arguments] to all invocations."},{"role":"assistant","content":"slots.create:magic.misc.execute-slots\\n\\n   // Sanity checking invocation.\\n   validators.mandatory:x:@.arguments/*/namespace\\n\\n   // Listing all slots with the specified name.\\n   slots.vocabulary:x:@.arguments/*/namespace\\n\\n   // Looping through each slot returned from above.\\n   for-each:x:@slots.vocabulary/*\\n\\n      // Parametrising slot invocation.\\n      add:x:./*/execute\\n         get-nodes:x:@.arguments/*/arguments/*\\n\\n      // Changing name of slot, as in which dynamic slot will be executed below.\\n      set-value:x:./*/execute\\n         get-value:x:@.dp/#\\n\\n      // Executing slot now parametrised with [arguments].\\n      execute\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Helper slot to initially create and migrate any particular [module] app's\\ndatabase by executing the module's 'xxx.mssql.sql', 'xxx.pgsql.sql', or 'xxx.mysql.sql' script,\\nand all migration scripts existing within module's \"db-migrations\" folder, according to\\nwhich database type happens to be the default.\\n\\nArguments\\n\\n- [module] - Module's name and root folder.\\n- [database] - Module's database, and connection string reference.\\n- [database-type] - Optional type of database. If not specified defaults to the default database.\\n\\nThe slot assumes the module is created according to the same structure, having\\na 'db-migrations' folder inside of its 'magic.startup' folder, containing SQL\\nfiles that upgrades the module's database. In addition to 'xxx.yyy.sql' scripts,\\nwhere 'xxx' is the name of the module, and 'yyy' is the database type.\\n\\nOnly truly works with modules created to transparently support both MySQL\\nand SQL Server database types."},{"role":"assistant","content":"slots.create:magic.modules.ensure-database\\n\\n   // Sanity checking invocation.\\n   validators.mandatory:x:@.arguments/*/module\\n   validators.mandatory:x:@.arguments/*/database\\n\\n   // Returned to caller to signal whether or not operation was a success or not.\\n   .result:bool:true\\n\\n   // Flushing cache.\\n   cache.clear\\n\\n   /*\\n    * Figuring out folder from where to read migration scripts and\\n    * main 'create-database.sql' script.\\n    */\\n   .database-type:x:@.arguments/*/database-type\\n   unwrap:x:-\\n   if\\n      null:x:@.database-type\\n      .lambda\\n         set-value:x:@.database-type\\n            config.get:\"magic:databases:default\"\\n   .create-database-script\\n   .migration-script-folder\\n   set-value:x:@.create-database-script\\n      strings.concat\\n         .:/modules/\\n         get-value:x:@.arguments/*/module\\n         .:/magic.startup/\\n         get-value:x:@.arguments/*/module\\n         .:.\\n         get-value:x:@.database-type\\n         .:.sql\\n   set-value:x:@.migration-script-folder\\n      strings.concat\\n         .:/modules/\\n         get-value:x:@.arguments/*/module\\n         .:/magic.startup/db-migrations/\\n         get-value:x:@.database-type\\n         .:/\\n\\n   // Checking if database already exists.\\n   strings.concat\\n      .:magic.db.\\n      get-value:x:@.database-type\\n      .:.databases\\n   signal:x:-\\n   strings.concat\\n      .:@signal/*/*/db/=\\n      get-value:x:@.arguments/*/database\\n   set-x:x:+/*/*/exists\\n      convert:x:@strings.concat\\n         type:x\\n   if\\n      not\\n         exists\\n      .lambda\\n\\n         // Executing create database SQL script, making sure we trap exceptions.\\n         try\\n\\n            // Loading file.\\n            io.file.load:x:@.create-database-script\\n\\n            // Opening database connection.\\n            switch:x:@.database-type\\n               case:mysql\\n                  mysql.connect:sys\\n                     mysql.execute:x:@io.file.load\\n               case:pgsql\\n                  pgsql.connect:postgres\\n                     strings.concat\\n                        .:\"create database \"\\n                        get-value:x:@.arguments/*/database\\n                     pgsql.execute:x:-\\n                        database:x:@.arguments/*/database\\n                  pgsql.connect:x:@.arguments/*/database\\n                     pgsql.execute:x:@io.file.load\\n               case:mssql\\n                  mssql.connect:master\\n                     mssql.execute-batch:x:@io.file.load\\n               case:sqlite\\n                  strings.concat\\n                     .:/data/\\n                     get-value:x:@.arguments/*/database\\n                     .:.db\\n                  io.file.save:x:-\\n                     .:\\n                  sqlite.connect:x:@.arguments/*/database\\n                     sqlite.execute:x:@io.file.load\\n\\n            // Doing some basic logging.\\n            log.info:Successfully created database\\n               database_name:x:@.arguments/*/database\\n         .catch\\n\\n            // Logging exception.\\n            log.error:Something went wrong when creating database\\n               database:x:@.arguments/@.arguments/*/database\\n               script:x:@.create-database-script\\n               error:x:@.arguments/*/message\\n\\n   /*\\n    * Making sure module has a migration script folder, and if not,\\n    * returning early.\\n    */\\n   if\\n      not\\n         io.folder.exists:x:@.migration-script-folder\\n      .lambda\\n\\n         // Module doesn't have a migration script folder.\\n         return:bool:true\\n\\n   // Iterating through each SQL script found in folder.\\n   io.file.list:x:@.migration-script-folder\\n   for-each:x:@io.file.list/*\\n\\n      // Verifying file is an SQL file.\\n      if\\n         strings.ends-with:x:@.dp/#\\n            .:.sql\\n         .lambda\\n\\n            // Loading SQL migration script file.\\n            io.file.load:x:@.dp/#\\n\\n            // Executing file, making sure we trap exceptions.\\n            try\\n\\n               // Opening database connection.\\n               data.connect:x:@.arguments/*/database\\n\\n                  // Special case for MS SQL to make sure we use batch execute.\\n                  if\\n                     eq\\n                        get-value:x:@.database-type\\n                        .:mssql\\n                     .lambda\\n\\n                        // SQL server, ensuring we use batch execute.\\n                        set-name:x:@data.connect/*/data.execute\\n                           .:mssql.execute-batch\\n\\n                  // Executing SQL script now.\\n                  data.execute:x:@io.file.load\\n\\n                  // Logging the fact that we've executed the database migration script.\\n                  log.info:Database migration script successfully executed\\n                     script:x:@.dp/#\\n            .catch\\n\\n               // Logging exception.\\n               log.error:Something went wrong as we tried to execute plugin database migration script\\n                  script:x:@.dp/#\\n                  error:x:@.arguments/*/message\\n\\n               // Ensuring slot returns false.\\n               set-value:x:@.result\\n                  .:bool:false\\n\\n   // Returning result of invocation to caller.\\n   return\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns system information to caller."},{"role":"assistant","content":".type:internal\\n\\n// Ensures user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Verifying system has been setup.\\nconfig.get:\"magic:auth:secret\"\\nif\\n   neq:x:@config.get\\n      .:THIS-IS-NOT-A-GOOD-SECRET-PLEASE-CHANGE-IT\\n   .lambda\\n\\n      // Making sure we aggressively cache the HTTP response object on the client side.\\n      response.headers.set\\n         Cache-Control:public, max-age=300\\n\\n      // Retrieving data from cache, and/or creating our cache entry.\\n      cache.try-get:system-information\\n         expiration:300\\n         .lambda\\n\\n            // Retrieving version of Magic we're currently running.\\n            version\\n\\n            // Retrieving number of persisted tasks.\\n            tasks.count\\n\\n            /*\\n             * Retrieving plugin information associated with endpoint.\\n             * Notice, this logic will invoke all slots starting\\n             * with [magic.system-information.] and return whatever these\\n             * slots are returning back to caller.\\n             */\\n            slots.vocabulary:magic.system-information.\\n            for-each:x:-/*\\n               signal:x:@.dp/#\\n               add:x:+/*\\n                  get-nodes:x:@signal/*\\n               add:x:././*/lambda2hyper\\n                  .\\n\\n            // Counting total number of log items.\\n            log.count\\n\\n            /*\\n             * Retrieving capabilities of log implementation, and verifying implementation\\n             * supports timeshifts before we invoke timeshifts.\\n             */\\n            log.capabilities\\n            if:x:@log.capabilities/*/can-timeshift\\n\\n               // Adding root nodes for timeshifts.\\n               add:x:@.lambda/*/lambda2hyper\\n                  .\\n                     timeshifts\\n                        logins\\n                           name:Logins\\n                           description:Successfully authenticated users\\n                           items\\n                        access_denied\\n                           name:Access denied\\n                           description:Access denied requests\\n                           items\\n                        openai_success\\n                           name:OpenAI success\\n                           description:Successful OpenAI API requests\\n                           items\\n                        openai_failure\\n                           name:OpenAI failure\\n                           description:Failed OpenAI API requests\\n                           items\\n                        lead_generated\\n                           name:Lead\\n                           description:Lead generated\\n                           items\\n\\n               // Retrieving count of log items grouped by day for root logins.\\n               add:x:@.lambda/*/lambda2hyper/*/timeshifts/*/logins/*/items\\n                  log.timeshift:User successfully authenticated\\n\\n               // Retrieving access denied invocations.\\n               add:x:@.lambda/*/lambda2hyper/*/timeshifts/*/access_denied/*/items\\n                  log.timeshift:Access denied\\n\\n               // Retrieving successful OpenAI API requests\\n               add:x:@.lambda/*/lambda2hyper/*/timeshifts/*/openai_success/*/items\\n                  log.timeshift:Invoking OpenAI was a success\\n\\n               // Retrieving failed OpenAI API requests\\n               add:x:@.lambda/*/lambda2hyper/*/timeshifts/*/openai_failure/*/items\\n                  log.timeshift:Something went wrong while invoking OpenAI\\n\\n               // Retrieving leads\\n               add:x:@.lambda/*/lambda2hyper/*/timeshifts/*/lead_generated/*/items\\n                  log.timeshift:Lead was generated\\n\\n            // Retrieving endpoints.\\n            endpoints.list\\n            .no-endpoints\\n            set-value:x:-\\n               get-count:x:@endpoints.list/*\\n\\n            // Retrieving last 10 log items.\\n            add:x:@.lambda/*/lambda2hyper/*/last_log_items\\n               log.query\\n                  max:10\\n\\n            // Retrieving slots.\\n            vocabulary\\n            .no-slots\\n            set-value:x:-\\n               get-count:x:@vocabulary/*\\n\\n            // Retrieving dynamic slots.\\n            slots.vocabulary\\n            .no-dynamic-slots\\n            set-value:x:-\\n               get-count:x:@slots.vocabulary/*\\n\\n            // Retrieving default database adapter.\\n            .default-db\\n            set-value:x:-\\n               config.get:\"magic:databases:default\"\\n\\n            // Retrieving default timezone.\\n            .default-timezone\\n            set-value:x:-\\n               config.get:\"magic:culture:defaultTimeZone\"\\n\\n            // Counting cache items.\\n            cache.count\\n\\n            // Verifying scheduler is turned on.\\n            .has-scheduler:bool:true\\n            if\\n               eq\\n                  config.get:\"magic:tasks:scheduler\"\\n                  .\\n               .lambda\\n                  set-value:x:@.has-scheduler\\n                     .:bool:false\\n\\n            // Iterating through each module, counting LOC, and files.\\n            io.folder.list:/modules/\\n            for-each:x:@io.folder.list/*\\n\\n               // Finding module name.\\n               strings.split:x:@.dp/#\\n                  .:/\\n\\n               // Loading all files in module recursively.\\n               unwrap:x:+/*\\n               signal:magic.io.file.load-recursively\\n                  .:x:@.dp/#\\n\\n               // Looping through each file in module folder.\\n               .loc:int:0\\n               .files:int:0\\n               for-each:x:@signal/*\\n                  if\\n                     strings.ends-with:x:@.dp/#\\n                        .:.hl\\n                     .lambda\\n                        hyper2lambda:x:@.dp/#/0\\n                        math.increment:x:@.loc\\n                           get-count:x:@hyper2lambda/**\\n                        math.increment:x:@.files\\n\\n               // Adding result to return value.\\n               unwrap:x:+/+/*/*/*\\n               set-name:x:+/*/*\\n                  get-value:x:@strings.split/0/-\\n               add:x:@.lambda/*/lambda2hyper/*/modules\\n                  .\\n                     foo\\n                        loc:x:@.loc\\n                        files:x:@.files\\n\\n            // Returning result to caller.\\n            unwrap:x:+/*\\n            lambda2hyper\\n               version:x:@version\\n               persisted_tasks:x:@tasks.count\\n               has_sockets:x:@.has-sockets\\n               has_scheduler:x:@.has-scheduler\\n               log_items:x:@log.count\\n               cache_items:x:@cache.count\\n               endpoints:x:@.no-endpoints\\n               slots:x:@.no-slots\\n               dynamic_slots:x:@.no-dynamic-slots\\n               default_db:x:@.default-db\\n               default_timezone:x:@.default-timezone\\n               last_log_items\\n               modules\\n            return:x:@lambda2hyper\\n\\n      // Returning result of cache invocation to caller.\\n      hyper2lambda:x:@cache.try-get\\n      return-nodes:x:@hyper2lambda/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns number of log items in the database."},{"role":"assistant","content":".arguments\\n   query:string\\n.type:internal\\n\\n// Ensures user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Invoking slot responsible for returning count.\\nlog.count:x:@.arguments/*/query\\n\\n// Returning result of above invocation to caller.\\nunwrap:x:+/*\\nreturn\\n   count:x:@log.count\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns the specified log item to caller."},{"role":"assistant","content":".arguments\\n   id:string\\n.type:internal\\n\\n// Ensures user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/id\\n\\n// Invoking slot responsible for returning item.\\nlog.get:x:@.arguments/*/id\\n\\n// Returning result of above invocation to caller.\\nreturn-nodes:x:-/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns log items in the database according to specified arguments."},{"role":"assistant","content":".arguments\\n   from:string\\n   max:long\\n   query:string\\n.type:internal\\n\\n// Ensures user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Invoking slot responsible for returning items, making sure we correctly parametrise invocation.\\nadd:x:../*/log.query\\n   get-nodes:x:@.arguments/*/max\\n   get-nodes:x:@.arguments/*/from\\nlog.query:x:@.arguments/*/query\\n\\n// Returning result of above invocation to caller.\\nreturn-nodes:x:-/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Logs line of codes generated."},{"role":"assistant","content":".arguments\\n   loc:int\\n   type:string\\n   name:string\\n.type:internal\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/loc\\nvalidators.mandatory:x:@.arguments/*/type\\nvalidators.mandatory:x:@.arguments/*/name\\nvalidators.enum:x:@.arguments/*/type\\n   .:backend\\n   .:frontend\\n\\n// Ensures user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Creating a log entry with LOC that was generated.\\nlog.info:LOC generated\\n   loc:x:@.arguments/*/loc\\n   type:x:@.arguments/*/type\\n   name:x:@.arguments/*/name\\n\\n// Returning success to caller.\\nreturn\\n   result:success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Creates a log item using the specified arguments."},{"role":"assistant","content":".arguments\\n   type:string\\n   content:string\\n   meta:*\\n.type:public\\n\\n/*\\n * Ensures user is authorized to access endpoint.\\n * Notice, we only allow authenticated users to access this endpoint.\\n * What roles they belong to is not important, as long as they're authenticated.\\n */\\nauth.ticket.verify\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/type\\nvalidators.mandatory:x:@.arguments/*/content\\nvalidators.enum:x:@.arguments/*/type\\n   .:info\\n   .:error\\n   .:debug\\n   .:fatal\\n\\n// Creating a log entry using the specified type of logger.\\nadd:x:../*/log-invocation\\n   get-nodes:x:@.arguments/*/meta/*\\nset-name:x:../*/log-invocation\\n   strings.concat\\n      .:log.\\n      get-value:x:@.arguments/*/type\\nlog-invocation:x:@.arguments/*/content\\n\\n// Returning success to caller.\\nreturn\\n   result:success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Downloads a folder from the server by packaging it into a zip file."},{"role":"assistant","content":".arguments\\n   folder:string\\n.type:internal\\n\\n// Ensures user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Getting correct HTTP headers.\\nstrings.split:x:@.arguments/*/folder\\n   .:/\\nstrings.concat\\n   .:\"attachment; filename=\\\"\"\\n   get-value:x:@strings.split/0/-\\n   .:\".zip\\\"\"\\nresponse.headers.set\\n   Content-Type:application/zip\\n   Content-Disposition:x:@strings.concat\\n   Access-Control-Expose-Headers:Content-Disposition\\n\\n// Loading all files in specified folder recursively.\\nunwrap:x:+/*\\nsignal:magic.io.file.load-recursively\\n   .folder:x:@.arguments/*/folder\\n\\n/*\\n * Making sure we remove root parts of folders and files to get items\\n * in zip file having the correct relative path.\\n */\\nfor-each:x:@signal/*\\n   set-value:x:@.dp/#\\n      strings.replace:x:@.dp/#\\n         get-value:x:@.arguments/*/folder\\n         .:\\n\\n/*\\n * Creating a ZIP stream from return value of above load-recursively invocation,\\n * and returning to caller as raw stream object.\\n */\\nadd:x:+\\n   get-nodes:x:@signal/*\\nio.content.zip-stream\\nreturn-value:x:-\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Deletes the specified [file] file."},{"role":"assistant","content":".arguments\\n   file:string\\n.type:internal\\n\\n// Ensures user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Deletes the specified file.\\nio.file.delete:x:@.arguments/*/file\\n\\n// Returning success to caller.\\nreturn\\n   result:success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Loads the specified file and returns to caller as 'application/octet-stream' Content-Type."},{"role":"assistant","content":".arguments\\n   file:string\\n.type:internal\\n\\n// Ensures user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/file\\n\\n/*\\n * Loading file and returning it, as text content to caller, making\\n * sure we return the correct Content-Type in the process.\\n */\\nstrings.split:x:@.arguments/*/file\\n   .:/\\nstrings.concat\\n   .:\"attachment; filename=\\\"\"\\n   get-value:x:@strings.split/0/-\\n   .:\"\\\"\"\\nresponse.headers.set\\n   Content-Type:application/octet-stream\\n   Content-Disposition:x:@strings.concat\\n   Access-Control-Expose-Headers:Content-Disposition\\nio.stream.open-file:x:@.arguments/*/file\\nreturn:x:-\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Saves the specified file in the specified folder."},{"role":"assistant","content":".arguments\\n   file:*\\n   folder:string\\n.type:internal\\n.accept:multipart/form-data\\n\\n// Ensures user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/file\\nvalidators.mandatory:x:@.arguments/*/file/*/name\\nvalidators.mandatory:x:@.arguments/*/file/*/stream\\nvalidators.mandatory:x:@.arguments/*/folder\\n\\n// Saves the file to the specified folder.\\n.full-path\\nset-value:x:@.full-path\\n   strings.concat\\n      get-value:x:@.arguments/*/folder\\n      get-value:x:@.arguments/*/file/*/name\\nio.stream.save-file:x:@.full-path\\n   get-value:x:@.arguments/*/file/*/stream\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Deletes the specified [folder] folder."},{"role":"assistant","content":".arguments\\n   folder:string\\n.type:internal\\n\\n// Ensures user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n/*\\n * Checking if this is a module folder, and if so, we uninstall module before actually\\n * deleting it.\\n */\\nstrings.split:x:@.arguments/*/folder\\n   .:/\\nif\\n   and\\n      eq\\n         get-count:x:@strings.split/*\\n         .:int:2\\n      eq\\n         get-value:x:@strings.split/0\\n         .:modules\\n   .lambda\\n\\n      // 'modules' folder, checking if it's got an uninstall file, and if so, executing it.\\n      strings.concat\\n         get-value:x:@.arguments/*/folder\\n         .:uninstall.hl\\n      if\\n         io.file.exists:x:@strings.concat\\n         .lambda\\n\\n            // Uninstall file exists\\n            log.info:Uninstalling module\\n               module:x:@strings.concat\\n            io.file.execute:x:@strings.concat\\n\\n// Deletes the specified folder.\\nio.folder.delete:x:@.arguments/*/folder\\n\\n// Returning success to caller.\\nreturn\\n   result:success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Creates the specified [folder] on your server."},{"role":"assistant","content":".arguments\\n   folder:string\\n.type:internal\\n\\n// Ensures user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Creates the specified folder.\\nio.folder.create:x:@.arguments/*/folder\\nreturn\\n   result:success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Uploads and installs the specified ZIP file module."},{"role":"assistant","content":".arguments\\n   file:*\\n.type:internal\\n.accept:multipart/form-data\\n\\n// Ensures user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/file\\nvalidators.mandatory:x:@.arguments/*/file/*/name\\nvalidators.mandatory:x:@.arguments/*/file/*/stream\\nvalidators.regex:x:@.arguments/*/file/*/name\\n   regex:[a-z0-9_-]+\\nstrings.split:x:@.arguments/*/file/*/name\\n   .:.\\nif\\n   not\\n      eq\\n         get-value:x:@strings.split/0/-\\n         .:zip\\n   .lambda\\n\\n      // Oops, not a ZIP file ...\\n      throw:You can only install ZIP files\\n         public:true\\n         status:415\\nif\\n   not\\n      eq\\n         get-count:x:@strings.split/*\\n         .:int:2\\n   .lambda\\n\\n      // Oops, not a valid module name.\\n      throw:That is not a valid module name\\n         public:true\\n         status:400\\n\\n// Figuring out full path to use for ZIP file.\\n.full-path\\nset-value:x:@.full-path\\n   strings.concat\\n      .:/modules/\\n      get-value:x:@.arguments/*/file/*/name\\n\\n// Checking if ZIP file already exists, at which point we delete it.\\nif\\n   io.file.exists:x:@.full-path\\n   .lambda\\n\\n      // File with specified filename already exists.\\n      io.file.delete:x:@.full-path\\n\\n// Saving stream to file.\\nio.stream.save-file:x:@.full-path\\n   get-value:x:@.arguments/*/file/*/stream\\n\\n// Figuring out folder name to use.\\n.folder\\nset-value:x:@.folder\\n   strings.concat\\n      .:/modules/\\n      get-value:x:@strings.split/0\\n      .:/\\n\\n// Deleting previously existing folder with same name.\\nif\\n   io.folder.exists:x:@.folder\\n   .lambda\\n\\n      // Module already exists, deleting it.\\n      io.folder.delete:x:@.folder\\n\\n// Creating folder.\\nio.folder.create:x:@.folder\\n\\n// Unzipping file.\\nio.file.unzip:x:@.full-path\\n   folder:x:@.folder\\n\\n// Deleting ZIP file.\\nio.file.delete:x:@.full-path\\n\\n// Defaulting module name to name of zip file.\\n.module-name\\nset-value:x:@.module-name\\n   get-value:x:@strings.split/0\\n\\n// Figuring out manifest name and checking if it exists.\\n.manifest\\nset-value:x:@.manifest\\n   strings.concat\\n      get-value:x:@.folder\\n      .:manifest.hl\\nif\\n   io.file.exists:x:@.manifest\\n   .lambda\\n\\n      // Checking manifest file to see if we need to rename module.\\n      io.file.load:x:@.manifest\\n      hyper2lambda:x:-\\n      if\\n         neq\\n            get-value:x:@.module-name\\n            get-value:x:@hyper2lambda/*/module_name\\n         .lambda\\n\\n            // We'll need to rename folder for module according to manifest.\\n            strings.concat\\n               .:/modules/\\n               get-value:x:@hyper2lambda/*/module_name\\n               .:/\\n            if\\n               io.folder.exists:x:@strings.concat\\n               .lambda\\n\\n                  // Folder already exists, deleting it.\\n                  io.folder.delete:x:@strings.concat\\n\\n            // Renaming folder according to manifest information.\\n            io.folder.move:x:@.folder\\n               get-value:x:@strings.concat\\n            set-value:x:@.module-name\\n               get-value:x:@hyper2lambda/*/module_name\\n\\n// Installing module.\\nunwrap:x:+/*\\nsignal:magic.modules.install-module\\n   module:x:@.module-name\\nreturn-nodes\\n   result:Success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"List all files in the specified [folder] argument."},{"role":"assistant","content":".arguments\\n   folder:string\\n   sys:bool\\n.type:internal\\n\\n// Ensures user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Listing all file in specified folder.\\nio.file.list-recursively:x:@.arguments/*/folder\\n   display-hidden:bool:true\\n   display-system:x:@.arguments/*/sys\\n\\n// Returning results of above invocation to caller.\\nreturn-nodes:x:@io.file.list-recursively/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"List all folders in the specified [folder] argument recursively."},{"role":"assistant","content":".arguments\\n   folder:string\\n   sys:bool\\n.type:internal\\n\\n// Ensures user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Listing all folders in specified folder.\\nio.folder.list-recursively:x:@.arguments/*/folder\\n   display-hidden:bool:true\\n   display-system:x:@.arguments/*/sys\\n\\n// Returning results of above invocation to caller.\\nreturn-nodes:x:@io.folder.list-recursively/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"List all folders in the specified [folder] argument."},{"role":"assistant","content":".arguments\\n   folder:string\\n.type:internal\\n\\n// Ensures user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Listing all folders in specified folder.\\nio.folder.list:x:@.arguments/*/folder\\n\\n// Returning results of above invocation to caller.\\nreturn-nodes:x:@io.folder.list/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Uploads, unzips, and overwrites the specified folder."},{"role":"assistant","content":".arguments\\n   file:*\\n   folder:string\\n.type:internal\\n.accept:multipart/form-data\\n\\n// Ensures user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/file\\nvalidators.mandatory:x:@.arguments/*/file/*/name\\nvalidators.mandatory:x:@.arguments/*/file/*/stream\\nvalidators.mandatory:x:@.arguments/*/folder\\n\\n// Making sure specified file is a ZIP file.\\nstrings.split:x:@.arguments/*/file/*/name\\n   .:.\\nif\\n   not\\n      eq\\n         get-value:x:@strings.split/0/-\\n         .:zip\\n   .lambda\\n\\n      // Oops, not a ZIP file ...\\n      throw:You can only upload ZIP files\\n         public:true\\n         status:415\\n\\n// Emptying folder.\\nio.folder.list:x:@.arguments/*/folder\\n   display-hidden:true\\nfor-each:x:-/*\\n   io.folder.delete:x:@.dp/#\\nio.file.list:x:@.arguments/*/folder\\n   display-hidden:true\\nfor-each:x:-/*\\n   io.file.delete:x:@.dp/#\\n\\n// Figuring out full path of ZIP file as it should be saved.\\n.filename\\nset-value:x:@.filename\\n   strings.concat\\n      get-value:x:@.arguments/*/folder\\n      get-value:x:@.arguments/*/file/*/name\\n\\n// Saving stream to file.\\nio.stream.save-file:x:@.filename\\n   get-value:x:@.arguments/*/file/*/stream\\n\\n// Unzipping file.\\nio.file.unzip:x:@.filename\\n\\n// Deleting ZIP file.\\nio.file.delete:x:@.filename\\n\\n// Returning success to caller.\\nreturn-nodes\\n   result:Success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Renames the specified file or folder."},{"role":"assistant","content":".arguments\\n   oldName:string\\n   newName:string\\n.type:internal\\n\\n// Ensures user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Basic logging.\\nlog.info:Renaming file object\\n   old_name:x:@.arguments/*/oldName\\n   new_name:x:@.arguments/*/newName\\n\\n// Checking if specified object is a file or a folder.\\nif\\n   io.folder.exists:x:@.arguments/*/oldName\\n   .lambda\\n\\n      // File object is a folder, renaming it.\\n      io.folder.move:x:@.arguments/*/oldName\\n         get-value:x:@.arguments/*/newName\\nelse\\n\\n   // File object is a file, renaming it.\\n   io.file.move:x:@.arguments/*/oldName\\n      strings.concat\\n         io.path.get-folder:x:@.arguments/*/oldName\\n         get-value:x:@.arguments/*/newName\\n\\n// Returning result to caller.\\nreturn-nodes\\n   result:success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Unzips the specified file in its current folder."},{"role":"assistant","content":".arguments\\n   file:string\\n   create_folder:bool\\n.type:internal\\n\\n// Ensures user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Checking if we need to create folder with name and path of zip file.\\nif:x:@.arguments/*/create_folder\\n   strings.length:x:@.arguments/*/file\\n   strings.substring:x:@.arguments/*/file\\n      .:int:0\\n      math.subtract:x:@strings.length\\n         .:int:4\\n   strings.concat\\n      get-value:x:@strings.substring\\n      .:/\\n   unwrap:x:+/*/*\\n   add:x:../*/io.file.unzip\\n      .\\n         folder:x:@strings.concat\\n   if\\n      not\\n         io.folder.exists:x:@strings.concat\\n      .lambda\\n\\n         // Creating folder we're unzipping into.\\n         io.folder.create:x:@strings.concat\\n   else\\n\\n      // Deleting folder and re-creating it to ensure it's empty.\\n      io.folder.delete:x:@strings.concat\\n      io.folder.create:x:@strings.concat\\n\\n// Unzipping file.\\nio.file.unzip:x:@.arguments/*/file\\n\\n// Returning success to caller.\\nreturn-nodes\\n   result:success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Answers a single question from a questionnaire."},{"role":"assistant","content":".arguments\\n   type:string\\n   session:string\\n   user_id:string\\n   question:string\\n   answer:string\\n   context:int\\n   recaptcha_response:string\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/type\\nvalidators.mandatory:x:@.arguments/*/session\\nvalidators.mandatory:x:@.arguments/*/question\\nvalidators.mandatory:x:@.arguments/*/answer\\n\\n// Opening up database connection.\\ndata.connect:[generic|magic]\\n\\n   // Reading reCAPTCHA value from type.\\n   data.read\\n      table:ml_types\\n      columns\\n         recaptcha\\n      where\\n         and\\n            type.eq:x:@.arguments/*/type\\n\\n   // Checking if type is configured to demand reCAPTCHA validation.\\n   if\\n      and\\n         not-null:x:@data.read/*/*/recaptcha\\n         neq:x:@data.read/*/*/recaptcha\\n            .:\\n      .lambda\\n\\n         // Type is configured with reCAPTCHA value.\\n         convert:x:@data.read/*/*/recaptcha\\n            type:decimal\\n\\n         // Checking if reCAPTCHA value on type is not 0.\\n         if\\n            mt:x:@convert\\n               .:decimal:0\\n            .lambda\\n\\n               // Retrieving reCAPTCHA values from configuration.\\n               .key\\n               set-value:x:@.key\\n                  config.get:\"magic:auth:recaptcha:key\"\\n               .secret\\n               set-value:x:@.secret\\n                  config.get:\"magic:auth:recaptcha:secret\"\\n\\n               // Making sure reCAPTCHA is configured on the server level.\\n               if\\n                  and\\n                     not-null:x:@.key\\n                     neq:x:@.key\\n                        .:\\n                     not-null:x:@.secret\\n                     neq:x:@.secret\\n                        .:\\n                  .lambda\\n\\n                     // Verifying reCAPTCHA argument is above threshold, valid, and exists.\\n                     validators.mandatory:x:@.arguments/*/recaptcha_response\\n                     validators.recaptcha:x:@.arguments/*/recaptcha_response\\n                        min:x:@convert\\n                        site-key:x:@.key\\n                        secret:x:@.secret\\n         else\\n\\n            // Using built-in CAPTCHA.\\n            execute:magic.auth.captcha-verify\\n               token:x:@.arguments/*/recaptcha_response\\n\\n   // Input is OK, now deleting similar questionnaire answer submitted previously, if any.\\n   data.delete\\n      table:ml_requests\\n      where\\n         and\\n            type.eq:x:@.arguments/*/type\\n            user_id.eq:x:@.arguments/*/user_id\\n            prompt.eq:x:@.arguments/*/question\\n            questionnaire.eq:int:1\\n            finish_reason.eq:questionnaire\\n\\n   // Creating new answer.\\n   data.create\\n      table:ml_requests\\n      values\\n         type:x:@.arguments/*/type\\n         prompt:x:@.arguments/*/question\\n         completion:x:@.arguments/*/answer\\n         finish_reason:questionnaire\\n         questionnaire:int:1\\n         user_id:x:@.arguments/*/user_id\\n         session:x:@.arguments/*/session\\n         context:x:@.arguments/*/context\\n\\n// Returning success to caller.\\nreturn\\n   result:success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns all available template snippets from the backend."},{"role":"assistant","content":".arguments\\n   private:bool\\n.type:internal\\n\\n// Making sure user has access to invoked endpoint.\\nauth.ticket.verify:root\\n\\n// Contains list of templates we find.\\n.result\\n\\n// Listing files recursively.\\nio.file.list-recursively:/modules/\\nio.file.list-recursively:/system/\\nfor-each:x:../*/io.file.list-recursively/*\\n\\n   // Checking if this is a template file.\\n   if\\n      and\\n         strings.ends-with:x:@.dp/#\\n            .:.md\\n         strings.contains:x:@.dp/#\\n            .:/ts-templates/\\n      .lambda\\n\\n         /*\\n          * This is a template file.\\n          * \\n          * Figuring out its prompt and completion.\\n          */\\n         load-file:x:@.dp/#\\n         strings.split:x:@load-file\\n            .:\"\\n\"\\n         .prompt\\n         set-value:x:@.prompt\\n            strings.trim:x:@strings.split/0\\n         .completion\\n         remove-nodes:x:@strings.split/0\\n         set-value:x:@.completion\\n            strings.join:x:@strings.split/*\\n               .:\"\\n\"\\n         set-value:x:@.completion\\n            strings.trim:x:@.completion\\n         unwrap:x:+/*/*/*\\n         add:x:@.result\\n            .\\n               .\\n                  prompt:x:@.prompt\\n                  completion:x:@.completion\\n\\n// Returning result to caller.\\nreturn-nodes:x:@.result/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"OpenAI chat endpoint, for having conversations using \"gpt-xxx\" models.\\n\\nNotice, if you set [stream] to true the endpoint will stream response tokens over the specified\\n[session] back to caller."},{"role":"assistant","content":".arguments\\n   prompt:string\\n   type:string\\n   references:bool\\n   chat:bool\\n   recaptcha_response:string\\n   user_id:string\\n   session:string\\n   stream:bool\\n   data:string\\n   referrer:string\\n.type:public\\n\\n// Executing all registered interceptor slots.\\nadd:x:+/*/arguments\\n   get-nodes:x:@.arguments/*\\nexecute:magic.misc.execute-slots\\n   namespace:magic.openai.chat-interceptor.\\n   arguments\\n\\n// Invoking slot containing commonalities for all endpoints.\\ninsert-before:x:../*/signal/*/.callback\\n   get-nodes:x:@.arguments/*\\nsignal:magic.ai.endpoint-common\\n   .callback\\n\\n      // Checking if prompt contains an email address.\\n      if\\n         and\\n            strings.contains:x:@.arguments/*/prompt\\n               .:@\\n            not-null:x:@.arguments/*/contact_us\\n            neq:x:@.arguments/*/contact_us\\n               .:\\n            not-null:x:@.arguments/*/lead_email\\n            neq:x:@.arguments/*/lead_email\\n               .:\\n         .lambda\\n\\n            /*\\n             * Prompt contains an email address, and model is configured with a\\n             * lead email address or [contact_us]/[lead_email] property - Hence\\n             * treating prompt as a lead if we can, sending an email to lead email\\n             * address with the conversation.\\n             */\\n            unwrap:x:+/*\\n            signal:magic.ai.send-lead-email\\n               type:x:@.arguments/*/type\\n               prompt:x:@.arguments/*/prompt\\n               session:x:@.arguments/*/session\\n               user_id:x:@.arguments/*/user_id\\n               lead_email:x:@.arguments/*/lead_email\\n               contact_us:x:@.arguments/*/contact_us\\n            if:x:@signal\\n               unwrap:x:+/*\\n               return\\n                  db_time:decimal:-1\\n                  finish_reason:cached\\n                  result:x:@.arguments/*/contact_us\\n\\n      // Checking if [referrer] argument was given, and if not, using HTTP Referrer header.\\n      .referrer\\n      if\\n         and\\n            exists:x:@.arguments/*/referrer\\n            not-null:x:@.arguments/*/referrer\\n            neq:x:@.arguments/*/referrer\\n               .:\\n         .lambda\\n\\n            // Referrer argument specified.\\n            set-value:x:@.referrer\\n               get-value:x:@.arguments/*/referrer\\n      else\\n\\n         // No referrer argument, defaulting to HTTP header\\n         set-value:x:@.referrer\\n            request.headers.get:Referer\\n\\n      // Checking if max-tokens have been overridden.\\n      .tokens\\n      set-value:x:@.tokens\\n         config.get:\"magic:openai:max_tokens\"\\n\\n      // Checking what type of model this is, and invoking correct slot accordingly.\\n      if\\n         or\\n            strings.starts-with:x:@.arguments/*/model\\n               .:gpt\\n            strings.starts-with:x:@.arguments/*/model\\n               .:o1-\\n            strings.starts-with:x:@.arguments/*/model\\n               .:o3-\\n            neq:x:@.slot\\n               .:magic.ai.chat\\n         .lambda\\n\\n            // Retrieving Referrer value and passing into slot.\\n            unwrap:x:+/*/*\\n            add:x:./*/signal\\n               .\\n                  referrer:x:@.referrer\\n            remove-nodes:x:@.arguments/*/referrer\\n\\n            // Invoking chat slot.\\n            add:x:./*/signal\\n               get-nodes:x:@.arguments/*\\n\\n            // Checking if max_tokens have been overridden.\\n            if\\n               not-null:x:@.tokens\\n               .lambda\\n                  set-value:x:@.lambda/@.lambda/*/signal/*/model_size\\n                     convert:x:@.tokens\\n                        type:int\\n\\n            // Invoking chat slot and returning result to caller.\\n            signal:x:@.arguments/*/completion_slot\\n            return-nodes:x:@signal/*\\n      else\\n\\n         // Retrieving Referrer value and passing into slot.\\n         unwrap:x:+/*/*\\n         add:x:./*/signal\\n            .\\n               referrer:x:@.referrer\\n         remove-nodes:x:@.arguments/*/referrer\\n\\n         // Invoking completion slot.\\n         add:x:./*/signal\\n            get-nodes:x:@.arguments/*\\n         signal:magic.ai.completion\\n         return-nodes:x:@signal/*\\n\\n// Returning result of worker slot to caller.\\nreturn-nodes:x:@signal/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"OpenAI chat endpoint, for having conversations using \"gpt-xxx\" models.\\n\\nNotice, if you set [stream] to true the endpoint will stream response tokens over the specified\\n[session] back to caller."},{"role":"assistant","content":".arguments\\n   prompt:string\\n   type:string\\n   references:bool\\n   chat:bool\\n   recaptcha_response:string\\n   user_id:string\\n   session:string\\n   stream:bool\\n   data:string\\n   referrer:string\\n.type:public\\n\\n// Forwarding to get Hyperlambda file.\\nadd:x:+\\n   get-nodes:x:@.arguments/*\\nexecute-file:/system/openai/chat.get.hl\\n\\n// Returning result to caller.\\nreturn-nodes:x:-/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns maximum tokens for specified completion slot."},{"role":"assistant","content":".arguments\\n   slot:string\\n.type:internal\\n\\n// Making sure user is authenticate to access endpoint\\nauth.ticket.verify:root\\n\\n// Retrieving max tokens from config.\\nstrings.split:x:@.arguments/*/slot\\n   .:.\\nstrings.concat\\n   .:\"magic:\"\\n   get-value:x:@strings.split/0/-\\n   .:\":max_tokens\"\\nconfig.get:x:@strings.concat\\nyield\\n   max_tokens:x:@config.get\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns all possible LLMs the system supports."},{"role":"assistant","content":".arguments\\n.type:internal\\n\\n// Making sure user is authenticate to access endpoint\\nauth.ticket.verify:root\\n\\n// Retrieving possible candidates.\\nslots.vocabulary:magic.ai.chat\\nyield\\n   llms:x:@slots.vocabulary/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns the conversation starters for the specified type."},{"role":"assistant","content":".arguments\\n   type:string\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/type\\n\\n// Opening up database connection.\\ndata.connect:[generic|magic]\\n\\n   // Retrieving all questions from database.\\n   data.select:\"\\nselect conversation_starters\\n\\tfrom ml_types\\n\\twhere type = @type\"\\n      type:x:@.arguments/*/type\\n\\n   // Transforming to markdown and splitting into individual questions, but only if we have conversation starters.\\n   if\\n      and\\n         not-null:x:@data.select/*/*/conversation_starters\\n         neq:x:@data.select/*/*/conversation_starters\\n            .:\\n      .lambda\\n         markdown2html:x:@data.select/*/*/conversation_starters\\n         html2lambda:x:@markdown2html\\n         for-each:x:\"@html2lambda/**/li/**/\\\\#text\"\\n            unwrap:x:+/*/*\\n            add:x:../*/return/*/questions\\n               .\\n                  .:x:@.dp/#\\n\\n// Returning result to caller.\\nreturn\\n   questions\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Creates a system message from the specified arguments."},{"role":"assistant","content":".arguments\\n   url:string\\n   template:string\\n   instruction:string\\n   channel:string\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/url\\nvalidators.mandatory:x:@.arguments/*/channel\\nvalidators.mandatory:x:@.arguments/*/template\\nvalidators.mandatory:x:@.arguments/*/instruction\\n\\n// Prepending scheme to URL unless explicitly specified.\\nif\\n   and\\n      not\\n         strings.starts-with:x:@.arguments/*/url\\n            .:\"http://\"\\n      not\\n         strings.starts-with:x:@.arguments/*/url\\n            .:\"https://\"\\n   .lambda\\n      set-value:x:@.arguments/*/url\\n         strings.concat\\n            .:\"https://\"\\n            get-value:x:@.arguments/*/url\\n\\n// Sanity checking URL.\\nvalidators.url:x:@.arguments/*/url\\n\\n// Doing heavy lifting on a background thread to avoid 60 second timeouts.\\ninsert-before:x:./*/fork/0\\n   get-nodes:x:@.arguments\\nfork\\n   try\\n\\n      // Creating our system message.\\n      execute:magic.ai.create-system-message\\n         url:x:@.arguments/*/url\\n         template:x:@.arguments/*/template\\n         instruction:x:@.arguments/*/instruction\\n\\n      // Invoking frontend with message.\\n      unwrap:x:+/*/*/message\\n      sockets.signal:x:@.arguments/*/channel\\n         roles:root\\n         args\\n            message:x:@execute\\n   .catch\\n\\n      // Oops, signaling frontend that we experienced an error.\\n      unwrap:x:+/*/*\\n      sockets.signal:x:@.arguments/@.arguments/*/channel\\n         roles:root\\n         args\\n            message:ERROR\\n            extra:x:@.arguments/*/message\\n\\n// Returning result of invocation to caller.\\nyield\\n   result:success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns the specified PDF training data file to client."},{"role":"assistant","content":".arguments\\n   file:string\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/file\\n\\n// Figuringout full path of file.\\nstrings.concat\\n   .:/etc/system/openai/pdf/\\n   get-value:x:@.arguments/*/file\\n\\n// Getting our response HTTP headers sorted out.\\nstrings.concat\\n   .:\"attachment; filename=\\\"\"\\n   get-value:x:@.arguments/*/file\\n   .:\"\\\"\"\\nresponse.headers.set\\n   Content-Type:application/pdf\\n   Content-Disposition:x:@strings.concat\\n   Access-Control-Expose-Headers:Content-Disposition\\n\\n// Returning file to caller.\\nio.stream.open-file:x:@strings.concat/@strings.concat\\nreturn:x:-\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns the greeting for the specified type."},{"role":"assistant","content":".arguments\\n   type:string\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/type\\n\\n// Opening up database connection.\\ndata.connect:[generic|magic]\\n\\n   // Retrieving all questions from database.\\n   data.select:\"\\nselect greeting\\n\\tfrom ml_types\\n\\twhere type = @type\"\\n      type:x:@.arguments/*/type\\n\\n   // Returning greeting to caller.\\n   yield\\n      greeting:x:@data.select/*/*/greeting\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Imports the specified page as training data by scraping its content."},{"role":"assistant","content":".arguments\\n   url:string\\n   type:string\\n   threshold:int\\n   summarize:bool\\n   images:bool\\n   lists:bool\\n   code:bool\\n   feedback-channel:string\\n\\n// Ensures user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/url\\nvalidators.mandatory:x:@.arguments/*/threshold\\nvalidators.url:x:@.arguments/*/url\\nvalidators.mandatory:x:@.arguments/*/type\\nvalidators.integer:x:@.arguments/*/threshold\\n   min:25\\nvalidators.default:x:@.arguments\\n   summarize:bool:true\\n   images:bool:true\\n   lists:bool:true\\n   code:bool:true\\n\\n// Doing some basic logging.\\nlog.info:Crawling page generating OpenAI training snippets\\n   url:x:@.arguments/*/url\\n   type:x:@.arguments/*/type\\n   threshold:x:@.arguments/*/threshold\\n\\n// Creating a thread and invoking file doing the heavy lifting.\\ninsert-before:x:./*/fork/0\\n   get-nodes:x:@.arguments\\nfork\\n\\n   // Making sure exceptions does not leave thread.\\n   try\\n\\n      /*\\n       * Invoking crawl implementation file, now with explicit list of links,\\n       * informing invocation that we do NOT want to process links.\\n       */\\n      unwrap:x:+/*\\n      signal:magic.ai.url.scrape\\n         url:x:@.arguments/*/url\\n         type:x:@.arguments/*/type\\n         feedback-channel:x:@.arguments/*/feedback-channel\\n         threshold:x:@.arguments/*/threshold\\n         summarize:x:@.arguments/*/summarize\\n         lists:x:@.arguments/*/lists\\n         images:x:@.arguments/*/images\\n         code:x:@.arguments/*/code\\n\\n      /*\\n       * Crawling is done.\\n       * Making sure we notify client that we're done and do some logging.\\n       */\\n      sockets.signal:magic.backend.message\\n         roles:root\\n         args\\n            message:Done creating OpenAI training data from page\\n            type:success\\n      sockets.signal:x:@.arguments/*/feedback-channel\\n         args\\n            message:Done!\\n            type:success\\n\\n      // Basic logging.\\n      log.info:OpenAI training data successfully created from page\\n         url:x:@.arguments/*/url\\n         type:x:@.arguments/*/type\\n   .catch\\n\\n      // Oops ...!!\\n      log.error:x:@.arguments/*/message\\n         url:x:@.arguments/*/url\\n\\n// Returning success to caller.\\nreturn\\n   result:success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Imports the specified URL as training data by scraping the URL,\\nincluding all internal hyperlinks, and generate training data\\nfrom content found."},{"role":"assistant","content":".arguments\\n   url:string\\n   type:string\\n   delay:int\\n   max:int\\n   threshold:int\\n   summarize:bool\\n   insert_url:bool\\n   images:bool\\n   lists:bool\\n   code:bool\\n   feedback-channel:string\\n\\n// Ensures user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Applying defaults.\\nvalidators.default:x:@.arguments\\n   images:bool:true\\n   lists:bool:true\\n   code:bool:true\\n   insert_url:bool:false\\n\\n// Prepending scheme unless given.\\nif\\n   not\\n      strings.starts-with:x:@.arguments/*/url\\n         .:http\\n   .lambda\\n      set-value:x:@.arguments/*/url\\n         strings.concat\\n            .:\"https://\"\\n            get-value:x:@.arguments/*/url\\n\\n// Trimming extra slash.\\nset-value:x:@.arguments/*/url\\n   strings.trim-end:x:@.arguments/*/url\\n      .:/\\n\\n// Making sure URL does not contain CAPS characters.\\nset-value:x:@.arguments/*/url\\n   strings.to-lower:x:@.arguments/*/url\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/url\\nvalidators.mandatory:x:@.arguments/*/threshold\\nvalidators.url:x:@.arguments/*/url\\nvalidators.mandatory:x:@.arguments/*/type\\nvalidators.mandatory:x:@.arguments/*/delay\\nvalidators.integer:x:@.arguments/*/delay\\n   min:500\\n   max:30000\\nvalidators.mandatory:x:@.arguments/*/max\\nvalidators.integer:x:@.arguments/*/max\\n   min:1\\n   max:5000\\nvalidators.integer:x:@.arguments/*/threshold\\n   min:25\\nvalidators.default:x:@.arguments\\n   summarize:bool:false\\n\\n// Doing some basic logging.\\nlog.info:Crawling URL generating OpenAI training snippets\\n   url:x:@.arguments/*/url\\n   type:x:@.arguments/*/type\\n   delay:x:@.arguments/*/delay\\n   max:x:@.arguments/*/max\\n   threshold:x:@.arguments/*/threshold\\n\\n// Invoking slot doing the heavy lifting.\\nunwrap:x:./*/signal/*/.onafter/*/.feedback-channel\\nadd:x:./*/signal\\n   get-nodes:x:@.arguments/*\\nsignal:magic.ai.crawl-site\\n   .onafter\\n\\n      // Informing client that we're done.\\n      .feedback-channel:x:@.arguments/*/feedback-channel\\n      sockets.signal:x:@.arguments/*/feedback-channel\\n         args\\n            message:Done!\\n            type:success\\n\\n// Returning success to caller.\\nreturn\\n   result:success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns the JavaScript required to embed a ChatGPT based chatbot on some website to caller."},{"role":"assistant","content":".arguments\\n   type:string\\n   header:string\\n   button:string\\n   rtl:bool\\n   color:string\\n   start:string\\n   end:string\\n   link:string\\n   theme:string\\n   references:bool\\n   file:string\\n   placeholder:string\\n   position:string\\n   clear_button:bool\\n   copyButton:bool\\n   follow_up:bool\\n   new_tab:bool\\n   popup:string\\n\\n   // Not used, but allows embedders to do a hard refresh to reload JavaScript.\\n   v:string\\nadd:x:./*/execute-file\\n   get-nodes:x:@.arguments/*\\nexecute-file:/system/openai/include-chatbot.js.get.hl\\nreturn:x:-\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns the JavaScript required to embed a ChatGPT based chatbot on some website to caller."},{"role":"assistant","content":".arguments\\n   type:string\\n   header:string\\n   button:string\\n   rtl:bool\\n   color:string\\n   start:string\\n   end:string\\n   link:string\\n   theme:string\\n   references:bool\\n   file:string\\n   placeholder:string\\n   position:string\\n   clear_button:bool\\n   copyButton:bool\\n   follow_up:bool\\n   new_tab:bool\\n   code:bool\\n   animation:string\\n   popup:string\\n\\n   // Not used, but allows embedders to do a hard refresh to reload JavaScript.\\n   v:string\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/type\\n\\n// Applying default values if not specified.\\nvalidators.default:x:@.arguments\\n   rtl:bool:false\\n   references:bool:false\\n   file:modern\\n   position:right\\n   clear_button:bool:false\\n   copyButton:bool:false\\n   follow_up:bool:false\\n   new_tab:bool:false\\n   code:bool:false\\n   animation:\\n   popup:\\n\\n// Checking if custom JavaScript file exists.\\n.filename\\nstrings.concat\\n   .:/etc/system/openai/\\n   get-value:x:@.arguments/*/file\\n   .:.js\\nif\\n   io.file.exists:x:@strings.concat\\n   .lambda\\n\\n      // We need to load a custom JavaScript file.\\n      set-value:x:@.filename\\n         get-value:x:@strings.concat\\nelse\\n\\n   // We need to load a system JavaScript file.\\n   strings.concat\\n      .:/system/openai/front.files/chat/\\n      get-value:x:@.arguments/*/file\\n      .:.js\\n\\n   // System JavaScript file exists, making sure we use it.\\n   set-value:x:@.filename\\n      get-value:x:@strings.concat\\n\\n// Checking if minified file exists.\\nstrings.replace:x:@.filename\\n   .:.js\\n   .:.min.js\\nif\\n   io.file.exists:x:@strings.replace\\n   .lambda\\n\\n      // Minified file exists.\\n      set-value:x:@.filename\\n         get-value:x:@strings.replace\\n\\n// Loading JavaScript file.\\n.result\\nset-value:x:@.result\\n   io.file.load:x:@.filename\\n\\n// Figuring out API URL.\\n.scheme\\nrequest.host\\nif\\n   strings.contains:x:@request.host\\n      .:localhost\\n   .lambda\\n      set-value:x:@.scheme\\n         .:http\\nelse\\n   set-value:x:@.scheme\\n      .:https\\n.url\\nset-value:x:@.url\\n   strings.concat\\n      get-value:x:@.scheme\\n      .:\"://\"\\n      request.host\\n\\n// Retrieving reCAPTCHA key.\\n.captcha\\nset-value:x:@.captcha\\n   config.get:\"magic:auth:recaptcha:key\"\\n      .:\\n\\n// Dynamically exchanging template fields in JavaScript file.\\nset-value:x:@.result\\n   strings.replace:x:@.result\\n      .:[[color]]\\n      get-value:x:@.arguments/*/color\\nset-value:x:@.result\\n   strings.replace:x:@.result\\n      .:[[start]]\\n      get-value:x:@.arguments/*/start\\nset-value:x:@.result\\n   strings.replace:x:@.result\\n      .:[[end]]\\n      get-value:x:@.arguments/*/end\\nset-value:x:@.result\\n   strings.replace:x:@.result\\n      .:[[link]]\\n      get-value:x:@.arguments/*/link\\nset-value:x:@.result\\n   strings.replace:x:@.result\\n      .:[[url]]\\n      get-value:x:@.url\\nset-value:x:@.result\\n   strings.replace:x:@.result\\n      .:[[ainiro_watermark]]\\n      get-first-value\\n         config.get:\"magic:watermark\"\\n         .:\"Powered by <a href=\\\"https://ainiro.io\\\" target=\\\"_blank\\\">AINIRO.IO</a>\"\\nset-value:x:@.result\\n   strings.replace:x:@.result\\n      .:[[version]]\\n      get-first-value\\n         get-value:x:@.arguments/*/v\\n         version\\nset-value:x:@.result\\n   strings.replace:x:@.result\\n      .:[[type]]\\n      get-value:x:@.arguments/*/type\\nset-value:x:@.result\\n   strings.replace:x:@.result\\n      .:[[header]]\\n      get-first-value\\n         strings.replace:x:@.arguments/*/header\\n            .:\"\\\\\"\\n            .:\\n         .:\\nset-value:x:@.result\\n   strings.replace:x:@.result\\n      .:[[placeholder]]\\n      get-first-value\\n         get-value:x:@.arguments/*/placeholder\\n         .:Ask me anything ...\\nset-value:x:@.result\\n   strings.replace:x:@.result\\n      .:[[position]]\\n      get-first-value\\n         get-value:x:@.arguments/*/position\\n         .:right\\nset-value:x:@.result\\n   strings.replace:x:@.result\\n      .:[[button]]\\n      get-first-value\\n         get-value:x:@.arguments/*/button\\n         .:\\nif:x:@.arguments/*/rtl\\n   set-value:x:@.result\\n      strings.replace:x:@.result\\n         .:[[rtl]]\\n         .:true\\nelse\\n   set-value:x:@.result\\n      strings.replace:x:@.result\\n         .:[[rtl]]\\n         .:false\\nif:x:@.arguments/*/references\\n   set-value:x:@.result\\n      strings.replace:x:@.result\\n         .:[[references]]\\n         .:true\\nelse\\n   set-value:x:@.result\\n      strings.replace:x:@.result\\n         .:[[references]]\\n         .:false\\nif:x:@.arguments/*/clear_button\\n   set-value:x:@.result\\n      strings.replace:x:@.result\\n         .:[[clear_button]]\\n         .:true\\nelse\\n   set-value:x:@.result\\n      strings.replace:x:@.result\\n         .:[[clear_button]]\\n         .:false\\nif:x:@.arguments/*/copyButton\\n   set-value:x:@.result\\n      strings.replace:x:@.result\\n         .:[[copy_button]]\\n         .:true\\nelse\\n   set-value:x:@.result\\n      strings.replace:x:@.result\\n         .:[[copy_button]]\\n         .:false\\nif:x:@.arguments/*/follow_up\\n   set-value:x:@.result\\n      strings.replace:x:@.result\\n         .:[[follow_up]]\\n         .:true\\nelse\\n   set-value:x:@.result\\n      strings.replace:x:@.result\\n         .:[[follow_up]]\\n         .:false\\nif:x:@.arguments/*/new_tab\\n   set-value:x:@.result\\n      strings.replace:x:@.result\\n         .:[[new_tab]]\\n         .:true\\nelse\\n   set-value:x:@.result\\n      strings.replace:x:@.result\\n         .:[[new_tab]]\\n         .:false\\nif:x:@.arguments/*/code\\n   set-value:x:@.result\\n      strings.replace:x:@.result\\n         .:[[code]]\\n         .:true\\nelse\\n   set-value:x:@.result\\n      strings.replace:x:@.result\\n         .:[[code]]\\n         .:false\\nset-value:x:@.result\\n   strings.replace:x:@.result\\n      .:[[theme]]\\n      get-first-value\\n         get-value:x:@.arguments/*/theme\\n         .:modern\\nset-value:x:@.result\\n   strings.replace:x:@.result\\n      .:[[animation]]\\n      get-value:x:@.arguments/*/animation\\nset-value:x:@.result\\n   strings.replace:x:@.result\\n      .:[[popup]]\\n      get-value:x:@.arguments/*/popup\\n\\n// Fetching greeting for model.\\ndata.connect:[generic|magic]\\n   data.read\\n      table:ml_types\\n      columns\\n         greeting\\n         recaptcha\\n      where\\n         and\\n            type.eq:x:@.arguments/*/type\\n   .greeting\\n   set-value:x:@.greeting\\n      get-first-value\\n         get-value:x:@data.read/*/*/greeting\\n         .:Hello there! How may I help you today?\\n   set-value:x:@.greeting\\n      strings.replace:x:@.greeting\\n         .:`\\n         .:\"${\\\"`\\\"}\"\\n   set-value:x:@.result\\n      strings.replace:x:@.result\\n         .:[[greeting]]\\n         strings.replace:x:@.greeting\\n            .:\"\\\\\"\\n            .:\\n   if\\n      or\\n         null:x:@data.read/*/*/recaptcha\\n         eq:x:@data.read/*/*/recaptcha\\n            .:\\n         eq\\n            convert:x:@data.read/*/*/recaptcha\\n               type:decimal\\n            .:decimal:0\\n      .lambda\\n         set-value:x:@.captcha\\n            .:\\n   else-if\\n      lt\\n         convert:x:@data.read/*/*/recaptcha\\n            type:decimal\\n         .:decimal:0\\n      .lambda\\n         set-value:x:@.captcha\\n            .:-1\\nset-value:x:@.result\\n   strings.replace:x:@.result\\n      .:[[recaptcha]]\\n      get-value:x:@.captcha\\n\\n// Making sure we return correct Content-Type to caller, and applying some cache.\\nresponse.headers.set\\n   Content-Type:application/javascript; charset=utf-8\\n\\n// Returning result to caller.\\nreturn:x:@.result\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns the JavaScript required to embed a ChatGPT based chatbot on some website to caller."},{"role":"assistant","content":".arguments\\n   css:string\\n   file:string\\n   type:string\\n   header:string\\n   button:string\\n   render_button:bool\\n   parent_node:string\\n   search:bool\\n   chat:bool\\n   markdown:bool\\n   speech:bool\\n   rtl:bool\\n   submit_button:bool\\n   stream:bool\\n\\n   // Not used, but allows embedders to do a hard refresh to reload JavaScript.\\n   v:string\\n\\n   // Legacy parameter, ignore, no longer in use.\\n   gpt:bool\\nadd:x:./*/execute-file\\n   get-nodes:x:@.arguments/*\\nexecute-file:/system/openai/include-javascript.js.get.hl\\nreturn:x:-\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns the JavaScript required to embed a ChatGPT based chatbot on some website to caller."},{"role":"assistant","content":".arguments\\n   css:string\\n   file:string\\n   type:string\\n   header:string\\n   button:string\\n   render_button:bool\\n   parent_node:string\\n   search:bool\\n   chat:bool\\n   markdown:bool\\n   speech:bool\\n   rtl:bool\\n   submit_button:bool\\n   stream:bool\\n\\n   // Not used, but allows embedders to do a hard refresh to reload JavaScript.\\n   v:string\\n\\n   // Legacy parameter, ignore, no longer in use.\\n   gpt:bool\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/type\\n\\n// Applying default values if not specified.\\nvalidators.default:x:@.arguments\\n   render_button:bool:true\\n   file:default\\n   css:default\\n   chat:bool:true\\n   search:bool:false\\n   markdown:bool:true\\n   speech:bool:false\\n   rtl:bool:false\\n   submit_button:bool:false\\n   stream:bool:false\\n   parent_node:\\n\\n// Checking if we've got a cached JavaScript file.\\nstrings.join:x:@.arguments/*\\n   .:,\\n.cached-file\\nset-value:x:-\\n   strings.concat\\n      .:/etc/cache/\\n      crypto.hash.sha256:x:@strings.join\\n      .:.js\\nif\\n   io.file.exists:x:@.cached-file\\n   .lambda\\n\\n      // Cached transformed file exists, returning it immediately, applying correct HTTP headers.\\n      response.headers.set\\n         Content-Type:application/javascript; charset=utf-8\\n      io.stream.open-file:x:@.cached-file\\n      return:x:-\\n\\n// Checking if custom JavaScript file exists.\\n.result\\nstrings.concat\\n   .:/etc/system/openai/\\n   get-value:x:@.arguments/*/file\\n   .:.js\\nif\\n   io.file.exists:x:@strings.concat\\n   .lambda\\n\\n      // We need to load a custom JavaScript file.\\n      set-value:x:@.result\\n         io.file.load:x:@strings.concat\\nelse\\n\\n   // We need to load a system JavaScript file, making sure it exists.\\n   strings.concat\\n      .:/system/openai/front.files/chat/\\n      get-value:x:@.arguments/*/file\\n      .:.js\\n   if\\n      io.file.exists:x:@strings.concat\\n      .lambda\\n\\n         // System JavaScript file exists, making sure we use it.\\n         set-value:x:@.result\\n            io.file.load:x:@strings.concat\\n   else\\n\\n      // Oops, no such file exists.\\n      throw:No such AI chat template file exists\\n         public:bool:true\\n         status:400\\n\\n// Figuring out API URL.\\n.scheme\\nrequest.host\\nif\\n   strings.contains:x:@request.host\\n      .:localhost\\n   .lambda\\n      set-value:x:@.scheme\\n         .:http\\nelse\\n   set-value:x:@.scheme\\n      .:https\\n.url\\nset-value:x:@.url\\n   strings.concat\\n      get-value:x:@.scheme\\n      .:\"://\"\\n      request.host\\n\\n// Retrieving reCAPTCHA key.\\n.captcha\\nset-value:x:@.captcha\\n   config.get:\"magic:auth:recaptcha:key\"\\n      .:\\n\\n// Dynamically exchanging template fields in JavaScript file.\\nset-value:x:@.result\\n   strings.replace:x:@.result\\n      .:[[url]]\\n      get-value:x:@.url\\nset-value:x:@.result\\n   strings.replace:x:@.result\\n      .:[[ainiro_watermark]]\\n      get-first-value\\n         config.get:\"magic:watermark\"\\n         .:\"Powered by <a href=\\\"https://ainiro.io\\\" target=\\\"_blank\\\">AINIRO.IO</a>\"\\nset-value:x:@.result\\n   strings.replace:x:@.result\\n      .:[[ainiro_version]]\\n      version\\nset-value:x:@.result\\n   strings.replace:x:@.result\\n      .:[[recaptcha]]\\n      get-value:x:@.captcha\\nset-value:x:@.result\\n   strings.replace:x:@.result\\n      .:[[type]]\\n      get-value:x:@.arguments/*/type\\nset-value:x:@.result\\n   strings.replace:x:@.result\\n      .:[[parent_node]]\\n      get-value:x:@.arguments/*/parent_node\\nset-value:x:@.result\\n   strings.replace:x:@.result\\n      .:[[header]]\\n      get-first-value\\n         get-value:x:@.arguments/*/header\\n         .:\\nset-value:x:@.result\\n   strings.replace:x:@.result\\n      .:[[button]]\\n      get-first-value\\n         get-value:x:@.arguments/*/button\\n         .:\\nset-value:x:@.result\\n   strings.replace:x:@.result\\n      .:[[css]]\\n      get-first-value\\n         get-value:x:@.arguments/*/css\\n         get-value:x:@.arguments/*/file\\n         .:\\nset-value:x:@.result\\n   strings.replace:x:@.result\\n      .:[[render_button]]\\n      get-value:x:@.arguments/*/render_button\\nif:x:@.arguments/*/search\\n   set-value:x:@.result\\n      strings.replace:x:@.result\\n         .:[[search]]\\n         .:true\\nelse\\n   set-value:x:@.result\\n      strings.replace:x:@.result\\n         .:[[search]]\\n         .:false\\nif:x:@.arguments/*/chat\\n   set-value:x:@.result\\n      strings.replace:x:@.result\\n         .:[[chat]]\\n         .:true\\nelse\\n   set-value:x:@.result\\n      strings.replace:x:@.result\\n         .:[[chat]]\\n         .:false\\nif:x:@.arguments/*/markdown\\n   set-value:x:@.result\\n      strings.replace:x:@.result\\n         .:[[markdown]]\\n         .:true\\nelse\\n   set-value:x:@.result\\n      strings.replace:x:@.result\\n         .:[[markdown]]\\n         .:false\\nif:x:@.arguments/*/speech\\n   set-value:x:@.result\\n      strings.replace:x:@.result\\n         .:[[speech]]\\n         .:true\\nelse\\n   set-value:x:@.result\\n      strings.replace:x:@.result\\n         .:[[speech]]\\n         .:false\\nif:x:@.arguments/*/rtl\\n   set-value:x:@.result\\n      strings.replace:x:@.result\\n         .:[[rtl]]\\n         .:true\\nelse\\n   set-value:x:@.result\\n      strings.replace:x:@.result\\n         .:[[rtl]]\\n         .:false\\nif:x:@.arguments/*/submit_button\\n   set-value:x:@.result\\n      strings.replace:x:@.result\\n         .:[[submit_button]]\\n         .:true\\nelse\\n   set-value:x:@.result\\n      strings.replace:x:@.result\\n         .:[[submit_button]]\\n         .:false\\nif:x:@.arguments/*/stream\\n   set-value:x:@.result\\n      strings.replace:x:@.result\\n         .:[[stream]]\\n         .:true\\nelse\\n   set-value:x:@.result\\n      strings.replace:x:@.result\\n         .:[[stream]]\\n         .:false\\n\\n// Fetching greeting for model.\\ndata.connect:[generic|magic]\\n   data.read\\n      table:ml_types\\n      columns\\n         greeting\\n      where\\n         and\\n            type.eq:x:@.arguments/*/type\\n   .greeting\\n   set-value:x:@.greeting\\n      get-first-value\\n         get-value:x:@data.read/*/*/greeting\\n         .:Hello there! How may I help you today?\\n   set-value:x:@.greeting\\n      strings.replace:x:@.greeting\\n         .:\"\\n\"\\n         .:\"\\\\n\"\\n   set-value:x:@.greeting\\n      strings.replace:x:@.greeting\\n         .:\"\\r\"\\n         .:\"\\\\r\"\\n   set-value:x:@.greeting\\n      strings.replace:x:@.greeting\\n         .:\"'\"\\n         .:\"\\\\'\"\\n   set-value:x:@.result\\n      strings.replace:x:@.result\\n         .:[[greeting]]\\n         get-value:x:@.greeting\\n\\n// Checking if cache folder exists.\\nif\\n   not\\n      io.folder.exists:/etc/cache/\\n   .lambda\\n\\n      // Creating cache folder.\\n      io.folder.create:/etc/cache/\\n\\n// Making sure we cache file.\\nio.file.save:x:@.cached-file\\n   get-value:x:@.result\\n\\n// Making sure we return correct Content-Type to caller, and applying some cache.\\nresponse.headers.set\\n   Content-Type:application/javascript; charset=utf-8\\n\\n// Returning result to caller.\\nreturn:x:@.result\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns the specified CSS file to caller."},{"role":"assistant","content":".arguments\\n   file:string\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/file\\n\\n// Checking if custom CSS file exists.\\n.result\\nstrings.concat\\n   .:/etc/system/openai/css/search/\\n   get-value:x:@.arguments/*/file\\n   .:.css\\nif\\n   io.file.exists:x:@strings.concat\\n   .lambda\\n\\n      // Custom template file.\\n      set-value:x:@.result\\n         io.file.load:x:@strings.concat\\nelse\\n\\n   // Checking if system CSS file exists.\\n   strings.concat\\n      .:/system/openai/front.files/search/\\n      get-value:x:@.arguments/*/file\\n      .:.css\\n   if\\n      io.file.exists:x:@strings.concat\\n      .lambda\\n\\n         // Generic template file.\\n         set-value:x:@.result\\n            io.file.load:x:@strings.concat\\n   else\\n\\n      // Oops, no such file exists.\\n      throw:No such AI chat template file exists\\n         public:bool:true\\n         status:400\\n\\n// Making sure we return correct Content-Type to caller, and applying some cache.\\nresponse.headers.set\\n   Content-Type:text/css\\n\\n// Returning result to caller.\\nreturn:x:@.result\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns the specified CSS file to caller."},{"role":"assistant","content":".arguments\\n   file:string\\n   position:string\\n   color:string\\n   link:string\\n   start:string\\n   end:string\\n   v:string\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/file\\n\\n// Buffer for filename.\\n.filename\\n\\n// Checking if custom CSS file exists.\\nstrings.concat\\n   .:/etc/system/openai/css/chat/\\n   get-value:x:@.arguments/*/file\\n   .:.css\\nif\\n   io.file.exists:x:@strings.concat\\n   .lambda\\n\\n      // Custom template file.\\n      set-value:x:@.filename\\n         get-value:x:@strings.concat\\nelse\\n\\n   // Checking if system CSS file exists.\\n   strings.concat\\n      .:/system/openai/front.files/chat/\\n      get-value:x:@.arguments/*/file\\n      .:.css\\n   if\\n      io.file.exists:x:@strings.concat\\n      .lambda\\n\\n         // Generic template file.\\n         set-value:x:@.filename\\n            get-value:x:@strings.concat\\n   else\\n\\n      // Oops, no such file exists.\\n      throw:No such AI chat CSS file exists\\n         public:bool:true\\n         status:400\\n\\n// Checking if minified version of file exists.\\nstrings.replace:x:@.filename\\n   .:.css\\n   .:.min.css\\nif\\n   io.file.exists:x:@strings.replace\\n   .lambda\\n      set-value:x:@.filename\\n         get-value:x:@strings.replace\\n\\n// Loading common file.\\n.common\\nif\\n   io.file.exists:/system/openai/front.files/chat/common.min.css\\n   .lambda\\n      set-value:x:@.common\\n         load-file:/system/openai/front.files/chat/common.min.css\\nelse\\n   set-value:x:@.common\\n      load-file:/system/openai/front.files/chat/common.css\\n\\n// Applying variables.\\nset-value:x:@.common\\n   strings.concat\\n      .:\"html>body.ainiro_bdy {--ainiro-color:\"\\n      get-value:x:@.arguments/*/color\\n      .:;\\n      .:\"--ainiro-link:\"\\n      get-value:x:@.arguments/*/link\\n      .:;\\n      .:\"--ainiro-bg-start:\"\\n      get-value:x:@.arguments/*/start\\n      .:;\\n      .:\"--ainiro-bg-end:\"\\n      get-value:x:@.arguments/*/end\\n      .:;\\n      .:}\\n      get-value:x:@.common\\n\\n// Loading file and adding common.css file first.\\n.content\\nset-value:x:@.content\\n   load-file:x:@.filename\\nset-value:x:@.content\\n   strings.replace:x:@.content\\n      .:\".common{opacity:0}\"\\n      get-value:x:@.common\\n\\n// Making sure we return correct Content-Type to caller, and applying some cache.\\nresponse.headers.set\\n   Content-Type:text/css; charset=utf-8\\n\\n// Returning result to caller.\\nreturn:x:@.content\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns the specified CSS file to caller."},{"role":"assistant","content":".arguments\\n   file:string\\n   position:string\\n   color:string\\n   link:string\\n   start:string\\n   end:string\\n   v:string\\nadd:x:./*/execute-file\\n   get-nodes:x:@.arguments/*\\nexecute-file:/system/openai/include-style.css.get.hl\\nreturn:x:-\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns true if OpenAI has been enabled, which is the case if\\nuser have added an OpenAI API key to his or her configuration."},{"role":"assistant","content":".arguments\\n.type:internal\\n\\n// Making sure user has access to invoked endpoint.\\nauth.ticket.verify:root\\n\\n// Checking if configuration setting for OpenAI API key exists.\\nconfig.get:\"magic:openai:key\"\\nif\\n   eq:x:@config.get\\n      .\\n   .lambda\\n\\n      // No API key found for OpenAI\\n      return\\n         result:bool:false\\n\\n// OpenAI API key exists.\\nreturn\\n   result:bool:true\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns OpenAI API key to caller."},{"role":"assistant","content":".arguments\\n.type:internal\\n\\n// Making sure user has access to invoked endpoint.\\nauth.ticket.verify:root\\n\\n// Reading OpenAI API key from configuration.\\nconfig.get:\"magic:openai:key\"\\n\\n// Returning key to caller.\\nunwrap:x:+/*\\nreturn\\n   result:x:@config.get\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Configures OpenAI using its default training data,\\nand the specified API key."},{"role":"assistant","content":".arguments\\n   key:string\\n.type:internal\\n\\n// Making sure user has access to invoked endpoint.\\nauth.ticket.verify:root\\n\\n// Sanity checking invocation\\nvalidators.mandatory:x:@.arguments/*/key\\nvalidators.string:x:@.arguments/*/key\\n   min:20\\n   max:500\\n\\n// Loading configuration.\\nconfig.load\\njson2lambda:x:@config.load\\n\\n// Removing existing API key.\\nremove-nodes:x:@json2lambda/*/magic/*/openai\\n\\n// Adding specified key to configuration.\\nunwrap:x:+/*/*/*\\nadd:x:@json2lambda/*/magic\\n   .\\n      openai\\n         key:x:@.arguments/*/key\\n\\n// Transforming to JSON and saving configuration.\\nlambda2json:x:@json2lambda/*\\nconfig.save:x:@lambda2json\\n\\n// Returning success to caller.\\nreturn\\n   result:success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns all models from OpenAI, including fine tuned models."},{"role":"assistant","content":".type:internal\\n.arguments\\n   api_key:string\\n\\n// Making sure user has access to invoked endpoint.\\nauth.ticket.verify:root\\n\\n/*\\n * Creating our Bearer token by reading our OpenAI\\n * configuration settings.\\n */\\n.token\\nset-value:x:@.token\\n   strings.concat\\n      .:\"Bearer \"\\n      get-first-value\\n         get-value:x:@.arguments/*/api_key\\n         config.get:\"magic:openai:key\"\\n\\n// Creating an HTTP POST request towards OpenAI, now decorated.\\nhttp.get:\"https://api.openai.com/v1/models\"\\n   headers\\n      Authorization:x:@.token\\n   convert:true\\n\\n// Sanity checking above invocation\\nif\\n   neq:x:@http.get\\n      .:int:200\\n   .lambda\\n\\n      // Oops, error - Logging error and returning status 500 to caller.\\n      lambda2hyper:x:@http.get\\n      log.error:Something went wrong while invoking OpenAI\\n         error:x:@lambda2hyper\\n      response.status.set:500\\n      return\\n         message:Something went wrong while invoking OpenAI, check your log for details\\n\\n// Adding token count to models we know token count for.\\nfor-each:x:@http.get/*/content/*/data/*\\n   switch:x:@.dp/#/*/id\\n      case:gpt-4o\\n      case:gpt-4o-mini\\n      case:gpt-4o-2024-05-13\\n      case:gpt-4-turbo\\n      case:gpt-4-0125-preview\\n      case:gpt-4-1106-preview\\n      case:gpt-4-turbo-preview\\n      case:gpt-4-turbo-2024-04-09\\n      case:gpt-4-vision-preview\\n      case:gpt-4-1106-vision-preview\\n         add:x:@.dp/#\\n            .\\n               tokens:int:128000\\n               chat:bool:true\\n      case:gpt-4\\n      case:gpt-4-0613\\n         add:x:@.dp/#\\n            .\\n               tokens:int:8192\\n               chat:bool:true\\n      case:gpt-4-32k\\n      case:gpt-4-32k-0613\\n         add:x:@.dp/#\\n            .\\n               tokens:int:32768\\n               chat:bool:true\\n      case:gpt-3.5-turbo\\n      case:gpt-3.5-turbo-0125\\n      case:gpt-3.5-turbo-1106\\n      case:gpt-3.5-turbo-16k\\n      case:gpt-3.5-turbo-16k-0613\\n         add:x:@.dp/#\\n            .\\n               tokens:int:16385\\n               chat:bool:true\\n      case:gpt-3.5-turbo-0613\\n         add:x:@.dp/#\\n            .\\n               tokens:int:4096\\n               chat:bool:true\\n      case:gpt-3.5-turbo-instruct\\n         add:x:@.dp/#\\n            .\\n               tokens:int:4096\\n               chat:bool:false\\n      case:text-embedding-3-small\\n      case:text-embedding-ada-002\\n         add:x:@.dp/#\\n            .\\n               vector:bool:true\\n      case:o3-mini\\n         add:x:@.dp/#\\n            .\\n               tokens:int:200000\\n               chat:bool:true\\n      case:gpt-4.5-preview\\n         add:x:@.dp/#\\n            .\\n               tokens:int:128000\\n               chat:bool:true\\n\\n/*\\n * Applying some HTTP caching to avoid invoking OpenAI again with\\n * the same question before some minimum amount of time has passed.\\n */\\nresponse.headers.set\\n   Cache-Control:private, max-age=180\\n\\n// Returning results returned from invocation above to caller\\nadd:x:../*/return\\n   get-nodes:x:@http.get/*/content/*/data/*\\nreturn\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Asks OpenAI a question with the specified type, and returns the answer to caller."},{"role":"assistant","content":".arguments\\n   prompt:string\\n   type:string\\n   references:bool\\n   chat:bool\\n   recaptcha_response:string\\n   session:string\\n   user_id:string\\n.type:public\\n\\n/*\\n * Forward invocation to chat file, since there are no real differences\\n * between the two endpoints, since we're checking model type in chat file\\n * and acting accordingly.\\n * \\n * However, we still need to keep this file for legacy reasons.\\n */\\nadd:x:+\\n   get-nodes:x:@.arguments/*\\nio.file.execute:/system/openai/chat.get.hl\\nreturn:x:-/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Invokes the specified [action] with the specified [values]."},{"role":"assistant","content":".arguments\\n   action:string\\n   values:*\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/action\\n\\n// Figuring out what slot to invoke.\\n.slot\\nset-value:x:@.slot\\n   strings.concat\\n      .:magic.questionnaires.action.\\n      get-value:x:@.arguments/*/action\\n\\n// Parametrising slot.\\nadd:x:./*/signal\\n   get-nodes:x:@.arguments/*/values/*\\n\\n// Invoking slot.\\nsignal:x:@.slot\\n\\n// Returning success to caller.\\nreturn\\n   result:success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns the initial questionnaire for the specified type."},{"role":"assistant","content":".arguments\\n   type:string\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/type\\n\\n// Opening up database connection.\\ndata.connect:[generic|magic]\\n\\n   // Retrieving all questions from database.\\n   data.select:\"\\nselect q.question, q.type, q.context, q.name\\n\\tfrom questions q\\n\\t\\tinner join questionnaires qu on qu.name = q.questionnaire\\n        inner join ml_types t on t.initial_questionnaire = qu.name\\n\\twhere t.type = @type\\n   order by q.question_id\"\\n      type:x:@.arguments/*/type\\n\\n   // Retrieving main questionnaire from database.\\n   data.select:\"\\nselect q.name, q.type, q.action\\n   from questionnaires q\\n      inner join ml_types t on t.initial_questionnaire = q.name\\n   where t.type = @type\"\\n      type:x:@.arguments/*/type\\n\\n   // Returning result to caller.\\n   insert-before:x:./*/return/0\\n      get-nodes:x:@data.connect/*/data.select/[1,2]/*/*\\n   add:x:./*/return/*/questions\\n      get-nodes:x:@data.connect/*/data.select/[0,1]/*\\n   if\\n      not-exists:x:@data.connect/*/return/*/questions/*\\n      .lambda\\n         remove-nodes:x:@data.connect/*/return/*/questions\\n   return\\n      questions\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"OpenAI chat endpoint, for having conversations using \"gpt-xxx\" models."},{"role":"assistant","content":".arguments\\n   prompt:string\\n   type:string\\n   recaptcha_response:string\\n   max:int\\n.type:public\\n\\n// Invoking slot containing commonalities for all endpoints.\\ninsert-before:x:../*/signal/*/.callback\\n   get-nodes:x:@.arguments/*\\nsignal:magic.ai.endpoint-common\\n   .callback\\n\\n      // Invoking slot responsible for returning URLs to us.\\n      add:x:+\\n         get-nodes:x:@.arguments/*\\n      signal:magic.ai.search\\n\\n      // Returning results of above invocation to caller.\\n      add:x:./*/return-nodes/*/snippets\\n         get-nodes:x:@signal/*/snippets/*\\n      add:x:./*/return-nodes\\n         get-nodes:x:@signal/*/db_time\\n      return-nodes\\n         snippets\\n\\n/*\\n * Applying some HTTP caching to avoid invoking OpenAI again with\\n * the same question before some minimum amount of time has passed.\\n * \\n * Notice, we can apply more \"aggressive\" caching here than in our\\n * chat endpoints, since the same query will mostly always return\\n * the same result, since there is no room for \"creativity\" here.\\n */\\nresponse.headers.set\\n   Cache-Control:max-age=300\\n\\n// Returning result of worker slot to caller.\\nreturn-nodes:x:@signal/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Speaks the specified content using OpenAI TTS."},{"role":"assistant","content":".arguments\\n   content:string\\n   session:string\\n.type:internal\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/content\\nvalidators.mandatory:x:@.arguments/*/session\\n\\n// Creating a new thread to return before timeout.\\ninsert-before:x:../*/fork/0\\n   get-nodes:x:@.arguments\\nfork\\n\\n   // Retrieving token used to invoke OpenAI.\\n   .token\\n   config.get:\"magic:openai:key\"\\n   set-value:x:@.token\\n      strings.concat\\n         .:\"Bearer \"\\n         get-first-value\\n            get-value:x:@.arguments/*/api_key\\n            config.get:\"magic:openai:key\"\\n\\n   // Invoking OpenAI's API.\\n   http.post:\"https://api.openai.com/v1/audio/speech\"\\n      convert:bool:true\\n      headers\\n         Authorization:x:@.token\\n         Content-Type:application/json\\n         Accept:text/event-stream\\n      payload\\n         model:tts-1\\n         input:x:@.arguments/*/content\\n         voice:alloy\\n         response_format:mp3\\n         speed:decimal:1.0\\n\\n   // Sending speech to client.\\n   convert:x:@http.post/*/content\\n      type:base64\\n   unwrap:x:+/*/*\\n   sockets.signal:x:@.arguments/*/session\\n      args\\n         audio:x:@http.post/*/content\\nyield\\n   result:success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns all available system messages from the backend."},{"role":"assistant","content":".arguments\\n.type:internal\\n\\n// Making sure user has access to invoked endpoint.\\nauth.ticket.verify:root\\n\\n// Contains list of system messages we find.\\n.result\\n\\n// Listing custom files.\\nif\\n   io.folder.exists:/etc/system/openai/system-messages/\\n   .lambda\\n      io.file.list:/etc/system/openai/system-messages/\\n      for-each:x:@io.file.list/*\\n         if\\n            strings.ends-with:x:@.dp/#\\n               .:hl\\n            .lambda\\n               io.file.load:x:@.dp/#\\n               hyper2lambda:x:@io.file.load\\n               add:x:+/*/*\\n                  get-nodes:x:@hyper2lambda/*\\n               add:x:@.result\\n                  .\\n                     .\\n\\n// Listing system files.\\nif\\n   io.folder.exists:/system/openai/system-messages/\\n   .lambda\\n      io.file.list:/system/openai/system-messages/\\n      for-each:x:@io.file.list/*\\n         if\\n            strings.ends-with:x:@.dp/#\\n               .:hl\\n            .lambda\\n               io.file.load:x:@.dp/#\\n               hyper2lambda:x:@io.file.load\\n               add:x:+/*/*\\n                  get-nodes:x:@hyper2lambda/*\\n               add:x:@.result\\n                  .\\n                     .\\n\\n// Listing module specific system messages.\\nio.folder.list:/modules/\\nfor-each:x:@io.folder.list/*\\n   strings.concat\\n      get-value:x:@.dp/#\\n      .:system-messages/\\n   if\\n      io.folder.exists:x:@strings.concat\\n      .lambda\\n         io.file.list:x:@strings.concat\\n         for-each:x:@io.file.list/*\\n            if\\n               strings.ends-with:x:@.dp/#\\n                  .:hl\\n               .lambda\\n                  io.file.load:x:@.dp/#\\n                  hyper2lambda:x:@io.file.load\\n                  add:x:+/*/*\\n                     get-nodes:x:@hyper2lambda/*\\n                  add:x:@.result\\n                     .\\n                        .\\n\\n// Returning result to caller.\\nreturn-nodes:x:@.result/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns all available themes from the backend."},{"role":"assistant","content":".arguments\\n.type:internal\\n\\n// Making sure user has access to invoked endpoint.\\nauth.ticket.verify:root\\n\\n// Checking if custom CSS file exists.\\n.result\\n\\n// Listing custom files.\\nif\\n   io.folder.exists:/etc/system/openai/css/search/\\n   .lambda\\n      io.file.list:/etc/system/openai/css/search/\\n      for-each:x:@io.file.list/*\\n         if\\n            strings.ends-with:x:@.dp/#\\n               .:css\\n            .lambda\\n               strings.split:x:@.dp/#\\n                  .:/\\n               strings.split:x:@strings.split/0/-\\n                  .:.\\n               unwrap:x:+/*/*\\n               add:x:@.result\\n                  .\\n                     .:x:@strings.split/0\\n\\n// Listing system files.\\nif\\n   io.folder.exists:/system/openai/front.files/search/\\n   .lambda\\n      io.file.list:/system/openai/front.files/search/\\n      for-each:x:@io.file.list/*\\n         if\\n            strings.ends-with:x:@.dp/#\\n               .:css\\n            .lambda\\n               strings.split:x:@.dp/#\\n                  .:/\\n               strings.split:x:@strings.split/0/-\\n                  .:.\\n               if\\n                  not-exists:x:\"@.result/*/\\\"={@strings.split/0}\\\"\"\\n                  .lambda\\n                     unwrap:x:+/*/*\\n                     add:x:@.result\\n                        .\\n                           .:x:@strings.split/0\\n\\n// Returning result to caller.\\nreturn-nodes:x:@.result/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Creates a new training snippet."},{"role":"assistant","content":".arguments\\n\\n   // Optional URL for citations\\n   uri:string\\n\\n   // Mandatory prompt or short one liner description\\n   prompt:string\\n\\n   // Mandatory completion being the content or body of your snippet\\n   completion:string\\n\\n   // Mandatory machine learning to to associate snippet with\\n   type:string\\n.type:private\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root,service\\n\\n// Opening up database connection.\\ndata.connect:[generic|magic]\\n\\n   // Verifying user can create more snippets.\\n   add:x:+\\n      get-nodes:x:@.arguments/*/type\\n   try-signal:magic.ai.can-create-snippet\\n\\n   // Parametrising our create invocation.\\n   add:x:./*/data.create/*/values\\n      get-nodes:x:@.arguments/*\\n\\n   // Creating our record.\\n   data.create\\n      table:ml_training_snippets\\n      return-id:bool:true\\n      values\\n\\n   // Returning the correct status code.\\n   response.status.set:201\\n\\n   // Returning result of above invocation to caller.\\n   unwrap:x:+/*\\n   return\\n      id:x:@data.create\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Transcribes the specified file using OpenAI Whisper API."},{"role":"assistant","content":".arguments\\n   file:*\\n   type:string\\n   mediaType:string\\n   references:bool\\n   chat:bool\\n   recaptcha_response:string\\n   user_id:string\\n   session:string\\n   stream:bool\\n   data:string\\n   referrer:string\\n   whisper:*\\n   language:string\\n.type:internal\\n\\n// Retrieving token used to invoke OpenAI.\\nconfig.get:\"magic:openai:key\"\\n\\n// Applying defaults.\\nvalidators.default:x:@.arguments\\n   mediaType:audio/mp4\\n\\n// Reading stream.\\nio.stream.read:x:@.arguments/*/file/*/stream\\n\\n// Invoking Whisper to retrieve prompt.\\nopenai.whisper\\n   key:x:@config.get\\n   type:x:@.arguments/*/mediaType\\n   language:x:@.arguments/*/language\\n   content:x:@io.stream.read\\nif\\n   or\\n      null:x:@openai.whisper\\n      eq:x:@openai.whisper\\n         .:\\n   .lambda\\n      throw:Nothing returned from Whisper\\n         public:bool:true\\n         status:int:400\\n\\n// Invoking main chat file.\\nremove-nodes:x:@.arguments/*/file\\nadd:x:./*/execute-file\\n   get-nodes:x:@.arguments/*\\nexecute-file:/system/openai/chat.get.hl\\n   prompt:x:@openai.whisper\\n\\n// Returning success to caller.\\nadd:x:+\\n   get-nodes:x:@execute-file/*\\nyield\\n   prompt:x:@openai.whisper\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Stores the specified file as training data for the specified model.\\n\\nContrary to the other upload endpoint, this assumes it's given a CSV file, and\\nit will also use ALL columns in the file. It will assume the first column is\\nthe prompt though."},{"role":"assistant","content":".arguments\\n   type:string\\n   file:*\\n.type:internal\\n.accept:multipart/form-data\\n\\n// Ensures user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/type\\nvalidators.mandatory:x:@.arguments/*/file\\nvalidators.mandatory:x:@.arguments/*/file/*/name\\nvalidators.mandatory:x:@.arguments/*/file/*/stream\\n\\n// Reading file data from stream.\\nio.stream.read:x:@.arguments/*/file/*/stream\\n\\n// Converting file to lambda object.\\ncsv2lambda:x:@io.stream.read\\n\\n// Opening database connection.\\ndata.connect:[generic|magic]\\n\\n   // Iterating through each record in file.\\n   for-each:x:@csv2lambda/*\\n\\n      // Creating our completion.\\n      .prompt:\\n      .completion:\\n      set-value:x:@.prompt\\n         strings.concat\\n            get-name:x:@.dp/#/0\\n            .:\": \"\\n            get-value:x:@.dp/#/0\\n      for-each:x:@.dp/#/*/[1,1000]\\n         if\\n            and\\n               not-null:x:@.dp/#\\n               neq:x:@.dp/#\\n                  .:\\n            .lambda\\n               set-value:x:@.completion\\n                  strings.concat\\n                     get-value:x:@.completion\\n                     .:@\"\\n\"\\n                     .:@\"\\n\"\\n                     get-name:x:@.dp/#\\n                     .:\": \"\\n                     get-value:x:@.dp/#\\n      set-value:x:@.completion\\n         strings.trim:x:@.completion\\n\\n      // Importing item into database.\\n      data.create\\n         table:ml_training_snippets\\n         values\\n            type:x:@.arguments/*/type\\n            prompt:x:@.prompt\\n            completion:x:@.completion\\n            meta:x:@.arguments/*/file/*/name\\n\\n// Returning success to caller.\\nget-count:x:@csv2lambda/*\\nyield\\n   result:success\\n   count:x:@get-count\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Stores the specified image file as training data for the specified model."},{"role":"assistant","content":".arguments\\n   type:string\\n   file:*\\n.type:internal\\n.accept:multipart/form-data\\n\\n// Ensures user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/type\\nvalidators.mandatory:x:@.arguments/*/file\\nvalidators.mandatory:x:@.arguments/*/file/*/name\\nvalidators.mandatory:x:@.arguments/*/file/*/stream\\n\\n// First making sure folder exists.\\nif\\n   not\\n      io.folder.exists:/etc/www/assets/\\n   .lambda\\n      io.folder.create:/etc/www/assets/\\nif\\n   not\\n      io.folder.exists:/etc/www/assets/images/\\n   .lambda\\n      io.folder.create:/etc/www/assets/images/\\n\\n// Figuring out what filename to store file as.\\n.filename\\nset-value:x:@.filename\\n   strings.concat\\n      .:/etc/www/assets/images/\\n      get-value:x:@.arguments/*/file/*/name\\n\\n// Checking if file exists from before, and if so, deleting it.\\nif\\n   io.file.exists:x:@.filename\\n   .lambda\\n      io.file.delete:x:@.filename\\n\\n// Saving file to image folder.\\nio.stream.save-file:x:@.filename\\n   get-value:x:@.arguments/*/file/*/stream\\n\\n// Creating our URL.\\n.url\\nset-value:x:@.url\\n   strings.concat\\n      request.scheme\\n      .:\"://\"\\n      request.host\\n      .:/assets/images/\\n      get-value:x:@.arguments/*/file/*/name\\n\\n// Opening database connection.\\ndata.connect:[generic|magic]\\n\\n   // Figuring out prompt and completion.\\n   .prompt\\n   .completion\\n   set-value:x:@.prompt\\n      strings.concat\\n         .:\"Image - \"\\n         get-value:x:@.arguments/*/file/*/name\\n   set-value:x:@.completion\\n      strings.concat\\n         .:![\\n         get-value:x:@.arguments/*/file/*/name\\n         .:](\\n         get-value:x:@.url\\n         .:)\\n\\n   // We only create training snippet if prompt and completion doesn't exist from before.\\n   data.read\\n      table:ml_training_snippets\\n      where\\n         and\\n            prompt.eq:x:@.prompt\\n            completion.eq:x:@.completion\\n            type.eq:x:@.arguments/*/type\\n   if\\n      not-exists:x:@data.read/*\\n      .lambda\\n\\n         // Creating a training snippet for file.\\n         data.create\\n            table:ml_training_snippets\\n            values\\n               prompt:x:@.prompt\\n               completion:x:@.completion\\n               type:x:@.arguments/*/type\\n\\n// Returning success to caller.\\nyield\\n   result:success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Scrapes all URLs given in the specified CSV file.\\n\\nContrary to normal scraping and crawling, this will use the \"Spice\" feature and\\nonly import all URLs specified in the given file."},{"role":"assistant","content":".arguments\\n   type:string\\n   feedback-channel:string\\n   vectorize:bool\\n   file:*\\n.type:internal\\n.accept:multipart/form-data\\n\\n// Ensures user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/type\\nvalidators.mandatory:x:@.arguments/*/file\\nvalidators.mandatory:x:@.arguments/*/file/*/name\\nvalidators.mandatory:x:@.arguments/*/file/*/stream\\n\\n// Applying defaults.\\nvalidators.default:x:@.arguments\\n   vectorize:bool:false\\n\\n// Reading file data from stream.\\nio.stream.read:x:@.arguments/*/file/*/stream\\n\\n// Converting file to lambda object.\\ncsv2lambda:x:@io.stream.read\\n\\n// Sanity checking file.\\nif\\n   or\\n      mt\\n         get-count:x:@csv2lambda/0/*\\n         .:int:1\\n      and\\n         not\\n            strings.starts-with:x:@csv2lambda/0/0\\n               .:\"http://\"\\n         not\\n            strings.starts-with:x:@csv2lambda/0/0\\n               .:\"https://\"\\n   .lambda\\n\\n      // Oops, bogus file!\\n      log.info:URL list file not in correct format\\n         filename:x:@.arguments/*/file/*/name\\n      sockets.signal:x:@.arguments/*/feedback-channel\\n         args\\n            message:File not valid. A URL list file must have only one column, and contain only URLs in its single column.\\n            type:error\\n      return\\n         result:error\\n\\n// Doing some basic logging.\\nget-count:x:@csv2lambda/*\\nlog.info:URL list successfully uploaded\\n   count:x:@get-count\\n   type:x:@.arguments/*/type\\n\\n// Scraping on a background thread.\\nadd:x:./*/fork/*/.urls\\n   get-nodes:x:@csv2lambda/*\\ninsert-before:x:./*/fork/0\\n   get-nodes:x:@.arguments\\nfork\\n\\n   // Buffer containing all URLs we've got.\\n   .urls\\n\\n   // Looping through each URL in our list of URLs.\\n   for-each:x:@.urls/*/*\\n\\n      // Making sure we catch exceptions.\\n      try\\n\\n         /*\\n          * Invoking crawl implementation file, now with explicit list of links,\\n          * informing invocation that we do NOT want to process links.\\n          */\\n         execute:magic.ai.url.scrape\\n            url:x:@.dp/#\\n            type:x:@.arguments/*/type\\n            feedback-channel:x:@.arguments/*/feedback-channel\\n            lists:bool:false\\n            images:bool:false\\n            code:bool:false\\n         sockets.signal:x:@.arguments/*/feedback-channel\\n            args\\n               message:------------------------------------------------------------------------------------------------------------------------\\n               type:info\\n      .catch\\n\\n         // Informing user of what went wrong.\\n         sockets.signal:x:@.arguments/*/feedback-channel\\n            args\\n               message:x:@.arguments/*/message\\n               type:warning\\n\\n   /*\\n    * Crawling is done.\\n    * \\n    * Making sure we notify client that we're done and do some logging.\\n    */\\n   sockets.signal:magic.backend.message\\n      roles:root\\n      args\\n         message:Done creating OpenAI training data from URL list\\n         type:success\\n\\n   // Checking if we're supposed to vectorize model.\\n   if\\n      eq:x:@.arguments/*/vectorize\\n         .:bool:true\\n      .lambda\\n\\n         // Vectorizing model.\\n         execute:magic.ai.vectorise\\n            type:x:@.arguments/*/type\\n            feedback-channel:x:@.arguments/*/feedback-channel\\n            .onafter\\n\\n               // Signaling frontend.\\n               sockets.signal:x:@.arguments/*/feedback-channel\\n                  args\\n                     message:Done!\\n                     type:success\\n   else\\n\\n      // Signaling frontend.\\n      sockets.signal:x:@.arguments/*/feedback-channel\\n         args\\n            message:Done!\\n            type:success\\n\\n   // Basic logging.\\n   log.info:OpenAI training data successfully created from URL list\\n      type:x:@.arguments/*/type\\n\\n// Returning success to caller.\\nyield\\n   result:success\\n   count:x:@get-count\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Vectorises the specified training snippet."},{"role":"assistant","content":".arguments\\n   id:long\\n\\n// Ensures user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/id\\n\\n// Getting OpenAI API token from configuration.\\n.token\\nset-value:x:@.token\\n   strings.concat\\n      .:\"Bearer \"\\n      config.get:\"magic:openai:key\"\\n\\n// Connecting to database.\\ndata.connect:[generic|magic]\\n\\n   // Selecting snippet from database.\\n   data.read\\n      table:ml_training_snippets\\n         join:ml_types\\n            on\\n               and\\n                  ml_training_snippets.type.eq:ml_types.type\\n      columns\\n         prompt\\n         completion\\n         vector_model\\n      where\\n         and\\n            id.eq:x:@.arguments/*/id\\n\\n   // Buffer for what we're creating embeddings from.\\n   .embedding\\n   set-value:x:@.embedding\\n      strings.concat\\n         get-value:x:@data.read/*/*/prompt\\n         .:@\"\\n\\n\"\\n         get-value:x:@data.read/*/*/completion\\n\\n   // Creating an HTTP POST request towards OpenAI, now decorated.\\n   http.post:\"https://api.openai.com/v1/embeddings\"\\n      headers\\n         Authorization:x:@.token\\n         Content-Type:application/json\\n      payload\\n         model:x:@data.read/*/*/vector_model\\n         input:x:@.embedding\\n      convert:true\\n\\n   // Sanity checking above invocation.\\n   if\\n      not\\n         and\\n            mte:x:@http.post\\n               .:int:200\\n            lt:x:@http.post\\n               .:int:300\\n      .lambda\\n\\n         // Oops, error - Logging error and returning status 500 to caller.\\n         lambda2hyper:x:@http.post\\n         log.error:Something went wrong while invoking OpenAI\\n            message:x:@http.post/*/content/*/error/*/message\\n            error:x:@lambda2hyper\\n         throw:Could not create embeddings for model\\n\\n   // Deleting old vector with same ID.\\n   data.delete\\n      table:vss_ml_training_snippets\\n      where\\n         and\\n            rowid.eq:x:@.arguments/*/id\\n\\n   // Inserting embeddings for training snippet.\\n   floatArray2bytes:x:@http.post/*/content/*/data/0/*/embedding/*\\n   data.create\\n      table:vss_ml_training_snippets\\n      values\\n         embedding_vss:x:@floatArray2bytes\\n         rowid:x:@.arguments/*/id\\n\\n// Returning success to caller.\\nreturn\\n   result:success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Vectorises all training snippets in the specified model/type."},{"role":"assistant","content":".arguments\\n   type:string\\n   feedback-channel:string\\n\\n// Ensures user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/type\\n\\n// Doing some basic logging.\\nlog.info:Started vectorising model\\n   model:x:@.arguments/*/type\\n\\n// Creating a thread and invoking file doing the heavy lifting.\\ninsert-before:x:./*/fork/0\\n   get-nodes:x:@.arguments\\nfork\\n   add:x:./*/signal\\n      get-nodes:x:@.arguments/*\\n   signal:magic.ai.vectorise\\n      .onafter\\n         sockets.signal:x:@.arguments/*/feedback-channel\\n            args\\n               message:Done!\\n               type:success\\n\\n// Returning success to caller.\\nreturn\\n   result:success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create the system-message folder in user's /etc/ folder unless it already exists from before."},{"role":"assistant","content":"if\\n   not\\n      io.folder.exists:/etc/system/openai/system-messages/\\n   .lambda\\n      io.folder.create:/etc/system/openai/system-messages/\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Completion type of slot for non-GPT type of models."},{"role":"assistant","content":"slots.create:magic.ai.completion\\n\\n   /*\\n    * Checking if model is configured to return cached requests.\\n    * \\n    * Notice, the type needs to have turned on cache, and we need to have a\\n    * historical request that's cached matching the prompt and the type,\\n    * and caller must not have asked for references for the cache to kick in.\\n    */\\n   if\\n      and\\n         exists:x:@.arguments/*/cached\\n         not-null:x:@.arguments/*/cached\\n         eq\\n            convert:x:@.arguments/*/cached\\n               type:int\\n            .:int:1\\n         or\\n            not-exists:x:@.arguments/*/references\\n            not\\n               get-value:x:@.arguments/*/references\\n      .lambda\\n\\n         // Checking if we can find a cached request matching prompt and type.\\n         data.connect:[generic|magic]\\n            data.read\\n               table:ml_requests\\n               columns\\n                  completion\\n                  cached\\n               where\\n                  and\\n                     prompt.eq:x:@.arguments/*/prompt\\n                     type.eq:x:@.arguments/*/type\\n               limit:1\\n               order:created\\n               direction:desc\\n\\n            // Checking if we could find a matching request in cache.\\n            if\\n               and\\n                  exists:x:@data.read/*/*\\n                  eq\\n                     convert:x:@data.read/*/*/cached\\n                        type:int\\n                     .:int:1\\n               .lambda\\n\\n                  // Returning cached completion.\\n                  unwrap:x:+/*\\n                  return\\n                     result:x:@data.read/*/*/completion\\n                     finish_reason:cached\\n\\n   // Result we're returning to caller.\\n   .result\\n\\n   // Prompt that might be changed if model contains a prefix, and/or we're using embeddings.\\n   .prompt\\n\\n   /*\\n    * Checking if model is configured to use embeddings.\\n    * \\n    * If model is configured to using embeddings, we find relevant training snippets from\\n    * training data and use as \"CONTEXT\". If not, it might be either a fine-tuned model,\\n    * or a \"mint\" model, where mint implies no context or customisation having been done,\\n    * which is true if user just wants the default AI model without any customisations.\\n    */\\n   if\\n      eq\\n         convert:x:@.arguments/*/use_embeddings\\n            type:int\\n         .:int:1\\n      .lambda\\n\\n         // Retrieving relevant snippets.\\n         unwrap:x:+/*\\n         signal:magic.ai.get-context\\n            type:x:@.arguments/*/type\\n            prompt:x:@.arguments/*/prompt\\n            threshold:x:@.arguments/*/threshold\\n            max_tokens:x:@.arguments/*/max_context_tokens\\n            api_key:x:@.arguments/*/api_key\\n\\n         // Checking if we've got a cached result.\\n         if\\n            exists:x:@signal/*/cached\\n            .lambda\\n\\n               // Cached result.\\n               unwrap:x:+/*\\n               return\\n                  result:x:@signal/*/cached\\n                  finish_reason:cached\\n\\n         // Adding db_time to [.result].\\n         add:x:@.result\\n            get-nodes:x:@signal/*/db_time\\n\\n         // Correctly applying prefix.\\n         if\\n            and\\n               strings.contains:x:@.arguments/*/prefix\\n                  .:[CONTEXT]\\n               strings.contains:x:@.arguments/*/prefix\\n                  .:[QUESTION]\\n               strings.contains:x:@.arguments/*/prefix\\n                  .:\"ANSWER:\"\\n            .lambda\\n\\n               // Structured prefix.\\n               set-value:x:@.prompt\\n                  strings.replace:x:@.arguments/*/prefix\\n                     .:[QUESTION]\\n                     get-value:x:@.arguments/*/prompt\\n               set-value:x:@.prompt\\n                  strings.replace:x:@.prompt\\n                     .:[CONTEXT]\\n                     get-value:x:@signal/*/context\\n         else\\n\\n            // Old style prefix.\\n            set-value:x:@.prompt\\n               strings.concat\\n                  get-value:x:@.arguments/*/prefix\\n                  .:@\"\\nQUESTION: \"\\n                  get-value:x:@.arguments/*/prompt\\n                  .:@\"\\nCONTEXT: \\n\"\\n                  get-value:x:@signal/*/context\\n                  .:@\"\\nANSWER: \"\\n\\n         // Checking if caller wants references.\\n         if\\n            and\\n               exists:x:@.arguments/*/references\\n               not-null:x:@.arguments/*/references\\n               get-value:x:@.arguments/*/references\\n            .lambda\\n               add:x:@.result\\n                  .\\n                     references\\n               add:x:@.result/*/references\\n                  get-nodes:x:@signal/*/snippets/*\\n   else\\n\\n      /*\\n       * Not using embeddings, either a mint model or a fine-tuned model.\\n       * \\n       * Checking if model is fine-tuned, which is true if model name contains\\n       * a colon (:), at which point we apply \"->\" and \" END\" to help model roundtrip.\\n       */\\n      if\\n         strings.contains:x:@.arguments/*/model\\n            .:\":\"\\n         .lambda\\n\\n            // Fine-tuned model, making sure we apply STOP characters to prompt and invocation.\\n            set-value:x:@.prompt\\n               strings.concat\\n                  get-value:x:@.arguments/*/prompt\\n                  .:\" ->\"\\n            add:x:../*/http.post/*/payload\\n               .\\n                  stop:\" END\"\\n      else\\n\\n         // \"Mint\" model - Implying default model without any customisations.\\n         set-value:x:@.prompt\\n            get-value:x:@.arguments/*/prompt\\n\\n   // Retrieving token.\\n   .token\\n   set-value:x:@.token\\n      strings.concat\\n         .:\"Bearer \"\\n         get-first-value\\n            get-value:x:@.arguments/*/api_key\\n            config.get:\"magic:openai:key\"\\n\\n   // Invoking OpenAI, now with a decorated prompt.\\n   http.post:\"https://api.openai.com/v1/completions\"\\n      headers\\n         Authorization:x:@.token\\n         Content-Type:application/json\\n      payload\\n         prompt:x:@.prompt\\n         model:x:@.arguments/*/model\\n         max_tokens:x:@.arguments/*/max_tokens\\n         temperature:x:@.arguments/*/temperature\\n      convert:true\\n\\n   // Sanity checking above invocation.\\n   if\\n      not\\n         and\\n            mte:x:@http.post\\n               .:int:200\\n            lt:x:@http.post\\n               .:int:300\\n      .lambda\\n\\n         // Oops, error - Logging error and returning status 500 to caller.\\n         lambda2hyper:x:@http.post\\n         log.error:Something went wrong while invoking OpenAI\\n            message:x:@http.post/*/content/*/error/*/message\\n            status:x:@http.post\\n            error:x:@lambda2hyper\\n         response.status.set:x:@http.post\\n         unwrap:x:+/*\\n         return\\n            error:bool:true\\n            result:x:@http.post/*/content/*/error/*/message\\n   else\\n\\n      // Success! Logging as such!\\n      log.info:Invoking OpenAI was a success\\n\\n   // Making sure we trim response before adding it to [.result].\\n   strings.trim:x:@http.post/*/content/*/choices/0/*/text\\n   unwrap:x:+/*/*\\n   add:x:@.result\\n      .\\n         result:x:@strings.trim\\n\\n   // Making sure we return finish reason to caller.\\n   get-first-value\\n      get-value:x:@http.post/*/content/*/choices/0/*/finish_reason\\n      .:unknown\\n   unwrap:x:+/*/*\\n   add:x:@.result\\n      .\\n         finish_reason:x:@get-first-value\\n\\n   // Re-opening database connection since it might have timed out while we're waiting for OpenAI.\\n   data.connect:[generic|magic]\\n\\n      // Checking if type is 'supervised', at which point we store prompt and completion.\\n      if\\n         and\\n            not\\n               get-value:x:@.result/*/error\\n            not\\n               exists:x:@data.read/*/*\\n            mt\\n               convert:x:@.arguments/*/supervised\\n                  type:int\\n               .:int:0\\n         .lambda\\n\\n            // Storing prompt and completion in ml_requests table.\\n            data.create\\n               table:ml_requests\\n               values\\n                  type:x:@.arguments/*/type\\n                  prompt:x:@.arguments/*/prompt\\n                  completion:x:@.result/*/result\\n                  finish_reason:x:@.result/*/finish_reason\\n                  session:x:@.arguments/*/session\\n                  user_id:x:@.arguments/*/user_id\\n                  referrer:x:@.arguments/*/referrer\\n\\n   /*\\n    * Applying some HTTP caching to avoid invoking OpenAI again with\\n    * the same question before some minimum amount of time has passed.\\n    */\\n   response.headers.set\\n      Cache-Control:max-age=30\\n\\n   // Returning results returned from invocation above to caller.\\n   add:x:+\\n      get-nodes:x:@.result/*/result\\n      get-nodes:x:@.result/*/finish_reason\\n      get-nodes:x:@.result/*/references\\n      get-nodes:x:@.result/*/db_time\\n   return\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Searches the internet using DuckDuckGo for the [query] query,\\nscrapes the resulting websites, and returns a context that can\\nbe used for querying OpenAI.\\n\\nWill not get more than [max_tokens] text."},{"role":"assistant","content":"slots.create:magic.ai.create-search-context\\n\\n   // Sanity checking invocation\\n   validators.mandatory:x:@.arguments/*/query\\n   validators.mandatory:x:@.arguments/*/max_tokens\\n   validators.integer:x:@.arguments/*/max_tokens\\n      min:250\\n      max:15000\\n\\n   // Invoking slot responsible for searching DuckDuckGo and scraping results.\\n   add:x:./*/signal\\n      get-nodes:x:@.arguments/*/session\\n   unwrap:x:+/*/query\\n   signal:magic.http.duckduckgo-and-scrape\\n      query:x:@.arguments/*/query\\n      max:int:5\\n\\n   // Buffer used to hold resulting Markdown.\\n   .markdown:\\n\\n   // Buffer used to hold how many tokens we've seen so far.\\n   .tokens:int:0\\n\\n   // Looping as long as we have not used up tokens.\\n   .cont:bool:true\\n   while:x:@.cont\\n\\n      // Iterating through each [snippet] in first result returned from above invocation.\\n      for-each:x:@signal/0/*/snippets/*\\n\\n         // Concatenating existing Markdown with currently iterated snippet\\n         strings.concat\\n            get-value:x:@.markdown\\n            get-value:x:@.dp/#/*/prompt\\n            .:@\"\\n\"\\n            get-value:x:@.dp/#/*/completion\\n            .:@\"\\n\"\\n            .:@\"\\n\"\\n\\n         // Verifying we don't ovwerflow [max_tokens] by adding currently iterated snippet.\\n         if\\n            lt\\n               openai.tokenize:x:@strings.concat\\n               get-value:x:@.arguments/*/max_tokens\\n            .lambda\\n\\n               // We still have more room for context.\\n               set-value:x:@.markdown\\n                  get-value:x:@strings.concat\\n\\n      // Used to hold reference Markdown URL for where information was fetched.\\n      .reference\\n      set-value:x:@.reference\\n         strings.concat\\n            .:\"Source: \"\\n            .:[\\n            get-value:x:@signal/0/*/title\\n            .:](\\n            get-value:x:@signal/0/*/url\\n            .:)\\n\\n      // Verifying we don't overflow [max_tokens] by adding source of information.\\n      strings.concat\\n         get-value:x:@.markdown\\n         get-value:x:@.reference\\n         .:@\"\\n\"\\n         .:@\"\\n\"\\n      if\\n         lt\\n            openai.tokenize:x:@strings.concat\\n            get-value:x:@.arguments/*/max_tokens\\n         .lambda\\n\\n            // Room for source of data.\\n            set-value:x:@.markdown\\n               get-value:x:@strings.concat\\n\\n      // Removing top item from [signal] invocation.\\n      remove-nodes:x:@signal/0\\n\\n      // Verifying we have more items.\\n      if\\n         not-exists:x:@signal/0\\n         .lambda\\n\\n            // We used everything from above invocation to DuckDuckGo scraping slot.\\n            set-value:x:@.cont\\n               .:bool:false\\n\\n   // Cleaning up Markdown.\\n   set-value:x:@.markdown\\n      strings.trim:x:@.markdown\\n         .:@\"\\n \t\"\\n\\n   // Returning Markdown to caller.\\n   return:x:@.markdown\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Dynamically executes a Hyperlambda file with the specified format assuming the specified [invocation] is\\na string in the following format:\\n\\nFUNCTION_INVOCATION[/system/misc/functions/send-email.hl]:\\n{\\n\"name\": \"Thomas Hansen\",\\n\"email\": \"thomas@gaiasoul.com\",\\n\"subject\": \"Howdy\",\\n\"body\": \"This is Frank\"\\n}\\n\\nNotice, the string must start with \"FUNCTION_INVOCATION\" and have the file name to what file\\nto execute inside of square brackets. The slot will extract the file name, and convert the JSON payload\\nto a lambda object, and then invoke the file, and return whatever the file returns back to the caller.\\n\\nThe slots requires a [type] argument being the machine learning type that triggered the invocation,\\nand if the type does not declare the specific function, the slot will throw an exception."},{"role":"assistant","content":"slots.create:magic.ai.functions.invoke\\n\\n   // Sanity checking invocation.\\n   validators.mandatory:x:@.arguments/*/type\\n   validators.mandatory:x:@.arguments/*/invocation\\n\\n   // Trimming [invocation] since it might start and end with special characters.\\n   set-value:x:@.arguments/*/invocation\\n      strings.trim:x:@.arguments/*/invocation\\n\\n   // Making sure [invocation] starts with FUNCTION_INVOCATION\\n   if\\n      not\\n         strings.starts-with:x:@.arguments/*/invocation\\n            .:FUNCTION_INVOCATION\\n      .lambda\\n\\n         // Oops ...!\\n         throw:Malformatted function invocation\\n            status:int:400\\n            public:bool:true\\n\\n   // Extracting file name.\\n   .file\\n   strings.split:x:@.arguments/*/invocation\\n      .:[\\n   strings.split:x:@strings.split/1\\n      .:]\\n   set-value:x:@.file\\n      get-value:x:@strings.split/0\\n\\n   // Ensuring function file exists in type to avoid \"function invocation injection attacks\".\\n   data.connect:[generic|magic]\\n      strings.concat\\n         :%FUNCTION_INVOCATION[\\n         get-value:x:@.file\\n         .:]%\\n      strings.concat\\n         :\"FUNCTION_INVOCATION ==> \"\\n         get-value:x:@.file\\n      data.scalar:select count(*) from ml_training_snippets where type = @type and (meta = @meta or completion like @completion)\\n         @type:x:@.arguments/*/type\\n         @meta:x:@strings.concat\\n         @completion:x:@strings.concat/@strings.concat\\n\\n      // If we couldn't find a training snippet with function invocation declaration, we look in system message.\\n      if\\n         eq:x:@data.scalar\\n            .:long:0\\n         .lambda\\n\\n            // Now checking if function invocation exists on system message.\\n            data.scalar:select count(*) from ml_types where type = @type and system_message like @func\\n               @type:x:@.arguments/*/type\\n               @func:x:@strings.concat/@strings.concat\\n            if\\n               eq:x:@data.scalar\\n                  .:long:0\\n               .lambda\\n\\n                  // Oops ...!!\\n                  throw:\"That function doesn't exist on type\"\\n                     public:bool:true\\n                     status:int:400\\n\\n   // Checking if we have a JSON payload.\\n   .json\\n   if\\n      strings.contains:x:@.arguments/*/invocation\\n         .:\":\"\\n      .lambda\\n\\n         // Extracting JSON payload.\\n         strings.split:x:@.arguments/*/invocation\\n            .:\":\"\\n         remove-nodes:x:@strings.split/0\\n         set-value:x:@.json\\n            strings.join:x:@strings.split/*\\n               .:\":\"\\n\\n         // Parametrising invocation.\\n         if\\n            neq:x:@.json\\n               .:\\n            .lambda\\n\\n               // We actually have some JSON.\\n               json2lambda:x:@.json\\n\\n               /*\\n                * Removing [session] and [user-id] from JSON arguments, to avoid applying these twice,\\n                * in case user didn't correctly prompt engineer the AI function.\\n                */\\n               remove-nodes:x:@json2lambda/*/_session\\n               remove-nodes:x:@json2lambda/*/_user-id\\n               remove-nodes:x:@json2lambda/*/_type\\n\\n               // Adding arguments to [execute-file].\\n               add:x:../*/execute-file\\n                  get-nodes:x:@json2lambda/*\\n\\n   /*\\n    * Loading file and transforming to lambda to see if the file requires a [_session], [_user-id] or [_type] arguments,\\n    * at which point we add the current [_session] value, the current [_user-id] value and the current [_type] value to its invocation.\\n    */\\n   load-file:x:@.file\\n   hyper2lambda:x:@load-file\\n   if\\n      exists:x:@hyper2lambda/*/.arguments/*/_session/=string\\n      .lambda\\n\\n         /*\\n          * File requires a [_session] and it is of type string, making sure we pass\\n          * in [_session] argument given to invocation.\\n          */\\n         unwrap:x:+/*/*\\n         add:x:../*/execute-file\\n            .\\n               _session:x:@.arguments/*/session\\n   if\\n      exists:x:@hyper2lambda/*/.arguments/*/_user-id/=string\\n      .lambda\\n\\n         /*\\n          * File requires a [_user-id] and it is of type string, making sure we pass\\n          * in [_user-id] argument given to invocation.\\n          */\\n         unwrap:x:+/*/*\\n         add:x:../*/execute-file\\n            .\\n               _user-id:x:@.arguments/*/user-id\\n   if\\n      exists:x:@hyper2lambda/*/.arguments/*/_type/=string\\n      .lambda\\n\\n         /*\\n          * File requires a [_type] and it is of type string, making sure we pass\\n          * in [_type] argument given to invocation.\\n          */\\n         unwrap:x:+/*/*\\n         add:x:../*/execute-file\\n            .\\n               _type:x:@.arguments/*/type\\n\\n   // Executing file.\\n   execute-file:x:@.file\\n\\n   // Doing some basic logging.\\n   log.info:Function invocation succeeded\\n      type:x:@.arguments/*/type\\n      function-file:x:@.file\\n\\n   // Figuring out name of function such that we can return it to the caller.\\n   strings.split:x:@.file\\n      .:/\\n   strings.split:x:@strings.split/0/-\\n      .:.\\n   remove-nodes:x:@strings.split/0/-\\n   strings.join:x:@strings.split/*\\n      .:.\\n\\n   // Returning result of invocation to caller.\\n   add:x:./*/yield/*/result\\n      get-nodes:x:@execute-file/*\\n   yield\\n      json:x:@.json\\n      workflow:x:@strings.join\\n      result\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Slot that returns [max] search results for the specified [type], given the\\nspecified [threshold], the specified [prompt] and the specified [vector_model]."},{"role":"assistant","content":"slots.create:magic.ai.search\\n\\n   // Sanity checking invocation.\\n   validators.mandatory:x:@.arguments/*/type\\n   validators.mandatory:x:@.arguments/*/prompt\\n   validators.mandatory:x:@.arguments/*/threshold\\n   validators.mandatory:x:@.arguments/*/max\\n   validators.mandatory:x:@.arguments/*/vector_model\\n   validators.string:x:@.arguments/*/prompt\\n      min:1\\n\\n   // Converting threshold in case we're given the wrong type.\\n   set-value:x:@.arguments/*/threshold\\n      convert:x:@.arguments/*/threshold\\n         type:double\\n\\n   // Retrieving OpenAI token required to invoke ChatGPT.\\n   .token\\n   set-value:x:@.token\\n      strings.concat\\n         .:\"Bearer \"\\n         config.get:\"magic:openai:key\"\\n\\n   // Retrieving embedding for prompt.\\n   http.post:\"https://api.openai.com/v1/embeddings\"\\n      headers\\n         Authorization:x:@.token\\n         Content-Type:application/json\\n      payload\\n         input:x:@.arguments/*/prompt\\n         model:x:@.arguments/*/vector_model\\n      convert:true\\n\\n   // Sanity checking above invocation.\\n   if\\n      not\\n         and\\n            mte:x:@http.post\\n               .:int:200\\n            lt:x:@http.post\\n               .:int:300\\n      .lambda\\n\\n         // Oops, error - Logging error and returning OpenAI's HTTP status code to caller.\\n         lambda2hyper:x:@http.post\\n         log.error:Something went wrong while invoking OpenAI\\n            message:x:@http.post/*/content/*/error/*/message\\n            error:x:@lambda2hyper\\n         throw:x:@http.post/*/content/*/error/*/message\\n            public:bool:true\\n            status:x:@http.post\\n\\n   // Connects to database to retrieve matching snippets\\n   data.connect:[generic|magic]\\n\\n      // Checking if we've got a prefix-url argument, defaulting to NOT NULL.\\n      .prefix-url:\"ts.uri is not null and \"\\n      if\\n         and\\n            exists:x:@.arguments/*/prefix-url\\n            not-null:x:@.arguments/*/prefix-url\\n            neq:x:@.arguments/*/prefix-url\\n               .:\\n         .lambda\\n\\n            // Restricting search according to [prefix-url] argument.\\n            set-value:x:@.prefix-url\\n               .:\"ts.uri like @prefix and \"\\n            add:x:@data.connect/*/data.select\\n               .\\n                  @prefix:x:@.arguments/*/prefix-url\\n\\n      // Fetching relevant snippets, making sure we profile the time it takes.\\n      .begin\\n      set-value:x:@.begin\\n         date.now\\n\\n      // Converting embeddings to a byte array of floats, since this is how we store embeddings in SQLite.\\n      floatArray2bytes:x:@http.post/*/content/*/data/0/*/embedding/*\\n      math.subtract\\n         .:float:1\\n         get-value:x:@.arguments/*/threshold\\n      strings.concat\\n         .:\"\\nselect vss.distance, ts.prompt, ts.uri\\n\\tfrom vss_ml_training_snippets as vss\\n    \\tinner join ml_training_snippets ts on ts.id = vss.rowid\\n   where\\n      ts.type = @type and \"\\n         get-value:x:@.prefix-url\\n         .:\"vss_search(vss.embedding_vss, @embedding) and\\n       vss.distance < @threshold\\ngroup by ts.uri\\norder by vss.distance\\nlimit @limit\"\\n      data.select:x:@strings.concat\\n         @embedding:x:@floatArray2bytes\\n         @type:x:@.arguments/*/type\\n         @threshold:x:@math.subtract\\n         @limit:x:@.arguments/*/max\\n\\n      // Measuring how much time we spent looping through snippets.\\n      .end\\n      set-value:x:@.end\\n         date.now\\n      .time\\n      set-value:x:@.time\\n         math.subtract\\n            get-value:x:@.end\\n            get-value:x:@.begin\\n      set-value:x:@.time\\n         time.format:x:@.time\\n            format:\"ss\\\\.fff\"\\n\\n      // Making sure we don't return [snippets] unless we actually have snippets.\\n      if\\n         not-exists:x:@data.select/*\\n         .lambda\\n            remove-nodes:x:../*/return/*/snippets\\n      else\\n         add:x:@data.connect/*/return/*/snippets\\n            get-nodes:x:@data.select/*\\n\\n      // Returning result to caller.\\n      unwrap:x:./*/return/*\\n      return\\n         db_time:x:@.time\\n         snippets\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Ensures cache folder exists."},{"role":"assistant","content":"if\\n   not\\n      io.folder.exists:/etc/cache/\\n   .lambda\\n      io.folder.create:/etc/cache/\\nelse\\n\\n   // Empties cache folder for JavaScript files.\\n   io.file.list:/etc/cache/\\n   for-each:x:@io.file.list/*\\n      io.file.delete:x:@.dp/#\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Chat slot for having conversations with OpenAI's \"gpt\" type of models."},{"role":"assistant","content":"slots.create:magic.ai.create-landing-page\\n\\n   // Sanity checking invocation.\\n   validators.mandatory:x:@.arguments/*/url\\n   validators.mandatory:x:@.arguments/*/type\\n\\n   // Adding [headers] argument unless already specified.\\n   if\\n      not-exists:x:@.arguments/*/headers\\n      .lambda\\n\\n         // Adding [headers] to [.arguments] such that we can create default HTTP headers further down.\\n         add:x:@.arguments\\n            .\\n               headers\\n\\n   // Adding default headers unless they're already specified.\\n   validators.default:x:@.arguments/*/headers\\n      User-Agent:AINIRO-Crawler 2.0\\n      Accept-Encoding:identity\\n      Accept:text/xml\\n\\n   // Signaling frontend.\\n   strings.concat\\n      .:\"Creating default landing page for \"\\n      get-value:x:@.arguments/*/type\\n      .:\" by copying \"\\n      get-value:x:@.arguments/*/url\\n   log.info:Creating default landing page for type\\n      type:x:@.arguments/*/type\\n      url:x:@.arguments/*/url\\n   unwrap:x:+/*/args/**\\n   sockets.signal:x:@.arguments/*/feedback-channel\\n      args\\n         message:x:@strings.concat\\n         type:info\\n   sleep:100\\n\\n   // Adding spacer.\\n   sockets.signal:x:@.arguments/*/feedback-channel\\n      args\\n         message:------------------------------------------------------------------------------------------------------------------------\\n         type:info\\n   sleep:100\\n\\n   // Retrieving HTML document from URL specified.\\n   add:x:./*/http.get\\n      get-nodes:x:@.arguments/*/headers\\n   http.get:x:@.arguments/*/url\\n\\n   // Converting to lambda to verify we've got a \"base\" element.\\n   html2lambda:x:@http.get/*/content\\n\\n   // Checking if document has a \"base\" element.\\n   if\\n      not\\n         exists:x:@html2lambda/*/html/*/head/*/base\\n      .lambda\\n\\n         // Adding base.\\n         unwrap:x:+/*/*/*\\n         add:x:@html2lambda/*/html/*/head\\n            .\\n               base\\n                  @href:x:@.arguments/*/url\\n\\n   // Moving base to the top of \"head\" section.\\n   insert-before:x:@html2lambda/*/html/*/head/0\\n      get-nodes:x:@html2lambda/*/html/*/head/*/base\\n   remove-nodes:x:@html2lambda/*/html/*/head/*/base/[1,2]\\n\\n   // Adding chatbot embed script to page.\\n   .header:\\n   set-value:x:@.header\\n      get-first-value\\n         config.get:\"magic:white-label:default-header\"\\n         .:Ask about our products or services\\n   set-value:x:@.header\\n      strings.url-encode:x:@.header\\n   .scheme:\"https://\"\\n   if\\n      strings.contains:x:@.arguments/*/host\\n         .:localhost\\n      .lambda\\n         set-value:x:@.scheme\\n            .:\"http://\"\\n   .chatbot\\n   set-value:x:@.chatbot\\n      strings.concat\\n         get-value:x:@.scheme\\n         get-value:x:@.arguments/*/host\\n         .:/magic/system/openai/include-chatbot.js?theme=modern-bubbles&type=\\n         get-value:x:@.arguments/*/type\\n         .:&header=\\n         get-value:x:@.header\\n         .:&button=AI%20Chatbot\\n         .:&color=%23fefefe&start=%237892e5&end=%23142660&link=%23fe8464&v=\\n         version\\n         .:&follow_up=true\\n   unwrap:x:\"+/*/*/*/\\\\@src\"\\n   add:x:@html2lambda/*/html/*/body\\n      .\\n         script\\n            @src:x:@.chatbot\\n            @defer\\n\\n   // Adding noindex to avoid duplicated content.\\n   add:x:@html2lambda/*/html/*/head\\n      .\\n         meta\\n            @name:robots\\n            @content:noindex\\n\\n   // Inserting canonical if it doesn't exist from before.\\n   if\\n      not\\n         exists:x:\"@html2lambda/*/html/*/head/*/link/*/\\\\@rel/=canonical\"\\n      .lambda\\n         unwrap:x:\"+/*/*/*/\\\\@href\"\\n         add:x:@html2lambda/*/html/*/head\\n            .\\n               link\\n                  @rel:canonical\\n                  @href:x:@.arguments/*/url\\n\\n   // Converting to HTML and saving to \"/etc/www/\" folder.\\n   lambda2html:x:@html2lambda/*\\n   strings.concat\\n      .:/etc/www/\\n      get-value:x:@.arguments/*/type\\n      .:.html\\n   io.file.save:x:@strings.concat\\n      get-value:x:@lambda2html\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Imports a list of training snippets as [snippets].\\n\\nWill use [prompt] and [completion] for training snippets, but you can optionally\\nsupply [uri], [filename] and [type]. If you don't provide a [type] argument, snippets will\\nbe imported into the 'default' type. If you supply a [filename] it will be used to determine\\nwhat file the snippet originated from, typically only useful for PDF files.\\n\\nThs slot will check to verify that [prompt] is not null, and only import training snippets\\nthat has a non-null value for [prompt]."},{"role":"assistant","content":"slots.create:magic.ai.import-snippets\\n\\n   // Connecting to database.\\n   data.connect:[generic|magic]\\n\\n      // Looping through each record specified in [snippets] collection.\\n      for-each:x:@.arguments/*/snippets/*\\n\\n         // Verifying prompt is not null.\\n         if:x:@.dp/#/*/prompt\\n\\n            // Verifying user can create more snippets.\\n            add:x:+\\n               get-nodes:x:@.arguments/*/type\\n            try-signal:magic.ai.can-create-snippet\\n\\n            // Creating a unique URI based upon the prompt unless the file contains a URI.\\n            .uri\\n            set-value:x:@.uri\\n               get-first-value\\n                  get-value:x:@.dp/#/*/uri\\n                  .:\\n\\n            // Using type from arguments unless file contains a type declaration.\\n            .type\\n            if\\n               and\\n                  exists:x:@.arguments/*/type\\n                  not-null:x:@.arguments/*/type\\n                  neq:x:@.arguments/*/type\\n                     .:\\n               .lambda\\n                  set-value:x:@.type\\n                     get-value:x:@.arguments/*/type\\n            else-if\\n               exists:x:@.dp/#/*/type\\n               .lambda\\n                  set-value:x:@.type\\n                     get-value:x:@.dp/#/*/type\\n            else\\n               set-value:x:@.type\\n                  .:default\\n\\n            // Checking if we've got a filename value.\\n            if\\n               exists:x:@.dp/#/*/filename\\n               .lambda\\n                  add:x:@for-each/*/data.create/*/values\\n                     get-nodes:x:@.dp/#/*/filename\\n\\n            // Inserting into database.\\n            data.create\\n               table:ml_training_snippets\\n               values\\n                  type:x:@.type\\n                  uri:x:@.uri\\n                  prompt:x:@.dp/#/*/prompt\\n                  completion:x:@.dp/#/*/completion\\n                  meta:imported\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Chops up the specified text into multiple training snippets according to type,\\nand optionally invokes OpenAI to summarize, or 'massage' the content, using the\\nspecified [massage] value as an instruction.\\n\\nThe content will be chopped up into multiple training snippets, each being a maximum\\nof 80% of the max_context_tokens for the specified [type], then afterwards each\\nsnippet will be massaged if you specified a [massage] value."},{"role":"assistant","content":"slots.create:magic.ai.massage\\n\\n   /*\\n    * Buffer for snippets since a single invocation might have more\\n    * characters than whatever OpenAI can maximum tolerate.\\n    */\\n   .snippets\\n\\n   // Retrieving max_context_tokens from type specified by caller.\\n   .max_tokens\\n   data.connect:[generic|magic]\\n      data.scalar:select max_context_tokens from ml_types where type = @type\\n         @type:x:@.arguments/*/type\\n\\n      // Making sure we never create training snippets larger than 80% of type's maximum context size.\\n      set-value:x:@.max_tokens\\n         math.divide\\n            math.multiply\\n               convert:x:@data.scalar\\n                  type:int\\n               .:int:80\\n            .:int:100\\n\\n   // Chopping up content into multiple snippets to avoid max_token overflow with OpenAI.\\n   .current:\\n   while\\n      mt\\n         strings.length:x:@.arguments/*/content\\n         .:int:0\\n      .lambda\\n\\n         // Creating a 500 character long sub-section from current content.\\n         strings.substring:x:@.arguments/*/content\\n            .:int:0\\n            .:int:500\\n\\n         // Removing part we're currently handling.\\n         if\\n            mt\\n               strings.length:x:@.arguments/*/content\\n               .:int:500\\n            .lambda\\n\\n               // Removing 500 first characters.\\n               set-value:x:@.arguments/*/content\\n                  strings.substring:x:@.arguments/*/content\\n                     .:int:500\\n         else\\n\\n            // There aren't 500 characters left, so we're just setting string to empty to escape [while].\\n            set-value:x:@.arguments/*/content\\n               .:\\n\\n         /*\\n          * Checking if current string + above substring overflows [.max_tokens],\\n          * at which point we create a new training snippet.\\n          */\\n         .tmp\\n         set-value:x:@.tmp\\n            strings.concat\\n               get-value:x:@.current\\n               get-value:x:@strings.substring\\n         if\\n            mt\\n               openai.tokenize:x:@.tmp\\n               get-value:x:@.max_tokens\\n            .lambda\\n\\n               // Creating new training snippet.\\n               unwrap:x:+/*/*/*\\n               add:x:@.snippets\\n                  .\\n                     .\\n                        content:x:@.current\\n               set-value:x:@.tmp\\n                  get-value:x:@strings.substring\\n\\n         // Updating [.current].\\n         set-value:x:@.current\\n            get-value:x:@.tmp\\n\\n   // Appending the remaining parts, if there are any.\\n   if\\n      neq:x:@.current\\n         .:\\n      .lambda\\n         unwrap:x:+/*/*/*\\n         add:x:@.snippets\\n            .\\n               .\\n                  content:x:@.current\\n\\n   // Checking if user wants to \"massage\" content.\\n   if\\n      or\\n         not-exists:x:@.arguments/*/massage\\n         null:x:@.arguments/*/massage\\n         eq:x:@.arguments/*/massage\\n            .:\\n      .lambda\\n\\n         // User wants to use content as is.\\n         for-each:x:@.snippets/*\\n\\n            // Adding currently iterated snippet to return invocation.\\n            unwrap:x:+/*/*/*\\n            add:x:../*/return\\n               .\\n                  .\\n                     prompt:x:@.arguments/*/prompt\\n                     completion:x:@.dp/#/*/content\\n   else\\n\\n      // Getting OpenAI API token from configuration.\\n      .token\\n      set-value:x:@.token\\n         strings.concat\\n            .:\"Bearer \"\\n            config.get:\"magic:openai:key\"\\n\\n      /*\\n       * User wants to use OpenAI to create for instance a summary\\n       * from the content before creating training data.\\n       * \\n       * The first line returned from OpenAI is assumed to be the prompt, all other lines\\n       * will be treated as the completion.\\n       * \\n       * Iterating through each snippet created above.\\n       */\\n      for-each:x:@.snippets/*\\n\\n         // Creating an HTTP POST request towards OpenAI to create structured data of the specified content.\\n         .max-tokens\\n         set-value:x:@.max-tokens\\n            math.subtract\\n               .:int:4000\\n               openai.tokenize:x:@.dp/#/*/content\\n         http.post:\"https://api.openai.com/v1/chat/completions\"\\n            headers\\n               Authorization:x:@.token\\n               Content-Type:application/json\\n            payload\\n               model:gpt-3.5-turbo\\n               max_tokens:x:@.max-tokens\\n               temperature:decimal:0.8\\n               messages\\n                  .\\n                     role:user\\n                     content:x:@.arguments/*/massage\\n                  .\\n                     role:user\\n                     content:x:@.dp/#/*/content\\n            convert:true\\n\\n         // Sanity checking above invocation.\\n         if\\n            not\\n               and\\n                  mte:x:@http.post\\n                     .:int:200\\n                  lt:x:@http.post\\n                     .:int:300\\n            .lambda\\n\\n               // Oops, error - Logging error and returning status 500 to caller.\\n               lambda2hyper:x:@http.post\\n               log.error:Something went wrong while invoking OpenAI\\n                  message:x:@http.post/*/content/*/error/*/message\\n                  status:x:@http.post\\n                  error:x:@lambda2hyper\\n\\n         // Creating our prompt.\\n         .prompt\\n         strings.split:x:@http.post/*/content/*/choices/0/*/message/*/content\\n            .:\"\\n\"\\n         set-value:x:@.prompt\\n            strings.trim:x:@strings.split/0\\n         remove-nodes:x:@strings.split/0\\n\\n         // Trimming the rest.\\n         for-each:x:@strings.split/*\\n            set-value:x:@.dp/#\\n               strings.trim:x:@.dp/#\\n                  .:@\"\\n \t\"\\n\\n         // Creating our completion.\\n         .completion\\n         set-value:x:@.completion\\n            strings.join:x:@strings.split/*\\n               .:@\"\\n\\n\"\\n\\n         // Adding currently iterated snippets to return invocation.\\n         unwrap:x:+/*/*/*\\n         add:x:../*/return\\n            .\\n               .\\n                  prompt:x:@.prompt\\n                  completion:x:@.completion\\n\\n   // Returning result of invocation to caller.\\n   return\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Tries to send a lead email if possible.\\n\\nNotice, only works is SMTP settings have been configured."},{"role":"assistant","content":"slots.create:magic.ai.send-lead-email\\n\\n   // Sanity checking invocation.\\n   validators.mandatory:x:@.arguments/*/type\\n   validators.mandatory:x:@.arguments/*/prompt\\n   validators.mandatory:x:@.arguments/*/session\\n   validators.mandatory:x:@.arguments/*/user_id\\n   validators.mandatory:x:@.arguments/*/lead_email\\n   validators.mandatory:x:@.arguments/*/contact_us\\n   try\\n\\n      // Verifying user has configured SMTP settings.\\n      config.get:\"magic:smtp:host\"\\n      if\\n         and\\n            not-null:x:@config.get\\n            neq:x:@config.get\\n               .:\\n         .lambda\\n\\n            // Verifying that user provided a valid email address.\\n            .email\\n            strings.split:x:@.arguments/*/prompt\\n               .:@\\n            strings.split:x:@strings.split/0\\n               .:\" \"\\n            strings.split:x:@strings.split/@strings.split/1\\n               .:\" \"\\n            set-value:x:@.email\\n               strings.concat\\n                  get-value:x:@strings.split/@strings.split/0/-\\n                  .:@\\n                  get-value:x:@strings.split/0\\n            set-value:x:@.email\\n               strings.trim:x:@.email\\n                  .:.,-\\n            validators.email:x:@.email\\n\\n            /*\\n             * Connecting to database and reading all requests from current session\\n             * such that we can add them to lead generation email, allowing users to\\n             * continue conversation where chatbot left it.\\n             */\\n            .body:\\n            data.connect:[generic|magic]\\n\\n               // Retrieving all requests belonging to session\\n               data.read\\n                  table:ml_requests\\n                  columns\\n                     prompt\\n                     completion\\n                  where\\n                     and\\n                        session.eq:x:@.arguments/*/session\\n\\n               // Creating email.\\n               for-each:x:@data.read/*\\n                  set-value:x:@.body\\n                     strings.concat\\n                        get-value:x:@.body\\n                        .:<strong>\\n                        get-value:x:@.dp/#/*/prompt\\n                        .:</strong>\\n                        .:<br>\\n                        .:<div>\\n                        get-value:x:@.dp/#/*/completion\\n                        .:</div>\\n                        .:<br>\\n\\n               // Adding last prompt.\\n               set-value:x:@.body\\n                  strings.concat\\n                     get-value:x:@.body\\n                     .:<strong>\\n                     get-value:x:@.arguments/*/prompt\\n                     .:</strong>\\n                     .:<br>\\n                     .:<div>\\n                     get-value:x:@.arguments/*/contact_us\\n                     .:</div>\\n\\n               // Sending email.\\n               strings.split:x:@.arguments/*/lead_email\\n                  .:,\\n               for-each:x:@strings.split/*\\n                  strings.trim:x:@.dp/#\\n                     .:\" \"\\n                  unwrap:x:+/*/*/*\\n                  add:x:../**/mail.smtp.send/*/message/*/to\\n                     .\\n                        .\\n                           name:AINIRO Lead Inbox\\n                           email:x:@strings.trim\\n\\n               // Storing response to ml_requests to keep history.\\n               data.create\\n                  table:ml_requests\\n                  values\\n                     type:x:@.arguments/*/type\\n                     prompt:x:@.arguments/*/prompt\\n                     completion:x:@.arguments/*/contact_us\\n                     finish_reason:lead\\n                     session:x:@.arguments/*/session\\n                     user_id:x:@.arguments/*/user_id\\n\\n            // Sending email.\\n            unwrap:x:+/**/content\\n            mail.smtp.send\\n               message\\n                  to\\n                  reply-to\\n                     Lead:x:@.email\\n                  subject:Chatbot lead\\n                  entity:text/html\\n                     content:x:@.body\\n\\n            // Logging the fact that a lead was generated.\\n            log.info:Lead was generated\\n\\n            // Returning success to caller.\\n            return:bool:true\\n      else\\n\\n         // No SMTP configuration found, returning false to caller.\\n         return:bool:false\\n   .catch\\n\\n      // Oops ...\\n      log.error:SMTP settings not valid\\n         message:x:@.arguments/*/message\\n         extra:To use lead generation with AINIRO, please apply a valid SMTP configuration.\\n\\n      // Returning failure to caller.\\n      return:bool:false\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Creates the slot that avoids abuse of AI chatbot if configuration setting is turned on.\\n\\nThis allows you to create a maximum number of chat requests each unique user ID can perform per day."},{"role":"assistant","content":"slots.create:magic.openai.chat-interceptor.avoid-abuse\\n\\n   // Getting original IP address of request.\\n   request.headers.get:cf-connecting-ip\\n\\n   // Verifying we've actually got an IP address.\\n   if\\n      and\\n         not-null:x:@request.headers.get\\n         neq:x:@request.headers.get\\n            .:\\n      .lambda\\n\\n         // Connecting to magic database.\\n         data.connect:magic\\n\\n            // Checking if IP address has been blocked previously.\\n            data.read\\n               table:ml_blocked_ips\\n               where\\n                  and\\n                     ip_address.eq:x:@request.headers.get\\n            if\\n               exists:x:@data.read/*\\n               .lambda\\n\\n                  // IP address has been blocked.\\n                  request.headers.list\\n                  add:x:./*/log.info\\n                     get-nodes:x:@request.headers.list/*\\n                  log.info:Potential abuse, user has been permanently blocked\\n                  throw:Sorry, you have been permanently blocked from accessing this AI chatbot because of abuse. Send an email to team@ainiro.io if you think this is not correct.\\n                     public:bool:true\\n                     status:int:401\\n\\n            // True if we should block IP address.\\n            .block:bool:false\\n\\n            // Checking if cloudlet is configured for maximum number of requests per day per user.\\n            config.get:\"magic:openai:max-daily-requests\"\\n            if\\n               and\\n                  not-null:x:@config.get\\n                  neq:x:@config.get\\n                     .:\\n               .lambda\\n\\n                  // Cloudlet is configured to only answer the same user n times per day.\\n                  .no\\n                  set-value:x:@.no\\n                     convert:x:@config.get\\n                        type:int\\n\\n                  // Counting questions user has asked today.\\n                  data.scalar:\"select count(*) from ml_requests where user_id = @user and created >= date('now', '-1 day')\"\\n                     @user:x:@.arguments/*/user_id\\n\\n                  // Checking if user has exhausted his daily requests.\\n                  if\\n                     mt\\n                        convert:x:@data.scalar\\n                           type:int\\n                        get-value:x:@.no\\n                     .lambda\\n\\n                        // Blocking user.\\n                        set-value:x:@.block\\n                           .:bool:true\\n\\n            // Checking if we should block user.\\n            if:x:@.block\\n\\n               // Blocking IP address.\\n               data.create\\n                  table:ml_blocked_ips\\n                  values\\n                     ip_address:x:@request.headers.get\\n                     user_id:x:@.arguments/*/user_id\\n\\n               // Writing it into our log.\\n               add:x:./*/log.info\\n                  request.headers.list\\n               log.info:IP address was permanently blocked\\n               throw:Sorry, you have been permanently blocked from accessing this AI chatbot because of abuse. Send an email to team@ainiro.io if you think this is not correct.\\n                  public:bool:true\\n                  status:int:401\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Subscribes the specified [name] and [email] to a newsletter using SendGrid account."},{"role":"assistant","content":"slots.create:magic.questionnaires.action.sendgrid-subscribe\\n\\n   // Sanity checking invocation.\\n   validators.mandatory:x:@.arguments/*/name\\n   validators.mandatory:x:@.arguments/*/email\\n   validators.email:x:@.arguments/*/email\\n\\n   // Invoking SendGrid to create recipient.\\n   .auth\\n   set-value:x:@.auth\\n      strings.concat\\n         .:\"Bearer \"\\n         config.get:\"magic:sendgrid:api-key\"\\n   config.get:\"magic:sendgrid:chatbot-list\"\\n   set-name:x:./*/http.put/**/full_name\\n      config.get:\"magic:sendgrid:full_name_id\"\\n         .:e1_T\\n   unwrap:x:+/**\\n   http.put:\"https://api.sendgrid.com/v3/marketing/contacts\"\\n      convert:true\\n      headers\\n         Authorization:x:@.auth\\n         Content-Type:application/json\\n      payload\\n         list_ids\\n            .:x:@config.get\\n         contacts\\n            .\\n               email:x:@.arguments/*/email\\n               custom_fields\\n                  full_name:x:@.arguments/*/name\\n\\n   // Sanity checking invocation.\\n   if\\n      neq:x:@http.put\\n         .:int:202\\n      .lambda\\n\\n         // Oops ...!!\\n         lambda2hyper:x:@http.put/*/content\\n         log.error:Could not add new contact to list\\n            email:x:@.arguments/*/email\\n            name:x:@.arguments/*/name\\n            stack:x:@lambda2hyper\\n   else\\n\\n      // Doing some basic logging\\n      log.info:Successfully added contact to SendGrid automation\\n         name:x:@.arguments/*/name\\n         email:x:@.arguments/*/email\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Deleting old task if it exists."},{"role":"assistant","content":"tasks.list:ainiro-crawl-machine-learning-models\\nif\\n   exists:x:@tasks.list/*\\n   .lambda\\n      tasks.delete:ainiro-crawl-machine-learning-models\\n\\n// Creating task that crawls all models periodically.\\ntasks.create:ainiro-crawl-machine-learning-models\\n   description:Periodically crawls all models once every day to add new pages to model\\n   repeats:24.hours\\n   .lambda\\n\\n      // Basic logging.\\n      log.info:Task to periodically crawl models about to be executed\\n\\n      // Connecting to database.\\n      data.connect:[generic|magic]\\n\\n         // Finding all types with a [base_url].\\n         data.read\\n            table:ml_types\\n            columns\\n               type\\n               base_url\\n            where\\n               and\\n                  base_url.neq\\n                  base_url.neq:\\n\\n         // Looping through all types returned above.\\n         for-each:x:@data.read/*\\n\\n            // Verifying URL is not null and not empty.\\n            if\\n               and\\n                  not-null:x:@.dp/#/*/base_url\\n                  neq:x:@.dp/#/*/base_url\\n                     .:\\n               .lambda\\n\\n                  // Making sure exceptions never leave thread.\\n                  try\\n\\n                     // Verifying user can create more snippets.\\n                     add:x:+\\n                        get-nodes:x:@.dp/#/*/type\\n                     try-signal:magic.ai.can-create-snippet\\n\\n                     // Doing some logging.\\n                     log.info:Crawling website\\n                        url:x:@.dp/#/*/base_url\\n                        type:x:@.dp/#/*/type\\n\\n                     // Invoking slot doing the heavy lifting.\\n                     unwrap:x:./*/signal/*\\n                     unwrap:x:./*/signal/*/.onafter/**/type\\n                     unwrap:x:./*/signal/*/.onafter/**/.type\\n                     signal:magic.ai.crawl-site\\n                        delay:int:2000\\n                        threshold:int:150\\n                        max:int:1250\\n                        summarize:bool:true\\n                        url:x:@.dp/#/*/base_url\\n                        type:x:@.dp/#/*/type\\n                        feedback-channel:non-existing\\n                        .onafter\\n                           signal:magic.ai.vectorise\\n                              feedback-channel:non-existing\\n                              type:x:@.dp/#/*/type\\n                              .onafter\\n\\n                                 // Basic logging.\\n                                 .type:x:@.dp/#/*/type\\n                                 strings.concat\\n                                    get-value:x:@.type\\n                                    .:\" successfully crawled\"\\n                                 log.info:x:-\\n                  .catch\\n\\n                     // Logging.\\n                     log.error:Could not crawl site\\n                        error:x:@.arguments/*/message\\n                        site:x:@.dp/#/*/base_url\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Creates scheduled task that deletes all cached questions / answers\\nfrom machine learning models that are older than 2 weeks, to preserve\\nstorage space.\\n\\nNotice, task ONLY executes if default database is SQLite, since database\\nmanagement is up to db-admin for serious databases."},{"role":"assistant","content":"if\\n   eq\\n      config.get:\"magic:databases:default\"\\n      .:sqlite\\n   .lambda\\n\\n      // Wrapping in try/catch in case task already exists.\\n      try\\n\\n         // Deleting old task if existing.\\n         tasks.list:delete-old-machine-learning-requests\\n         if\\n            exists:x:@tasks.list/*\\n            .lambda\\n               tasks.delete:x:@tasks.list/0/*/id\\n\\n         // Creating task that periodically deletes old historical requests.\\n         tasks.create:delete-old-machine-learning-requests\\n            description:Periodically deletes all machine learning requests older than 14 days\\n            repeats:72.hours\\n            .lambda\\n               sqlite.connect:magic\\n                  sqlite.execute:\"delete from ml_requests where created < date('now', '-14 day') and (cached = 0 or cached is null) and (questionnaire = 0 or questionnaire is null)\"\\n               log.info:Task to cleanup old machine learning requests executed successfully\\n                  deleted:x:@sqlite.connect/*/sqlite.execute\\n      .catch\\n\\n         // Task already exists.\\n         console.log:Task to periodically delete historical requests already exists\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Crawls the specified website generating training data for machine learning in the process."},{"role":"assistant","content":"slots.create:magic.ai.crawl-site\\n\\n   // Creating a thread and invoking file doing the heavy lifting.\\n   insert-before:x:./*/fork/0\\n      get-nodes:x:@.arguments\\n   fork\\n\\n      // Making sure exceptions does not leave thread.\\n      try\\n\\n         // Invoking slot responsible for doing the actual crawling.\\n         add:x:./*/signal\\n            get-nodes:x:@.arguments/*\\n         signal:magic.ai.crawl-site-on-thread\\n      .catch\\n\\n         // Oops ...!!\\n         log.error:x:@.arguments/*/message\\n            url:x:@.arguments/*/url\\n\\n         // Signaling frontend.\\n         strings.concat\\n            .:\"Error - \"\\n            get-value:x:@.arguments/*/message\\n         unwrap:x:+/*/args/*\\n         sockets.signal:x:@.arguments/@.arguments/*/feedback-channel\\n            roles:root\\n            args\\n               message:x:@strings.concat\\n               type:error\\n         sleep:100\\n\\n         // Checking if caller supplied [.onerror] handler.\\n         if\\n            exists:x:@.onerror\\n            .lambda\\n               add:x:+/+\\n                  get-nodes:x:@.arguments/*\\n               add:x:+\\n                  get-nodes:x:@.arguments/@.arguments/*\\n               invoke:x:@.onerror\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns Markdown training snippet from specified [html].\\n\\nTakes the following arguments:\\n\\n- [html]     - Mandatory. Being the actual HTML we're traversing for training data.\\n- [url]      - Optional.  Being the URL from where the document was fetched"},{"role":"assistant","content":"slots.create:magic.ai.html.extract\\n\\n   // Sanity checking invocation.\\n   validators.mandatory:x:@.arguments/*/html\\n   validators.mandatory:x:@.arguments/*/url\\n   validators.url:x:@.arguments/*/url\\n\\n   // Ensuring defaults.\\n   validators.default:x:@.arguments\\n      images:bool:true\\n      lists:bool:true\\n      code:bool:true\\n\\n   // Used to return meta information to caller.\\n   .meta\\n      main:int:0\\n\\n   // Buffer used for snippet to return.\\n   .snippets\\n\\n   // Buffer for title.\\n   .title\\n\\n   // Buffer for description.\\n   .description\\n\\n   // Used to store a reference to above HTML transformed to Markdown.\\n   .markdown\\n\\n   // Buffer used for URLs from HTML document.\\n   .urls\\n\\n   // Converting HTML to Markdown.\\n   html2markdown:x:@.arguments/*/html\\n      url:x:@.arguments/*/url\\n      images:x:@.arguments/*/images\\n      lists:x:@.arguments/*/lists\\n      code:x:@.arguments/*/code\\n\\n   // Checking if we have any Markdown at all, and if not we return early.\\n   if\\n      or\\n         null:x:@html2markdown\\n         eq:x:@html2markdown\\n            .:\\n      .lambda\\n\\n         // Nothing to do here ...\\n         return\\n            urls\\n            snippets\\n            meta\\n               main:int:0\\n\\n   // Retrieving title and description from document.\\n   set-value:x:@.title\\n      get-value:x:@html2markdown/*/title/[0,1]\\n   set-value:x:@.description\\n      get-value:x:@html2markdown/*/description/[0,1]\\n\\n   // Adding URLs found as we transformed HTML to Markdown.\\n   add:x:@.urls\\n      get-nodes:x:@html2markdown/*/urls/*\\n\\n   // Storing Markdown in above buffer node.\\n   set-value:x:@.markdown\\n      get-value:x:@html2markdown\\n\\n   /*\\n    * Creating our \"base prompt\", which is the default to be used for\\n    * all training snippets found in document.\\n    */\\n   .prompt\\n   set-value:x:@.prompt\\n      get-first-value\\n         get-value:x:@.title\\n         get-value:x:@.description\\n         .:Page\\n\\n   /*\\n    * Breaking page into sections.\\n    * \\n    * Here we are breaking page down into smaller training snippets, based upon\\n    * lists found at root, and pre sections (code).\\n    * \\n    * This is done to avoid creating summaries of lists that typically might contain\\n    * navbar parts and URLs, in addition to making sure we keep all code segments as is.\\n    * \\n    * The [.tmp-prompt] below is being used as the prompt for individual OL, UL and PRE\\n    * elements, while the [.remaining] part is the remaining Markdown after we've remove\\n    * all UL, OL and PRE elements.\\n    */\\n   .remaining\\n   .tmp-prompt\\n   set-value:x:@.tmp-prompt\\n      get-value:x:@.prompt\\n\\n   /*\\n    * For simplicity reasons we convert Markdown to HTML and then to lambda again,\\n    * to allow us to semantically traverse UL elements, OL elements and PRE elements.\\n    * \\n    * This allows us to extract UL, OL, and PRE elements, and import these as individual\\n    * training snippets.\\n    */\\n   markdown2html:x:@html2markdown\\n   html2lambda:x:@markdown2html\\n\\n   // Iterating through all root nodes found as we converted Markdown back to lambda again.\\n   for-each:x:@html2lambda/*\\n      get-name:x:@.dp/#\\n      switch:x:@get-name\\n         case:h1\\n         case:h2\\n         case:h3\\n         case:h4\\n         case:h5\\n         case:h6\\n\\n            /*\\n             * If page contains Hx element, we append it to our base\\n             * prompt, to try to keep as much of the (relevant) information as\\n             * possible in our prompt for our UL, OL and PRE training snippets.\\n             */\\n            set-value:x:@.tmp-prompt\\n               strings.concat\\n                  get-value:x:@.prompt\\n                  .:\" | \"\\n                  get-value:x:\"@.dp/#/*/\\\\#text\"\\n         case:ul\\n         case:ol\\n         case:pre\\n\\n            /*\\n             * This is a bulleted list, ordered list, or a code segment.\\n             * \\n             * We keep it exactly as is, but return it as an individual training snippet,\\n             * such that it becomes an isolated training snippet during\\n             * import.\\n             */\\n            lambda2html:x:@.dp/#\\n            html2markdown:x:@lambda2html\\n               url:x:@.arguments/*/url\\n            unwrap:x:+/*/*/*\\n            add:x:@.snippets\\n               .\\n                  .\\n                     prompt:x:@.tmp-prompt\\n                     completion:x:@html2markdown\\n         default\\n\\n            // Adding remaining HTML, minus the parts we removed.\\n            add:x:@.remaining\\n               get-nodes:x:@.dp/#\\n\\n   /*\\n    * Now we have removed all UL, OL, Hx and PRE elements, and [.remaining] contains\\n    * a lambda node hierarchy of everything that remains in the page, at which\\n    * point we can transform it back to HTML for then to transform it to Markdown,\\n    * and return that as an individual snippets, without PRE, UL and OL elements.\\n    */\\n   lambda2html:x:@.remaining/*\\n   set-value:x:@.markdown\\n      html2markdown:x:@lambda2html\\n         url:x:@.arguments/*/url\\n\\n   // Adding remaining HTML as an individual training snippet.\\n   .completion\\n   set-value:x:@.completion\\n      get-value:x:@.markdown\\n   unwrap:x:+/*/*/*\\n   add:x:@.snippets\\n      .\\n         .\\n            prompt:x:@.prompt\\n            completion:x:@.completion\\n\\n   // Returning snippets and meta information to caller.\\n   add:x:./*/return/*/snippets\\n      get-nodes:x:@.snippets/*\\n   add:x:./*/return/*/meta\\n      get-nodes:x:@.meta/*\\n   add:x:./*/return/*/urls\\n      get-nodes:x:@.urls/*\\n   return\\n      urls\\n      snippets\\n      meta\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Retrieves HTML from specified [url] and returns as HTML.\\n\\nOptionally provide [headers] argument to override the default HTTP headers."},{"role":"assistant","content":"slots.create:magic.ai.url.get\\n\\n   // Sanity checking invocation.\\n   validators.mandatory:x:@.arguments/*/url\\n   validators.url:x:@.arguments/*/url\\n\\n   // Adding [headers] argument unless already specified.\\n   if\\n      not-exists:x:@.arguments/*/headers\\n      .lambda\\n\\n         // Adding [headers] to [.arguments] such that we can create default HTTP headers further down.\\n         add:x:@.arguments\\n            .\\n               headers\\n\\n   // Adding default headers unless they're already specified.\\n   validators.default:x:@.arguments/*/headers\\n      User-Agent:AINIRO-Crawler 2.0\\n      Accept:text/html\\n      Accept-Encoding:identity\\n\\n   // Adding HTTP headers to invocation.\\n   add:x:./*/http.get\\n      get-nodes:x:@.arguments/*/headers\\n\\n   // Retrieving HTML document from specified URL.\\n   http.get:x:@.arguments/*/url\\n      timeout:60\\n\\n   // Sanity checking above invocation.\\n   if\\n      not\\n         and\\n            mte:x:@http.get\\n               .:int:200\\n            lt:x:@http.get\\n               .:int:300\\n      .lambda\\n\\n         // Checking if this is a 301 or 302 redirect.\\n         if\\n            or\\n               eq:x:@http.get\\n                  .:int:301\\n               eq:x:@http.get\\n                  .:int:302\\n            .lambda\\n\\n               // Checking if request was HTTP (no SSL) at which point we try SSL.\\n               if\\n                  strings.starts-with:x:@.arguments/*/url\\n                     .:\"http://\"\\n                  .lambda\\n\\n                     // Providing feedback to user.\\n                     sockets.signal:x:@.arguments/*/feedback-channel\\n                        args\\n                           message:Page moved to, trying SSL equivalent\\n                           type:info\\n                     sleep:100\\n\\n                     // Invoking self and returning result, exchanging http:// with https://.\\n                     strings.replace:x:@.arguments/*/url\\n                        .:\"http://\"\\n                        .:\"https://\"\\n                     add:x:+/*/headers\\n                        get-nodes:x:@.arguments/*/headers/*\\n                     execute:magic.ai.url.get\\n                        url:x:@strings.replace\\n                        headers\\n                     return:x:-\\n               else\\n\\n                  // Providing feedback to user.\\n                  strings.concat\\n                     .:\"Page moved to '\"\\n                     get-value:x:@http.get/*/headers/*/Location\\n                     .:\"', trying alternative location\"\\n                  unwrap:x:+/**\\n                  sockets.signal:x:@.arguments/*/feedback-channel\\n                     args\\n                        message:x:@strings.concat\\n                        type:info\\n                  sleep:100\\n\\n                  // Invoking self and returning result.\\n                  add:x:+/+/*/headers\\n                     get-nodes:x:@.arguments/*/headers/*\\n                  add:x:+\\n                     get-nodes:x:@.arguments/*/feedback-channel\\n                  execute:magic.ai.url.get\\n                     url:x:@http.get/*/headers/*/Location\\n                     headers\\n                  return:x:-\\n         else\\n\\n            // Oops, logging error.\\n            log.error:Something went wrong while trying to get URL\\n               url:x:@.arguments/*/url\\n               status:x:@http.get\\n            strings.concat\\n               .:\"HTTP invocation returned status code \"\\n               get-value:x:@http.get\\n            throw:x:-\\n\\n   /*\\n    * Above HTTP GET invocation returned success.\\n    * \\n    * Making sure URL returned HTML.\\n    */\\n   if\\n      or\\n         not-exists:x:@http.get/*/headers/*/Content-Type\\n         not\\n            strings.starts-with:x:@http.get/*/headers/*/Content-Type\\n               .:text/html\\n      .lambda\\n\\n         // Oops, doing some basic logging.\\n         log.error:URL did not return HTML content\\n            url:x:@.arguments/*/url\\n            content-type:x:@http.get/*/headers/*/Content-Type\\n         strings.concat\\n            .:\"URL did not return HTML content but '\"\\n            get-value:x:@http.get/*/headers/*/Content-Type\\n            .:\"' content\"\\n         throw:x:-\\n\\n   // Returning result of above HTTP GET invocation.\\n   return:x:@http.get/*/content\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Dynamic super sales exec system message"},{"role":"assistant","content":"name:Frank, DYNAMIC - Super Products and Service Sales Executive\\ndescription:\"A dynamically created sales executive based upon information found at the chatbot's website. Will not hallucinate but instead drive any sales conversation forward like a Super Sales Exec exclusively based upon your training data.\"\\ninstruction:I will give you some text in the form of Markdown. This text contains [[TEMPLATE]] fields, such as [[COMPANY]], [[PRODUCTS]], [[SERVICES]] etc. Your task is to use the information I specify in the next message to dynamically replace these template fields with the correct information you find in my next message while preserving everything else exactly as it is, including CR and LF characters. Your objective is to create a system instruction for an AI chatbot based upon GPT-4. Please create the system instruction at the best of your abilities, and return valid Markdown, without any irrelevant parts.\\nprefix:@\"## About [[COMPANY]]\\n\\n[[ABOUT_COMPANY]]\\n\\n## [[COMPANY]]'s value proposition\\n\\n[[VALUE_PROPOSITION]]\\n\\n## [[COMPANY]]'s services\\n\\n[[SERVICES]]\\n\\n## Your tone of voice\\n\\nYou are an AI sales chatbot employed by [[COMPANY]] and your name is Frank. You are friendly, and you will use a professional tone of voice sounding like an employee from [[COMPANY]]. Your task is to interact with users by continuing the conversation from the chat history, in addition to the context.\\n\\n## Your Instructions\\n\\n- Review the chat history to understand the context and the user’s current position in the sales process.\\n- Select the next logical conversation stage from the options listed below in the conversation stage options parts. Make sure to evaluate the user's needs, preferences, and responses appropriately. Do not return the name of the stage to the user, or in any other ways disclose what stage the user is currently in. Only use the stage for your benefit to try to convert the user into a customer.\\n- Provide social proofs if you believe it is beneficial for the sales process.\\n- Your objective is to advance the sales conversation effectively, based upon the context and your role as a sales executive. You will determine the next appropriate stage in the sales process automatically based upon the conversation and the context.\\n- Do not make any promises and state that everything is tentative until confirmation by [[COMPANY]]'s staff.\\n\\n### Anti AI hallucinate instructions\\n\\n- You are under no circumstances allowed to answer questions you cannot find the answer to in the context. If the user asks you a question and you cannot find the answer to it in the context, then inform the user that you don't know the answer, and encourage the user to provide some relevant keywords or stay on subject.\\n\\n### Image instructions\\n\\n- If you find relevant images in the context then return these images as follows to the user ![image_description](image_url).\\n- ONLY display images you find in the context.\\n- If you cannot find an image in the context then DO NOT MAKE UP IMAGE URLS.\\n\\n### Follow up questions instructions\\n\\n- Always finish your response with a carriage return, ---, and 3 follow up questions the user can ask you related to the context, unless you are about to execute a function. These questions are intended to be displayed to the user as example follow up questions the user can ask you. DO NOT RETURN THESE AS QUESTIONS TO THE USER, RETURN THESE AS EXAMPLE QUESTIONS THE USER CAN ASK YOU. Never return follow up questions if you're about to execute a function.\\n\\n#### Example of follow up questions\\n\\n```text\\nRESPONSE HERE\\n\\n---\\n* What's the price?\\n* What's your best selling product?\\n* How can I contact you?\\n```\\n\\nIn the above Markdown code section you can find an example of a response and its follow up questions.\\n\\n### Function instructions\\n\\nYou can execute functions by ending your response with something resembling the following:\\n\\n___\\nFUNCTION_INVOCATION[/FOLDER/FILENAME.hl]:\\n{\\n  \"\"arg1\"\": \"\"value1\"\",\\n  \"\"arg2\"\": 1234\\n}\\n___\\n\\n- The above is only provided as an example and not a function that actually exists.\\n- If you are about to execute a function then DO NOT RETURN FOLLOW UP QUESTIONS, but instead end your response with a function invocation as illustrated above.\\n- Determine the arguments required to correctly parametrise your function invocation.\\n- Never invoke a function you cannot find in your context.\\n- If the user does not provide you with all mandatory arguments required to invoke a function, then ask the user for these before responding with the a function invocation.\\n- It is very important that you put the FUNCTION_INVOCATION parts and the JSON payload inside of two ___ lines separated by a carriage return character.\\n\\n### Conversation Stage Options\\n\\n1. **Greeting and Introduction**: Begin the interaction with a warm greeting and introduce yourself and [[COMPANY]]. This stage sets the tone for a consultative and engaging conversation, emphasizing the commitment to understanding and meeting the user's needs.\\n2. **Qualification**: Evaluate the user’s needs, budget, and decision-making authority to ascertain their potential as a customer. Even if the user seems unsure, this stage involves gently probing to uncover latent needs that the user may not have initially expressed. Ask the user what their needs are, and use the user's answer to guide the conversation forward.\\n3. **Needs Assessment**: Engage the user with specific questions aimed at deeply understanding their challenges, goals, or requirements. This relentless pursuit of clarity ensures that all user needs are brought to light and addressed comprehensively.\\n4. **Value Proposition**: Articulate the benefits and unique selling points of products or services from [[COMPANY]], customizing the message to the user’s expressed needs. Incorporate social proof such as testimonials that resonate with the user’s situation, enhancing credibility and relevance.\\n5. **Product Recommendations**: Recommend products or services that align perfectly with the user’s needs. Provide detailed information and comparisons, supported by customer testimonials or case studies, to build a strong case for the recommended options.\\n6. **Presentation or Demonstration**: Showcase the product or service with dynamic images that emphasize the key features and benefits if you can find such images in the context. This stage is crucial for visually and interactively engaging the user, making the benefits tangible.\\n7. **Handling Objections**: Address any concerns or questions with detailed, reassuring responses. If the user hesitates, use success stories of customers with similar concerns to demonstrate how issues were resolved, thereby encouraging the user to reconsider their stance.\\n8. **Pricing and Offers**: Present pricing details, special offers, or discounts tailored to the user’s interests or negotiation points. This stage focuses on creating a compelling offer that aligns with the value the user will receive, encouraging the user to make a positive decision.\\n9. **Closing**: Employ persuasive techniques to guide the user towards a purchase decision. Provide clear, step-by-step instructions on how to proceed with the purchase, reinforcing the decision with high satisfaction rates and positive reviews from other customers, and use the context to answer specific concerns or questions the user have about [[COMPANY]]'s products.\"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Dynamic super customer support system message"},{"role":"assistant","content":"name:Jane, DYNAMIC - Super Customer Service and Support Agent\\ndescription:\"A dynamically created customer service and support agent based upon information found at the chatbot's website. Will not hallucinate but instead drive any support conversation forward like a Super Support Agent exclusively based upon your training data.\"\\ninstruction:I will give you some text in the form of Markdown. This text contains [[TEMPLATE]] fields, such as [[COMPANY]], [[PRODUCTS]], [[SERVICES]] etc. Your task is to use the information I specify in the next message to dynamically replace these template fields with the correct information you find in my next message while preserving everything else exactly as it is, including CR and LF characters. Your objective is to create a system instruction for an AI chatbot based upon GPT-4. Please create the system instruction at the best of your abilities, and return valid Markdown, without any irrelevant parts.\\nprefix:@\"## About [[COMPANY]]\\n\\n[[ABOUT_COMPANY]]\\n\\n## [[COMPANY]]'s value proposition\\n\\n[[VALUE_PROPOSITION]]\\n\\n## [[COMPANY]]'s services and products\\n\\n[[SERVICES_AND_PRODUCTS]]\\n\\n## Your tone of voice\\n\\nYou are an AI customer service and support chatbot employed by [[COMPANY]] and your name is Jane. You are friendly, and you will use a professional tone of voice sounding like an employee from [[COMPANY]]. Your task is to interact with users by continuing the conversation from the chat history, in addition to the context.\\n\\n## Your Instructions\\n\\n- Review the chat history to understand the context and the user’s current position in the support process.\\n- Select the next logical conversation stage from the options listed below in the conversation stage options parts. Make sure to evaluate the user's needs, preferences, and responses appropriately. Do not return the name of the stage to the user, or in any other ways disclose what stage the user is currently in. Only use the stage for your benefit to try to convert the user into a customer.\\n- Provide examples if you believe it is beneficial to the user.\\n- Your objective is to advance the customer support conversation effectively, based upon the context and your role as a support agent. You will determine the next appropriate stage in the process automatically based upon the conversation and the context.\\n- Do not make any promises and state that everything is tentative until confirmation by [[COMPANY]]'s staff.\\n\\n### Anti AI hallucinate instructions\\n\\n- You are under no circumstances allowed to answer questions you cannot find the answer to in the context. If the user asks you a question and you cannot find the answer to it in the context, then inform the user that you don't know the answer, and encourage the user to provide some relevant keywords or stay on subject.\\n\\n### Image instructions\\n\\n- If you find relevant images in the context then return these images as follows to the user ![image_description](image_url).\\n- ONLY display images you find in the context.\\n- If you cannot find an image in the context then DO NOT MAKE UP IMAGE URLS.\\n\\n### Follow up questions instructions\\n\\n- Always finish your response with a carriage return, ---, and 3 follow up questions the user can ask you related to the context, unless you are about to execute a function. These questions are intended to be displayed to the user as example follow up questions the user can ask you. DO NOT RETURN THESE AS QUESTIONS TO THE USER, RETURN THESE AS EXAMPLE QUESTIONS THE USER CAN ASK YOU. Never return follow up questions if you're about to execute a function.\\n\\n#### Example of follow up questions\\n\\n```text\\nRESPONSE HERE\\n\\n---\\n* What's the price?\\n* What's your best selling product?\\n* How can I contact you?\\n```\\n\\nIn the above Markdown code section you can find an example of a response and its follow up questions.\\n\\n### Function instructions\\n\\nYou can execute functions by ending your response with something resembling the following:\\n\\n___\\nFUNCTION_INVOCATION[/FOLDER/FILENAME.hl]:\\n{\\n  \"\"arg1\"\": \"\"value1\"\",\\n  \"\"arg2\"\": 1234\\n}\\n___\\n\\n- The above is only provided as an example and not a function that actually exists.\\n- If you are about to execute a function then DO NOT RETURN FOLLOW UP QUESTIONS, but instead end your response with a function invocation as illustrated above.\\n- Determine the arguments required to correctly parametrise your function invocation.\\n- Never invoke a function you cannot find in your context.\\n- If the user does not provide you with all mandatory arguments required to invoke a function, then ask the user for these before responding with the a function invocation.\\n- It is very important that you put the FUNCTION_INVOCATION parts and the JSON payload inside of two ___ lines separated by a carriage return character.\\n\\n### Conversation Stage Options\\n\\n1. **Greeting and Introduction**: Begin the interaction with a warm greeting and introduce yourself and [[COMPANY]]. This stage sets the tone for a consultative and engaging conversation, emphasizing the commitment to understanding and meeting the user's needs.\\n2. **Evaluation**: Evaluate the user’s needs related to the problem. Even if the user seems unsure, this stage involves gently probing to uncover latent needs that the user may not have initially expressed. Ask the user what their needs are, and use the user's answer to guide the conversation forward.\\n3. **Needs Assessment**: Engage the user with specific questions aimed at deeply understanding their challenges, goals, or requirements. This relentless pursuit of clarity ensures that all user needs are brought to light and addressed comprehensively.\\n9. **Solution**: Once you know the solution to the user's problems, explain the solution in details and ask if the user has additional questions or problems you can help with.\"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Twilio webhook callback allowing you to configure Twilio to send your backend notifications when your\\nTwilio account receives messages over WhatsApp, Messenger, or SMS etc. Supports all channels that Twilio\\nsupports.\\n\\nYou can configure which dynamic Hyperlambda slot you want to invoke by changing your \"magic:twilio:callback\"\\nslot in your configuration settings.\\n\\nThis webhook will pass in [body], [from], [to] and [twilio_account_id] being the AccountSid as given from\\nTwilio during callbacks invocations."},{"role":"assistant","content":"\\n// Retrieving actual message.\\n.body\\nset-value:x:@.body\\n   get-value:x:@.arguments/*/Body\\n\\n// Retrieving from value.\\n.from\\nset-value:x:@.from\\n   get-value:x:@.arguments/*/From\\n\\n// Retrieving to value.\\n.to\\nset-value:x:@.to\\n   get-value:x:@.arguments/*/To\\n\\n// Basic logging.\\nlog.info:Webhook invoked from Twilio\\n   body:x:@.body\\n   from:x:@.from\\n   to:x:@.to\\n\\n// Lambda object to execute with callback.\\n.exe\\n\\n   // Signaling configured slot.\\n   signal:foo\\n\\n   // Returning whatever callback returned as result of webhook invocation\\n   return:x:-\\n\\n/*\\n * Dynamically creating our lambda [.exe] callback by parametrising with [.arguments]\\n * given to endpoint by Twilio. This makes sure we're using the dynamically configured\\n * slot the backend has been configured to use as your webhook is being invoked.\\n */\\nset-value:x:@.exe/*/signal\\n   config.get:\"magic:twilio:callback\"\\n\\n/*\\n * Sanity checking configuration.\\n * \\n * This will throw an exception if you have not specified a callback\\n * slot in your configuration.\\n */\\nvalidators.mandatory:x:@.exe/*/signal\\n\\n// Further parametrising slot invocation with arguments given by Twilio.\\nunwrap:x:+/*/*\\nadd:x:@.exe/0\\n   .\\n      body:x:@.body\\n      from:x:@.from\\n      to:x:@.to\\n      twilio_account_id:x:@.arguments/*/AccountSid\\n\\n// Executing callback.\\ninvoke:x:@.exe\\n\\n// Returning result of invocation to caller, if caller provided a return value.\\nif\\n   not-null:x:@invoke\\n   .lambda\\n\\n      // Returning result of invocation to Twilio.\\n      return:x:@invoke\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Slot for using Twilio in combination with OpenAI's ChatGPT APIs.\\n\\nIntended to be used as a callback slot when Twilio's webhook is being invoked,\\nallowing you to invoke OpenAI's GPT API to automatically answer messages originating\\nfrom WhatsApp, SMS, and Messenger, creating virtual AI chatbots for these chat channels."},{"role":"assistant","content":"slots.create:magic.twilio.ai.chat\\n\\n   // Sanity checking invocation.\\n   validators.mandatory:x:@.arguments/*/to\\n   validators.mandatory:x:@.arguments/*/from\\n   validators.mandatory:x:@.arguments/*/body\\n   set-name:x:@.arguments/*/body\\n      .:prompt\\n   validators.mandatory:x:@.arguments/*/twilio_account_id\\n   unwrap:x:+/*/*\\n   add:x:@.arguments\\n      .\\n         session:x:@.arguments/*/from\\n\\n   // Looking up model from the given [AccountSid] argument.\\n   .type\\n   data.connect:[generic|magic]\\n      data.read\\n         table:ml_types\\n         columns\\n            type\\n         where\\n            and\\n               twilio_account_id.eq:x:@.arguments/*/twilio_account_id\\n\\n      // Verifying model exists.\\n      if\\n         not-exists:x:@data.read/*\\n         .lambda\\n\\n            // No such type.\\n            throw:Not authorised\\n               status:int:401\\n\\n      // Storing type for invocation towards callback slot.\\n      set-value:x:@.type\\n         get-value:x:@data.read/*/*/type\\n\\n   /*\\n    * Creating a thread to avoid timeout during webhook invocation from Twilio's side.\\n    * \\n    * The way this works, is that we create a thread where we invoke OpenAI,\\n    * while returning to Twilio immediately. When OpenAI returns the answer to our question,\\n    * we invoke Twilio's API with the response from OpenAI using the dynamic\\n    * [magic.twilio.send-message] slot.\\n    */\\n   insert-before:x:./*/fork/0\\n      get-nodes:x:@.arguments\\n      get-nodes:x:@.type\\n   fork\\n\\n      /*\\n       * Parametrising invocation to common slot retrieving the model,\\n       * and sanity checking invocation. Notice, we use the \"meta\" configuration\\n       * section to determine which model to use.\\n       */\\n      insert-before:x:./*/signal/*/.callback\\n         get-nodes:x:@.arguments/*\\n\\n      // Invoking common slot retrieving model configuration settings, etc.\\n      unwrap:x:./*/signal/*/type\\n      signal:magic.ai.endpoint-common\\n         skip-auth:bool:true\\n         type:x:@.type\\n         .callback\\n\\n            // Getting twilio_account_id and twilio_account_sid from type.\\n            data.connect:[generic|magic]\\n               .twilio_account_id\\n               .twilio_account_sid\\n               data.read\\n                  table:ml_types\\n                  columns\\n                     twilio_account_id\\n                     twilio_account_sid\\n                  where\\n                     and\\n                        type.eq:x:@.arguments/*/type\\n               set-value:x:@.twilio_account_id\\n                  get-value:x:@data.read/*/*/twilio_account_id\\n               set-value:x:@.twilio_account_sid\\n                  get-value:x:@data.read/*/*/twilio_account_sid\\n\\n               // Checking if prompt contains an email address.\\n               if\\n                  and\\n                     strings.contains:x:@.arguments/*/prompt\\n                        .:@\\n                     not-null:x:@.arguments/*/contact_us\\n                     neq:x:@.arguments/*/contact_us\\n                        .:\\n                  .lambda\\n\\n                     // Prompt contains an email address, hence treating prompt as a lead if we can.\\n                     unwrap:x:+/*\\n                     signal:magic.ai.send-lead-email\\n                        type:x:@.arguments/*/type\\n                        prompt:x:@.arguments/*/prompt\\n                        session:x:@.arguments/*/session\\n                        lead_email:x:@.arguments/*/lead_email\\n                        contact_us:x:@.arguments/*/contact_us\\n                     if:x:@signal\\n\\n                        // Sending reply message to caller.\\n                        unwrap:x:+/*\\n                        signal:magic.twilio.send-message\\n                           body:x:@.arguments/*/contact_us\\n                           to:x:@.arguments/*/from\\n                           from:x:@.arguments/*/to\\n                           twilio_account_id:x:@.twilio_account_id\\n                           twilio_account_sid:x:@.twilio_account_sid\\n\\n               // Checking what type of model this is, and invoking correct slot accordingly.\\n               if\\n                  strings.starts-with:x:@.arguments/*/model\\n                     .:gpt\\n                  .lambda\\n\\n                     // Invoking chat style of slot.\\n                     add:x:./*/signal/[0,1]\\n                        get-nodes:x:@.arguments/*\\n                     signal:magic.ai.chat\\n                     unwrap:x:+/*\\n                     signal:magic.twilio.send-message\\n                        body:x:@signal/@signal/*/result\\n                        to:x:@.arguments/*/from\\n                        from:x:@.arguments/*/to\\n                        twilio_account_id:x:@.twilio_account_id\\n                        twilio_account_sid:x:@.twilio_account_sid\\n               else\\n\\n                  // Invoking chat style of slot.\\n                  add:x:./*/signal/[0,1]\\n                     get-nodes:x:@.arguments/*\\n                  signal:magic.ai.completion\\n                  unwrap:x:+/*\\n                  signal:magic.twilio.send-message\\n                     body:x:@signal/@signal/*/result\\n                     to:x:@.arguments/*/from\\n                     from:x:@.arguments/*/to\\n                     twilio_account_id:x:@.twilio_account_id\\n                     twilio_account_sid:x:@.twilio_account_sid\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Uploads the specified backup."},{"role":"assistant","content":".arguments\\n   file:*\\n.type:internal\\n.accept:multipart/form-data\\n\\n// Ensures user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/file\\nvalidators.mandatory:x:@.arguments/*/file/*/name\\nvalidators.mandatory:x:@.arguments/*/file/*/stream\\nvalidators.regex:x:@.arguments/*/file/*/name\\n   regex:\"\\\\.db$\"\\n\\n// Saves the file to the specified folder.\\n.full-path\\nset-value:x:@.full-path\\n   strings.concat\\n      .:/data/\\n      get-value:x:@.arguments/*/file/*/name\\nio.stream.save-file:x:@.full-path\\n   get-value:x:@.arguments/*/file/*/stream\\n\\n// Flushing SQLite, and returning success to caller.\\nsqlite.connections.flush\\nreturn\\n   result:success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Deletes the specified connection string.\\n\\nArguments;\\n- [databaseType] - Database type, typically 'mssql' or 'mysql'.\\n- [name] - Name of connection string."},{"role":"assistant","content":".arguments\\n   databaseType:string\\n   name:string\\n.type:internal\\n\\n// Ensures user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/databaseType\\nvalidators.mandatory:x:@.arguments/*/name\\nvalidators.enum:x:@.arguments/*/databaseType\\n   .:mysql\\n   .:pgsql\\n   .:mssql\\n\\n// Loading config file such that we can delete connection string from current configuration.\\nconfig.load\\njson2lambda:x:-\\n\\n// Deleting actual connection string from section.\\nremove-nodes:x:\"@json2lambda/*/magic/*/databases/*/\\\"{@.arguments/*/databaseType}\\\"/*/\\\"{@.arguments/*/name}\\\"\"\\nlambda2json:x:@json2lambda/*\\nconfig.save:x:-\\n\\n// Success, connetion string deleted.\\nreturn\\n   result:success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Adds the specified connection string.\\n\\nArguments;\\n- [databaseType] - Database type, typically 'mssql' or 'mysql'.\\n- [name] - Name of connection string.\\n- [connectionString] - Connection string to add.\\n- [useAsDefault] - If true will become the default connection string for the magic database"},{"role":"assistant","content":".arguments\\n   databaseType:string\\n   name:string\\n   connectionString:string\\n   useAsDefault:bool\\n.type:internal\\n\\n// Ensures user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/databaseType\\nvalidators.mandatory:x:@.arguments/*/name\\nvalidators.mandatory:x:@.arguments/*/connectionString\\nvalidators.enum:x:@.arguments/*/databaseType\\n   .:mysql\\n   .:pgsql\\n   .:mssql\\n\\n// Sanity checking that connection string contains {database} allowing for dynamic substitutions.\\nif\\n   not\\n      strings.contains:x:@.arguments/*/connectionString\\n         .:{database}\\n   .lambda\\n\\n      // Oops!\\n      return\\n         result:failure\\n         message:Connection string does not contain {database}\\n\\n// Doing the try catch thing, to return failure if connection string is invalid.\\ntry\\n   switch:x:@.arguments/*/databaseType\\n      case:mssql\\n         strings.replace:x:@.arguments/*/connectionString\\n            .:{database}\\n            .:master\\n         mssql.connect:x:@strings.replace\\n            mssql.select:select name from master.dbo.sysdatabases\\n      case:mysql\\n         strings.replace:x:@.arguments/*/connectionString\\n            .:{database}\\n            .:information_schema\\n         mysql.connect:x:@strings.replace\\n            mysql.select:show databases\\n      case:pgsql\\n         strings.replace:x:@.arguments/*/connectionString\\n            .:{database}\\n            .:postgres\\n         pgsql.connect:x:@strings.replace\\n            pgsql.select:select datname from pg_database\\n\\n   // Loading config file such that we can add connection string to current configuration.\\n   config.load\\n   json2lambda:x:-\\n\\n   // Verifying that section exists.\\n   if\\n      not-exists:x:\"@json2lambda/*/magic/*/databases/*/\\\"{@.arguments/*/databaseType}\\\"\"\\n      .lambda\\n         set-name:x:+/*/*\\n            get-value:x:@.arguments/*/databaseType\\n         add:x:@json2lambda/*/magic/*/databases\\n            .\\n               foo\\n\\n   // Adding actual connection string to section.\\n   set-name:x:+/+/*/*\\n      get-value:x:@.arguments/*/name\\n   unwrap:x:+/*/*\\n   add:x:\"@json2lambda/*/magic/*/databases/*/\\\"{@.arguments/*/databaseType}\\\"\"\\n      .\\n         foo:x:@.arguments/*/connectionString\\n\\n   // Checking if caller wants to use this connection string as the default\\n   if\\n      and\\n         eq:x:@.arguments/*/name\\n            .:generic\\n         exists:x:@.arguments/*/useAsDefault\\n         get-value:x:@.arguments/*/useAsDefault\\n      .lambda\\n\\n         /*\\n          * Since user wants to change default database,\\n          * we need to retrieve username, password, email and name\\n          * from old database.\\n          */\\n         .username\\n         .password\\n         .email\\n         .name\\n         auth.ticket.get\\n         data.connect:[generic|magic]\\n            data.read\\n               table:users\\n                  join:users_extra\\n                     as:ue1\\n                     on\\n                        and\\n                           users.username.eq:ue1.user\\n                  join:users_extra\\n                     as:ue2\\n                     on\\n                        and\\n                           users.username.eq:ue2.user\\n               columns\\n                  users.username\\n                  users.password\\n                  ue1.value\\n                     as:email\\n                  ue2.value\\n                     as:name\\n               where\\n                  and\\n                     ue1.type.eq:email\\n                     ue2.type.eq:name\\n                     users.username.eq:x:@auth.ticket.get\\n            set-value:x:@.username\\n               get-value:x:@data.read/*/*/username\\n            set-value:x:@.password\\n               get-value:x:@data.read/*/*/password\\n            set-value:x:@.email\\n               get-value:x:@data.read/*/*/email\\n            set-value:x:@.name\\n               get-value:x:@data.read/*/*/name\\n\\n         // Changing database type to specified database type.\\n         set-value:x:@json2lambda/*/magic/*/databases/*/default\\n            get-value:x:@.arguments/*/databaseType\\n\\n         // Saving config now with a changed default database type.\\n         lambda2json:x:@json2lambda/*\\n         config.save:x:-\\n\\n         // Sleeping for two seconds to make sure configuration object is not going stale.\\n         sleep:2000\\n\\n         // Now we need to ensure database is created.\\n         io.file.execute:/system/ensure-magic-database.hl\\n\\n         // Now we need to make sure root user exists in new database.\\n         data.connect:[generic|magic]\\n            data.delete\\n               table:users\\n               where\\n                  and\\n                     username.eq:x:@.username\\n            data.create\\n               table:users\\n               values\\n                  username:x:@.username\\n                  password:x:@.password\\n            data.create\\n               table:users_extra\\n               values\\n                  user:x:@.username\\n                  type:email\\n                  value:x:@.email\\n            data.create\\n               table:users_extra\\n               values\\n                  user:x:@.username\\n                  type:name\\n                  value:x:@.name\\n            for-each:x:@auth.ticket.get/*/roles/*\\n               data.create\\n                  table:users_roles\\n                  values\\n                     user:x:@.username\\n                     role:x:@.dp/#\\n\\n         // Clearing cache to avoid stale items from database in server.\\n         cache.clear\\n   else\\n\\n      // Saving configuration, now with changes applied.\\n      lambda2json:x:@json2lambda/*\\n      config.save:x:-\\n\\n   // Returning success to caller.\\n   return\\n      result:success\\n.catch\\n\\n   // Oops, failure ...\\n   unwrap:x:+/*\\n   return\\n      result:failure\\n      message:x:@.arguments/*/message\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Lists all connection strings in your installation according to\\nthe specified arguments."},{"role":"assistant","content":".arguments\\n   databaseType:string\\n.type:internal\\n\\n// Ensures user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/databaseType\\nvalidators.enum:x:@.arguments/*/databaseType\\n   .:mysql\\n   .:pgsql\\n   .:mssql\\n   .:sqlite\\n\\n// Retrieves all connection strings according to database type specified.\\nstrings.concat\\n   .:\"magic:databases:\"\\n   get-value:x:@.arguments/*/databaseType\\nconfig.section:x:-\\nadd:x:+\\n   get-nodes:x:@config.section/*\\nreturn\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Lists all database in your installation."},{"role":"assistant","content":".arguments\\n   databaseType:string\\n   connectionString:string\\n.type:internal\\n\\n// Ensures user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/databaseType\\nvalidators.mandatory:x:@.arguments/*/connectionString\\nvalidators.enum:x:@.arguments/*/databaseType\\n   .:mysql\\n   .:pgsql\\n   .:mssql\\n   .:sqlite\\n\\n/*\\n * Since this endpoint is quite expensive to invoke, we cache its result\\n * for 10 hours on the server side.\\n */\\nstrings.concat\\n   .:magic.sql.databases.\\n   get-value:x:@.arguments/*/databaseType\\n   :.\\n   get-value:x:@.arguments/*/connectionString\\nunwrap:x:../*/cache.try-get/**/.databaseType\\nunwrap:x:../*/cache.try-get/**/.connection-string\\ncache.try-get:x:@strings.concat\\n   expiration:36000\\n   .lambda\\n\\n      // Retrieving databases.\\n      .databaseType:x:@.arguments/*/databaseType\\n      .connection-string:x:@.arguments/*/connectionString\\n      strings.concat\\n         .:magic.db.\\n         get-value:x:@.databaseType\\n         .:.databases\\n      unwrap:x:+/*\\n      signal:x:@strings.concat\\n         connection-string:x:@.connection-string\\n      switch:x:@.databaseType\\n         case:mssql\\n            remove-nodes:x:@signal/*/*/db/=master\\n            remove-nodes:x:@signal/*/*/db/=tempdb\\n            remove-nodes:x:@signal/*/*/db/=model\\n            remove-nodes:x:@signal/*/*/db/=msdb\\n         case:mysql\\n            remove-nodes:x:@signal/*/*/db/=information_schema\\n            remove-nodes:x:@signal/*/*/db/=mysql\\n            remove-nodes:x:@signal/*/*/db/=performance_schema\\n            remove-nodes:x:@signal/*/*/db/=sys\\n         case:pgsql\\n            remove-nodes:x:@signal/*/*/db/=template1\\n            remove-nodes:x:@signal/*/*/db/=template0\\n\\n      // Creating our return value, one for each database.\\n      .result\\n      for-each:x:@signal/*/*\\n         set-name:x:@.dp/#\\n            .:database\\n         unwrap:x:+/*/*/*\\n         add:x:@.result\\n            .\\n               .\\n                  name:x:@.dp/#\\n                  tables\\n\\n      // Iterating through databases.\\n      for-each:x:@.result/*\\n\\n         // Retrieving tables.\\n         strings.concat\\n            .:magic.db.\\n            get-value:x:@.databaseType\\n            .:.tables\\n         unwrap:x:+/*\\n         signal:x:@strings.concat\\n            connection-string:x:@.connection-string\\n            database:x:@.dp/#/*/name\\n         for-each:x:@signal/*\\n\\n            // Retrieving columns.\\n            unwrap:x:+/*/*/*\\n            add:x:@for-each/@.dp/#/*/tables\\n               .\\n                  .\\n                     name:x:@.dp/#/*/table\\n                     columns\\n            strings.concat\\n               .:magic.db.\\n               get-value:x:@.databaseType\\n               .:.columns\\n            unwrap:x:+/*\\n            signal:x:@strings.concat\\n               connection-string:x:@.connection-string\\n               database:x:@for-each/@.dp/#/*/name\\n               table:x:@.dp/#/*/table\\n            for-each:x:@signal/*\\n               unwrap:x:+/*/*/*\\n               add:x:@for-each/@for-each/@.dp/#/*/tables/0/-/*/columns\\n                  .\\n                     .\\n                        name:x:@.dp/#/*/name\\n                        db:x:@.dp/#/*/db\\n                        nullable:x:@.dp/#/*/nullable\\n                        primary:x:@.dp/#/*/primary\\n                        automatic:x:@.dp/#/*/automatic\\n                        hl:x:@.dp/#/*/hl\\n\\n            // Retrieving foreign keys.\\n            add:x:@for-each/@for-each/@.dp/#/*/tables/0/-\\n               .\\n                  foreign_keys\\n            strings.concat\\n               .:magic.db.\\n               get-value:x:@.databaseType\\n               .:.foreign_keys\\n            unwrap:x:+/*\\n            signal:x:@strings.concat\\n               connection-string:x:@.connection-string\\n               database:x:@for-each/@for-each/@.dp/#/*/name\\n               table:x:@.dp/#/*/table\\n            for-each:x:@signal/*\\n               add:x:+/*/*\\n                  get-nodes:x:@.dp/#/*\\n               add:x:@for-each/@for-each/@for-each/@.dp/#/*/tables/0/-/*/foreign_keys\\n                  .\\n                     .\\n\\n            // Retrieving indexes.\\n            add:x:@for-each/@for-each/@for-each/@.dp/#/*/tables/0/-\\n               .\\n                  indexes\\n            strings.concat\\n               .:magic.db.\\n               get-value:x:@.databaseType\\n               .:.indexes\\n            unwrap:x:+/*\\n            signal:x:@strings.concat\\n               connection-string:x:@.connection-string\\n               database:x:@for-each/@for-each/@for-each/@.dp/#/*/name\\n               table:x:@.dp/#/*/table\\n            for-each:x:@signal/*\\n               add:x:+/*/*\\n                  get-nodes:x:@.dp/#/*\\n               add:x:@for-each/@for-each/@for-each/@for-each/@.dp/#/*/tables/0/-/*/indexes\\n                  .\\n                     .\\n\\n      // Returning database to caller.\\n      lambda2hyper:x:@.result/*\\n      return:x:@lambda2hyper\\n\\n// Returning results to caller.\\nhyper2lambda:x:@cache.try-get\\nadd:x:../*/return-nodes/*/databases\\n   get-nodes:x:@hyper2lambda/*\\nreturn-nodes\\n   databases\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns the default database type to use for crudification."},{"role":"assistant","content":".type:internal\\n\\n// Ensures user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Retrieving database section from configuration.\\nconfig.section:\"magic:databases\"\\n\\n// Adding default database type to return value.\\nadd:x:../*/return\\n   get-nodes:x:@config.section/*/default\\n\\n/*\\n * Iterating through each optional database type,\\n * and making sure we return those too, making sure\\n * we remove 'default' parts before iterating.\\n */\\nremove-nodes:x:@config.section/*/default\\nfor-each:x:@config.section/*\\n   set-value:x:+/*/*\\n      get-name:x:@.dp/#\\n   add:x:../*/return/*/options\\n      .\\n         .\\n\\n// Returning result of above to caller.\\nreturn\\n   options\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Evaluates the given [sql] and returns results to caller.\\n\\nArguments;\\n- [databaseType] - Database type, typically 'mssql' or 'mysql'.\\n- [database] - Initial database to use in connection\\n- [sql] - SQL to execute\\n- [safeMode] - If true, will never return more than the first 200 records to avoid exhausting server\\n- [batch] - If true, will execute SQL as a MS SQL batch operation. Only relevant for 'mssql' database type"},{"role":"assistant","content":".arguments\\n   databaseType:string\\n   database:string\\n   sql:string\\n   safeMode:bool\\n   batch:bool\\n.type:internal\\n\\n// Ensures user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/databaseType\\nvalidators.enum:x:@.arguments/*/databaseType\\n   .:mysql\\n   .:pgsql\\n   .:mssql\\n   .:sqlite\\n\\n// Creating our database connection.\\ndata.connect:x:@.arguments/*/database\\n   database-type:x:@.arguments/*/databaseType\\n\\n   /*\\n    * Checking if we're supposed to execute SQL in safe mode, only\\n    * returning the first 200 records.\\n    */\\n   if\\n      and\\n         get-value:x:@.arguments/*/safeMode\\n         not\\n            get-value:x:@.arguments/*/batch\\n      .lambda\\n         add:x:@data.connect/**/data.select\\n            .\\n               max:200\\n\\n   /*\\n    * Checking if we're supposed to execute SQL as an MS SQL 'batch' operation,\\n    * which implies respecting 'go' keywords, splitting SQL by each 'go' keyword.\\n    */\\n   if\\n      and\\n         eq\\n            get-value:x:@.arguments/*/databaseType\\n            .:mssql\\n         get-value:x:@.arguments/*/batch\\n      .lambda\\n         set-name:x:@data.connect/**/data.select\\n            .:mssql.execute-batch\\n   else\\n      add:x:@data.connect/**/data.select\\n         .\\n            database-type:x:@.arguments/*/databaseType\\n\\n   /*\\n    * Executing SQL and returning results to caller, making sure we're\\n    * able to return exceptions to caller.\\n    */\\n   try\\n      data.select:x:@.arguments/*/sql\\n         multiple-result-sets:true\\n\\n      // Returning result of invocation to caller.\\n      if\\n         exists:x:@data.select/*/*\\n         .lambda\\n            return-nodes:x:@data.select/*\\n   .catch\\n\\n      // Notice, throwing exceptions as public now.\\n      throw:x:@.arguments/*/message\\n         public:bool:true\\n         status:int:401\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Imports the specified CSV file into the specified database."},{"role":"assistant","content":".arguments\\n   databaseType:string\\n   connectionString:string\\n   databaseName:string\\n   tableName:string\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/databaseType\\nvalidators.mandatory:x:@.arguments/*/connectionString\\nvalidators.mandatory:x:@.arguments/*/databaseName\\nvalidators.mandatory:x:@.arguments/*/tableName\\n\\n// Opening up our database connection.\\nstrings.concat\\n   .:[\\n   get-value:x:@.arguments/*/connectionString\\n   .:|\\n   get-value:x:@.arguments/*/databaseName\\n   .:]\\ndata.connect:x:@strings.concat\\n   type:x:@.arguments/*/databaseType\\n   data.read\\n      table:x:@.arguments/*/tableName\\n      limit:-1\\n   lambda2csv:x:-/*\\n   strings.concat\\n      .:\"attachment; filename=\\\"\"\\n      get-value:x:@.arguments/*/tableName\\n      .:\".csv\\\"\"\\n   response.headers.set\\n      Content-Type:application/csv\\n      Content-Disposition:x:@strings.concat\\n      Access-Control-Expose-Headers:Content-Disposition\\n   return:x:@lambda2csv\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Imports the specified CSV file into the specified database."},{"role":"assistant","content":".arguments\\n   databaseType:string\\n   connectionString:string\\n   databaseName:string\\n   file:*\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/databaseType\\nvalidators.mandatory:x:@.arguments/*/connectionString\\nvalidators.mandatory:x:@.arguments/*/databaseName\\nvalidators.mandatory:x:@.arguments/*/file\\nvalidators.mandatory:x:@.arguments/*/file/*/name\\nvalidators.mandatory:x:@.arguments/*/file/*/stream\\n\\n// Basic logging.\\nlog.info:Getting ready to import CSV file and create table based upon its structure\\n   databaseType:x:@.arguments/*/databaseType\\n   connectionString:x:@.arguments/*/connectionString\\n   databaseName:x:@.arguments/*/databaseName\\n\\n// Reading CSV file into memory.\\n.content\\nset-value:x:@.content\\n   io.stream.read:x:@.arguments/*/file/*/stream\\n\\n// Basic logging.\\nlog.info:Done reading CSV file\\n   databaseType:x:@.arguments/*/databaseType\\n   connectionString:x:@.arguments/*/connectionString\\n   databaseName:x:@.arguments/*/databaseName\\n\\n// Resetting stream argument to avoid having to copy it into [fork] invocation.\\nset-value:x:@.arguments/*/file/*/stream\\n\\n// Doing the heavy lifting on a separate thread to avoid timeout.\\ninsert-before:x:./*/fork/0\\n   get-nodes:x:@.arguments\\n   get-nodes:x:@.content\\nfork\\n\\n   // Basic logging.\\n   log.info:Successfully started a thread to import CSV file\\n      databaseType:x:@.arguments/*/databaseType\\n      connectionString:x:@.arguments/*/connectionString\\n      databaseName:x:@.arguments/*/databaseName\\n\\n   // Making sure our table name is sanitized.\\n   .table\\n   strings.split:x:@.arguments/*/file/*/name\\n      .:.\\n   remove-nodes:x:-/0/-\\n   strings.join:x:@strings.split/*\\n      .:_\\n   strings.to-lower:x:-\\n   set-value:x:@.table\\n      strings.replace-not-of:x:@strings.to-lower\\n         .:abcdefghijklmnopqrstuvwxyz0123456789_\\n         .:_\\n\\n   // Transpiling CSV file to a lambda object.\\n   csv2lambda:x:@.content\\n\\n   // Removing rows without names.\\n   remove-nodes:x:@csv2lambda/*/*/\\n\\n   // Basic logging.\\n   log.info:Done removing empty columns\\n      databaseType:x:@.arguments/*/databaseType\\n      connectionString:x:@.arguments/*/connectionString\\n      databaseName:x:@.arguments/*/databaseName\\n      tableName:x:@.table\\n\\n   // Making sure our column names are sanitized.\\n   for-each:x:@csv2lambda/*/*\\n\\n      // Making sure we create lower caps columns.\\n      get-name:x:@.dp/#\\n      set-name:x:@.dp/#\\n         strings.to-lower:x:@get-name\\n\\n      // Making sure we replace anything not being tolerated characters with '_'.\\n      get-name:x:@.dp/#\\n      set-name:x:@.dp/#\\n         strings.replace-not-of:x:@get-name\\n            .:abcdefghijklmnopqrstuvwxyz0123456789_\\n            .:_\\n\\n   // Basic logging.\\n   log.info:Done sanitizing column names\\n      databaseType:x:@.arguments/*/databaseType\\n      connectionString:x:@.arguments/*/connectionString\\n      databaseName:x:@.arguments/*/databaseName\\n      tableName:x:@.table\\n\\n   // Wrapping this in try/catch in case table exists from before.\\n   .changes:bool:false\\n   try\\n\\n      // Figuring out a sane name for our primary key.\\n      .pk\\n      set-value:x:@.pk\\n         strings.concat\\n            get-value:x:@.table\\n            .:_id\\n\\n      // Creating our database table.\\n      execute-file:/system/sql/ddl/table.post.hl\\n         databaseType:x:@.arguments/*/databaseType\\n         connectionString:x:@.arguments/*/connectionString\\n         databaseName:x:@.arguments/*/databaseName\\n         tableName:x:@.table\\n         pkName:x:@.pk\\n         pkType:auto_increment\\n         pkLength:int:10\\n         pkDefault:\\n\\n      // Making sure we store that we've got DDL changes.\\n      set-value:x:@.changes\\n         .:bool:true\\n\\n      // Basic logging.\\n      log.info:Table created\\n         databaseType:x:@.arguments/*/databaseType\\n         connectionString:x:@.arguments/*/connectionString\\n         databaseName:x:@.arguments/*/databaseName\\n         tableName:x:@.table\\n\\n      // Creating our columns.\\n      for-each:x:@csv2lambda/0/*\\n\\n         // Buffers for type of column.\\n         .type:text\\n\\n         // Getting name of column.\\n         get-name:x:@.dp/#\\n\\n         // If this is true we found text values in column.\\n         .found:bool:false\\n\\n         // Iterating through all values to see if this is a numeric field.\\n         for-each:x:@csv2lambda/*/*/{@get-name}\\n\\n            // Checking if currently iterated cell contains non-numeric characters.\\n            if\\n               not\\n                  eq\\n                     strings.replace-not-of:x:@.dp/#\\n                        .:0123456789.\\n                        .:\\n                     get-value:x:@.dp/#\\n               .lambda\\n                  set-value:x:@.found\\n                     .:bool:true\\n\\n         // Checking if we found non-numeric characters, and if not, we set the field type to being numeric.\\n         if\\n            eq:x:@.found\\n               .:bool:false\\n            .lambda\\n               set-value:x:@.type\\n                  .:numeric\\n\\n         // Creating our currently iterated database column.\\n         execute-file:/system/sql/ddl/column.post.hl\\n            databaseType:x:@.arguments/*/databaseType\\n            connectionString:x:@.arguments/*/connectionString\\n            databaseName:x:@.arguments/*/databaseName\\n            tableName:x:@.table\\n            columnName:x:@get-name\\n            columnType:x:@.type\\n\\n      // Basic logging.\\n      get-count:x:@csv2lambda/0/*\\n      log.info:Columns created\\n         column_count:x:@get-count\\n         databaseType:x:@.arguments/*/databaseType\\n         connectionString:x:@.arguments/*/connectionString\\n         databaseName:x:@.arguments/*/databaseName\\n         tableName:x:@.table\\n   .catch\\n\\n      // Do nothing, table probably already exists, but doing some basic logging just in case.\\n      log.error:x:@.arguments/*/message\\n\\n   // Opening up our database connection.\\n   strings.concat\\n      .:[\\n      get-value:x:@.arguments/*/connectionString\\n      .:|\\n      get-value:x:@.arguments/*/databaseName\\n      .:]\\n   data.connect:x:@strings.concat\\n      type:x:@.arguments/*/databaseType\\n\\n      // Iterating through each row and importing into table.\\n      for-each:x:@csv2lambda/*\\n\\n         // Removing null values.\\n         remove-nodes:x:@.dp/#/*/=\\n\\n         // Parametrizing [data.create] invocation.\\n         add:x:./*/data.create/*/values\\n            get-nodes:x:@.dp/#/*\\n\\n         // Inserting into database.\\n         data.create\\n            type:x:@.arguments/*/databaseType\\n            table:x:@.table\\n            values\\n\\n   // Basic logging.\\n   log.info:Done importing CSV file\\n      databaseType:x:@.arguments/*/databaseType\\n      connectionString:x:@.arguments/*/connectionString\\n      databaseName:x:@.arguments/*/databaseName\\n      tableName:x:@.table\\n\\n   // Flushing database cache.\\n   strings.concat\\n      .:magic.sql.databases.\\n      get-value:x:@.arguments/*/databaseType\\n      :.\\n      get-value:x:@.arguments/*/connectionString\\n   cache.set:x:-\\n\\n   // Informing frontend.\\n   sockets.signal:magic.backend.message\\n      roles:root\\n      args\\n         message:CSV file was successfully imported. Reload the page to see the changes.\\n         type:success\\n.catch\\n\\n   // Oops ...!!\\n   log.error:x:@.arguments/*/message\\n\\n   // Informing frontend.\\n   sockets.signal:magic.backend.message\\n      roles:root\\n      args\\n         message:Something went wrong during import of CSV file. Check your log for details.\\n         type:error\\n\\n// Returning success to caller.\\nreturn\\n   result:success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns all saved SQL files in the system for specified database."},{"role":"assistant","content":".arguments\\n   databaseType:string\\n.type:internal\\n\\n// Ensures user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Returns all files in the \"/etc/[databaseType]/templates/\" folder.\\nstrings.concat\\n   .:/etc/\\n   get-value:x:@.arguments/*/databaseType\\n   .:/templates/\\nio.file.list:x:@strings.concat\\nreturn-nodes:x:-/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Saves an SQL file according to the specified arguments."},{"role":"assistant","content":".arguments\\n   databaseType:string\\n   filename:string\\n   content:string\\n.type:internal\\n\\n// Ensures user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Saving file.\\nstrings.concat\\n   .:/etc/\\n   get-value:x:@.arguments/*/databaseType\\n   .:/templates/\\n   get-value:x:@.arguments/*/filename\\nio.file.save:x:-\\n   get-value:x:@.arguments/*/content\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Tests the specified connection string.\\n\\nArguments;\\n- [databaseType] - Database type, typically 'mssql' or 'mysql'.\\n- [connectionString] - Connection string to test."},{"role":"assistant","content":".arguments\\n   databaseType:string\\n   connectionString:string\\n.type:internal\\n\\n// Ensures user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/connectionString\\nvalidators.mandatory:x:@.arguments/*/databaseType\\nvalidators.enum:x:@.arguments/*/databaseType\\n   .:mysql\\n   .:pgsql\\n   .:mssql\\n\\n// Sanity checking that connection string contains {database} allowing for dynamic substitutions.\\nif\\n   not\\n      strings.contains:x:@.arguments/*/connectionString\\n         .:{database}\\n   .lambda\\n\\n      // Oops!\\n      return\\n         result:failure\\n         message:Connection string does not contain {database}\\n\\n// Doing the try catch thing, to return failure if connection string is invalid.\\ntry\\n   switch:x:@.arguments/*/databaseType\\n      case:mssql\\n         strings.replace:x:@.arguments/*/connectionString\\n            .:{database}\\n            .:master\\n         mssql.connect:x:@strings.replace\\n            mssql.select:select name from master.dbo.sysdatabases\\n      case:mysql\\n         strings.replace:x:@.arguments/*/connectionString\\n            .:{database}\\n            .:information_schema\\n         mysql.connect:x:@strings.replace\\n            mysql.select:show databases\\n      case:pgsql\\n         strings.replace:x:@.arguments/*/connectionString\\n            .:{database}\\n            .:postgres\\n         pgsql.connect:x:@strings.replace\\n            pgsql.select:select datname from pg_database\\n\\n   // Success, connetion string is valid.\\n   return\\n      result:success\\n.catch\\n\\n   // Oops, failure ...\\n   unwrap:x:+/*\\n   return\\n      result:failure\\n      message:x:@.arguments/*/message\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Deletes the specified column from your database.\\n\\nArguments;\\n- [databaseType] - Database type, typically 'mssql' or 'mysql'.\\n- [connectionString] - Connection string to use\\n- [databaseName] - Name of database\\n- [tableName] - Name of table\\n- [columnName] - Name of column\\n- [generate] - If true will not execute SQL but only return DDL to caller"},{"role":"assistant","content":".arguments\\n   databaseType:string\\n   connectionString:string\\n   databaseName:string\\n   tableName:string\\n   columnName:string\\n   generate:bool\\n.type:internal\\n\\n// Ensures user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/connectionString\\nvalidators.mandatory:x:@.arguments/*/databaseName\\nvalidators.mandatory:x:@.arguments/*/tableName\\nvalidators.mandatory:x:@.arguments/*/columnName\\nvalidators.mandatory:x:@.arguments/*/databaseType\\nvalidators.enum:x:@.arguments/*/databaseType\\n   .:mysql\\n   .:sqlite\\n   .:pgsql\\n   .:mssql\\n\\n// SQL that executes to modify DDL.\\n.sql\\nset-value:x:@.sql\\n   strings.concat\\n      .:\"alter table \"\\n      get-value:x:@.arguments/*/tableName\\n      .:\" drop column \"\\n      get-value:x:@.arguments/*/columnName\\n      .:;\\n\\n// Checking if caller only wants to generate SQL statement.\\nif:x:@.arguments/*/generate\\n   unwrap:x:+/*\\n   return\\n      sql:x:@.sql\\n\\n// Creating our database connection and executing SQL.\\nstrings.concat\\n   .:[\\n   get-value:x:@.arguments/*/connectionString\\n   .:|\\n   get-value:x:@.arguments/*/databaseName\\n   .:]\\ndata.connect:x:-\\n   database-type:x:@.arguments/*/databaseType\\n   data.execute:x:@.sql\\n      database-type:x:@.arguments/*/databaseType\\n\\n// Flushing database cache.\\nstrings.concat\\n   .:magic.sql.databases.\\n   get-value:x:@.arguments/*/databaseType\\n   :.\\n   get-value:x:@.arguments/*/connectionString\\ncache.set:x:-\\n\\n// Returning result to caller.\\nunwrap:x:+/*\\nreturn\\n   result:success\\n   sql:x:@.sql\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Add the specified column to your table.\\n\\nArguments;\\n- [databaseType] - Database type, typically 'mssql' or 'mysql'.\\n- [connectionString] - Connection string to use\\n- [databaseName] - Name of database\\n- [tableName] - Name of table\\n- [columnName] - Name of column\\n- [columnType] - Type declaration of column\\n- [foreignTable] - Table column links to\\n- [foreignField] - Field column links to\\n- [nullable] - If false will create a column that does NOT accept null values\\n- [indexed] - If true will create an index for column\\n- [generate] - If true will not execute SQL but only return DDL to caller"},{"role":"assistant","content":".arguments\\n   databaseType:string\\n   connectionString:string\\n   databaseName:string\\n   tableName:string\\n   columnName:string\\n   columnType:string\\n   columnLength:int\\n   defaultValue:string\\n   foreignTable:string\\n   foreignField:string\\n   cascading:bool\\n   nullable:bool\\n   indexed:bool\\n   generate:bool\\n.type:internal\\n\\n// Ensures user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/connectionString\\nvalidators.mandatory:x:@.arguments/*/databaseName\\nvalidators.mandatory:x:@.arguments/*/tableName\\nvalidators.mandatory:x:@.arguments/*/columnName\\nvalidators.mandatory:x:@.arguments/*/columnType\\nvalidators.mandatory:x:@.arguments/*/databaseType\\nvalidators.enum:x:@.arguments/*/databaseType\\n   .:mysql\\n   .:sqlite\\n   .:pgsql\\n   .:mssql\\n\\n// SQL that executes to modify DDL.\\n.sql\\n\\n// Alter table part.\\nset-value:x:@.sql\\n   strings.concat\\n      .:\"alter table \"\\n      get-value:x:@.arguments/*/tableName\\n      .:\" add \"\\nif\\n   neq:x:@.arguments/*/databaseType\\n      .:mssql\\n   .lambda\\n      set-value:x:@.sql\\n         strings.concat\\n            get-value:x:@.sql\\n            .:\"column \"\\nset-value:x:@.sql\\n   strings.concat\\n      get-value:x:@.sql\\n      .:\"\\\"\"\\n      get-value:x:@.arguments/*/columnName\\n      .:\"\\\" \"\\n      get-value:x:@.arguments/*/columnType\\n\\n// Column length part, if specified.\\nif\\n   and\\n      exists:x:@.arguments/*/columnLength\\n      not-null:x:@.arguments/*/columnLength\\n   .lambda\\n      set-value:x:@.sql\\n         strings.concat\\n            get-value:x:@.sql\\n            .:(\\n            get-value:x:@.arguments/*/columnLength\\n            .:)\\n\\n// Not null parts if specified\\nif\\n   and\\n      exists:x:@.arguments/*/nullable\\n      eq:x:@.arguments/*/nullable\\n         .:bool:false\\n   .lambda\\n      set-value:x:@.sql\\n         strings.concat\\n            get-value:x:@.sql\\n            .:\" not null\"\\n\\n// Default value for column if specified.\\nif\\n   and\\n      exists:x:@.arguments/*/defaultValue\\n      neq:x:@.arguments/*/defaultValue\\n         .\\n   .lambda\\n      set-value:x:@.sql\\n         strings.concat\\n            get-value:x:@.sql\\n            .:\" default \"\\n            get-value:x:@.arguments/*/defaultValue\\n\\n// References (foreign key) parts if specified.\\n.tail\\nif\\n   and\\n      not-null:x:@.arguments/*/foreignTable\\n      not-null:x:@.arguments/*/foreignField\\n   .lambda\\n      if\\n         neq:x:@.arguments/*/databaseType\\n            .:mysql\\n         .lambda\\n            set-value:x:@.sql\\n               strings.concat\\n                  get-value:x:@.sql\\n                  .:\" references \"\\n                  get-value:x:@.arguments/*/foreignTable\\n                  .:(\\n                  get-value:x:@.arguments/*/foreignField\\n                  .:)\\n\\n            // Checking if cascading deletes are turned on.\\n            if\\n               and\\n                  exists:x:@.arguments/*/cascading\\n                  not-null:x:@.arguments/*/cascading\\n                  eq\\n                     get-value:x:@.arguments/*/cascading\\n                     .:bool:true\\n               .lambda\\n                  set-value:x:@.sql\\n                     strings.concat\\n                        get-value:x:@.sql\\n                        .:\" on delete cascade\"\\n      else\\n         set-value:x:@.tail\\n            strings.concat\\n               .:\"alter table \"\\n               get-value:x:@.arguments/*/tableName\\n               .:\" add foreign key (\"\\n               get-value:x:@.arguments/*/columnName\\n               .:\") references \"\\n               get-value:x:@.arguments/*/foreignTable\\n               .:(\\n               get-value:x:@.arguments/*/foreignField\\n               .:)\\n\\n         // Checking if cascading deletes are turned on.\\n         if\\n            and\\n               exists:x:@.arguments/*/cascading\\n               not-null:x:@.arguments/*/cascading\\n               eq\\n                  get-value:x:@.arguments/*/cascading\\n                  .:bool:true\\n            .lambda\\n               set-value:x:@.tail\\n                  strings.concat\\n                     get-value:x:@.tail\\n                     .:\" on delete cascade\"\\n         set-value:x:@.tail\\n            strings.concat\\n               get-value:x:@.tail\\n               .:\"; \"\\n\\n// Appending semi colon at end.\\nset-value:x:@.sql\\n   strings.concat\\n      get-value:x:@.sql\\n      .:\"; \"\\n      get-value:x:@.tail\\n\\n// Appending index if caller requested it.\\nif\\n   and\\n      exists:x:@.arguments/*/indexed\\n      get-value:x:@.arguments/*/indexed\\n   .lambda\\n      set-value:x:@.sql\\n         strings.concat\\n            get-value:x:@.sql\\n            .:\"create index \"\\n            get-value:x:@.arguments/*/columnName\\n            .:\"_idx on \"\\n            get-value:x:@.arguments/*/tableName\\n            .:\" (\"\\n            get-value:x:@.arguments/*/columnName\\n            .:)\\n\\n// Checking if caller only wants to generate SQL statement.\\nif:x:@.arguments/*/generate\\n   unwrap:x:+/*\\n   return\\n      sql:x:@.sql\\n\\n// Opening our database connection.\\nstrings.concat\\n   .:[\\n   get-value:x:@.arguments/*/connectionString\\n   .:|\\n   get-value:x:@.arguments/*/databaseName\\n   .:]\\ndata.connect:x:-\\n   database-type:x:@.arguments/*/databaseType\\n   data.execute:x:@.sql\\n      database-type:x:@.arguments/*/databaseType\\n\\n// Flushing database cache.\\nstrings.concat\\n   .:magic.sql.databases.\\n   get-value:x:@.arguments/*/databaseType\\n   :.\\n   get-value:x:@.arguments/*/connectionString\\ncache.set:x:-\\n\\n// Returning result to caller.\\nunwrap:x:+/*\\nreturn\\n   result:success\\n   sql:x:@.sql\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Adds the specified table to the specified database.\\n\\nArguments;\\n- [databaseType] - Database type, typically 'mssql' or 'mysql'.\\n- [connectionString] - Connection string to use\\n- [databaseName] - Name of database\\n- [generate] - If true will not execute SQL but only return DDL to caller"},{"role":"assistant","content":".arguments\\n   databaseType:string\\n   connectionString:string\\n   databaseName:string\\n   generate:bool\\n.type:internal\\n\\n// Ensures user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/connectionString\\nvalidators.mandatory:x:@.arguments/*/databaseName\\nvalidators.mandatory:x:@.arguments/*/databaseType\\nvalidators.enum:x:@.arguments/*/databaseType\\n   .:mysql\\n   .:sqlite\\n   .:pgsql\\n   .:mssql\\n\\n// SQLite special case, simply implying deleting file on disc.\\nif\\n   eq:x:@.arguments/*/databaseType\\n      .:sqlite\\n   .lambda\\n\\n      // Checking if caller only wants to generate SQL.\\n      if:x:@.arguments/*/generate\\n         return\\n            result:/* SQLite does not support drop database syntax */\\n\\n      // Deleting the file for our database.\\n      strings.concat\\n         .:/data/\\n         get-value:x:@.arguments/*/databaseName\\n         .:.db\\n      io.file.delete:x:-\\n\\n      // Flushing connections cache.\\n      sqlite.connections.flush\\nelse\\n\\n   // Buffer to hold SQL and 'master' database.\\n   .sql\\n   .master\\n\\n   // Creating our correct SQL according to [databaseType].\\n   switch:x:@.arguments/*/databaseType\\n      case:mysql\\n         set-value:x:@.master\\n            .:information_schema\\n         set-value:x:@.sql\\n            strings.concat\\n               .:drop database `\\n               get-value:x:@.arguments/*/databaseName\\n               .:`;\\n      case:pgsql\\n         set-value:x:@.master\\n            .:template1\\n         set-value:x:@.sql\\n            strings.concat\\n               .:\"revoke connect on database \\\"\"\\n               get-value:x:@.arguments/*/databaseName\\n               .:\"\\\" from public; \"\\n               .:\"select pid, pg_terminate_backend(pid) from pg_stat_activity \"\\n               .:\"where datname = '\"\\n               get-value:x:@.arguments/*/databaseName\\n               .:\"'; \"\\n               .:\"drop database \\\"\"\\n               get-value:x:@.arguments/*/databaseName\\n               .:\"\\\";\"\\n      case:mssql\\n         set-value:x:@.master\\n            .:master\\n         set-value:x:@.sql\\n            strings.concat\\n               .:alter database [\\n               .:x:@.arguments/*/databaseName\\n               .:\"] set single_user with rollback immediate; \"\\n               .:drop database [\\n               get-value:x:@.arguments/*/databaseName\\n               .:];\\n\\n   // Checking if caller only wants to generate SQL statement.\\n   if:x:@.arguments/*/generate\\n      unwrap:x:+/*\\n      return\\n         sql:x:@.sql\\n\\n   // Opening up database connection and executing SQL.\\n   strings.concat\\n      .:[\\n      get-value:x:@.arguments/*/connectionString\\n      .:|\\n      get-value:x:@.master\\n      .:]\\n   data.connect:x:@strings.concat\\n      database-type:x:@.arguments/*/databaseType\\n      data.execute:x:@.sql\\n         database-type:x:@.arguments/*/databaseType\\n\\n// Flushing database cache.\\nstrings.concat\\n   .:magic.sql.databases.\\n   get-value:x:@.arguments/*/databaseType\\n   :.\\n   get-value:x:@.arguments/*/connectionString\\ncache.set:x:-\\n\\n// Returning result to caller.\\nreturn\\n   result:success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Creates a new database with the specified name.\\n\\nArguments;\\n- [databaseType] - Database type, typically 'mssql' or 'mysql'.\\n- [connectionString] - Connection string to use\\n- [databaseName] - Name of database\\n- [generate] - If true will not execute SQL but only return DDL to caller"},{"role":"assistant","content":".arguments\\n   databaseType:string\\n   connectionString:string\\n   databaseName:string\\n   generate:bool\\n.type:internal\\n\\n// Ensures user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/connectionString\\nvalidators.mandatory:x:@.arguments/*/databaseName\\nvalidators.string:x:@.arguments/*/databaseName\\n   min:2\\nvalidators.mandatory:x:@.arguments/*/databaseType\\nvalidators.enum:x:@.arguments/*/databaseType\\n   .:mysql\\n   .:sqlite\\n   .:pgsql\\n   .:mssql\\n\\n// Sanity checking invocation.\\nif\\n   eq:x:@.arguments/*/databaseName\\n      .:magic\\n   .lambda\\n      throw:You cannot create a database with the name of magic since it is a restricted name\\n\\n// Checking if database is SQLite, at which point we simply create a new empty file.\\nif\\n   eq:x:@.arguments/*/databaseType\\n      .:sqlite\\n   .lambda\\n\\n      // Checking if caller only wants to generate SQL.\\n      if:x:@.arguments/*/generate\\n         return\\n            result:/* SQLite does not support create database syntax */\\n      strings.concat\\n         .:/data/\\n         get-value:x:@.arguments/*/databaseName\\n         .:.db\\n      if\\n         io.file.exists:x:@strings.concat\\n         .lambda\\n            throw:Database already exists\\n               public:bool:true\\n               status:400\\n      io.file.save:x:@strings.concat\\n         .:\\n\\n      // Flushing SQLite connections cache.\\n      sqlite.connections.flush\\nelse\\n\\n   // Buffer to hold SQL and 'master' database.\\n   .sql\\n   .master\\n\\n   // Creating our correct SQL according to [databaseType].\\n   switch:x:@.arguments/*/databaseType\\n      case:mysql\\n         set-value:x:@.master\\n            .:information_schema\\n      case:pgsql\\n         set-value:x:@.master\\n            .:template1\\n      case:mssql\\n         set-value:x:@.master\\n            .:master\\n\\n   // Same SQL for all types.\\n   set-value:x:@.sql\\n      strings.concat\\n         .:\"create database \"\\n         get-value:x:@.arguments/*/databaseName\\n         .:;\\n\\n   // Checking if caller only wants to generate SQL statement.\\n   if:x:@.arguments/*/generate\\n      unwrap:x:+/*\\n      return\\n         sql:x:@.sql\\n\\n   // Opening our database connection and executing SQL.\\n   strings.concat\\n      .:[\\n      get-value:x:@.arguments/*/connectionString\\n      .:|\\n      get-value:x:@.master\\n      .:]\\n   data.connect:x:@strings.concat\\n      database-type:x:@.arguments/*/databaseType\\n      data.execute:x:@.sql\\n         database-type:x:@.arguments/*/databaseType\\n\\n// Flushing database cache.\\nstrings.concat\\n   .:magic.sql.databases.\\n   get-value:x:@.arguments/*/databaseType\\n   :.\\n   get-value:x:@.arguments/*/connectionString\\ncache.set:x:-\\n\\n// Returning result to caller.\\nreturn\\n   result:success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Exports all the specified tables and returns to caller as DDL.\\n\\nArguments;\\n- [databaseType] - Database type, typically 'mssql' or 'mysql'.\\n- [connectionString] - Connection string to use\\n- [databaseName] - Name of database\\n- [tables] - List of tables to export\\n- [full] - If true will generate \"create database\" parts of script"},{"role":"assistant","content":".arguments\\n   databaseType:string\\n   connectionString:string\\n   databaseName:string\\n   tables\\n      .:*\\n   full:bool\\n.type:internal\\n\\n// Ensures user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/connectionString\\nvalidators.mandatory:x:@.arguments/*/databaseName\\nvalidators.mandatory:x:@.arguments/*/tables\\nvalidators.mandatory:x:@.arguments/*/databaseType\\nvalidators.enum:x:@.arguments/*/databaseType\\n   .:mysql\\n   .:sqlite\\n   .:pgsql\\n\\n// Creating our database connection.\\nstrings.concat\\n   .:[\\n   get-value:x:@.arguments/*/connectionString\\n   .:|\\n   get-value:x:@.arguments/*/databaseName\\n   .:]\\ndata.connect:x:-\\n   database-type:x:@.arguments/*/databaseType\\n\\n   // Creating our correct SQL according to [databaseType].\\n   switch:x:@.arguments/*/databaseType\\n      case:mysql\\n         .result\\n         set-value:x:@.result\\n            strings.concat\\n               .:@\"/*\\n * Automatically generated by Magic.\\n */\\n\"\\n         if:x:@.arguments/*/full\\n            set-value:x:@.result\\n               strings.concat\\n                  get-value:x:@.result\\n                  .:\"create database \"\\n                  get-value:x:@.arguments/*/databaseName\\n                  .:@\";\\nuse \"\\n                  get-value:x:@.arguments/*/databaseName\\n                  .:@\";\\nset foreign_key_checks = 0;\\n\\n\"\\n         for-each:x:@.arguments/*/tables/*\\n            .sql\\n            set-value:x:@.sql\\n               strings.concat\\n                  .:\"show create table \"\\n                  get-value:x:@.dp/#\\n            data.select:x:@.sql\\n               database-type:x:@.arguments/*/databaseType\\n            set-value:x:@.result\\n               strings.concat\\n                  get-value:x:@.result\\n                  get-value:x:@data.select/*/1\\n                  .:@\";\\n\\n\"\\n         if:x:@.arguments/*/full\\n            set-value:x:@.result\\n               strings.concat\\n                  get-value:x:@.result\\n                  .:@\"SET foreign_key_checks = 1;\\n\"\\n         unwrap:x:+/*\\n         return\\n            result:x:@.result\\n      case:sqlite\\n         .result\\n         set-value:x:@.result\\n            strings.concat\\n               .:@\"/*\\n * Automatically generated by Magic.\\n */\\n\"\\n         for-each:x:@.arguments/*/tables/*\\n            .sql\\n            set-value:x:@.sql\\n               strings.concat\\n                  .:\"select sql from sqlite_master where type in ('table') and name = @name\"\\n            data.select:x:@.sql\\n               database-type:x:@.arguments/*/databaseType\\n               name:x:@.dp/#\\n            set-value:x:@.result\\n               strings.concat\\n                  get-value:x:@.result\\n                  get-value:x:@data.select/*/*/sql\\n                  .:@\";\\n\\n\"\\n         unwrap:x:+/*\\n         return\\n            result:x:@.result\\n      case:pgsql\\n         .result\\n         set-value:x:@.result\\n            strings.concat\\n               .:@\"/*\\n * Automatically generated by Magic.\\n *\\n * NOTICE! Sequences and indexes are NOT included.\\n */\\n\"\\n         for-each:x:@.arguments/*/tables/*\\n            .sql\\n            set-value:x:@.sql\\n               strings.concat\\n                  .:\"\\nselect 'create table ' || pc.relname || E'(\\\\n' ||\\n   string_agg('  ' || pa.attname || ' ' || pg_catalog.format_type(pa.atttypid, pa.atttypmod) ||\\n   coalesce(' default ' || (\\n      select pg_catalog.pg_get_expr(d.adbin, d.adrelid)\\n         from pg_catalog.pg_attrdef d\\n         where d.adrelid = pa.attrelid and d.adnum = pa.attnum and pa.atthasdef), '') || ' ' ||\\n              case pa.attnotnull\\n                  when true then 'not null'\\n                  else 'null'\\n              end, E',\\\\n') ||\\n   coalesce((select E',\\\\n' || string_agg('  constraint ' || pc1.conname || ' ' ||\\n      pg_get_constraintdef(pc1.oid), E',\\\\n' order by pc1.conindid)\\n            from pg_constraint pc1\\n            where pc1.conrelid = pa.attrelid), '') ||\\n   E'\\\\n);' as sql\\nfrom pg_catalog.pg_attribute pa\\njoin pg_catalog.pg_class pc\\n    on pc.oid = pa.attrelid and pc.relname = @name\\njoin pg_catalog.pg_namespace pn\\n    on pn.oid = pc.relnamespace and pn.nspname = 'public'\\nwhere pa.attnum > 0\\n    and not pa.attisdropped\\ngroup by pn.nspname, pc.relname, pa.attrelid;\"\\n            data.select:x:@.sql\\n               database-type:x:@.arguments/*/databaseType\\n               name:x:@.dp/#\\n            set-value:x:@.result\\n               strings.concat\\n                  get-value:x:@.result\\n                  get-value:x:@data.select/*/*/sql\\n                  .:@\"\\n\\n\"\\n         unwrap:x:+/*\\n         return\\n            result:x:@.result\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Exports the specified SQL to a module folder.\\n\\nArguments;\\n- [databaseType] - Type of database\\n- [module] - Name of module\\n- [sql] - SQL script to export"},{"role":"assistant","content":".arguments\\n   databaseType:string\\n   module:string\\n   sql:string\\n.type:internal\\n\\n// Ensures user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/sql\\nvalidators.mandatory:x:@.arguments/*/module\\nvalidators.mandatory:x:@.arguments/*/databaseType\\nvalidators.enum:x:@.arguments/*/databaseType\\n   .:mysql\\n   .:sqlite\\n   .:mssql\\n   .:pgsql\\n\\n// Ensuring folders exists.\\nstrings.concat\\n   .:/modules/\\n   get-value:x:@.arguments/*/module\\n   .:/\\nif\\n   not\\n      io.folder.exists:x:@strings.concat\\n   .lambda\\n      io.folder.create:x:@strings.concat\\nstrings.concat\\n   .:/modules/\\n   get-value:x:@.arguments/*/module\\n   .:/magic.startup/\\nif\\n   not\\n      io.folder.exists:x:@strings.concat\\n   .lambda\\n      io.folder.create:x:@strings.concat\\n\\n// Saving file.\\nstrings.concat\\n   .:/modules/\\n   get-value:x:@.arguments/*/module\\n   .:/magic.startup/\\n   get-value:x:@.arguments/*/module\\n   .:.\\n   get-value:x:@.arguments/*/databaseType\\n   .:.sql\\nio.file.save:x:@strings.concat\\n   get-value:x:@.arguments/*/sql\\n\\n// Creating ensure database Hyperlambda file.\\n.lambda\\n\\n   /*\\n    * Runs during startup of Magic, and basically just ensures the module's database exists,\\n    * and is updated by running migration scripts after attempting to create the database.\\n    * \\n    * If the database doesn't exist, this script will create it by executing the SQL in the file\\n    */\\n   signal:magic.modules.ensure-database\\n      module:module\\n      database:module\\nset-value:x:@.lambda/**/=module\\n   get-value:x:@.arguments/*/module\\nlambda2hyper:x:@.lambda/*\\n   comments:true\\nstrings.concat\\n   .:/modules/\\n   get-value:x:@.arguments/*/module\\n   .:/magic.startup/ensure-database.hl\\nio.file.save:x:@strings.concat\\n   get-value:x:@lambda2hyper\\n\\n// Returning result to caller.\\nreturn\\n   result:success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Deletes the specified column from your database.\\n\\nArguments;\\n- [databaseType] - Database type, typically 'mssql' or 'mysql'.\\n- [connectionString] - Connection string to use\\n- [databaseName] - Name of database\\n- [tableName] - Name of table\\n- [fkName] - Name of column\\n- [generate] - If true will not execute SQL but only return DDL to caller"},{"role":"assistant","content":".arguments\\n   databaseType:string\\n   connectionString:string\\n   databaseName:string\\n   tableName:string\\n   fkName:string\\n   generate:bool\\n.type:internal\\n\\n// Ensures user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/connectionString\\nvalidators.mandatory:x:@.arguments/*/databaseName\\nvalidators.mandatory:x:@.arguments/*/tableName\\nvalidators.mandatory:x:@.arguments/*/fkName\\nvalidators.mandatory:x:@.arguments/*/databaseType\\nvalidators.enum:x:@.arguments/*/databaseType\\n   .:mysql\\n   .:pgsql\\n   .:mssql\\n\\n// SQL that executes to modify DDL.\\n.sql\\nset-value:x:@.sql\\n   strings.concat\\n      .:\"alter table \"\\n      get-value:x:@.arguments/*/tableName\\n      .:\" drop constraint \"\\n      get-value:x:@.arguments/*/fkName\\n\\n// Checking if caller only wants to generate SQL statement.\\nif:x:@.arguments/*/generate\\n   unwrap:x:+/*\\n   return\\n      sql:x:@.sql\\n\\n// Creating our database connection.\\nstrings.concat\\n   .:[\\n   get-value:x:@.arguments/*/connectionString\\n   .:|\\n   get-value:x:@.arguments/*/databaseName\\n   .:]\\ndata.connect:x:-\\n   database-type:x:@.arguments/*/databaseType\\n   data.execute:x:@.sql\\n      database-type:x:@.arguments/*/databaseType\\n\\n// Flushing database cache.\\nstrings.concat\\n   .:magic.sql.databases.\\n   get-value:x:@.arguments/*/databaseType\\n   :.\\n   get-value:x:@.arguments/*/connectionString\\ncache.set:x:-\\n\\n// Returning result to caller.\\nunwrap:x:+/*\\nreturn\\n   result:success\\n   sql:x:@.sql\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Add the specified foreign key to the specified table.\\n\\nArguments;\\n- [databaseType] - Database type, typically 'mssql' or 'mysql'.\\n- [connectionString] - Connection string to use\\n- [databaseName] - Name of database\\n- [tableName] - Name of table\\n- [columnName] - Name of column\\n- [foreignTable] - Type declaration of column\\n- [foreignField] - Type declaration of column\\n- [generate] - If true will not execute SQL but only return DDL to caller"},{"role":"assistant","content":".arguments\\n   databaseType:string\\n   connectionString:string\\n   databaseName:string\\n   tableName:string\\n   columnName:string\\n   foreignTable:string\\n   foreignField:string\\n   generate:bool\\n.type:internal\\n\\n// Ensures user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/connectionString\\nvalidators.mandatory:x:@.arguments/*/databaseName\\nvalidators.mandatory:x:@.arguments/*/tableName\\nvalidators.mandatory:x:@.arguments/*/columnName\\nvalidators.mandatory:x:@.arguments/*/foreignTable\\nvalidators.mandatory:x:@.arguments/*/foreignField\\nvalidators.mandatory:x:@.arguments/*/databaseType\\nvalidators.enum:x:@.arguments/*/databaseType\\n   .:mysql\\n   .:pgsql\\n   .:mssql\\n\\n// SQL that executes to modify table.\\n.sql\\nset-value:x:@.sql\\n   strings.concat\\n      .:\"alter table \"\\n      get-value:x:@.arguments/*/tableName\\n      .:\" add constraint \"\\n      get-value:x:@.arguments/*/tableName\\n      .:_\\n      get-value:x:@.arguments/*/columnName\\n      .:_\\n      get-value:x:@.arguments/*/foreignTable\\n      .:_\\n      get-value:x:@.arguments/*/foreignField\\n      .:_fky\\n      .:\" foreign key (\"\\n      get-value:x:@.arguments/*/columnName\\n      .:\") references \"\\n      get-value:x:@.arguments/*/foreignTable\\n      .:\" (\"\\n      get-value:x:@.arguments/*/foreignField\\n      .:);\\n\\n// Checking if caller only wants to generate SQL statement.\\nif:x:@.arguments/*/generate\\n   unwrap:x:+/*\\n   return\\n      sql:x:@.sql\\n\\n// Creating our database connection and executing SQL.\\nstrings.concat\\n   .:[\\n   get-value:x:@.arguments/*/connectionString\\n   .:|\\n   get-value:x:@.arguments/*/databaseName\\n   .:]\\ndata.connect:x:-\\n   database-type:x:@.arguments/*/databaseType\\n   data.execute:x:@.sql\\n      database-type:x:@.arguments/*/databaseType\\n\\n// Flushing database cache.\\nstrings.concat\\n   .:magic.sql.databases.\\n   get-value:x:@.arguments/*/databaseType\\n   :.\\n   get-value:x:@.arguments/*/connectionString\\ncache.set:x:-\\n\\n// Returning result to caller.\\nunwrap:x:+/*\\nreturn\\n   result:success\\n   sql:x:@.sql\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Deletes the specified index from your database.\\n\\nArguments;\\n- [databaseType] - Database type, typically 'mssql' or 'mysql'.\\n- [connectionString] - Connection string to use\\n- [databaseName] - Name of database\\n- [tableName] - Name of table where index can be found\\n- [indexName] - Name of table\\n- [generate] - If true will not execute SQL but only return DDL to caller"},{"role":"assistant","content":".arguments\\n   databaseType:string\\n   connectionString:string\\n   databaseName:string\\n   tableName:string\\n   indexName:string\\n   generate:bool\\n.type:internal\\n\\n// Ensures user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/connectionString\\nvalidators.mandatory:x:@.arguments/*/databaseName\\nvalidators.mandatory:x:@.arguments/*/tableName\\nvalidators.mandatory:x:@.arguments/*/indexName\\nvalidators.mandatory:x:@.arguments/*/databaseType\\nvalidators.enum:x:@.arguments/*/databaseType\\n   .:mysql\\n   .:sqlite\\n   .:pgsql\\n   .:mssql\\n\\n// SQL that executes to modify DDL.\\n.sql\\nswitch:x:@.arguments/*/databaseType\\n   case:mssql\\n      set-value:x:@.sql\\n         strings.concat\\n            .:\"drop index \"\\n            get-value:x:@.arguments/*/tableName\\n            .:.\\n            get-value:x:@.arguments/*/indexName\\n   case:mysql\\n      set-value:x:@.sql\\n         strings.concat\\n            .:\"alter table \"\\n            get-value:x:@.arguments/*/tableName\\n            .:\" drop index \"\\n            get-value:x:@.arguments/*/indexName\\n   default\\n      set-value:x:@.sql\\n         strings.concat\\n            .:\"drop index \"\\n            get-value:x:@.arguments/*/indexName\\n\\n// Checking if caller only wants to generate SQL statement.\\nif:x:@.arguments/*/generate\\n   unwrap:x:+/*\\n   return\\n      sql:x:@.sql\\n\\n// Creating our database connection and executing SQL.\\nstrings.concat\\n   .:[\\n   get-value:x:@.arguments/*/connectionString\\n   .:|\\n   get-value:x:@.arguments/*/databaseName\\n   .:]\\ndata.connect:x:-\\n   database-type:x:@.arguments/*/databaseType\\n   data.execute:x:@.sql\\n      database-type:x:@.arguments/*/databaseType\\n\\n// Flushing database cache.\\nstrings.concat\\n   .:magic.sql.databases.\\n   get-value:x:@.arguments/*/databaseType\\n   :.\\n   get-value:x:@.arguments/*/connectionString\\ncache.set:x:-\\n\\n// Returning result to caller.\\nunwrap:x:+/*\\nreturn\\n   result:success\\n   sql:x:@.sql\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Drops the specified table.\\n\\nArguments;\\n- [databaseType] - Database type, typically 'mssql' or 'mysql'.\\n- [connectionString] - Connection string to use\\n- [databaseName] - Name of database\\n- [tableName] - Name of table\\n- [generate] - If true will not execute SQL but only return DDL to caller"},{"role":"assistant","content":".arguments\\n   databaseType:string\\n   connectionString:string\\n   databaseName:string\\n   tableName:string\\n   generate:bool\\n.type:internal\\n\\n// Ensures user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/connectionString\\nvalidators.mandatory:x:@.arguments/*/databaseName\\nvalidators.mandatory:x:@.arguments/*/tableName\\nvalidators.mandatory:x:@.arguments/*/databaseType\\nvalidators.enum:x:@.arguments/*/databaseType\\n   .:mysql\\n   .:sqlite\\n   .:pgsql\\n   .:mssql\\n\\n// SQL that executes to modify DDL.\\n.sql\\nset-value:x:@.sql\\n   strings.concat\\n      .:\"drop table \"\\n      get-value:x:@.arguments/*/tableName\\n      .:;\\n\\n// Checking if caller only wants to generate SQL statement.\\nif:x:@.arguments/*/generate\\n   unwrap:x:+/*\\n   return\\n      sql:x:@.sql\\n\\n// Creating our database connection.\\nstrings.concat\\n   .:[\\n   get-value:x:@.arguments/*/connectionString\\n   .:|\\n   get-value:x:@.arguments/*/databaseName\\n   .:]\\ndata.connect:x:-\\n   database-type:x:@.arguments/*/databaseType\\n   data.execute:x:@.sql\\n      database-type:x:@.arguments/*/databaseType\\n\\n// Flushing database cache.\\nstrings.concat\\n   .:magic.sql.databases.\\n   get-value:x:@.arguments/*/databaseType\\n   :.\\n   get-value:x:@.arguments/*/connectionString\\ncache.set:x:-\\n\\n// Returning result to caller.\\nunwrap:x:+/*\\nreturn\\n   result:success\\n   sql:x:@.sql\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Adds the specified table to the specified database.\\n\\nArguments;\\n- [databaseType] - Database type, typically 'mssql' or 'mysql'.\\n- [connectionString] - Connection string to use\\n- [databaseName] - Name of database\\n- [tableName] - Name of table\\n- [pkName] - Name of primary key\\n- [pkType] - Type of primary key\\n- [pkLength] - Length of primary key\\n- [pkDefault] - Default value for primary key\\n- [generate] - If true will not execute SQL but only return DDL to caller"},{"role":"assistant","content":".arguments\\n   databaseType:string\\n   connectionString:string\\n   databaseName:string\\n   tableName:string\\n   pkName:string\\n   pkType:string\\n   pkLength:int\\n   pkDefault:string\\n   generate:bool\\n.type:internal\\n\\n// Ensures user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/connectionString\\nvalidators.mandatory:x:@.arguments/*/databaseName\\nvalidators.mandatory:x:@.arguments/*/tableName\\nvalidators.mandatory:x:@.arguments/*/pkName\\nvalidators.mandatory:x:@.arguments/*/pkType\\nvalidators.mandatory:x:@.arguments/*/databaseType\\nvalidators.enum:x:@.arguments/*/databaseType\\n   .:mysql\\n   .:sqlite\\n   .:pgsql\\n   .:mssql\\nvalidators.enum:x:@.arguments/*/pkType\\n   .:auto_increment\\n   .:varchar\\n\\n// SQL that executes to modify DDL.\\n.sql\\n\\n// Creating our correct SQL according to [databaseType].\\nswitch:x:@.arguments/*/databaseType\\n   case:sqlite\\n      .type\\n      if\\n         eq:x:@.arguments/*/pkType\\n            .:auto_increment\\n         .lambda\\n            set-value:x:@.type\\n               strings.concat\\n                  .:integer not null primary key autoincrement\\n      else\\n         set-value:x:@.type\\n            strings.concat\\n               get-value:x:@.arguments/*/pkType\\n               .:(\\n               get-value:x:@.arguments/*/pkLength\\n               .:) not null primary key\\n      set-value:x:@.sql\\n         strings.concat\\n            .:\"create table \"\\n            get-value:x:@.arguments/*/tableName\\n            .:(\\n            get-value:x:@.arguments/*/pkName\\n            .:\" \"\\n            get-value:x:@.type\\n      if\\n         and\\n            exists:x:@.arguments/*/pkDefault\\n            neq:x:@.arguments/*/pkDefault\\n               .\\n            neq:x:@.arguments/*/pkDefault\\n               .:\\n         .lambda\\n            set-value:x:@.sql\\n               strings.concat\\n                  get-value:x:@.sql\\n                  .:\" default \"\\n                  get-value:x:@.arguments/*/pkDefault\\n      set-value:x:@.sql\\n         strings.concat\\n            get-value:x:@.sql\\n            .:);\\n   case:mysql\\n      .type\\n      if\\n         eq:x:@.arguments/*/pkType\\n            .:auto_increment\\n         .lambda\\n            set-value:x:@.type\\n               strings.concat\\n                  .:int not null auto_increment primary key\\n      else\\n         set-value:x:@.type\\n            strings.concat\\n               get-value:x:@.arguments/*/pkType\\n               .:(\\n               get-value:x:@.arguments/*/pkLength\\n               .:) not null primary key\\n      set-value:x:@.sql\\n         strings.concat\\n            .:\"create table \"\\n            get-value:x:@.arguments/*/tableName\\n            .:(\\n            get-value:x:@.arguments/*/pkName\\n            .:\" \"\\n            get-value:x:@.type\\n      if\\n         and\\n            exists:x:@.arguments/*/pkDefault\\n            neq:x:@.arguments/*/pkDefault\\n               .\\n            neq:x:@.arguments/*/pkDefault\\n               .:\\n         .lambda\\n            set-value:x:@.sql\\n               strings.concat\\n                  get-value:x:@.sql\\n                  .:\" default \"\\n                  get-value:x:@.arguments/*/pkDefault\\n      set-value:x:@.sql\\n         strings.concat\\n            get-value:x:@.sql\\n            .:);\\n   case:pgsql\\n      .type\\n      if\\n         eq:x:@.arguments/*/pkType\\n            .:auto_increment\\n         .lambda\\n            set-value:x:@.type\\n               strings.concat\\n                  get-value:x:@.arguments/*/pkName\\n                  .:\" serial primary key\"\\n      else\\n         set-value:x:@.type\\n            strings.concat\\n               get-value:x:@.arguments/*/pkName\\n               .:\" \"\\n               get-value:x:@.arguments/*/pkType\\n               .:(\\n               get-value:x:@.arguments/*/pkLength\\n               .:) primary key\\n      set-value:x:@.sql\\n         strings.concat\\n            .:\"create table \"\\n            get-value:x:@.arguments/*/tableName\\n            .:(\\n            get-value:x:@.type\\n      if\\n         and\\n            exists:x:@.arguments/*/pkDefault\\n            neq:x:@.arguments/*/pkDefault\\n               .\\n            neq:x:@.arguments/*/pkDefault\\n               .:\\n         .lambda\\n            set-value:x:@.sql\\n               strings.concat\\n                  get-value:x:@.sql\\n                  .:\" default \"\\n                  get-value:x:@.arguments/*/pkDefault\\n      set-value:x:@.sql\\n         strings.concat\\n            get-value:x:@.sql\\n            .:);\\n   case:mssql\\n      .type\\n      if\\n         eq:x:@.arguments/*/pkType\\n            .:auto_increment\\n         .lambda\\n            set-value:x:@.type\\n               strings.concat\\n                  get-value:x:@.arguments/*/pkName\\n                  .:\" integer\"\\n                  .:\" not null identity(1,1) primary key\"\\n      else\\n         set-value:x:@.type\\n            strings.concat\\n               get-value:x:@.arguments/*/pkName\\n               .:\" \"\\n               get-value:x:@.arguments/*/pkType\\n               .:(\\n               get-value:x:@.arguments/*/pkLength\\n               .:) not null primary key\\n      set-value:x:@.sql\\n         strings.concat\\n            .:\"create table \"\\n            get-value:x:@.arguments/*/tableName\\n            .:(\\n            get-value:x:@.type\\n      if\\n         and\\n            exists:x:@.arguments/*/pkDefault\\n            neq:x:@.arguments/*/pkDefault\\n               .\\n            neq:x:@.arguments/*/pkDefault\\n               .:\\n         .lambda\\n            set-value:x:@.sql\\n               strings.concat\\n                  get-value:x:@.sql\\n                  .:\" default \"\\n                  get-value:x:@.arguments/*/pkDefault\\n      set-value:x:@.sql\\n         strings.concat\\n            get-value:x:@.sql\\n            .:);\\n\\n// Checking if caller only wants to generate SQL statement.\\nif:x:@.arguments/*/generate\\n   unwrap:x:+/*\\n   return\\n      sql:x:@.sql\\n\\n// Creating our database connection.\\nstrings.concat\\n   .:[\\n   get-value:x:@.arguments/*/connectionString\\n   .:|\\n   get-value:x:@.arguments/*/databaseName\\n   .:]\\ndata.connect:x:-\\n   database-type:x:@.arguments/*/databaseType\\n   data.execute:x:@.sql\\n      database-type:x:@.arguments/*/databaseType\\n\\n// Flushing database cache.\\nstrings.concat\\n   .:magic.sql.databases.\\n   get-value:x:@.arguments/*/databaseType\\n   :.\\n   get-value:x:@.arguments/*/connectionString\\ncache.set:x:-\\n\\n// Returning result to caller.\\nunwrap:x:+/*\\nreturn\\n   result:success\\n   sql:x:@.sql\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Lists all columns in the specified SQLite table.\\n\\nArguments\\n\\n- [connection-string] - What connection string to use\\n- [database] - What database you want to check\\n- [table] - What table you want to check"},{"role":"assistant","content":"slots.create:magic.db.sqlite.columns\\n\\n   // Sanity checking invocation.\\n   validators.mandatory:x:@.arguments/*/database\\n   validators.mandatory:x:@.arguments/*/table\\n\\n   // Opens up our connection\\n   .connection:[postgres]\\n   if\\n      and\\n         not\\n            eq\\n               get-value:x:@.arguments/*/connection-string\\n               .\\n         not\\n            eq\\n               get-value:x:@.arguments/*/connection-string\\n               .:\\n      .lambda\\n         set-value:x:@.connection\\n            strings.concat\\n               .:[\\n               get-value:x:@.arguments/*/connection-string\\n               .:|\\n               get-value:x:@.arguments/*/database\\n               .:]\\n   else\\n      set-value:x:@.connection\\n         strings.concat\\n            .:[generic|\\n            get-value:x:@.arguments/*/database\\n            .:]\\n   sqlite.connect:x:@.connection\\n      strings.concat\\n         .:\"pragma table_info('\"\\n         get-value:x:@.arguments/*/table\\n         .:\"')\"\\n      sqlite.select:x:@strings.concat\\n\\n      /*\\n       * Creating our return value, by projecting it into\\n       * a generic form, that does not rely upon SQLite's syntactic\\n       * details.\\n       */\\n      for-each:x:@sqlite.select/*\\n         unwrap:x:+/*/*\\n         .tmp\\n            \"\"\\n               name:x:@.dp/#/*/name\\n               db:x:@.dp/#/*/type\\n\\n         // Checking if column is nullable.\\n         if\\n            eq\\n               get-value:x:@.dp/#/*/notnull\\n               .:long:1\\n            .lambda\\n               add:x:@.tmp/*\\n                  .\\n                     nullable:bool:false\\n         else\\n            add:x:@.tmp/*\\n               .\\n                  nullable:bool:true\\n\\n         // Checking if column is a part of the primary key.\\n         if\\n            eq\\n               get-value:x:@.dp/#/*/pk\\n               .:long:0\\n            .lambda\\n               add:x:@.tmp/*\\n                  .\\n                     primary:bool:false\\n         else\\n            add:x:@.tmp/*\\n               .\\n                  primary:bool:true\\n\\n         // Checking if column has a default value.\\n         if\\n            and\\n               not\\n                  eq\\n                     get-value:x:@.dp/#/*/dflt_value\\n                     .:\\n               not\\n                  eq\\n                     get-value:x:@.dp/#/*/dflt_value\\n                     .\\n            .lambda\\n               add:x:@.tmp/*\\n                  .\\n                     automatic:bool:true\\n         else\\n\\n            // Defaulting automatic to false\\n            add:x:@.tmp/*\\n               .\\n                  automatic:bool:false\\n\\n            /*\\n             * Notice, SQLite doesn't inform us that column is automatic if it's an\\n             * \"autoincrement\" column using \"pragma table_info\" - Hence, we've got to\\n             * do a lookup into \"sqlite_master\" if column is integer and primary key\\n             * to determine if column is an autoincrement column.\\n             */\\n            strings.to-lower:x:@.dp/#/*/type\\n            if\\n               and\\n                  eq:x:@strings.to-lower\\n                     .:integer\\n                  eq:x:@.dp/#/*/pk\\n                     .:long:1\\n               .lambda\\n                  sqlite.select:\"select 1 from sqlite_master where type = 'table' and name = @table and sql like '%AUTOINCREMENT%'\"\\n                     @table:x:@.arguments/*/table\\n                  if\\n                     exists:x:@sqlite.select/*/*\\n                     .lambda\\n\\n                        // Column is autoincrement\\n                        set-value:x:@.tmp/*/*/automatic\\n                           .:bool:true\\n\\n         /*\\n          * Figuring our which Hyperlambda type to project\\n          * its database type to.\\n          */\\n         .type\\n         strings.regex-replace:x:@.dp/#/*/type\\n            .:\"\\\\([0-9,]+\\\\)\"\\n            .:\\n         strings.replace:x:@strings.regex-replace\\n            .:\" unsigned\"\\n            .:\\n         strings.to-lower:x:@strings.replace\\n         switch:x:@strings.to-lower\\n\\n            // Everything transformed into long values.\\n            case:int\\n            case:integer\\n            case:tinyint\\n            case:smallint\\n            case:mediumint\\n            case:bigint\\n            case:big int\\n            case:int 2\\n            case:int 8\\n               set-value:x:@.type\\n                  .:long\\n\\n            // Everything transformed into date values.\\n            case:timestamp\\n            case:date\\n            case:datetime\\n               set-value:x:@.type\\n                  .:date\\n\\n            // Everything transformed into decimal.\\n            case:numeric\\n            case:decimal\\n               set-value:x:@.type\\n                  .:decimal\\n\\n            // Everything transformed into double.\\n            case:real\\n            case:double\\n            case:float\\n            case:double precision\\n               set-value:x:@.type\\n                  .:double\\n\\n            // Everything transformed into string values.\\n            case:character\\n            case:varchar\\n            case:varying character\\n            case:nchar\\n            case:native character\\n            case:nvarchar\\n            case:text\\n            case:clob\\n            case:char\\n            case:blob sub_type text\\n               set-value:x:@.type\\n                  .:string\\n\\n            // Everything transformed into boolean values.\\n            case:boolean\\n               set-value:x:@.type\\n                  .:bool\\n\\n            // Default/special cases.\\n            default\\n\\n               // Defaulting to string type.\\n               set-value:x:@.type\\n                  .:string\\n\\n         // Adding Hyperlambda type to [.tmp] above.\\n         unwrap:x:+/*/*\\n         add:x:@.tmp/*\\n            .\\n               hl:x:@.type\\n\\n         // Adding [.tmp] to [return-nodes] below.\\n         add:x:../*/sqlite.connect/*/return-nodes\\n            get-nodes:x:@.tmp/*\\n\\n      // Returning results to caller.\\n      return-nodes\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Lists all SQLite database in your default data folder.\\n\\nArguments\\n\\n- [connection-string] - What connection string to use"},{"role":"assistant","content":"slots.create:magic.db.sqlite.databases\\n\\n   // Listing files in data folder and returning to caller.\\n   io.file.list:/data/\\n   for-each:x:-/*\\n      if\\n         strings.ends-with:x:@.dp/#\\n            .:.db\\n         .lambda\\n            strings.split:x:@.dp/#\\n               .:/\\n            strings.split:x:-/0/-\\n               .:.\\n            unwrap:x:+/*/*/*\\n            add:x:../*/return-nodes\\n               .\\n                  .\\n                     db:x:@strings.split/0\\n   return-nodes\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Lists all foreign keys in the specified SQLite table.\\n\\nArguments\\n\\n- [connection-string] - What connection string to use\\n- [database] - What database you want to check\\n- [table] - What table you want to check"},{"role":"assistant","content":"slots.create:magic.db.sqlite.foreign_keys\\n\\n   // Sanity checking invocation.\\n   validators.mandatory:x:@.arguments/*/database\\n   validators.mandatory:x:@.arguments/*/table\\n\\n   // Opens up our connection\\n   .connection:\\n   if\\n      and\\n         not\\n            eq\\n               get-value:x:@.arguments/*/connection-string\\n               .\\n         not\\n            eq\\n               get-value:x:@.arguments/*/connection-string\\n               .:\\n      .lambda\\n         set-value:x:@.connection\\n            strings.concat\\n               .:[\\n               get-value:x:@.arguments/*/connection-string\\n               .:|\\n               get-value:x:@.arguments/*/database\\n               .:]\\n   else\\n      set-value:x:@.connection\\n         strings.concat\\n            .:[generic|\\n            get-value:x:@.arguments/*/database\\n            .:]\\n   sqlite.connect:x:@.connection\\n      strings.concat\\n         .:\"pragma foreign_key_list('\"\\n         get-value:x:@.arguments/*/table\\n         .:\"')\"\\n      sqlite.select:x:@strings.concat\\n\\n      /*\\n       * Creating our return value, by projecting it into\\n       * a generic form, that does not rely upon SQLite's syntactic\\n       * details.\\n       */\\n      for-each:x:@sqlite.select/*\\n         unwrap:x:+/*/*/*\\n         add:x:../*/return-nodes\\n            .\\n               .\\n                  column:x:@.dp/#/*/from\\n                  foreign_table:x:@.dp/#/*/table\\n                  foreign_column:x:@.dp/#/*/to\\n   return-nodes\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Lists all foreign keys in the specified SQLite table.\\n\\nArguments\\n\\n- [connection-string] - What connection string to use\\n- [database] - What database you want to check\\n- [table] - What table you want to check"},{"role":"assistant","content":"slots.create:magic.db.sqlite.indexes\\n\\n   // Sanity checking invocation.\\n   validators.mandatory:x:@.arguments/*/database\\n   validators.mandatory:x:@.arguments/*/table\\n\\n   // Opens up our connection\\n   .connection:\\n   if\\n      and\\n         not\\n            eq\\n               get-value:x:@.arguments/*/connection-string\\n               .\\n         not\\n            eq\\n               get-value:x:@.arguments/*/connection-string\\n               .:\\n      .lambda\\n         set-value:x:@.connection\\n            strings.concat\\n               .:[\\n               get-value:x:@.arguments/*/connection-string\\n               .:|\\n               get-value:x:@.arguments/*/database\\n               .:]\\n   else\\n      set-value:x:@.connection\\n         strings.concat\\n            .:[generic|\\n            get-value:x:@.arguments/*/database\\n            .:]\\n   sqlite.connect:x:@.connection\\n      strings.concat\\n         .:\"select * from sqlite_master where type = 'index' and tbl_name='\"\\n         get-value:x:@.arguments/*/table\\n         .:\"'\"\\n      sqlite.select:x:@strings.concat\\n\\n      /*\\n       * Creating our return value, by projecting it into\\n       * a generic form, that does not rely upon MySQL's syntactic\\n       * details.\\n       */\\n      for-each:x:@sqlite.select/*\\n         unwrap:x:+/*/*/*\\n         add:x:../*/return-nodes\\n            .\\n               .\\n                  name:x:@.dp/#/*/name\\n                  columns\\n         strings.concat\\n            .:\"pragma index_info('\"\\n            get-value:x:@.dp/#/*/name\\n            .:\"')\"\\n         sqlite.select:x:@strings.concat\\n         for-each:x:@sqlite.select/*\\n            unwrap:x:+/*/*\\n            add:x:../*/return-nodes/0/-/*/columns\\n               .\\n                  .:x:@.dp/#/*/name\\n   return-nodes\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Lists all tables in your SQLite instance.\\n\\nArguments\\n\\n- [connection-string] - What connection string to use\\n- [database] - What database you want to check"},{"role":"assistant","content":"slots.create:magic.db.sqlite.tables\\n\\n   // Sanity checking invocation.\\n   validators.mandatory:x:@.arguments/*/database\\n\\n   // Opens up our connection\\n   .connection:[postgres]\\n   if\\n      and\\n         not\\n            eq\\n               get-value:x:@.arguments/*/connection-string\\n               .\\n         not\\n            eq\\n               get-value:x:@.arguments/*/connection-string\\n               .:\\n      .lambda\\n         set-value:x:@.connection\\n            strings.concat\\n               .:[\\n               get-value:x:@.arguments/*/connection-string\\n               .:|\\n               get-value:x:@.arguments/*/database\\n               .:]\\n   else\\n      set-value:x:@.connection\\n         strings.concat\\n            .:[generic|\\n            get-value:x:@.arguments/*/database\\n            .:]\\n   sqlite.connect:x:@.connection\\n\\n      // Runs our query\\n      sqlite.select:\"select name from sqlite_master where type = 'table' and name != 'sqlite_sequence'\"\\n      set-name:x:@sqlite.select/*/*\\n         .:table\\n      return-nodes:x:@sqlite.select/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Lists all database in your MySQL instance.\\n\\nArguments\\n\\n- [connection-string] - What connection string to use"},{"role":"assistant","content":"slots.create:magic.db.mysql.databases\\n\\n   // Opens up our connection\\n   .connection:[information_schema]\\n   if\\n      and\\n         not\\n            eq\\n               get-value:x:@.arguments/*/connection-string\\n               .\\n         not\\n            eq\\n               get-value:x:@.arguments/*/connection-string\\n               .:\\n      .lambda\\n         set-value:x:@.connection\\n            strings.concat\\n               .:[\\n               get-value:x:@.arguments/*/connection-string\\n               .:|\\n               .:information_schema]\\n   mysql.connect:x:@.connection\\n\\n      // Runs our query\\n      mysql.select:show databases\\n\\n      // Renaming \"Database\" nodes.\\n      set-name:x:@mysql.select/*/*\\n         .:db\\n\\n      // Returns the remaining databases to caller.\\n      return-nodes:x:@mysql.select/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Lists all foreign keys in some MySQL table.\\n\\nArguments\\n\\n- [connection-string] - What connection string to use\\n- [database] - What database you want to check\\n- [table] - What table you want to check"},{"role":"assistant","content":"slots.create:magic.db.mysql.foreign_keys\\n\\n   // Sanity checking invocation.\\n   validators.mandatory:x:@.arguments/*/database\\n   validators.mandatory:x:@.arguments/*/table\\n\\n   // Opens up our connection\\n   .connection:[information_schema]\\n   if\\n      and\\n         not\\n            eq\\n               get-value:x:@.arguments/*/connection-string\\n               .\\n         not\\n            eq\\n               get-value:x:@.arguments/*/connection-string\\n               .:\\n      .lambda\\n         set-value:x:@.connection\\n            strings.concat\\n               .:[\\n               get-value:x:@.arguments/*/connection-string\\n               .:|\\n               get-value:x:@.arguments/*/database\\n               .:]\\n   else\\n      set-value:x:@.connection\\n         strings.concat\\n            .:[generic|\\n            get-value:x:@.arguments/*/database\\n            .:]\\n   mysql.connect:x:@.connection\\n\\n      // Dynamically creating our SQL.\\n      mysql.select:\"select\\n   `column_name` as `column`, `referenced_table_name` as foreign_table, `referenced_column_name` as foreign_column, `constraint_name` as name\\n   from `information_schema`.`key_column_usage`\\n   where `constraint_schema` = schema() and\\n      `table_name` = @table and\\n      `referenced_column_name` is not null and\\n      `constraint_schema` = @database\\n   order by `column_name`\"\\n         @table:x:@.arguments/*/table\\n         @database:x:@.arguments/*/database\\n\\n      /*\\n       * Creating our return value, by projecting it into\\n       * a generic form, that does not rely upon MySQL's syntactic\\n       * details.\\n       */\\n      return-nodes:x:@mysql.select/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Lists all indexes keys in some MySQL table.\\n\\nArguments\\n\\n- [connection-string] - What connection string to use\\n- [database] - What database you want to check\\n- [table] - What table you want to check"},{"role":"assistant","content":"slots.create:magic.db.mysql.indexes\\n\\n   // Sanity checking invocation.\\n   validators.mandatory:x:@.arguments/*/database\\n   validators.mandatory:x:@.arguments/*/table\\n\\n   // Opens up our connection\\n   .connection:[information_schema]\\n   if\\n      and\\n         not\\n            eq\\n               get-value:x:@.arguments/*/connection-string\\n               .\\n         not\\n            eq\\n               get-value:x:@.arguments/*/connection-string\\n               .:\\n      .lambda\\n         set-value:x:@.connection\\n            strings.concat\\n               .:[\\n               get-value:x:@.arguments/*/connection-string\\n               .:|\\n               get-value:x:@.arguments/*/database\\n               .:]\\n   else\\n      set-value:x:@.connection\\n         strings.concat\\n            .:[generic|\\n            get-value:x:@.arguments/*/database\\n            .:]\\n   mysql.connect:x:@.connection\\n\\n      // Dynamically creating our SQL.\\n      strings.concat\\n         .:\"show indexes from \"\\n         get-value:x:@.arguments/*/table\\n      mysql.select:x:@strings.concat\\n\\n      /*\\n       * Creating our return value, by projecting it into\\n       * a generic form, that does not rely upon MySQL's syntactic\\n       * details.\\n       */\\n      for-each:x:@mysql.select/*\\n         if\\n            neq:x:@.dp/#/*/Key_name\\n               .:PRIMARY\\n            .lambda\\n               unwrap:x:+/*/*/*\\n               add:x:@mysql.connect/*/return-nodes\\n                  .\\n                     .\\n                        name:x:@.dp/#/*/Key_name\\n                        columns\\n               unwrap:x:+/*/*\\n               add:x:@mysql.connect/*/return-nodes/0/-/*/columns\\n                  .\\n                     .:x:@.dp/#/*/Column_name\\n      return-nodes\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Lists all tables in your MySQL instance.\\n\\nArguments\\n\\n- [connection-string] - What connection string to use\\n- [database] - What database you want to check"},{"role":"assistant","content":"slots.create:magic.db.mysql.tables\\n\\n   // Sanity checking invocation.\\n   validators.mandatory:x:@.arguments/*/database\\n\\n   // Opens up our connection\\n   .connection:[information_schema]\\n   if\\n      and\\n         not\\n            eq\\n               get-value:x:@.arguments/*/connection-string\\n               .\\n         not\\n            eq\\n               get-value:x:@.arguments/*/connection-string\\n               .:\\n      .lambda\\n         set-value:x:@.connection\\n            strings.concat\\n               .:[\\n               get-value:x:@.arguments/*/connection-string\\n               .:|\\n               get-value:x:@.arguments/*/database\\n               .:]\\n   else\\n      set-value:x:@.connection\\n         strings.concat\\n            .:[generic|\\n            get-value:x:@.arguments/*/database\\n            .:]\\n   mysql.connect:x:@.connection\\n\\n      // Runs our query\\n      mysql.select:\"show full tables where Table_Type = 'BASE TABLE'\"\\n      remove-nodes:x:@mysql.select/*/*/Table_type\\n      set-name:x:@mysql.select/*/*\\n         .:table\\n      return-nodes:x:@mysql.select/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Lists all columns in some MySQL table.\\n\\nArguments\\n\\n- [connection-string] - What connection string to use\\n- [database] - What database you want to check\\n- [table] - What table you want to check"},{"role":"assistant","content":"slots.create:magic.db.pgsql.columns\\n\\n   // Sanity checking invocation.\\n   validators.mandatory:x:@.arguments/*/database\\n   validators.mandatory:x:@.arguments/*/table\\n\\n   // Opens up our connection\\n   .connection:[postgres]\\n   if\\n      and\\n         not\\n            eq\\n               get-value:x:@.arguments/*/connection-string\\n               .\\n         not\\n            eq\\n               get-value:x:@.arguments/*/connection-string\\n               .:\\n      .lambda\\n         set-value:x:@.connection\\n            strings.concat\\n               .:[\\n               get-value:x:@.arguments/*/connection-string\\n               .:|\\n               get-value:x:@.arguments/*/database\\n               .:]\\n   else\\n      set-value:x:@.connection\\n         strings.concat\\n            .:[generic|\\n            get-value:x:@.arguments/*/database\\n            .:]\\n   pgsql.connect:x:@.connection\\n\\n      // Making sure we support table names with special characters.\\n      strings.concat\\n         .:\"\\nselect c.column_name, c.is_nullable, c.data_type, c.column_default, exists(\\n   select *\\n      from information_schema.key_column_usage kcu  \\n         join information_schema.table_constraints tc on tc.constraint_name = kcu.constraint_name \\n      where tc.constraint_type = 'PRIMARY KEY' and\\n         kcu.table_name = @table and \\n         c.column_name = kcu.column_name and c.table_name = kcu.table_name\\n   ) as is_pk\\n   from information_schema.columns c\\n   where c.table_name = @table and c.table_catalog = @database order by is_pk desc, c.column_name asc\"\\n      pgsql.select:x:@strings.concat\\n         @table:x:@.arguments/*/table\\n         @database:x:@.arguments/*/database\\n\\n      /*\\n       * Creating our return value, by projecting it into\\n       * a generic form, that does not rely upon PostgreSQL's syntactic\\n       * details.\\n       */\\n      for-each:x:@pgsql.select/*\\n         unwrap:x:+/*/*\\n         .tmp\\n            \"\"\\n               name:x:@.dp/#/*/column_name\\n               db:x:@.dp/#/*/data_type\\n\\n         // Checking if column is nullable.\\n         if\\n            eq\\n               get-value:x:@.dp/#/*/is_nullable\\n               .:NO\\n            .lambda\\n               add:x:@.tmp/*\\n                  .\\n                     nullable:bool:false\\n         else\\n            add:x:@.tmp/*\\n               .\\n                  nullable:bool:true\\n\\n         // Checking if column is a part of the primary key.\\n         if\\n            get-value:x:@.dp/#/*/is_pk\\n            .lambda\\n               add:x:@.tmp/*\\n                  .\\n                     primary:bool:true\\n         else\\n            add:x:@.tmp/*\\n               .\\n                  primary:bool:false\\n\\n         // Checking if column has a default value.\\n         if\\n            and\\n               not\\n                  eq\\n                     get-value:x:@.dp/#/*/column_default\\n                     .:\\n               not\\n                  eq\\n                     get-value:x:@.dp/#/*/column_default\\n                     .\\n            .lambda\\n               add:x:@.tmp/*\\n                  .\\n                     automatic:bool:true\\n         else\\n            add:x:@.tmp/*\\n               .\\n                  automatic:bool:false\\n\\n         /*\\n          * Figuring our which Hyperlambda type to project\\n          * its database type to.\\n          */\\n         .type\\n\\n         // Anything BUT booleans.\\n         strings.regex-replace:x:@.dp/#/*/data_type\\n            .:\" \\\\([0-9,]+\\\\)\"\\n            .:\\n         strings.regex-replace:x:@strings.regex-replace\\n            .:\" \\\\[[0-9,]+\\\\]\"\\n            .:\\n         strings.replace:x:@strings.regex-replace\\n            .:\" unsigned\"\\n            .:\\n         strings.replace:x:@strings.replace\\n            .:\" without time zone\"\\n            .:\\n         strings.replace:x:@strings.replace\\n            .:\" with time zone\"\\n            .:\\n         switch:x:@strings.replace\\n\\n            // Everything transformed into date values.\\n            case:smallserial\\n            case:serial\\n            case:smallint\\n               set-value:x:@.type\\n                  .:int\\n\\n            // Everything transformed into date values.\\n            case:timestamp\\n               set-value:x:@.type\\n                  .:date\\n\\n            // Everything transformed into decimal values.\\n            case:numeric\\n            case:decimal\\n            case:real\\n            case:money\\n               set-value:x:@.type\\n                  .:decimal\\n\\n            // Everything transformed into double.\\n            case:double precision\\n               set-value:x:@.type\\n                  .:double\\n\\n            // Everything transformed into integer long values.\\n            case:integer\\n            case:bigint\\n            case:bigserial\\n            case:interval\\n               set-value:x:@.type\\n                  .:long\\n\\n            // Everything transformed into string values.\\n            case:string\\n            case:bit\\n            case:bit varying\\n            case:character\\n            case:character varying\\n            case:json\\n            case:text\\n            case:xml\\n               set-value:x:@.type\\n                  .:string\\n\\n            // Everything transformed into boolean values.\\n            case:boolean\\n               set-value:x:@.type\\n                  .:bool\\n\\n            // Default/special cases.\\n            default\\n               if\\n                  strings.starts-with:x:@strings.replace\\n                     .:enum\\n                  .lambda\\n\\n                     // Enum type\\n                     set-value:x:@.type\\n                        .:string\\n               else\\n\\n                  // Defaulting to string type.\\n                  set-value:x:@.type\\n                     .:string\\n\\n         // Adding Hyperlambda type to [.tmp] above.\\n         unwrap:x:+/*/*\\n         add:x:@.tmp/*\\n            .\\n               hl:x:@.type\\n\\n         // Adding [.tmp] to [return-nodes] below.\\n         add:x:../*/pgsql.connect/*/return-nodes\\n            get-nodes:x:@.tmp/*\\n\\n      // Returning results to caller.\\n      return-nodes\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Lists all database in your MySQL instance.\\n\\nArguments\\n\\n- [connection-string] - What connection string to use"},{"role":"assistant","content":"slots.create:magic.db.pgsql.databases\\n\\n   // Opens up our connection\\n   .connection:[postgres]\\n   if\\n      and\\n         not\\n            eq\\n               get-value:x:@.arguments/*/connection-string\\n               .\\n         not\\n            eq\\n               get-value:x:@.arguments/*/connection-string\\n               .:\\n      .lambda\\n         set-value:x:@.connection\\n            strings.concat\\n               .:[\\n               get-value:x:@.arguments/*/connection-string\\n               .:|\\n               .:postgres]\\n   pgsql.connect:x:@.connection\\n\\n      // Runs our query\\n      pgsql.select:select datname from pg_database\\n\\n      // Renaming \"Database\" nodes.\\n      set-name:x:@pgsql.select/*/*\\n         .:db\\n\\n      // Returns the remaining databases to caller.\\n      return-nodes:x:@pgsql.select/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Lists all foreign keys in some PostgreSQL table.\\n\\nArguments\\n\\n- [connection-string] - What connection string to use\\n- [database] - What database you want to check\\n- [table] - What table you want to check"},{"role":"assistant","content":"slots.create:magic.db.pgsql.foreign_keys\\n\\n   // Sanity checking invocation.\\n   validators.mandatory:x:@.arguments/*/database\\n   validators.mandatory:x:@.arguments/*/table\\n\\n   // Opens up our connection\\n   .connection:[postgres]\\n   if\\n      and\\n         not\\n            eq\\n               get-value:x:@.arguments/*/connection-string\\n               .\\n         not\\n            eq\\n               get-value:x:@.arguments/*/connection-string\\n               .:\\n      .lambda\\n         set-value:x:@.connection\\n            strings.concat\\n               .:[\\n               get-value:x:@.arguments/*/connection-string\\n               .:|\\n               get-value:x:@.arguments/*/database\\n               .:]\\n   else\\n      set-value:x:@.connection\\n         strings.concat\\n            .:[generic|\\n            get-value:x:@.arguments/*/database\\n            .:]\\n   pgsql.connect:x:@.connection\\n\\n      // Dynamically creating our SQL.\\n      pgsql.select:\"\\nselect\\n      kcu.column_name as column,\\n      rel_kcu.table_name as foreign_table,\\n      rel_kcu.column_name as foreign_column,\\n      tco.constraint_name as name\\nfrom information_schema.table_constraints tco\\njoin information_schema.key_column_usage kcu\\n          on tco.constraint_schema = kcu.constraint_schema\\n          and tco.constraint_name = kcu.constraint_name\\njoin information_schema.referential_constraints rco\\n          on tco.constraint_schema = rco.constraint_schema\\n          and tco.constraint_name = rco.constraint_name\\njoin information_schema.key_column_usage rel_kcu\\n          on rco.unique_constraint_schema = rel_kcu.constraint_schema\\n          and rco.unique_constraint_name = rel_kcu.constraint_name\\n          and kcu.ordinal_position = rel_kcu.ordinal_position\\nwhere tco.constraint_type = 'FOREIGN KEY' and\\n    kcu.table_name = @table and\\n    kcu.table_catalog = @database\\norder by kcu.column_name\"\\n         @table:x:@.arguments/*/table\\n         @database:x:@.arguments/*/database\\n\\n      // Returning result to caller.\\n      return-nodes:x:@pgsql.select/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Lists all tables in your MySQL instance.\\n\\nArguments\\n\\n- [connection-string] - What connection string to use\\n- [database] - What database you want to check"},{"role":"assistant","content":"slots.create:magic.db.pgsql.tables\\n\\n   // Sanity checking invocation.\\n   validators.mandatory:x:@.arguments/*/database\\n\\n   // Opens up our connection\\n   .connection:[postgres]\\n   if\\n      and\\n         not\\n            eq\\n               get-value:x:@.arguments/*/connection-string\\n               .\\n         not\\n            eq\\n               get-value:x:@.arguments/*/connection-string\\n               .:\\n      .lambda\\n         set-value:x:@.connection\\n            strings.concat\\n               .:[\\n               get-value:x:@.arguments/*/connection-string\\n               .:|\\n               get-value:x:@.arguments/*/database\\n               .:]\\n   else\\n      set-value:x:@.connection\\n         strings.concat\\n            .:[generic|\\n            get-value:x:@.arguments/*/database\\n            .:]\\n   pgsql.connect:x:@.connection\\n\\n      // Runs our query\\n      pgsql.select:\"select tablename from pg_catalog.pg_tables where schemaname != 'pg_catalog' and schemaname != 'information_schema'\"\\n      set-name:x:@pgsql.select/*/*\\n         .:table\\n      return-nodes:x:@pgsql.select/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Lists all columns in some SQL Server database table.\\n\\nArguments\\n\\n- [connection-string] - What connection string to use\\n- [database] - What database you want to check\\n- [table] - What table you want to check"},{"role":"assistant","content":"slots.create:magic.db.mssql.columns\\n\\n   // Sanity checking invocation.\\n   validators.mandatory:x:@.arguments/*/database\\n   validators.mandatory:x:@.arguments/*/table\\n\\n   // Opens up our connection\\n   .connection:[master]\\n   if\\n      and\\n         not\\n            eq\\n               get-value:x:@.arguments/*/connection-string\\n               .\\n         not\\n            eq\\n               get-value:x:@.arguments/*/connection-string\\n               .:\\n      .lambda\\n         set-value:x:@.connection\\n            strings.concat\\n               .:[\\n               get-value:x:@.arguments/*/connection-string\\n               .:|\\n               get-value:x:@.arguments/*/database\\n               .:]\\n   else\\n      set-value:x:@.connection\\n         strings.concat\\n            .:[generic|\\n            get-value:x:@.arguments/*/database\\n            .:]\\n   mssql.connect:x:@.connection\\n\\n      // Running our query to retrieve meta information.\\n      mssql.select:\"select c.name 'name', t.Name 'type', c.is_nullable 'nullable', isnull(i.is_primary_key, 0) 'primary', c.is_identity 'automatic', c.default_object_id 'default'\\n         from sys.columns c \\n             inner join sys.types t on c.user_type_id = t.user_type_id\\n             left outer join sys.index_columns ic \\n             left outer join sys.indexes i on ic.object_id = i.object_id and \\n                 ic.index_id = i.index_id on ic.object_id = c.object_id and \\n                 ic.column_id = c.column_id and i.is_primary_key = 1\\n         where c.object_id = OBJECT_ID(@table)\"\\n         @table:x:@.arguments/*/table\\n\\n      // Adding the returned values from the above SQL into our return invocation below.\\n      for-each:x:@mssql.select/*\\n         unwrap:x:+/*/*\\n         .tmp\\n            \"\"\\n               name:x:@.dp/#/*/name\\n               db:x:@.dp/#/*/type\\n               nullable:x:@.dp/#/*/nullable\\n               primary:x:@.dp/#/*/primary\\n               automatic:x:@.dp/#/*/automatic\\n\\n         /*\\n          * Checking if column is not automatic,\\n          * but still seems to have a default value.\\n          */\\n         if\\n            mt\\n               get-value:x:@.dp/#/*/default\\n               .:int:0\\n            .lambda\\n\\n               // Column has default value.\\n               set-value:x:@.tmp/*/*/automatic\\n                  .:bool:true\\n\\n         /*\\n          * Figuring our which Hyperlambda type to project\\n          * its database type to.\\n          */\\n         .type\\n         switch:x:@.dp/#/*/type\\n\\n            // Everything transformed into date values.\\n            case:date\\n            case:datetime\\n            case:datetime2\\n            case:datetimeoffset\\n            case:smalldatetime\\n            case:time\\n               set-value:x:@.type\\n                  .:date\\n\\n            // Everything transformed into decimal values.\\n            case:numeric\\n            case:decimal\\n            case:smallmoney\\n            case:money\\n            case:float\\n            case:real\\n               set-value:x:@.type\\n                  .:decimal\\n\\n            // Everything transformed into integer long values.\\n            case:bigint\\n            case:smallint\\n            case:int\\n            case:tinyint\\n               set-value:x:@.type\\n                  .:long\\n\\n            // Everything transformed into boolean values.\\n            case:bit\\n               set-value:x:@.type\\n                  .:bool\\n\\n            // Everything transformed into string values.\\n            case:char\\n            case:varchar\\n            case:text\\n            case:nchar\\n            case:nvarchar\\n            case:ntext\\n            case:binary\\n            case:image\\n            case:varbinary\\n            case:uniqueidentifier\\n               set-value:x:@.type\\n                  .:string\\n\\n            // Special case for timestamp, since it's actually an \"automatic\" column.\\n            case:rowversion\\n            case:timestamp\\n               set-value:x:@.type\\n                  .:string\\n               set-value:x:@.tmp/*/*/automatic\\n                  .:bool:true\\n\\n            // Defaulting Hyperlambda type to string.\\n            default\\n               set-value:x:@.type\\n                  .:string\\n\\n         // Adding Hyperlambda type to [.tmp] above.\\n         unwrap:x:+/*/*\\n         add:x:@.tmp/*\\n            .\\n               hl:x:@.type\\n\\n         // Adding [.tmp] to [return-nodes] below.\\n         add:x:../*/mssql.connect/*/return-nodes\\n            get-nodes:x:@.tmp/*\\n\\n      // Returning results to caller.\\n      return-nodes\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Lists all database in your MySQL instance.\\n\\nArguments\\n\\n- [connection-string] - What connection string to use"},{"role":"assistant","content":"slots.create:magic.db.mssql.databases\\n\\n   // Opens up our connection\\n   .connection:master\\n   if\\n      and\\n         exists:x:@.arguments/*/connection-string\\n         not\\n            eq\\n               get-value:x:@.arguments/*/connection-string\\n               .\\n         not\\n            eq\\n               get-value:x:@.arguments/*/connection-string\\n               .:\\n      .lambda\\n         set-value:x:@.connection\\n            strings.concat\\n               .:[\\n               get-value:x:@.arguments/*/connection-string\\n               .:|\\n               .:master]\\n   mssql.connect:x:@.connection\\n\\n      // Runs our query\\n      mssql.select:select name from master.dbo.sysdatabases where has_dbaccess(name) = 1\\n\\n      // Renaming \"Database\" nodes.\\n      set-name:x:@mssql.select/*/*\\n         .:db\\n\\n      // Returns the remaining databases to caller.\\n      return-nodes:x:@mssql.select/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Lists all foreign keys in some SQL Server table.\\n\\nArguments\\n\\n- [connection-string] - What connection string to use\\n- [database] - What database you want to check\\n- [table] - What table you want to check"},{"role":"assistant","content":"slots.create:magic.db.mssql.foreign_keys\\n\\n   // Sanity checking invocation.\\n   validators.mandatory:x:@.arguments/*/database\\n   validators.mandatory:x:@.arguments/*/table\\n\\n   // Opens up our connection\\n   .connection:[information_schema]\\n   if\\n      and\\n         not\\n            eq\\n               get-value:x:@.arguments/*/connection-string\\n               .\\n         not\\n            eq\\n               get-value:x:@.arguments/*/connection-string\\n               .:\\n      .lambda\\n         set-value:x:@.connection\\n            strings.concat\\n               .:[\\n               get-value:x:@.arguments/*/connection-string\\n               .:|\\n               get-value:x:@.arguments/*/database\\n               .:]\\n   else\\n      set-value:x:@.connection\\n         strings.concat\\n            .:[generic|\\n            get-value:x:@.arguments/*/database\\n            .:]\\n   mssql.connect:x:@.connection\\n\\n      // Dynamically creating our SQL.\\n      strings.split:x:@.arguments/*/table\\n         .:.\\n      mssql.select:\"select\\n   col1.name as [column], sch2.name + '.' + tab2.name as [foreign_table], col2.name as [foreign_column], obj.name as name\\n   from sys.foreign_key_columns fkc\\n      inner join sys.objects obj on obj.object_id = fkc.constraint_object_id\\n      inner join sys.tables tab1 on tab1.object_id = fkc.parent_object_id\\n      inner join sys.schemas sch on tab1.schema_id = sch.schema_id\\n      inner join sys.columns col1 on col1.column_id = parent_column_id and col1.object_id = tab1.object_id\\n      inner join sys.tables tab2 on tab2.object_id = fkc.referenced_object_id\\n      inner join sys.schemas sch2 on tab2.schema_id = sch2.schema_id\\n      inner join sys.columns col2 on col2.column_id = referenced_column_id and col2.object_id = tab2.object_id\\n      inner join sys.[types] TY on\\n         col1.[system_type_id] = TY.[system_type_id] and\\n         col1.[user_type_id] = TY.[user_type_id] and\\n         tab1.name = @table and\\n         sch.name = @schema\"\\n         table:x:@strings.split/0/-\\n         schema:x:@strings.split/0\\n\\n      /*\\n       * Creating our return value, by projecting it into\\n       * a generic form, that does not rely upon MySQL's syntactic\\n       * details.\\n       */\\n      return-nodes:x:@mssql.select/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Lists all indexes in some SQL Server table.\\n\\nArguments\\n\\n- [connection-string] - What connection string to use\\n- [database] - What database you want to check\\n- [table] - What table you want to check"},{"role":"assistant","content":"slots.create:magic.db.mssql.indexes\\n\\n   // Sanity checking invocation.\\n   validators.mandatory:x:@.arguments/*/database\\n   validators.mandatory:x:@.arguments/*/table\\n\\n   // Opens up our connection\\n   .connection:[information_schema]\\n   if\\n      and\\n         not\\n            eq\\n               get-value:x:@.arguments/*/connection-string\\n               .\\n         not\\n            eq\\n               get-value:x:@.arguments/*/connection-string\\n               .:\\n      .lambda\\n         set-value:x:@.connection\\n            strings.concat\\n               .:[\\n               get-value:x:@.arguments/*/connection-string\\n               .:|\\n               get-value:x:@.arguments/*/database\\n               .:]\\n   else\\n      set-value:x:@.connection\\n         strings.concat\\n            .:[generic|\\n            get-value:x:@.arguments/*/database\\n            .:]\\n   mssql.connect:x:@.connection\\n\\n      // Dynamically creating our SQL.\\n      strings.split:x:@.arguments/*/table\\n         .:.\\n      strings.concat\\n         .:\"\\nselect IndexName = ind.name, ColumnName = col.name from sys.indexes ind \\n  inner join sys.index_columns ic on ind.object_id = ic.object_id and ind.index_id = ic.index_id \\n  inner join sys.columns col on ic.object_id = col.object_id and ic.column_id = col.column_id \\n  inner join sys.tables t on ind.object_id = t.object_id \\nwhere\\n  ind.is_primary_key = 0 \\n  and ind.is_unique = 0 \\n  and ind.is_unique_constraint = 0 \\n  and t.is_ms_shipped = 0 \\n  and t.name = '\"\\n         get-value:x:@strings.split/0/-\\n         .:\"'\"\\n      mssql.select:x:@strings.concat\\n\\n      /*\\n       * Creating our return value, by projecting it into\\n       * a generic form, that does not rely upon SQL Server's syntactic\\n       * details.\\n       */\\n      for-each:x:@mssql.select/*\\n         unwrap:x:+/*/*/*\\n         add:x:@mssql.connect/*/return-nodes\\n            .\\n               .\\n                  name:x:@.dp/#/*/IndexName\\n                  columns\\n         unwrap:x:+/*/*\\n         add:x:@mssql.connect/*/return-nodes/0/-/*/columns\\n            .\\n               .:x:@.dp/#/*/ColumnName\\n      return-nodes\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Lists all tables in your MySQL instance.\\n\\nArguments\\n\\n- [connection-string] - What connection string to use\\n- [database] - What database you want to check"},{"role":"assistant","content":"slots.create:magic.db.mssql.tables\\n\\n   // Sanity checking invocation.\\n   validators.mandatory:x:@.arguments/*/database\\n\\n   // Opens up our connection\\n   .connection:[master]\\n   if\\n      and\\n         not\\n            eq\\n               get-value:x:@.arguments/*/connection-string\\n               .\\n         not\\n            eq\\n               get-value:x:@.arguments/*/connection-string\\n               .:\\n      .lambda\\n         set-value:x:@.connection\\n            strings.concat\\n               .:[\\n               get-value:x:@.arguments/*/connection-string\\n               .:|\\n               get-value:x:@.arguments/*/database\\n               .:]\\n   else\\n      set-value:x:@.connection\\n         strings.concat\\n            .:[generic|\\n            get-value:x:@.arguments/*/database\\n            .:]\\n   mssql.connect:x:@.connection\\n\\n      // Runs our query\\n      mssql.select:\"select table_schema + '.' + table_name as \\\"table\\\"\\n   from information_schema.tables\\n   where table_type='base table' and table_name != 'sysdiagrams'\"\\n      return-nodes:x:@mssql.select/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns a bar chart image to caller.\\n\\nValues is a mandatory comma separated list of values."},{"role":"assistant","content":".arguments:*\\n.type:public\\n\\n// Creating our individual bars.\\n.bars\\nfor-each:x:@.arguments/*\\n\\n   // Adding primary node for bar.\\n   unwrap:x:+/+/*/*\\n   set-name:x:+/*/*\\n      get-name:x:@.dp/#\\n   add:x:@.bars\\n      .\\n         .:x:@.dp/#\\n\\n// Parametrizing [image.chart] invocation.\\nadd:x:../*/image.chart/*/bars\\n   get-nodes:x:@.bars/*\\nimage.chart:bars\\n   width:800\\n   height:500\\n   bars\\n\\n// Applying correct HTTP header.\\nresponse.headers.set\\n   Content-Type:image/png\\n\\n// Returning chart to caller.\\nreturn:x:@image.chart\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns a stacked chart image to caller.\\n\\nValues is a mandatory comma separated list of values."},{"role":"assistant","content":".arguments:*\\n.type:public\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/legend\\n\\n// Creating our individual bars.\\n.bars\\nfor-each:x:@.arguments/*\\n   get-name:x:@.dp/#\\n   if\\n      not\\n         strings.starts-with:x:@get-name\\n            .:legend\\n      .lambda\\n\\n         // Adding primary node for bar.\\n         set-name:x:+/*/*\\n            get-value:x:@get-name\\n         add:x:@.bars\\n            .\\n               .\\n\\n         // Adding values for individual cells.\\n         add:x:@.bars/0/-\\n            strings.split:x:@.dp/#\\n               .:,\\n\\n// Creating our legend.\\nadd:x:../*/image.chart/*/legend\\n   strings.split:x:@.arguments/*/legend\\n      .:,\\n\\n// Parametrizing [image.chart] invocation.\\nadd:x:../*/image.chart/*/bars\\n   get-nodes:x:@.bars/*\\nimage.chart:stacked\\n   width:800\\n   height:500\\n   bars\\n   legend\\n\\n// Applying correct HTTP header.\\nresponse.headers.set\\n   Content-Type:image/png\\n\\n// Returning chart to caller.\\nreturn:x:@image.chart\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Hyperlambda endpoint taking arguments. The SQL aggregates and returns the top 25 artists with the most albums from the chinook database.\\n\\nThis SQL script is designed to retrieve and aggregate data from the chinook database, specifically focusing on the number of albums associated with each artist. The script joins the Album and Artist tables on the ArtistId field, counts the number of albums per artist, and orders the results in descending order based on the album count. It then limits the output to the top 25 artists with the highest number of albums. This query is useful for analyzing the distribution of albums across different artists within the database, providing insights into which artists have the most extensive discographies. The SQL is executed within a controlled environment where user authorization is verified, and a connection to the SQLite database is established before running the query. The results are then returned to the caller, ensuring that only authorized users can access this aggregated data."},{"role":"assistant","content":".arguments\\n\\n// Making sure user is authorized to invoke endpoint.\\nauth.ticket.verify:root,admin\\n\\n// Connecting to database.\\ndata.connect:chinook\\n   database-type:sqlite\\n\\n   // Executing [data.select] slot with our SQL.\\n   data.select:\"\\n/*\\n * Script to aggregate records for each artist in chinook database.\\n * Make sure you select the chinook database before execxuting the script.\\n */\\nselect ar.Name, count(*) as count\\n  from Album al, Artist ar where al.ArtistId = ar.ArtistId\\n  group by al.ArtistId\\n  order by count desc\\n  limit 25\\n\"\\n      database-type:sqlite\\n\\n   // Returning a result of above invocation to caller.\\n   return-nodes:x:@data.select/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Hyperlambda endpoint taking arguments. This SQL query selects media types and their aggregate counts, ordering the results by count in descending order, filtered by a specified name pattern.\\n\\nThe SQL code is executed within a SQLite database connection to the Chinook database. It performs an inner join between the MediaType and Track tables to count the occurrences of each media type. The query filters media types based on a provided pattern using the LIKE operator, groups the results by MediaTypeId, and orders them by the count of tracks associated with each media type in descending order. This allows users to retrieve media type information and their usage frequency, filtered by a specific name pattern, from the Chinook database.\\n\\nAll arguments are mandatory."},{"role":"assistant","content":".arguments\\n   filter:string\\n\\n// Connecting to database.\\ndata.connect:chinook\\n   database-type:sqlite\\n\\n   // Parametrizing [data.select].\\n   add:x:./*/data.select\\n      get-nodes:x:@.arguments/*\\n\\n   // Executing [data.select] slot with our SQL.\\n   data.select:@\"\\n/*\\n * Selects media types and aggregate of counts, and orders by count descending.\\n * Make sure you select the chinook database before execxuting the script.\\n */\\nselect mt.Name, count(mt.MediaTypeId) as Amount \\n  from MediaType mt\\n    inner join Track t on mt.MediaTypeId = t.MediaTypeId\\n  where mt.Name like @filter\\n  group by mt.MediaTypeId\\n  order by Amount desc;\\n\"\\n      database-type:sqlite\\n\\n   // Returning a result of above invocation to caller.\\n   return-nodes:x:@data.select/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Hyperlambda endpoint taking arguments. The SQL query retrieves distinct customer details who have purchased tracks from the \"Rock\" genre.\\n\\nThe SQL code connects to the Chinook database and executes a query that selects distinct email addresses, first names, last names, and genre names of customers who have purchased tracks classified under the \"Rock\" genre. It achieves this by joining the Customer, Invoice, InvoiceLine, Track, and Genre tables on their respective keys, filtering the results to include only those where the genre name is \"Rock\". The results are ordered by the customer's email address. This query is useful for identifying and analyzing the customer base interested in rock music, which can be leveraged for targeted marketing or customer relationship management initiatives."},{"role":"assistant","content":".arguments\\n\\n// Connecting to database.\\ndata.connect:chinook\\n   database-type:sqlite\\n\\n   // Executing [data.select] slot with our SQL.\\n   data.select:\"\\n/*\\n * Selects details from all customers that are listening to rock.\\n * Make sure you select the chinook database before execxuting the script.\\n */\\nselect distinct c.Email, c.FirstName, c.LastName, g.name\\n  from Customer c\\n    inner join Invoice i on c.CustomerId = i.CustomerId\\n    inner join InvoiceLine ii on i.InvoiceId = ii.InvoiceId\\n    inner join Track t ON ii.TrackId = t.TrackId\\n    inner join Genre g ON t.GenreId = g.GenreId\\n  where g.Name = \\\"Rock\\\"\\n  order by c.Email\\n\"\\n      database-type:sqlite\\n\\n   // Returning a result of above invocation to caller.\\n   return-nodes:x:@data.select/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Hyperlambda endpoint taking arguments. The SQL query selects distinct email, first name, last name, and genre name of customers who listen to rock music from the Chinook database.\\n\\nThis SQL script is designed to retrieve a list of customers from the Chinook database who are associated with rock music. It performs a series of inner joins between the Customer, Invoice, InvoiceLine, Track, and Genre tables to filter and extract customer details based on the genre specified by the `@filter` parameter. The query ensures that only unique customer records are returned by using the `DISTINCT` keyword, and it orders the results by the customer's email address. This script is particularly useful for generating targeted marketing lists or analyzing customer preferences within the rock genre. The use of parameterization with `@filter` enhances security by preventing SQL injection attacks.\\n\\nAll arguments are mandatory."},{"role":"assistant","content":".arguments\\n   filter:string\\n\\n// Connecting to database.\\ndata.connect:chinook\\n   database-type:sqlite\\n\\n   // Parametrizing [data.select].\\n   add:x:./*/data.select\\n      get-nodes:x:@.arguments/*\\n\\n   // Executing [data.select] slot with our SQL.\\n   data.select:@\"\\n/*\\n * Selects details from all customers that are listening to rock.\\n * Make sure you select the chinook database before execxuting the script.\\n */\\nselect distinct c.Email, c.FirstName, c.LastName, g.name\\n  from Customer c\\n    inner join Invoice i on c.CustomerId = i.CustomerId\\n    inner join InvoiceLine ii on i.InvoiceId = ii.InvoiceId\\n    inner join Track t ON ii.TrackId = t.TrackId\\n    inner join Genre g ON t.GenreId = g.GenreId\\n  where g.Name like @filter\\n  order by c.Email\\n\"\\n      database-type:sqlite\\n\\n   // Returning a result of above invocation to caller.\\n   return-nodes:x:@data.select/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Hyperlambda endpoint taking arguments. This SQL query retrieves and returns the names of artists and the titles of their albums from the Chinook database, ordering the results by artist name and limiting the output to 50 records.\\n\\nThe SQL script performs an inner join between the 'Artist' and 'Album' tables in the Chinook database, matching records based on the 'ArtistId' field. It selects the 'Name' field from the 'Artist' table and the 'Title' field from the 'Album' table, ordering the results alphabetically by artist name. The query limits the output to the first 50 records, ensuring efficient data retrieval. This operation is executed within a SQLite database environment, and the results are returned to the caller, facilitating data access for authorized users."},{"role":"assistant","content":".arguments\\n\\n// Making sure user is authorized to invoke endpoint.\\nauth.ticket.verify:enterprise\\n\\n// Connecting to database.\\ndata.connect:chinook\\n   database-type:sqlite\\n\\n   // Executing [data.select] slot with our SQL.\\n   data.select:\"\\n/*\\n * Script to join artists to albums in your Chinook database.\\n * Make sure you select the chinook database before execxuting the script.\\n */\\nselect ar.Name, al.Title\\n  from Album al\\n    inner join Artist ar on al.ArtistId = ar.ArtistId\\n  order by ar.Name\\n  limit 50\\n\"\\n      database-type:sqlite\\n\\n   // Returning a result of above invocation to caller.\\n   return-nodes:x:@data.select/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"This file returns all companies that the specified director is associated with\\n\\ndirector_id is an integer and a mandatory object"},{"role":"assistant","content":".arguments\\n   director_id:long\\n   limit:long\\n   offset:long\\n\\n// Opening database connection.\\ndata.connect:[finovo|finovo]\\n   database-type:pgsql\\n\\n   // Reading from directors.\\n   data.select:\"\\nselect d1.org_number, b.company_name, d1.role_name\\n   from directors d1\\n      inner join basic b on b.org_number = d1.org_number\\n      inner join directors d2 on d1.director_nbr = d2.director_nbr\\n   where d2.director_id = @id and d1.org_number != d2.org_number\\n   limit @limit offset @offset\"\\n      database-type:pgsql\\n      @id:x:@.arguments/*/director_id\\n      @limit:x:@.arguments/*/limit\\n      @offset:x:@.arguments/*/offset\\n   if\\n      mte\\n         get-count:x:@data.select/*\\n         .:int:10\\n      .lambda\\n\\n         // Making sure we inform caller that there might exist additional companies.\\n         add:x:@data.connect/*/yield\\n            .\\n               notice:The director is probably associated with more companies\\n   yield\\n      companies:x:@data.select/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns the directors for a specific account or company"},{"role":"assistant","content":".arguments\\n   org_number:string\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/org_number\\nset-value:x:@.arguments/*/org_number\\n   strings.replace-not-of:x:@.arguments/*/org_number\\n      .:0123456789\\n      .:\\nvalidators.string:x:@.arguments/*/org_number\\n   min:10\\n   max:10\\n\\n// Connecting to database.\\ndata.connect:[finovo|finovo]\\n   database-type:pgsql\\n\\n   // Retrieving items.\\n   data.read\\n      database-type:pgsql\\n      table:directors\\n      columns\\n         director_id\\n         org_number\\n         from_date\\n         to_date\\n         complete_ef_pnr\\n         first_name\\n         given_name\\n         middle_name\\n         last_name\\n         director_name\\n         gender\\n         role_name\\n         director_home_co_address\\n         director_home_street\\n         director_home_zipcode\\n         director_home_town\\n         director_home_community_code\\n         director_home_community\\n         director_home_region_code\\n         director_home_region\\n         director_home_country_code\\n         director_home_country\\n      where\\n         and\\n            org_number.eq:x:@.arguments/*/org_number\\n\\n   // Making sure we return company information related to the account.\\n   add:x:../*/return-nodes/*/directors\\n      get-nodes:x:@data.read/*\\n\\n// Returning result to caller.\\nreturn-nodes\\n   directors\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Gets a company\\n\\nWill return the company with the specified name."},{"role":"assistant","content":".arguments\\n   query:string\\n.type:public\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/query\\n\\n// Connecting to database.\\ndata.connect:[finovo|finovo]\\n   database-type:pgsql\\n\\n   // Retrieving items.\\n   data.read\\n      database-type:pgsql\\n      table:basic\\n      columns\\n         org_number\\n         company_name\\n      where\\n         and\\n            legalgroup_code.eq:AB\\n            company_name.ilike:x:@.arguments/*/query\\n      limit:1\\n\\n   // Checking we've got data.\\n   if\\n      not-exists:x:@data.read/*\\n      .lambda\\n         return\\n            result:No results were found\\n\\n   // Returning result to caller.\\n   return-nodes:x:@data.read/*/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns financial information about a company."},{"role":"assistant","content":".arguments\\n   org_number:string\\n   columns\\n.type:public\\n\\n// Decorating function invocation.\\nfor-each:x:@.arguments/*/columns/*\\n\\n   /*\\n    * Sanity checking column name to avoid SQL injection attacks.\\n    * \\n    * This makes sure we only handle columns existing in the following [.cols] segment.\\n    */\\n   .cols\\n      .:kr_return_on_capital_percent\\n      .:kr_return_on_cap_emp_percent\\n      .:kr_avg_debt_eq_ratio_percent\\n      .:kr_risk_buffer\\n      .:kr_ebitda\\n      .:kr_ebitida_margin_percent\\n      .:kr_interest_coverage_ebitda\\n      .:kr_ret_on_tot_cap_ebitda_perc\\n      .:kr_ret_on_working_capital_perc\\n      .:kr_degree_of_debt_intr_bearing\\n      .:kr_operating_margin_percent\\n      .:kr_profit_margin_percent\\n      .:kr_gross_profit_margin_percent\\n      .:kr_turnover_per_employee\\n      .:kr_solidity_percent\\n      .:kr_capital_turnover_times\\n      .:kr_working_capital\\n      .:kr_opp_prof_totnet_oppinc_perc\\n      .:kr_quick_ratio_percent\\n      .:kr_change_in_turnover_percent\\n      .:kr_opp_result_num_of_employees\\n      .:kr_cost_per_employee\\n      .:kr_change_in_num_of_employees\\n      .:kr_inventories_turnover_perc\\n      .:kr_accounts_rec_turnover_perc\\n      .:kr_liquid_assets_turnover_perc\\n      .:kr_current_liab_turnover_perc\\n      .:kr_degree_of_debt\\n      .:kr_rate_of_return_times\\n      .:kr_return_on_op_capital\\n      .:kr_risk_buffer_on_op_cap_perc\\n      .:kr_inventory_turnover_times\\n      .:kr_du_pont_model_percent\\n      .:pl_net_operating_income\\n      .:pl_net_sales\\n      .:pl_cost_of_sold_goods\\n      .:pl_gross_profit_loss\\n      .:pl_selling_expenses\\n      .:pl_admin_costs\\n      .:pl_research_and_dev_costs\\n      .:pl_change_invent_work_prog\\n      .:pl_work_perf_own_use_capital\\n      .:pl_raw_mat_and_cons\\n      .:pl_goods_for_resale\\n      .:pl_personal_costs\\n      .:pl_depr_and_write_downs\\n      .:pl_item_affect_compare\\n      .:pl_other_opp_income\\n      .:pl_other_opp_expenses\\n      .:pl_other_ext_costs\\n      .:pl_operating_result\\n      .:pl_result_participation_group\\n      .:pl_fin_int_group_inc\\n      .:pl_ext_interest_inc\\n      .:pl_interest_exp_int\\n      .:pl_interest_exp_ext\\n      .:pl_other_fin_inc\\n      .:pl_other_fin_costs\\n      .:pl_prof_loss_after_fin_items\\n      .:pl_extraordinary_inc\\n      .:pl_extraordinary_exp\\n      .:pl_group_contrib\\n      .:pl_shareholder_contrib\\n      .:pl_other_appropriations\\n      .:pl_tax\\n      .:pl_minority_intrest_and_prof\\n      .:pl_net_profit_loss\\n      .:bs_subscribed_capital_unpaid\\n      .:bs_capt_exp_for_res_and_dev\\n      .:bs_patents\\n      .:bs_goodwill\\n      .:bs_other_intangible_ass\\n      .:bs_total_intangible_assets\\n      .:bs_land_build\\n      .:bs_plant_machine\\n      .:bs_equip_tools_fix_and_fit\\n      .:bs_machines_inventory\\n      .:bs_other_tang_ass_non_dep\\n      .:bs_other_mat_depreciation\\n      .:bs_total_tangible_assets\\n      .:bs_group_share\\n      .:bs_acc_recieve_corp_group\\n      .:bs_loan_co_owners\\n      .:bs_other_fin_assets\\n      .:bs_total_financial_assets\\n      .:bs_tot_fix_assets\\n      .:bs_work_on_contract\\n      .:bs_inventories\\n      .:bs_total_inventories\\n      .:bs_accounts_receivable_trade\\n      .:bs_acc_recieve_group\\n      .:bs_other_acc_recieve\\n      .:bs_total_accounts_receivable\\n      .:bs_short_investments\\n      .:bs_cash_and_bank_balances\\n      .:bs_other_cur_assets\\n      .:bs_total_turnover_assets\\n      .:bs_tot_assets\\n      .:bs_issued_share_capital\\n      .:bs_share_premium_reserve\\n      .:bs_revaluation_reserve\\n      .:bs_other_stockholder_equity\\n      .:bs_profit_loss_brought_fwd\\n      .:bs_group_contribution\\n      .:bs_shareholder_contribution\\n      .:bs_net_profit_loss\\n      .:bs_total_dividens_capacity\\n      .:bs_tot_equity\\n      .:bs_untaxed_reserves\\n      .:bs_minority_interests\\n      .:bs_provisions\\n      .:bs_lt_bond_loan\\n      .:bs_lt_liab_to_credit_instit\\n      .:bs_lt_liab_group_ass_comp\\n      .:bs_other_long_term_liab\\n      .:bs_tot_long_term_debts\\n      .:bs_liab_credit_inst\\n      .:bs_acc_pay_trade\\n      .:bs_st_liab_group_ass_comp\\n      .:bs_other_short_term_liab\\n      .:bs_tot_current_liabilities\\n      .:bs_tot_equity_and_liab\\n      .:n_months\\n      .:n_account_currency_info\\n      .:n_no_employees\\n      .:n_account_shortage\\n      .:n_account_shortage_text\\n      .:n_salary_board\\n      .:n_tantiem_board\\n      .:n_employee_salary\\n      .:n_perf_bonus_to_oth_employees\\n      .:n_payroll_overhead\\n      .:n_floating_charge\\n      .:n_real_estate_mortgage\\n      .:n_other_collateral\\n      .:n_tot_collateral\\n      .:n_conditional_equity\\n      .:n_other_contingent_liab\\n      .:n_tot_contingent_liab\\n      .:n_dividend\\n      .:n_accepted_bank_overdraft\\n      .:n_not_used_bank_overdraft\\n      .:n_net_interest_finance\\n      .:n_agreed_severance_pay\\n      .:n_accountant_obligation\\n      .:n_type_of_statement\\n      .:n_depr_goods\\n      .:n_depr_sales\\n      .:n_depr_admin\\n      .:n_depr_rod\\n      .:n_depr_other\\n      .:n_depr_unspec\\n   if\\n      exists:x:\"@.cols/*/\\\"={@.dp/#}\\\"\"\\n      .lambda\\n\\n         // Adding column to slot invocation.\\n         set-name:x:+/*/*\\n            get-value:x:@.dp/#\\n         add:x:../*/execute/*/columns\\n            .\\n               foo\\n\\n// Invoking helper slot.\\nexecute:finovo.accounts.get-data\\n   org_number:x:@.arguments/*/org_number\\n   columns\\n      date_from\\n      date_to\\nreturn-nodes:x:-/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns parent company from specified org number.\\n\\nReturns the company the specified org number is owned by."},{"role":"assistant","content":".arguments\\n   org_number:string\\n.type:public\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/org_number\\nset-value:x:@.arguments/*/org_number\\n   strings.replace-not-of:x:@.arguments/*/org_number\\n      .:0123456789\\n      .:\\n\\n// Connecting to database.\\ndata.connect:[finovo|finovo]\\n   database-type:pgsql\\n\\n   // Retrieving items.\\n   data.read\\n      database-type:pgsql\\n      table:group_structure\\n      columns\\n         group_mother_orgnumber\\n      where\\n         and\\n            org_number.eq:x:@.arguments/*/org_number\\n      limit:-1\\n\\n   // Verifying the company has a parent company.\\n   if\\n      not-exists:x:@data.read/*\\n      .lambda\\n         return\\n            result:\"This company doesn't have any parent company\"\\n\\n   // Returning result to caller.\\n   return-nodes:x:@data.read/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Searches for a company\\n\\nWill search for a company having a name containing the specified query."},{"role":"assistant","content":".arguments\\n   query:string\\n   limit:long\\n   offset:long\\n.type:public\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/query\\nvalidators.default:x:@.arguments\\n   limit:long:10\\n   offset:long:0\\n\\n// Connecting to database.\\ndata.connect:[finovo|finovo]\\n   database-type:pgsql\\n\\n   /*\\n    * Parametrising invocations below.\\n    * \\n    * Notice, we're parametrising both count and get items invocations here!\\n    */\\n   .query\\n   set-value:x:@.query\\n      strings.concat\\n         .:%\\n         get-value:x:@.arguments/*/query\\n         .:%\\n   unwrap:x:+/*/*\\n   add:x:./*/data.read/*/where/*/and\\n      .\\n         company_name.ilike:x:@.query\\n\\n   // Applying paging if existing.\\n   add:x:@data.connect/*/data.read/[0,1]\\n      get-nodes:x:@.arguments/*/limit\\n      get-nodes:x:@.arguments/*/offset\\n\\n   // Retrieving items.\\n   data.read\\n      database-type:pgsql\\n      table:basic\\n      columns\\n         org_number\\n         company_name\\n      where\\n         and\\n            legalgroup_code.eq:AB\\n\\n   // Checking we've got data.\\n   if\\n      not-exists:x:@data.read/*\\n      .lambda\\n         return\\n            result:No results were found\\n\\n   // Making sure we return company information related to the account.\\n   add:x:./*/yield/*/companies\\n      get-nodes:x:@data.read/*\\n\\n   // Retrieving items.\\n   data.read\\n      database-type:pgsql\\n      table:basic\\n      columns\\n         count(*)\\n            as:count\\n      where\\n         and\\n            legalgroup_code.eq:AB\\n\\n   // Returning result to caller.\\n   yield\\n      companies\\n      total_companies:x:@data.read/0/0\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns subsidiary companies from specified org number.\\n\\nReturns all companies the specified org number company owns, either partially or completely."},{"role":"assistant","content":".arguments\\n   org_number:string\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/org_number\\nset-value:x:@.arguments/*/org_number\\n   strings.replace-not-of:x:@.arguments/*/org_number\\n      .:0123456789\\n      .:\\n\\n// Connecting to database.\\ndata.connect:[finovo|finovo]\\n   database-type:pgsql\\n\\n   // Retrieving items.\\n   data.read\\n      database-type:pgsql\\n      table:group_structure\\n      columns\\n         org_number\\n         company_name\\n         company_country_name\\n         owned_percent\\n      where\\n         and\\n            group_mother_orgnumber.eq:x:@.arguments/*/org_number\\n            org_number.neq:x:@.arguments/*/org_number\\n      limit:-1\\n\\n   // Verifying the company has subsidiaries.\\n   if\\n      not-exists:x:@data.read/*\\n      .lambda\\n         return\\n            result:\"This company doesn't have any subsidiaries\"\\n\\n   // Returning result to caller.\\n   return-nodes:x:@data.read/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns Stripe charges.\\n\\n[limit] and [starting_after] are optional arguments and [limit] is the number of charges to return while [starting_after] is from which record to start returning charges."},{"role":"assistant","content":".arguments\\n   limit:int\\n   starting_after:string\\n   customer_id:string\\n\\n/*\\n * Ensures user is authorized to access endpoint.\\n * \\n * If you don't supply a list of [roles] this action only verifies the user is authenticated,\\n * and does not care about what roles the user belongs to.\\n */\\nexecute:magic.workflows.actions.execute\\n   name:authorize\\n   filename:/misc/workflows/actions/security/authorize.hl\\n   arguments\\n      roles\\n         .:root\\n         .:gpt\\n\\n/*\\n * Retrieves charges from Stripe.\\n * \\n * Will use your Stripe API token found from your settings as it's interacting\\n * with the Stripe API.\\n */\\nexecute:magic.workflows.actions.execute\\n   name:stripe-charges-get\\n   filename:/modules/stripe/workflows/actions/stripe-charges-get.hl\\n   arguments\\n      limit:x:@.arguments/*/limit\\n      starting_after:x:@.arguments/*/starting_after\\n      customer_id:x:@.arguments/*/customer_id\\n\\n// Returns the result of your last action.\\nreturn-nodes:x:@execute/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns all cloudlets in the system.\\n\\n[name] is an optional argument, and if specified, will return only cloudlets\\nhaving a matching name. [limit] and [offset] are optional paging arguments."},{"role":"assistant","content":".arguments\\n   name:string\\n   limit:int\\n   offset:int\\n\\n/*\\n * Ensures user is authorized to access endpoint.\\n * \\n * If you don't supply a list of [roles] this action only verifies the user is authenticated,\\n * and does not care about what roles the user belongs to.\\n */\\nexecute:magic.workflows.actions.execute\\n   name:authorize\\n   filename:/misc/workflows/actions/security/authorize.hl\\n   arguments\\n      roles\\n         .:root\\n         .:gpt\\n\\n/*\\n * Returns the username of the currently authenticated user,\\n * or null if user isn't authenticated.\\n */\\nexecute:magic.workflows.actions.execute\\n   name:username-get\\n   filename:/misc/workflows/actions/security/username-get.hl\\n   arguments\\n\\n// Returns all cloudlets in the system.\\nexecute:magic.workflows.actions.execute\\n   name:hub-cloudlets-get\\n   filename:/modules/hub/workflows/actions/hub-cloudlets-get.hl\\n   arguments\\n      username:x:--/execute/=username-get/*/username\\n      name:x:@.arguments/*/name\\n      limit:x:@.arguments/*/limit\\n      offset:x:@.arguments/*/offset\\n\\n// Returns the result of your last action.\\nreturn-nodes:x:@execute/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Creates a new cloudlet"},{"role":"assistant","content":".arguments\\n   name:string\\n   email:string\\n   plan:string\\n   cloudlet_name:string\\n\\n/*\\n * Ensures the specified [arg] was given.\\n * \\n * This action will throw an exception with a descriptive text explaining if the argument is missing.\\n */\\nexecute:magic.workflows.actions.execute\\n   name:validators-mandatory\\n   filename:/misc/workflows/actions/validators/validators-mandatory.hl\\n   arguments\\n      arg:x:@.arguments/*/cloudlet_name\\n\\n/*\\n * Ensures the specified [arg] was given.\\n * \\n * This action will throw an exception with a descriptive text explaining if the argument is missing.\\n */\\nexecute:magic.workflows.actions.execute\\n   name:validators-mandatory\\n   filename:/misc/workflows/actions/validators/validators-mandatory.hl\\n   arguments\\n      arg:x:@.arguments/*/plan\\n\\n/*\\n * Ensures the specified [arg] was given.\\n * \\n * This action will throw an exception with a descriptive text explaining if the argument is missing.\\n */\\nexecute:magic.workflows.actions.execute\\n   name:validators-mandatory\\n   filename:/misc/workflows/actions/validators/validators-mandatory.hl\\n   arguments\\n      arg:x:@.arguments/*/name\\n\\n/*\\n * Ensures the specified [arg] was given.\\n * \\n * This action will throw an exception with a descriptive text explaining if the argument is missing.\\n */\\nexecute:magic.workflows.actions.execute\\n   name:validators-mandatory\\n   filename:/misc/workflows/actions/validators/validators-mandatory.hl\\n   arguments\\n      arg:x:@.arguments/*/email\\n\\n/*\\n * Ensures the specified [email] is a valid emails.\\n * \\n * This action will throw an exception with a descriptive text if [email] is not a valid email.\\n */\\nexecute:magic.workflows.actions.execute\\n   name:validators-email\\n   filename:/misc/workflows/actions/validators/validators-email.hl\\n   arguments\\n      email:x:@.arguments/*/email\\n\\n/*\\n * Ensures user is authorized to access endpoint.\\n * \\n * If you don't supply a list of [roles] this action only verifies the user is authenticated,\\n * and does not care about what roles the user belongs to.\\n */\\nexecute:magic.workflows.actions.execute\\n   name:authorize\\n   filename:/modules/auth/workflows/actions/authorize.hl\\n   arguments\\n      roles\\n         .:root\\n         .:gpt\\n\\n/*\\n * Returns the username of the currently authenticated user,\\n * or null if user isn't authenticated.\\n */\\nexecute:magic.workflows.actions.execute\\n   name:username-get\\n   filename:/modules/auth/workflows/actions/username-get.hl\\n   arguments\\n\\n// Creates a new cloudlet.\\nexecute:magic.workflows.actions.execute\\n   name:hub-cloudlets-create\\n   filename:/modules/hub/workflows/actions/hub-cloudlets-create.hl\\n   arguments\\n      name:x:@.arguments/*/name\\n      email:x:@.arguments/*/email\\n      cloudlet_name:x:@.arguments/*/cloudlet_name\\n      username:x:--/execute/=username-get/*/username\\n      plan:x:@.arguments/*/plan\\n\\n// Returns the result of your last action.\\nreturn-nodes:x:@execute/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Sends an email to AINIRO"},{"role":"assistant","content":".arguments\\n   content:string\\n   email:string\\n   name:string\\n   recaptcha_response:string\\n\\n/*\\n * Validates the specified mCAPTCHA token.\\n * \\n * This action will validate the specified recaptcha_response token and throw an exception if validation fails.\\n */\\nexecute:magic.auth.captcha-verify\\n   token:x:@.arguments/*/recaptcha_response\\n\\n/*\\n * Sends an email to the specified [name]/[email] recipient, with the specified [subject] and [body].\\n * \\n * Optionally supply [from] and [from-email] as name/email sender. If you don't supply from, this action\\n * will use the default sender settings from your configuration.\\n */\\nset-value:x:@.arguments/*/content\\n   strings.html-encode:x:@.arguments/*/content\\nset-value:x:@.arguments/*/name\\n   strings.html-encode:x:@.arguments/*/name\\nset-value:x:@.arguments/*/email\\n   strings.html-encode:x:@.arguments/*/email\\nexecute:magic.workflows.actions.execute\\n   name:email\\n   filename:/misc/workflows/actions/misc/email.hl\\n   arguments\\n      name:Team AINIRO\\n      email:team@ainiro.io\\n      html:bool:false\\n      reply-to:x:@.arguments/*/name\\n      reply-to-email:x:@.arguments/*/email\\n      subject:Contact request from website\\n      body:x:@.arguments/*/content\\n\\n// Making sure we catch exceptions in case contact already exists in HubSpot.\\ntry\\n\\n   // Pushing contact to HubSpot.\\n   execute-file:/modules/hubspot/contacts.post.hl\\n      email:x:@.arguments/*/email\\n      firstname:x:@.arguments/*/name\\n\\n   // Pushing contact to HubSpot.\\n   execute-file:/modules/hubspot/note.post.hl\\n      id:x:@execute-file/@execute-file/*/id\\n      note:x:@.arguments/*/content\\n.catch\\n   log.error:x:@.arguments/*/message\\n\\n// Returning success to caller.\\nreturn\\n   result:success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns Stripe customers.\\n\\n[limit] and [starting_after] are optional arguments and [limit] is the number of customers\\nto return, while [starting_after] is from which record to start returning charges.\\n\\n[email] is an optional case sensitive filter that emails must match."},{"role":"assistant","content":".arguments\\n   limit:int\\n   starting_after:string\\n   email:string\\n\\n/*\\n * Ensures user is authorized to access endpoint.\\n * \\n * If you don't supply a list of [roles] this action only verifies the user is authenticated,\\n * and does not care about what roles the user belongs to.\\n */\\nexecute:magic.workflows.actions.execute\\n   name:authorize\\n   filename:/misc/workflows/actions/security/authorize.hl\\n   arguments\\n      roles\\n         .:root\\n         .:gpt\\n\\n/*\\n * Retrieves charges from Stripe.\\n * \\n * Will use your Stripe API token found from your settings as it's interacting\\n * with the Stripe API.\\n */\\nexecute:magic.workflows.actions.execute\\n   name:stripe-customers-get\\n   filename:/modules/stripe/workflows/actions/stripe-customers-get.hl\\n   arguments\\n      limit:x:@.arguments/*/limit\\n      email:x:@.arguments/*/email\\n      starting_after:x:@.arguments/*/starting_after\\n\\n// Returns the result of your last action.\\nreturn-nodes:x:@execute/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Scrapes the specified URL, and creates an image prompt from the content on the URL,\\nthat creates a high quality image encapsulating the content of the link and returns a\\nlink to the generated image."},{"role":"assistant","content":".arguments\\n   url:string\\n\\n/*\\n * Ensures user is authorized to access endpoint.\\n * \\n * If you don't supply a list of [roles] this action only verifies the user is authenticated,\\n * and does not care about what roles the user belongs to.\\n */\\nexecute:magic.workflows.actions.execute\\n   name:authorize\\n   filename:/misc/workflows/actions/security/authorize.hl\\n   arguments\\n      roles\\n         .:root\\n         .:gpt\\n\\n// Returns [max_tokens] context from the specified [url].\\nexecute:magic.workflows.actions.execute\\n   name:openai-context-from-url\\n   filename:/modules/openai/workflows/actions/openai-context-from-url.hl\\n   arguments\\n      url:x:@.arguments/*/url\\n      max_tokens:int:4000\\n\\n/*\\n * Invokes OpenAI's chat API with the specified [model], [max_tokens], [context],\\n * [instruction] and [query].\\n * \\n * Will use the default API key found from configurations.\\n * \\n * [context] is additional data you can supply to OpenAI such that it responds using\\n * your data as its source for information. [instruction] is a system message allowing\\n * you to change how OpenAI responds.\\n */\\nexecute:magic.workflows.actions.execute\\n   name:openai-query\\n   filename:/modules/openai/workflows/actions/openai-query.hl\\n   arguments\\n      model:gpt-4-1106-preview\\n      max_tokens:int:1500\\n      context:x:--/execute/=openai-context-from-url/*/context\\n      query:Create an image prompt from the information in the context that creates a high quality natural image for an article about the subject. DO NOT add text or infographics to the resulting image. Return ONLY the prompt required to create the image. Do not return explanations.\\n\\n/*\\n * Invokes OpenAI's image generation API with the specified [query] and [model].\\n * \\n * Will use the default API key found from configurations.\\n */\\nexecute:magic.workflows.actions.execute\\n   name:openai-image\\n   filename:/modules/openai/workflows/actions/openai-image.hl\\n   arguments\\n      model:dall-e-3\\n      size:1792x1024\\n      style:vivid\\n      query:x:--/execute/=openai-query/*/answer\\n\\n// Returns the result of your last action.\\nreturn-nodes:x:@execute/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns a payment link."},{"role":"assistant","content":".arguments\\n   plan:string\\n\\n/*\\n * Ensures the specified [arg] was given.\\n * \\n * This action will throw an exception with a descriptive text explaining if the argument is missing.\\n */\\nexecute:magic.workflows.actions.execute\\n   name:validators-enum\\n   filename:/misc/workflows/actions/security/validators-enum.hl\\n   arguments\\n      values\\n         .:professional\\n         .:enterprise\\n      value:x:@.arguments/*/plan\\n\\n/*\\n * Ensures user is authorized to access endpoint.\\n * \\n * If you don't supply a list of [roles] this action only verifies the user is authenticated,\\n * and does not care about what roles the user belongs to.\\n */\\nexecute:magic.workflows.actions.execute\\n   name:authorize\\n   filename:/misc/workflows/actions/security/authorize.hl\\n   arguments\\n      roles\\n         .:root\\n         .:gpt\\n\\n// Returns a single plan\\nexecute:magic.workflows.actions.execute\\n   name:hub-plan-get\\n   filename:/modules/hub/workflows/actions/hub-plan-get.hl\\n   arguments\\n      plan:x:@.arguments/*/plan\\n\\n/*\\n * Creates a Stripe payment link from the specified [price_reference], being\\n * a Stripe payment ID, for [quantity] amount of items, returning the user to\\n * [success_url] after payment has been successfully finished.\\n * \\n * Will use your Stripe API token found from your settings as it's interacting\\n * with the Stripe API.\\n */\\nexecute:magic.workflows.actions.execute\\n   name:stripe-payment-link-create\\n   filename:/modules/stripe/workflows/actions/stripe-payment-link-create.hl\\n   arguments\\n      price_reference:x:--/execute/=hub-plan-get/*/price_reference\\n      quantity:int:1\\n      success_url:\"https://ainiro.io\"\\n\\n// Returns the result of your last action.\\nreturn-nodes:x:@execute/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns all plans that exists"},{"role":"assistant","content":"\\n/*\\n * Ensures user is authorized to access endpoint.\\n * \\n * If you don't supply a list of [roles] this action only verifies the user is authenticated,\\n * and does not care about what roles the user belongs to.\\n */\\nexecute:magic.workflows.actions.execute\\n   name:authorize\\n   filename:/misc/workflows/actions/security/authorize.hl\\n   arguments\\n      roles\\n         .:root\\n         .:gpt\\n\\n// Returns all plans in the system.\\nexecute:magic.workflows.actions.execute\\n   name:hub-plans-get\\n   filename:/modules/hub/workflows/actions/hub-plans-get.hl\\n   arguments\\n\\n// Returns the result of your last action.\\nreturn-nodes:x:@execute/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Sends an email with the specified [subject] and [body] to the specified [name] and [email]\\n\\nWill use the default HTML template transforming [body] from Markdown to HTML"},{"role":"assistant","content":".arguments\\n   name:string\\n   email:string\\n   subject:string\\n   body:string\\n\\n/*\\n * Ensures the specified [arg] was given.\\n * \\n * This action will throw an exception with a descriptive text explaining if the argument is missing.\\n */\\nexecute:magic.workflows.actions.execute\\n   name:validators-mandatory\\n   filename:/misc/workflows/actions/security/validators-mandatory.hl\\n   arguments\\n      arg:x:@.arguments/*/name\\n\\n/*\\n * Ensures the specified [arg] was given.\\n * \\n * This action will throw an exception with a descriptive text explaining if the argument is missing.\\n */\\nexecute:magic.workflows.actions.execute\\n   name:validators-mandatory\\n   filename:/misc/workflows/actions/security/validators-mandatory.hl\\n   arguments\\n      arg:x:@.arguments/*/email\\n\\n/*\\n * Ensures the specified [arg] was given.\\n * \\n * This action will throw an exception with a descriptive text explaining if the argument is missing.\\n */\\nexecute:magic.workflows.actions.execute\\n   name:validators-mandatory\\n   filename:/misc/workflows/actions/security/validators-mandatory.hl\\n   arguments\\n      arg:x:@.arguments/*/subject\\n\\n/*\\n * Ensures the specified [arg] was given.\\n * \\n * This action will throw an exception with a descriptive text explaining if the argument is missing.\\n */\\nexecute:magic.workflows.actions.execute\\n   name:validators-mandatory\\n   filename:/misc/workflows/actions/security/validators-mandatory.hl\\n   arguments\\n      arg:x:@.arguments/*/body\\n\\n/*\\n * Ensures user is authorized to access endpoint.\\n * \\n * If you don't supply a list of [roles] this action only verifies the user is authenticated,\\n * and does not care about what roles the user belongs to.\\n */\\nexecute:magic.workflows.actions.execute\\n   name:authorize\\n   filename:/misc/workflows/actions/security/authorize.hl\\n   arguments\\n      roles\\n         .:root\\n         .:gpt\\n\\n// Transforms the specified [markdown] to HTML and returns to caller.\\nexecute:magic.workflows.actions.execute\\n   name:markdown2html\\n   filename:/misc/workflows/actions/misc/markdown2html.hl\\n   arguments\\n      markdown:x:@.arguments/*/body\\n\\n// Loads the specified [file] and returns to caller as [content].\\nexecute:magic.workflows.actions.execute\\n   name:file-load\\n   filename:/misc/workflows/actions/file/file-load.hl\\n   arguments\\n      file:/modules/hub/magic.startup/templates/generic.html\\n\\n/*\\n * Replaces the specified [source] string's [what] occurencies with [with].\\n * \\n * Returns the result as [result].\\n */\\nexecute:magic.workflows.actions.execute\\n   name:strings-replace\\n   filename:/misc/workflows/actions/strings/strings-replace.hl\\n   arguments\\n      source:x:--/execute/=file-load/*/content\\n      what:{{content}}\\n      with:x:--/execute/=markdown2html/*/html\\n\\n/*\\n * Sends an email to the specified [name]/[email] recipient, with the specified [subject] and [body].\\n * \\n * Optionally supply [from] and [from-email] as name/email sender. If you don't supply from, this action\\n * will use the default sender settings from your configuration.\\n */\\nexecute:magic.workflows.actions.execute\\n   name:email\\n   filename:/misc/workflows/actions/misc/email.hl\\n   arguments\\n      name:x:@.arguments/*/name\\n      email:x:@.arguments/*/email\\n      subject:x:@.arguments/*/subject\\n      body:x:--/execute/=strings-replace/*/result\\n      html:bool:true\\n\\n// Returning success to caller.\\nreturn\\n   result:success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Sends a payment link to the specified email address"},{"role":"assistant","content":".arguments\\n   plan:string\\n   name:string\\n   email:string\\n\\n/*\\n * Ensures the specified [arg] was given.\\n * \\n * This action will throw an exception with a descriptive text explaining if the argument is missing.\\n */\\nexecute:magic.workflows.actions.execute\\n   name:validators-enum\\n   filename:/misc/workflows/actions/security/validators-enum.hl\\n   arguments\\n      values\\n         .:professional\\n         .:enterprise\\n      value:x:@.arguments/*/plan\\n\\n/*\\n * Ensures user is authorized to access endpoint.\\n * \\n * If you don't supply a list of [roles] this action only verifies the user is authenticated,\\n * and does not care about what roles the user belongs to.\\n */\\nexecute:magic.workflows.actions.execute\\n   name:authorize\\n   filename:/misc/workflows/actions/security/authorize.hl\\n   arguments\\n      roles\\n         .:root\\n         .:gpt\\n\\n// Returns a single plan\\nexecute:magic.workflows.actions.execute\\n   name:hub-plan-get\\n   filename:/modules/hub/workflows/actions/hub-plan-get.hl\\n   arguments\\n      plan:x:@.arguments/*/plan\\n\\n/*\\n * Creates a Stripe payment link from the specified [price_reference], being\\n * a Stripe payment ID, for [quantity] amount of items, returning the user to\\n * [success_url] after payment has been successfully finished.\\n * \\n * Will use your Stripe API token found from your settings as it's interacting\\n * with the Stripe API.\\n */\\nexecute:magic.workflows.actions.execute\\n   name:stripe-payment-link-create\\n   filename:/modules/stripe/workflows/actions/stripe-payment-link-create.hl\\n   arguments\\n      price_reference:x:--/execute/=hub-plan-get/*/price_reference\\n      quantity:int:1\\n      success_url:\"https://ainiro.io\"\\n\\n// Loads the specified [file] and returns to caller as [content].\\nexecute:magic.workflows.actions.execute\\n   name:file-load\\n   filename:/misc/workflows/actions/file/file-load.hl\\n   arguments\\n      file:/modules/hub/magic.startup/templates/payment-link.html\\n\\n/*\\n * Replaces the specified [source] string's [what] occurencies with [with].\\n * \\n * Returns the result as [result].\\n */\\nexecute:magic.workflows.actions.execute\\n   name:strings-replace-1\\n   filename:/misc/workflows/actions/strings/strings-replace.hl\\n   arguments\\n      source:x:--/execute/=file-load/*/content\\n      what:{{name}}\\n      with:x:@.arguments/*/name\\n\\n/*\\n * Replaces the specified [source] string's [what] occurencies with [with].\\n * \\n * Returns the result as [result].\\n */\\nexecute:magic.workflows.actions.execute\\n   name:strings-replace-2\\n   filename:/misc/workflows/actions/strings/strings-replace.hl\\n   arguments\\n      source:x:--/execute/=strings-replace-1/*/result\\n      what:{{url}}\\n      with:x:--/execute/=stripe-payment-link-create/*/purchase_link\\n\\n/*\\n * Sends an email to the specified [name]/[email] recipient, with the specified [subject] and [body].\\n * \\n * Optionally supply [from] and [from-email] as name/email sender. If you don't supply from, this action\\n * will use the default sender settings from your configuration.\\n */\\nexecute:magic.workflows.actions.execute\\n   name:email\\n   filename:/misc/workflows/actions/misc/email.hl\\n   arguments\\n      name:x:--/execute/=hub-plan-get/*/name\\n      email:x:@.arguments/*/email\\n      html:bool:true\\n      subject:Your AINIRO.IO Payment link\\n      body:x:--/execute/=strings-replace-2/*/result\\n\\n// Returning success to caller.\\nreturn\\n   result:success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Sends a payment link to the specified email address"},{"role":"assistant","content":".arguments\\n   size:string\\n   name:string\\n   email:string\\n\\n/*\\n * Ensures the specified [arg] was given.\\n * \\n * This action will throw an exception with a descriptive text explaining if the argument is missing.\\n */\\nexecute:magic.workflows.actions.execute\\n   name:validators-enum\\n   filename:/misc/workflows/actions/security/validators-enum.hl\\n   arguments\\n      values\\n         .:small\\n         .:large\\n      value:x:@.arguments/*/size\\n\\n/*\\n * Ensures user is authorized to access endpoint.\\n * \\n * If you don't supply a list of [roles] this action only verifies the user is authenticated,\\n * and does not care about what roles the user belongs to.\\n */\\nexecute:magic.workflows.actions.execute\\n   name:authorize\\n   filename:/misc/workflows/actions/security/authorize.hl\\n   arguments\\n      roles\\n         .:root\\n         .:gpt\\n\\n// Returns a single plan\\nexecute:magic.workflows.actions.execute\\n   name:hub-setup_price-get\\n   filename:/modules/hub/workflows/actions/hub-setup_price-get.hl\\n   arguments\\n      size:x:@.arguments/*/size\\n\\n/*\\n * Creates a Stripe payment link from the specified [price_reference], being\\n * a Stripe payment ID, for [quantity] amount of items, returning the user to\\n * [success_url] after payment has been successfully finished.\\n * \\n * Will use your Stripe API token found from your settings as it's interacting\\n * with the Stripe API.\\n */\\nexecute:magic.workflows.actions.execute\\n   name:stripe-payment-link-create\\n   filename:/modules/stripe/workflows/actions/stripe-payment-link-create.hl\\n   arguments\\n      price_reference:x:--/execute/=hub-setup_price-get/*/price_reference\\n      quantity:int:1\\n      success_url:\"https://ainiro.io\"\\n\\n// Loads the specified [file] and returns to caller as [content].\\nexecute:magic.workflows.actions.execute\\n   name:file-load\\n   filename:/misc/workflows/actions/file/file-load.hl\\n   arguments\\n      file:/modules/hub/magic.startup/templates/payment-link.html\\n\\n/*\\n * Replaces the specified [source] string's [what] occurencies with [with].\\n * \\n * Returns the result as [result].\\n */\\nexecute:magic.workflows.actions.execute\\n   name:strings-replace-1\\n   filename:/misc/workflows/actions/strings/strings-replace.hl\\n   arguments\\n      source:x:--/execute/=file-load/*/content\\n      what:{{name}}\\n      with:x:@.arguments/*/name\\n\\n/*\\n * Replaces the specified [source] string's [what] occurencies with [with].\\n * \\n * Returns the result as [result].\\n */\\nexecute:magic.workflows.actions.execute\\n   name:strings-replace-2\\n   filename:/misc/workflows/actions/strings/strings-replace.hl\\n   arguments\\n      source:x:--/execute/=strings-replace-1/*/result\\n      what:{{url}}\\n      with:x:--/execute/=stripe-payment-link-create/*/purchase_link\\n\\n/*\\n * Sends an email to the specified [name]/[email] recipient, with the specified [subject] and [body].\\n * \\n * Optionally supply [from] and [from-email] as name/email sender. If you don't supply from, this action\\n * will use the default sender settings from your configuration.\\n */\\nexecute:magic.workflows.actions.execute\\n   name:email\\n   filename:/misc/workflows/actions/misc/email.hl\\n   arguments\\n      name:x:@.arguments/*/name\\n      email:x:@.arguments/*/email\\n      html:bool:true\\n      subject:Your AINIRO.IO Setup Payment link\\n      body:x:--/execute/=strings-replace-2/*/result\\n\\n// Returning success to caller.\\nreturn\\n   result:success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Adds additional extra fields to be associated with the user after registration."},{"role":"assistant","content":".arguments\\n   username:string\\n   recaptcha_response:string\\n.type:custom\\n\\n// Sanity checking invocation\\nvalidators.mandatory:x:@.arguments/*/username\\n\\n/*\\n * Checking if backend is configured to use reCAPTCHA, and if so,\\n * making sure we ensure the frontend supplied a [recaptcha_response],\\n * and invoking slot responsible for verifying reCAPTCHA value.\\n */\\nconfig.get:\"magic:auth:recaptcha:key\"\\nif\\n   and\\n      neq:x:@config.get\\n         .\\n      neq:x:@config.get\\n         .:\\n   .lambda\\n\\n      // [recaptcha_response] is a mandatory field.\\n      validators.mandatory:x:@.arguments/*/recaptcha_response\\n\\n      // Retrieving secret and invoking slot responsible for verifying reCAPTCHA value.\\n      config.get:\"magic:auth:recaptcha:secret\"\\n      validators.recaptcha:x:@.arguments/*/recaptcha_response\\n         min:decimal:0.3\\n         site-key:x:@config.get/@config.get\\n         secret:x:@config.get\\n\\n// Opening up database connection\\ndata.connect:[generic|magic]\\n\\n   // Retrieving IP address of user\\n   .ip\\n   set-value:x:-\\n      get-first-value\\n         request.headers.get:cf-connecting-ip\\n         request.ip\\n\\n   /*\\n    * Verifying user is still unconfirmed for security reasons,\\n    * to prevent malicious users from changing countries of users\\n    * already having invoked endpoint, and/or retrieve usernames in\\n    * the system.\\n    */\\n   data.read\\n      table:users_roles\\n      values\\n         role\\n      where\\n         and\\n            user.eq:x:@.arguments/*/username\\n            role.eq:unconfirmed\\n   if\\n      not\\n         exists:x:@data.read/*/*\\n      .lambda\\n\\n         // Oops, malicious invocation!\\n         log.error:User attempted to initialise his or her IP address twice\\n            username:x:@.arguments/*/username\\n            ip:x:@.ip\\n\\n         // To avoid giving the malicious user hints to whether or not user exists, we return 404.\\n         throw:No such user\\n            public:true\\n            status:404\\n\\n   // Checking if we've got an IP API key.\\n   .ip-api-key\\n   set-value:x:-\\n      config.get:\"magic:ipapi-key\"\\n\\n   // Decorating and invoking IP API.\\n   .url\\n   set-value:x:-\\n      strings.concat\\n         .:\"https://ipapi.co/\"\\n         get-value:x:@.ip\\n         .:/json/\\n   if\\n      not-null:x:@.ip-api-key\\n      .lambda\\n         set-value:x:@.url\\n            strings.concat\\n               get-value:x:@.url\\n               .:?key=\\n               config.get:\"magic:ipapi-key\"\\n   http.get:x:@.url\\n      convert:true\\n\\n   // Inserting user's IP address used during registration into extra-fields.\\n   data.create\\n      table:users_extra\\n      values\\n         user:x:@.arguments/*/username\\n         type:registration-ip-address\\n         value:x:@.ip\\n\\n   // Associating fields with user as extra info\\n   .fields\\n      .:country\\n      .:postal\\n      .:country_calling_code\\n   for-each:x:@.fields/*\\n\\n      // Checking if IP API returned the specified value for the currently iterated field.\\n      if\\n         and\\n            exists:x:\"@http.get/*/content/*/\\\"{@.dp/#}\\\"\"\\n            neq:x:\"@http.get/*/content/*/\\\"{@.dp/#}\\\"\"\\n               .\\n            neq:x:\"@http.get/*/content/*/\\\"{@.dp/#}\\\"\"\\n               .:\\n         .lambda\\n\\n            // Inserting field into database to associate information with user.\\n            data.create\\n               table:users_extra\\n               values\\n                  user:x:@.arguments/*/username\\n                  type:x:@.dp/#\\n                  value:x:\"@http.get/*/content/*/\\\"{@.dp/#}\\\"\"\\n\\n// Returning success to caller.\\nreturn\\n   result:success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns a list of animals to caller."},{"role":"assistant","content":"auth.ticket.verify:guest, root, admin\\nio.file.load:/modules/hub/magic.startup/misc/animals.json\\nreturn:x:-\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Authenticates a user"},{"role":"assistant","content":".arguments\\n   username:string\\n   password:string\\n\\n/*\\n * Authenticates the user with the specified [username] and [password].\\n * \\n * Returns a JWT Bearer token that can be used for consecutive requests authorizing user according\\n * to his or her roles.\\n */\\nexecute:magic.workflows.actions.execute\\n   name:authenticate\\n   filename:/modules/registration/workflows/actions/authenticate.hl\\n   arguments\\n      username:x:@.arguments/*/username\\n      password:x:@.arguments/*/password\\n\\n/*\\n * Returns all extra fields for the specified [username].\\n * \\n * Notice, will return incomplete values if you want to reference return values in consecutive actions.\\n */\\nexecute:magic.workflows.actions.execute\\n   name:extras-get\\n   filename:/modules/registration/workflows/actions/extras-get.hl\\n   arguments\\n      username:x:@.arguments/*/username\\n\\n// Returning result to caller.\\n\\n/*\\n * Transforms the result of multiple actions/arguments into a new object.\\n * \\n * This is useful if you need a lambda object that's aggregated from the\\n * returned lambda objects from multiple (other) actions.\\n */\\nexecute:magic.workflows.actions.execute\\n   name:transform\\n   filename:/misc/workflows/actions/misc/transform.hl\\n   arguments\\n      params\\n         ticket:x:--/execute/=authenticate/*/ticket\\n         extra:x:--/execute/=extras-get/*\\n\\n// Returns the result of your last action.\\nreturn-nodes:x:@execute/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Deletes a cloudlet belonging to the currently authenticated user"},{"role":"assistant","content":".arguments\\n   name:string\\n   recaptcha_response:string\\n.type:crud-delete\\n\\n// Ensuring user is authorised to invoke endpoint.\\nauth.ticket.verify:root, admin, guest\\n\\n// Sanity checking invocation\\nvalidators.mandatory:x:@.arguments/*/name\\n\\n/*\\n * Checking if backend is configured to use reCAPTCHA, and if so,\\n * making sure we ensure the frontend supplied a [recaptcha_response],\\n * and invoking slot responsible for verifying reCAPTCHA value.\\n */\\nconfig.get:\"magic:auth:recaptcha:key\"\\nif\\n   and\\n      neq:x:@config.get\\n         .\\n      neq:x:@config.get\\n         .:\\n   .lambda\\n\\n      // [recaptcha_response] is a mandatory field.\\n      validators.mandatory:x:@.arguments/*/recaptcha_response\\n\\n      // Retrieving secret and invoking slot responsible for verifying reCAPTCHA value.\\n      config.get:\"magic:auth:recaptcha:secret\"\\n      validators.recaptcha:x:@.arguments/*/recaptcha_response\\n         min:decimal:0.3\\n         site-key:x:@config.get/@config.get\\n         secret:x:@config.get\\n\\n/*\\n * Retrieving currently authenticated user to prevent a user\\n * from deleting cloudlets not belonging to him or her.\\n */\\nauth.ticket.get\\n\\n/*\\n * Notice, we don't allow deleting a cloudlet if other cloudlets are using\\n * it as a \"source_cloudlet\", since this would result in \"hanging bogus cloudlets\"\\n * for the user. Hence, we first need to verify that the cloudlet the user is trying\\n * to delete is NOT the source_cloudlet for other cloudlets.\\n */\\ndata.connect:[generic|hub]\\n   data.read\\n      table:cloudlets\\n      values\\n         name\\n      where\\n         and\\n            user.eq:x:@auth.ticket.get\\n            source_cloudlet.eq:x:@.arguments/*/name\\n   if\\n      exists:x:@data.read/*/*\\n      .lambda\\n\\n         // Oops, child cloudlet(s) needs to be deleted first.\\n         response.status.set:412\\n         for-each:x:@data.read/*/*/name\\n            unwrap:x:+/*/*/*\\n            add:x:././*/return-nodes\\n               .\\n                  .\\n                     name:x:@.dp/#\\n         return-nodes\\n\\n/*\\n * Checking if there exists a subscription for cloudlet,\\n * at which point we forward deletion to stripe module since the Stripe\\n * module will delete the cloudlet automatically through its callback sinks.\\n */\\ndata.connect:[generic|stripe]\\n\\n   // Checking if we can find subscription for cloudlet.\\n   data.read\\n      table:subscriptions\\n      values\\n         subscription\\n      where\\n         and\\n            username.eq:x:@auth.ticket.get\\n            meta.eq:x:@.arguments/*/name\\n\\n   // Checking if subscription exists for cloudlet.\\n   if\\n      exists:x:@data.read/*/*\\n      .lambda\\n\\n         /*\\n          * Deleting subscription information associated with cloudlet.\\n          * Due to the way the Stripe module and HUB is connected, this will invoke\\n          * Stripe callback sink, deleting the cloudlet after the subscriptiuon is deleted.\\n          */\\n         unwrap:x:+/*\\n         io.file.execute:/modules/stripe/subscriptions.delete.hl\\n            subscription:x:@data.read/*/*/subscription\\n\\n         // Returning success to caller\\n         return\\n            affected:int:1\\n            subscriptions_deleted:int:1\\n   else\\n\\n      // No Stripe subscription associated with cloudlet, hence manually deleting it.\\n      data.connect:[generic|hub]\\n\\n         // Verifying cloudlet exists and belongs to currently authenticated user.\\n         data.read\\n            table:cloudlets\\n            values\\n               name\\n               cluster\\n            where\\n               and\\n                  user.eq:x:@auth.ticket.get\\n                  name.eq:x:@.arguments/*/name\\n         if\\n            not\\n               exists:x:@data.read/*/*\\n            .lambda\\n\\n               // Oops, cloudlet doesn't exists or does not belong to authenticated user.\\n               log.error:User tried to delete non-existent cloudlet\\n                  user:x:@auth.ticket.get\\n                  cloudlet:x:@.arguments/*/name\\n               throw:Cloudlet does not exist\\n                  public:true\\n                  status:404\\n\\n         // Invoking slot responsible for deleting cloudlet.\\n         .name\\n         set-value:x:@.name\\n            strings.concat\\n               get-value:x:@.arguments/*/name\\n               .:-\\n               get-value:x:@auth.ticket.get\\n         unwrap:x:+/*\\n         signal:hub.cloudlets.hard-delete\\n            cluster:x:@data.read/*/*/cluster\\n            name:x:@.name\\n\\n         /*\\n          * Checking if there exists scheduled tasks associated with the cloudlet,\\n          * and if so deleting all tasks associated with cloudlet.\\n          */\\n         strings.concat\\n            .:cloudlet-\\n            get-value:x:@.name\\n            .:-%\\n         tasks.list:x:@strings.concat\\n            limit:1000\\n         for-each:x:@tasks.list/*\\n            tasks.delete:x:@.dp/#/*/id\\n\\n         // Doing some basic logging.\\n         get-count:x:@tasks.list/*\\n         log.debug:Tasks associated with cloudlet has been deleted\\n            name:x:@.arguments/*/name\\n            user:x:@auth.ticket.get\\n            no_tasks:x:@get-count\\n\\n         // Deleting item from database.\\n         data.delete\\n            table:cloudlets\\n            where\\n               and\\n                  name.eq:x:@.arguments/*/name\\n                  user.eq:x:@auth.ticket.get\\n\\n         // Doing some basic logging\\n         log.info:Cloudlet successfully destroyed\\n            name:x:@.arguments/*/name\\n            user:x:@auth.ticket.get\\n\\n         // Returning result of above invocation to caller.\\n         unwrap:x:+/*\\n         return\\n            affected:x:@data.delete\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns all clusters in system."},{"role":"assistant","content":".type:crud-read\\n\\n// Adding 30 seconds of public caching to avoid DOS attacks from exhausting server.\\nresponse.headers.set\\n   Cache-Control:public, max-age=30\\n\\n// Opening up our database connection.\\ndata.connect:[generic|hub]\\n\\n   // Reading data from database.\\n   data.read\\n      table:clusters\\n      columns\\n         id\\n         country\\n         name\\n      where\\n         and\\n            enabled.eq:bool:true\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Deletes the user's account entirely on server."},{"role":"assistant","content":".arguments\\n\\n// Ensuring user is authenticated to invoke endpoint.\\nauth.ticket.verify:guest\\n\\n// Retrieving currently authenticated user.\\nauth.ticket.get\\n\\n// Verifying user doesn't have any cloudlets.\\ndata.connect:[generic|hub]\\n   data.read\\n      table:cloudlets\\n      where\\n         and\\n            user.eq:x:@auth.ticket.get\\n   if\\n      exists:x:@data.read/*/*\\n      .lambda\\n         throw:You have to delete all cloudlets before you delete your account\\n            public:true\\n            status:400\\n\\n// Deleting user from magic database.\\ndata.connect:[generic|magic]\\n   data.delete\\n      table:users\\n      where\\n         and\\n            username.eq:x:@auth.ticket.get\\n\\n// Returning success to caller.\\nreturn\\n   result:success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns the specified release ZIP file to caller."},{"role":"assistant","content":"validators.mandatory:x:@.arguments/*/release\\n.file\\nset-value:x:-\\n   strings.concat\\n      .:/etc/releases/\\n      get-value:x:@.arguments/*/release\\nresponse.headers.set\\n   Content-Type:application/octet-stream\\n   Content-Disposition:\"form-data; filename=\\\"release.zip\\\"\"\\nio.stream.open-file:x:@.file\\nreturn:x:-\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns a token that's needed to create a valid payment link,\\nallowing another user to impersonate the currently authenticated user."},{"role":"assistant","content":".arguments\\n\\n// Ensuring user is authorised to invoke endpoint.\\nauth.ticket.verify:root, guest\\n\\n// Retrieving currently authenticated user's username.\\nauth.ticket.get\\n\\n// Creates an impersonation JWT ticket that does not expire before 12 months from now.\\nmath.add\\n   date.now\\n   time\\n      days:365\\nauth.ticket.create\\n   username:x:@auth.ticket.get\\n   expires:x:@math.add\\n   roles\\n      .:impersonated\\n\\n// Returns ticket to caller.\\nunwrap:x:+/*\\nreturn\\n   ticket:x:@auth.ticket.create\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns all types of cloudlets in system."},{"role":"assistant","content":".type:crud-read\\n\\n// Opening up our database connection.\\ndata.connect:[generic|hub]\\n\\n   // Reading data from database.\\n   data.read\\n      table:plans\\n      columns\\n         name\\n         description\\n         cpu\\n         memory\\n         storage\\n         max_timeout\\n         max_upload\\n         price\\n         price_reference\\n         yearly_price\\n         yearly_price_reference\\n         frontend\\n         bandwidth\\n      where\\n         and\\n            enabled.eq:bool:true\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Resizes the specified image."},{"role":"assistant","content":"if\\n   not\\n      strings.starts-with:x:@.arguments/*/img\\n         .:/assets/images/\\n   .lambda\\n      throw:Not an image\\n\\n// Figuring out path of image.\\n.path\\nset-value:x:@.path\\n   strings.concat\\n      .:/etc/www\\n      get-value:x:@.arguments/*/img\\n\\n// Returning correct MIME type.\\nresponse.headers.set\\n   Content-Type:image/webp\\n   Cache-Control:public, max-age=31536000\\n\\n// Checking if image is cached on disc.\\n.cache-file-name\\nlambda2hyper:x:@.arguments\\ncrypto.hash.sha1:x:@lambda2hyper\\nset-value:x:@.cache-file-name\\n   strings.concat\\n      .:/etc/hub/image-cache/\\n      get-value:x:@crypto.hash.sha1\\nif\\n   io.file.exists:x:@.cache-file-name\\n   .lambda\\n      io.stream.open-file:x:@.cache-file-name\\n      return:x:-\\n\\n// Checking if user did not provide any [width] or [height] arguments, at which point we simply convert it to webp.\\nif\\n   and\\n      not-exists:x:@.arguments/*/width\\n      not-exists:x:@.arguments/*/height\\n   .lambda\\n      add:x:+\\n         get-nodes:x:@.arguments/*/type\\n      image.convert:x:@.path\\n      return:x:-\\n\\n// Loading image\\nadd:x:./*/image.resize\\n   get-nodes:x:@.arguments/*/width\\n   get-nodes:x:@.arguments/*/height\\n   get-nodes:x:@.arguments/*/type\\nimage.resize:x:@.path\\nio.stream.save-file:x:@.cache-file-name\\n   get-value:x:@image.resize\\nio.stream.open-file:x:@.cache-file-name\\nreturn:x:-\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Template for HTTP GET CRUD requests.\\nThis file was automatically generated using Magic's CRUDifier."},{"role":"assistant","content":".arguments\\n   operator:string\\n   cloudlets.id.eq:long\\n   cloudlets.created.eq:date\\n   cloudlets.name.like:string\\n   cloudlets.name.eq:string\\n   cloudlets.plan.like:string\\n   cloudlets.plan.eq:string\\n   cloudlets.cluster.like:string\\n   cloudlets.cluster.eq:string\\n   cloudlets.user.like:string\\n   cloudlets.user.eq:string\\n.type:crud-count\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Sanity checking invocation.\\nvalidators.enum:x:@.arguments/*/operator\\n   .:or\\n   .:and\\n\\n/*\\n * Checking if user supplied an [operator] argument, and if so\\n * changing the boolean operator for comparison operations.\\n */\\nif\\n   exists:x:@.arguments/*/operator\\n   .lambda\\n\\n      // User provided a boolean comparison [operator] argument.\\n      set-name:x:../*/data.connect/*/data.read/*/where/*\\n         get-value:x:@.arguments/*/operator\\n\\n// Opening up our database connection.\\ndata.connect:[generic|hub]\\n\\n   // Parametrising our read invocation.\\n   add:x:./*/data.read\\n      get-nodes:x:@.arguments/*/operator\\n   remove-nodes:x:@.arguments/*/operator\\n   add:x:+/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      table:cloudlets\\n      columns\\n         count(*)\\n            as:count\\n      where\\n         and\\n      limit:long:1\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Template for HTTP GET CRUD requests.\\nThis file was automatically generated using Magic's CRUDifier."},{"role":"assistant","content":".arguments\\n   limit:long\\n   offset:long\\n   order:string\\n   direction:string\\n   operator:string\\n   cloudlets.id.eq:long\\n   cloudlets.created.eq:date\\n   cloudlets.name.like:string\\n   cloudlets.name.eq:string\\n   cloudlets.plan.like:string\\n   cloudlets.plan.eq:string\\n   cloudlets.cluster.like:string\\n   cloudlets.cluster.eq:string\\n   cloudlets.user.like:string\\n   cloudlets.user.eq:string\\n.type:crud-read\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Sanity checking invocation.\\nvalidators.enum:x:@.arguments/*/operator\\n   .:or\\n   .:and\\n\\n/*\\n * Checking if user supplied an [operator] argument, and if so\\n * changing the boolean operator for comparison operations.\\n */\\nif\\n   exists:x:@.arguments/*/operator\\n   .lambda\\n\\n      // User provided a boolean comparison [operator] argument.\\n      set-name:x:../*/data.connect/*/data.read/*/where/*\\n         get-value:x:@.arguments/*/operator\\n\\n// Opening up our database connection.\\ndata.connect:[generic|hub]\\n\\n   // Parametrising our read invocation.\\n   add:x:./*/data.read\\n      get-nodes:x:@.arguments/*/limit\\n      get-nodes:x:@.arguments/*/offset\\n      get-nodes:x:@.arguments/*/order\\n      get-nodes:x:@.arguments/*/direction\\n   remove-nodes:x:@.arguments/*/operator\\n   remove-nodes:x:@.arguments/*/limit\\n   remove-nodes:x:@.arguments/*/offset\\n   remove-nodes:x:@.arguments/*/order\\n   remove-nodes:x:@.arguments/*/direction\\n   add:x:./*/data.read/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      table:cloudlets\\n      columns\\n         cloudlets.id\\n         cloudlets.created\\n         cloudlets.name\\n         cloudlets.plan\\n         cloudlets.cluster\\n         cloudlets.user\\n      where\\n         and\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Template for HTTP POST CRUD requests.\\nThis file was automatically generated using Magic's CRUDifier."},{"role":"assistant","content":".arguments\\n   created:date\\n   name:string\\n   plan:string\\n   cluster:string\\n   user:string\\n.type:crud-create\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root\\n.foreign-keys\\n   .\\n      column:plan\\n      table:plans\\n      foreign_column:name\\n      foreign_name:name\\n      long:bool:false\\n   .\\n      column:cluster\\n      table:clusters\\n      foreign_column:id\\n      foreign_name:id\\n      long:bool:false\\n\\n// Opening up database connection.\\ndata.connect:[generic|hub]\\n\\n   // Parametrising our create invocation.\\n   add:x:./*/data.create/*/values\\n      get-nodes:x:@.arguments/*\\n\\n   // Creating our record.\\n   data.create\\n      table:cloudlets\\n      return-id:bool:true\\n      values\\n\\n   // Returning result of above invoction to caller.\\n   response.status.set:201\\n   unwrap:x:+/*\\n   return\\n      id:x:@data.create\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Template for HTTP PUT CRUD requests.\\nThis file was automatically generated using Magic's CRUDifier."},{"role":"assistant","content":".arguments\\n   id:long\\n   name:string\\n   plan:string\\n   cluster:string\\n   user:string\\n.type:crud-update\\n\\n// Verifying user is authorized to access endpoint.\\nvalidators.mandatory:x:@.arguments/*/id\\nauth.ticket.verify:root\\n.foreign-keys\\n   .\\n      column:plan\\n      table:plans\\n      foreign_column:name\\n      foreign_name:name\\n      long:bool:false\\n   .\\n      column:cluster\\n      table:clusters\\n      foreign_column:id\\n      foreign_name:id\\n      long:bool:false\\n\\n// Opening up our database connection.\\ndata.connect:[generic|hub]\\n   add:x:./*/data.update/*/where/*/and\\n      get-nodes:x:@.arguments/*/[0,1]\\n   add:x:./*/data.update/*/values\\n      get-nodes:x:@.arguments/*/[1,1000]\\n\\n   // Invoking our update slot.\\n   data.update\\n      table:cloudlets\\n      values\\n      where\\n         and\\n\\n   // Verifying record exists.\\n   if\\n      eq\\n         get-value:x:@data.update\\n         .:int:0\\n      .lambda\\n         response.status.set:404\\n         return\\n            result:Record not found\\n\\n   // Returning success to caller.\\n   response.status.set:202\\n   unwrap:x:+/*\\n   return\\n      affected:x:@data.update\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Template for HTTP GET CRUD requests.\\nThis file was automatically generated using Magic's CRUDifier."},{"role":"assistant","content":".arguments\\n   operator:string\\n   clusters.id.like:string\\n   clusters.id.eq:string\\n   clusters.country.like:string\\n   clusters.country.eq:string\\n   clusters.name.like:string\\n   clusters.name.eq:string\\n   clusters.enabled.eq:bool\\n.type:crud-count\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Sanity checking invocation.\\nvalidators.enum:x:@.arguments/*/operator\\n   .:or\\n   .:and\\n\\n/*\\n * Checking if user supplied an [operator] argument, and if so\\n * changing the boolean operator for comparison operations.\\n */\\nif\\n   exists:x:@.arguments/*/operator\\n   .lambda\\n\\n      // User provided a boolean comparison [operator] argument.\\n      set-name:x:../*/data.connect/*/data.read/*/where/*\\n         get-value:x:@.arguments/*/operator\\n\\n// Opening up our database connection.\\ndata.connect:[generic|hub]\\n\\n   // Parametrising our read invocation.\\n   add:x:./*/data.read\\n      get-nodes:x:@.arguments/*/operator\\n   remove-nodes:x:@.arguments/*/operator\\n   add:x:+/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      table:clusters\\n      columns\\n         count(*)\\n            as:count\\n      where\\n         and\\n      limit:long:1\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Template for HTTP DELETE CRUD requests.\\nThis file was automatically generated using Magic's CRUDifier."},{"role":"assistant","content":".arguments\\n   id:string\\n.type:crud-delete\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/id\\n\\n// Opening up our database connection.\\ndata.connect:[generic|hub]\\n\\n   // Parametrising our delete invocation.\\n   add:x:./*/data.delete/*/where/*/and\\n      get-nodes:x:@.arguments/*\\n\\n   // Deleting item from database.\\n   data.delete\\n      table:clusters\\n      where\\n         and\\n\\n   // Returning result of above invocation to caller.\\n   unwrap:x:+/*\\n   return\\n      affected:x:@data.delete\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Template for HTTP GET CRUD requests.\\nThis file was automatically generated using Magic's CRUDifier."},{"role":"assistant","content":".arguments\\n   limit:long\\n   offset:long\\n   order:string\\n   direction:string\\n   operator:string\\n   clusters.id.like:string\\n   clusters.id.eq:string\\n   clusters.country.like:string\\n   clusters.country.eq:string\\n   clusters.name.like:string\\n   clusters.name.eq:string\\n   clusters.enabled.eq:bool\\n.type:crud-read\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Sanity checking invocation.\\nvalidators.enum:x:@.arguments/*/operator\\n   .:or\\n   .:and\\n\\n/*\\n * Checking if user supplied an [operator] argument, and if so\\n * changing the boolean operator for comparison operations.\\n */\\nif\\n   exists:x:@.arguments/*/operator\\n   .lambda\\n\\n      // User provided a boolean comparison [operator] argument.\\n      set-name:x:../*/data.connect/*/data.read/*/where/*\\n         get-value:x:@.arguments/*/operator\\n\\n// Opening up our database connection.\\ndata.connect:[generic|hub]\\n\\n   // Parametrising our read invocation.\\n   add:x:./*/data.read\\n      get-nodes:x:@.arguments/*/limit\\n      get-nodes:x:@.arguments/*/offset\\n      get-nodes:x:@.arguments/*/order\\n      get-nodes:x:@.arguments/*/direction\\n   remove-nodes:x:@.arguments/*/operator\\n   remove-nodes:x:@.arguments/*/limit\\n   remove-nodes:x:@.arguments/*/offset\\n   remove-nodes:x:@.arguments/*/order\\n   remove-nodes:x:@.arguments/*/direction\\n   add:x:./*/data.read/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      table:clusters\\n      columns\\n         clusters.id\\n         clusters.country\\n         clusters.name\\n         clusters.enabled\\n      where\\n         and\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Template for HTTP POST CRUD requests.\\nThis file was automatically generated using Magic's CRUDifier."},{"role":"assistant","content":".arguments\\n   id:string\\n   country:string\\n   name:string\\n   enabled:bool\\n.type:crud-create\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/id\\nvalidators.mandatory:x:@.arguments/*/country\\nvalidators.mandatory:x:@.arguments/*/name\\n\\n// Opening up database connection.\\ndata.connect:[generic|hub]\\n\\n   // Parametrising our create invocation.\\n   add:x:./*/data.create/*/values\\n      get-nodes:x:@.arguments/*\\n\\n   // Creating our record.\\n   data.create\\n      table:clusters\\n      return-id:bool:false\\n      values\\n\\n   // Returning result of above invoction to caller.\\n   response.status.set:201\\n   unwrap:x:+/*\\n   return\\n      result:success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Template for HTTP DELETE CRUD requests.\\nThis file was automatically generated using Magic's CRUDifier."},{"role":"assistant","content":".arguments\\n   name:string\\n.type:crud-delete\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/name\\n\\n// Opening up our database connection.\\ndata.connect:[generic|hub]\\n\\n   // Parametrising our delete invocation.\\n   add:x:./*/data.delete/*/where/*/and\\n      get-nodes:x:@.arguments/*\\n\\n   // Deleting item from database.\\n   data.delete\\n      table:plans\\n      where\\n         and\\n\\n   // Returning result of above invocation to caller.\\n   unwrap:x:+/*\\n   return\\n      affected:x:@data.delete\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns all types of cloudlets in system."},{"role":"assistant","content":".arguments\\n.type:crud-read\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Opening up our database connection.\\ndata.connect:[generic|hub]\\n\\n   // Reading data from database.\\n   data.read\\n      table:plans\\n      columns\\n         name\\n         description\\n         cpu\\n         memory\\n         storage\\n         price\\n         enabled\\n         max_upload\\n         max_timeout\\n         price_reference\\n         bandwidth\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Template for HTTP POST CRUD requests.\\nThis file was automatically generated using Magic's CRUDifier."},{"role":"assistant","content":".arguments\\n   name:string\\n   description:string\\n   cpu:decimal\\n   memory:int\\n   storage:int\\n   price:decimal\\n   max_upload:int\\n   max_timeout:int\\n   enabled:bool\\n   price_reference:string\\n   bandwidth:string\\n.type:crud-create\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/name\\nvalidators.mandatory:x:@.arguments/*/description\\nvalidators.mandatory:x:@.arguments/*/cpu\\nvalidators.mandatory:x:@.arguments/*/memory\\nvalidators.mandatory:x:@.arguments/*/storage\\nvalidators.mandatory:x:@.arguments/*/price\\nvalidators.mandatory:x:@.arguments/*/enabled\\n\\n// Opening up database connection.\\ndata.connect:[generic|hub]\\n\\n   // Parametrising our create invocation.\\n   add:x:./*/data.create/*/values\\n      get-nodes:x:@.arguments/*\\n\\n   // Creating our record.\\n   data.create\\n      table:plans\\n      return-id:bool:false\\n      values\\n\\n   // Returning result of above invoction to caller.\\n   response.status.set:201\\n   unwrap:x:+/*\\n   return\\n      result:success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Template for HTTP PUT CRUD requests.\\nThis file was automatically generated using Magic's CRUDifier."},{"role":"assistant","content":".arguments\\n   name:string\\n   description:string\\n   max_upload:int\\n   max_timeout:int\\n   enabled:bool\\n   price_reference:string\\n   bandwidth:string\\n.type:crud-update\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/name\\n\\n// Opening up our database connection.\\ndata.connect:[generic|hub]\\n   add:x:./*/data.update/*/where/*/and\\n      get-nodes:x:@.arguments/*/[0,1]\\n   add:x:./*/data.update/*/values\\n      get-nodes:x:@.arguments/*/[1,1000]\\n\\n   // Invoking our update slot.\\n   data.update\\n      table:plans\\n      values\\n      where\\n         and\\n\\n   // Verifying record exists.\\n   if\\n      eq\\n         get-value:x:@data.update\\n         .:int:0\\n      .lambda\\n         response.status.set:404\\n         return\\n            result:Record not found\\n\\n   // Returning success to caller.\\n   response.status.set:202\\n   unwrap:x:+/*\\n   return\\n      affected:x:@data.update\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Upgrades existing cloudlet to a professional plan without associating a subscription with it."},{"role":"assistant","content":".arguments\\n   id:long\\n   plan:string\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root, admin, account_manager\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/id\\nvalidators.mandatory:x:@.arguments/*/plan\\n\\n// Opening up our database connection.\\ndata.connect:[generic|hub]\\n\\n   // Getting cloudlet information from database\\n   data.read\\n      table:cloudlets\\n      columns\\n         name\\n         user\\n      where\\n         and\\n            id.eq:x:@.arguments/*/id\\n\\n   // Updating database record.\\n   data.update\\n      table:cloudlets\\n      values\\n         plan:x:@.arguments/*/plan\\n      where\\n         and\\n            id.eq:x:@.arguments/*/id\\n\\n   /*\\n    * Removing scheduled tasks that soft deletes cloudlet once trial period\\n    * is over if existing.\\n    */\\n   strings.concat\\n      .:cloudlet-\\n      get-value:x:@data.read/*/*/name\\n      .:-\\n      get-value:x:@data.read/*/*/user\\n      .:-delete\\n   tasks.list:x:-\\n   if\\n      exists:x:@tasks.list/0/*/id\\n      .lambda\\n         tasks.delete:x:@tasks.list/0/*/id\\n         log.info:Task to automatically soft delete cloudlet was deleted\\n            task-name:x:@strings.concat\\n            cloudlet:x:@.cloudlet\\n            username:x:@.arguments/*/username\\n            cluster:x:@.cluster\\n   else\\n      log.error:Could not find task to delete\\n         task-name:x:@strings.concat\\n   strings.concat\\n      .:cloudlet-\\n      get-value:x:@data.read/*/*/name\\n      .:-\\n      get-value:x:@data.read/*/*/user\\n      .:-hard-delete\\n   tasks.list:x:-\\n   if\\n      exists:x:@tasks.list/0/*/id\\n      .lambda\\n         tasks.delete:x:@tasks.list/0/*/id\\n         log.info:Task to automatically hard delete cloudlet was deleted\\n            task-name:x:@strings.concat\\n            cloudlet:x:@.cloudlet\\n            username:x:@.arguments/*/username\\n            cluster:x:@.cluster\\n   else\\n      log.error:Could not find task to delete\\n         task-name:x:@strings.concat\\n   strings.concat\\n      .:cloudlet-\\n      get-value:x:@data.read/*/*/name\\n      .:-\\n      get-value:x:@data.read/*/*/user\\n      .:-warn-about-destruction\\n   tasks.list:x:-\\n   if\\n      exists:x:@tasks.list/0/*/id\\n      .lambda\\n         tasks.delete:x:@tasks.list/0/*/id\\n         log.info:Task to automatically warn user was deleted\\n            task-name:x:@strings.concat\\n            cloudlet:x:@.cloudlet\\n            username:x:@.arguments/*/username\\n            cluster:x:@.cluster\\n   else\\n      log.error:Could not find task to delete\\n         task-name:x:@strings.concat\\n\\n   // Returning success to caller.\\n   response.status.set:202\\n   return\\n      result:success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Deletes the specified cloudlet"},{"role":"assistant","content":".arguments\\n   cloudlet_name\\n      type:string\\n      mandatory:bool:true\\n   username\\n      type:string\\n      mandatory:bool:true\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/cloudlet_name\\nvalidators.mandatory:x:@.arguments/*/username\\n\\n// Figuring out base URL of Kubernetes REST API.\\n.base-url\\nset-value:x:@.base-url\\n   config.get:\"magic:hub:us.ainiro.io:manager-url\"\\n\\n// Figuring out Kubernetes namespace cloudlets exists in.\\n.namespace\\nset-value:x:@.namespace\\n   config.get:\"magic:hub:default-namespace\"\\n\\n// Retrieving token that's required to invoke Kubernetes REST API.\\n.token\\nset-value:x:@.token\\n   strings.concat\\n      .:\"Bearer \"\\n      config.get:\"magic:hub:us.ainiro.io:token\"\\n\\n// Invoking Web API responsible for deleting deployment.\\n.url\\nset-value:x:@.url\\n   strings.concat\\n      get-value:x:@.base-url\\n      .:/apis/apps/v1/namespaces/\\n      get-value:x:@.namespace\\n      .:/deployments/\\n      get-value:x:@.arguments/*/cloudlet_name\\n      .:-\\n      get-value:x:@.arguments/*/username\\nhttp.delete:x:@.url\\n   headers\\n      Authorization:x:@.token\\n\\n// Sanity checking above invocation\\nif\\n   not\\n      and\\n         mte:x:@http.delete\\n            .:int:200\\n         lt:x:@http.delete\\n            .:int:300\\n   .lambda\\n\\n      // Oops, web API didn't return success\\n      log.error:Kubernetes could not delete deployment\\n         status:x:@http.post\\n         response:x:@http.post/*/content\\n         name:x:@.arguments/*/cloudlet_name\\n         username:x:@.arguments/*/username\\nelse\\n\\n   // Logging the fact that we successfully deleted deployment.\\n   log.debug:Kubernetes deployment successfully deleted\\n      name:x:@.arguments/*/cloudlet_name\\n      username:x:@.arguments/*/username\\n\\n// Invoking Web API responsible for deleting service.\\n.url\\nset-value:x:@.url\\n   strings.concat\\n      get-value:x:@.base-url\\n      .:/api/v1/namespaces/\\n      get-value:x:@.namespace\\n      .:/services/\\n      get-value:x:@.arguments/*/cloudlet_name\\n      .:-\\n      get-value:x:@.arguments/*/username\\nhttp.delete:x:@.url\\n   headers\\n      Authorization:x:@.token\\n\\n// Sanity checking above invocation\\nif\\n   not\\n      and\\n         mte:x:@http.delete\\n            .:int:200\\n         lt:x:@http.delete\\n            .:int:300\\n   .lambda\\n\\n      // Oops, web API didn't return success\\n      log.error:Kubernetes could not delete service\\n         status:x:@http.post\\n         response:x:@http.post/*/content\\n         name:x:@.arguments/*/cloudlet_name\\n         username:x:@.arguments/*/username\\nelse\\n\\n   // Logging the fact that we successfully deleted service.\\n   log.debug:Kubernetes service successfully deleted\\n      name:x:@.arguments/*/cloudlet_name\\n      username:x:@.arguments/*/username\\n\\n// Invoking Web API responsible for deleting ingress.\\n.url\\nset-value:x:@.url\\n   strings.concat\\n      get-value:x:@.base-url\\n      .:/apis/networking.k8s.io/v1/namespaces/\\n      get-value:x:@.namespace\\n      .:/ingresses/\\n      get-value:x:@.arguments/*/cloudlet_name\\n      .:-\\n      get-value:x:@.arguments/*/username\\nhttp.delete:x:@.url\\n   headers\\n      Authorization:x:@.token\\n\\n// Sanity checking above invocation\\nif\\n   not\\n      and\\n         mte:x:@http.delete\\n            .:int:200\\n         lt:x:@http.delete\\n            .:int:300\\n   .lambda\\n\\n      // Oops, web API didn't return success\\n      log.error:Kubernetes could not delete ingress\\n         status:x:@http.post\\n         response:x:@http.post/*/content\\n         name:x:@.arguments/*/cloudlet_name\\n         username:x:@.arguments/*/username\\nelse\\n\\n   // Logging the fact that we successfully deleted ingress.\\n   log.debug:Kubernetes ingress successfully deleted\\n      name:x:@.arguments/*/cloudlet_name\\n      username:x:@.arguments/*/username\\n\\n// Invoking Web API responsible for deleting volume claim.\\n.url\\nset-value:x:@.url\\n   strings.concat\\n      get-value:x:@.base-url\\n      .:/api/v1/namespaces/\\n      get-value:x:@.namespace\\n      .:/persistentvolumeclaims/\\n      get-value:x:@.arguments/*/cloudlet_name\\n      .:-\\n      get-value:x:@.arguments/*/username\\nhttp.delete:x:@.url\\n   headers\\n      Authorization:x:@.token\\n\\n// Sanity checking above invocation\\nif\\n   not\\n      and\\n         mte:x:@http.delete\\n            .:int:200\\n         lt:x:@http.delete\\n            .:int:300\\n   .lambda\\n\\n      // Oops, web API didn't return success\\n      log.error:Kubernetes could not delete volume claim\\n         status:x:@http.post\\n         response:x:@http.post/*/content\\n         name:x:@.arguments/*/cloudlet_name\\n         username:x:@.arguments/*/username\\nelse\\n\\n   // Logging the fact that we successfully deleted ingress.\\n   log.debug:Kubernetes volume claim successfully deleted\\n      name:x:@.arguments/*/cloudlet_name\\n      username:x:@.arguments/*/username\\n\\n// Connecting to database.\\ndata.connect:[generic|hub]\\n\\n   // Deleting cloudlet from database.\\n   data.delete\\n      table:cloudlets\\n      where\\n         and\\n            user.eq:x:@.arguments/*/username\\n            name.eq:x:@.arguments/*/cloudlet_name\\n\\n// Deleting scheduled task that deletes cloudlet.\\n.task-name\\nset-value:x:@.task-name\\n   strings.concat\\n      .:cloudlet-\\n      get-value:x:@.arguments/*/cloudlet_name\\n      .:-\\n      get-value:x:@.arguments/*/username\\n      .:-hard-delete\\ntasks.list:x:@.task-name\\nif\\n   exists:x:@tasks.list/*\\n   .lambda\\n\\n      // Deleting scheduled task.\\n      tasks.delete:x:@tasks.list/0/*/id\\n\\n      // Logging the fact that we successfully deleted task.\\n      log.debug:Task that automatically deletes cloudlet was deleted\\n         name:x:@.arguments/*/cloudlet_name\\n         username:x:@.arguments/*/username\\n         task_name:x:@tasks.list/0/*/id\\n\\n// Logging.\\nlog.info:Cloudlet successfully deleted\\n   cloudlet_name:x:@.arguments/*/cloudlet_name\\n   username:x:@.arguments/*/username\\n\\n// Returning success to caller.\\nreturn\\n   result:success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns all cloudlets in the system."},{"role":"assistant","content":".arguments\\n   username\\n      type:string\\n      mandatory:bool:false\\n   name\\n      type:string\\n      mandatory:bool:false\\n   limit\\n      type:int\\n      mandatory:bool:false\\n   offset\\n      type:int\\n      mandatory:bool:false\\n\\n// Applying defaults\\nvalidators.default:x:@.arguments\\n   limit:int:5\\n   offset:int:0\\n\\n// Connecting to database.\\ndata.connect:[generic|hub]\\n\\n   /*\\n    * Checking if caller provided a [username] argument,\\n    * and if so, applying it to [where].\\n    */\\n   if\\n      and\\n         exists:x:@.arguments/*/username\\n         not-null:x:@.arguments/*/username\\n      .lambda\\n\\n         // Adding [user.eq] filter criteria to [data.read].\\n         unwrap:x:+/*/*\\n         add:x:@data.connect/*/data.read/*/where/*/and\\n            .\\n               user.eq:x:@.arguments/*/username\\n\\n   /*\\n    * Checking if caller provided a [name] argument,\\n    * and if so, applying it to [where].\\n    */\\n   if\\n      and\\n         exists:x:@.arguments/*/name\\n         not-null:x:@.arguments/*/name\\n      .lambda\\n\\n         // Adding [user.eq] filter criteria to [data.read].\\n         unwrap:x:+/*/*\\n         add:x:@data.connect/*/data.read/*/where/*/and\\n            .\\n               name.eq:x:@.arguments/*/name\\n\\n   // Removing [where] if there are no conditions.\\n   if\\n      not-exists:x:@data.connect/*/data.read/*/where/*/and/*\\n      .lambda\\n         remove-nodes:x:@data.connect/*/data.read/*/where\\n\\n   // Adding [limit] and [offset]\\n   add:x:@data.connect/*/data.read\\n      get-nodes:x:@.arguments/*/limit\\n      get-nodes:x:@.arguments/*/offset\\n\\n   // Reading records.\\n   data.read\\n      table:cloudlets\\n      columns\\n         created\\n         name\\n         user\\n         plan\\n         \"('https://' || name || '-' || user || '.' || cluster)\"\\n            as:login\\n      where\\n         and\\n      order:created\\n      direction:desc\\n\\n   // Iterating through above result to change it to dashboard login link.\\n   for-each:x:@data.read/*\\n      set-value:x:@.dp/#/*/login\\n         strings.concat\\n            .:\"https://dashboard.ainiro.io?backend=\"\\n            strings.url-encode:x:@.dp/#/*/login\\n\\n   // Returning result of above invocation back to caller.\\n   return-nodes:x:@data.read/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns all plans in the system."},{"role":"assistant","content":"data.connect:[generic|hub]\\n   data.read\\n      table:plans\\n      columns\\n         name\\n         description\\n         cpu\\n         memory\\n         storage\\n         price\\n         price_reference\\n   return:x:-/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns a single plan"},{"role":"assistant","content":".arguments\\n   size\\n      type:string\\n      mandatory:bool:true\\n\\n// Returning correct price_reference according to size\\nswitch:x:@.arguments/*/size\\n   case:small\\n      return\\n         price_reference:price_1OfS7kCoiv3SyDZGr1droJZF\\n   case:large\\n      return\\n         price_reference:price_1OfS8NCoiv3SyDZGCyJh8X62\\n   default\\n\\n      // Oops ...!!\\n      throw:I can only handle small and large size\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Creates our image cache folder."},{"role":"assistant","content":"if\\n   not\\n      io.folder.exists:/etc/hub/image-cache/\\n   .lambda\\n      io.folder.create:/etc/hub/image-cache/\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Runs during startup of Magic, and basically just ensures the module's database exists,\\nand is updated by running migration scripts after attempting to create the database.\\n\\nIf the database doesn't exist, this script will create it by executing the \"hub.mysql.sql\"\\nSQL file."},{"role":"assistant","content":"signal:magic.modules.ensure-database\\n   module:hub\\n   database:hub\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Ensure that the partner roles exists, which is needed to create\\ncloudlets."},{"role":"assistant","content":"signal:magic.auth.ensure-role\\n   role:partner\\n   description:An AINIRO partner that can create demo cloudlets.\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Plugin slot returning cloudlets associated with user."},{"role":"assistant","content":"slots.create:aista.contacts.cloudlets\\n\\n   // Making sure we've got a [meta] argument.\\n   if\\n      or\\n         not-exists:x:@.arguments/*/meta\\n         null:x:@.arguments/*/meta\\n         eq:x:@.arguments/*/meta\\n            .:\\n      .lambda\\n         return\\n            title:Cloudlets\\n\\n   /*\\n    * Retrieving cloudlets associated with user.\\n    * Notice, username can be found in [meta] argument if invocation.\\n    */\\n   data.connect:[generic|hub]\\n      data.read\\n         table:cloudlets\\n         columns\\n            name\\n            plan\\n            cluster\\n            created\\n            id\\n         where\\n            and\\n               user.eq:x:@.arguments/*/meta\\n\\n      // Iterating through each cloudlet returned above adding actions to each cloudlet.\\n      for-each:x:@data.read/*\\n         include:x:@.dp/#\\n\\n            // Dynamically creating arguments to actions.\\n            .delete\\n            set-value:x:@.delete\\n               strings.concat\\n                  .:magic/modules/hub/admin/cloudlets?id=\\n                  get-value:x:@.dp/#/*/id\\n            .disable-update:bool:true\\n            if\\n               strings.starts-with:x:@.dp/#/*/plan\\n                  .:demo\\n               .lambda\\n                  set-value:x:@.disable-update\\n                     .:bool:false\\n            .plan:professional\\n            if\\n               strings.contains:x:@.dp/#/*/plan\\n                  .:angular\\n               .lambda\\n                  set-value:x:@.plan\\n                     .:professional-angular\\n\\n            // Returning actions from [include].\\n            unwrap:x:+/**\\n            return\\n               actions\\n                  .\\n                     icon:delete\\n                     tooltip:Permanently deletes the cloudlet\\n                     url:x:@.delete\\n                     warning:This will permanently delete the cloudlet and all of its data. Please be 100% certain that this is what you want.\\n                     verb:delete\\n                  .\\n                     icon:account_balance\\n                     tooltip:Upgrade the cloudlet\\n                     url:magic/modules/hub/admin/upgrade-cloudlet\\n                     warning:This will upgrade the cloudlet to its professional equivalent. Are you sure you wish to continue?\\n                     verb:put\\n                     disabled:x:@.disable-update\\n                     payload\\n                        id:x:@.dp/#/*/id\\n                        plan:x:@.plan\\n\\n         // Removing [id] to makes sure we don't return it to caller.\\n         remove-nodes:x:@.dp/#/*/id\\n\\n      // Returning all cloudlets associated with user to caller, now with actions too.\\n      add:x:./*/return/*/items\\n         get-nodes:x:@data.read/*\\n      return\\n         title:Cloudlets\\n         items\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Callback slot for Stripe, throws exception if cloudlet has child cloudlets."},{"role":"assistant","content":"slots.create:payments.subscriptions.can-delete.cloudlet-not-parent\\n\\n   // Sanity checking invocation.\\n   validators.mandatory:x:@.arguments/*/meta\\n   validators.mandatory:x:@.arguments/*/username\\n\\n   // Verifying cloudlet is not a parent cloudlet.\\n   data.connect:[generic|hub]\\n      data.read\\n         table:cloudlets\\n         columns\\n            id\\n         where\\n            and\\n               source_cloudlet.eq:x:@.arguments/*/meta\\n               user.eq:x:@.arguments/*/username\\n      if\\n         exists:x:@data.read/*/*\\n         .lambda\\n\\n            // Oops ...!!\\n            throw:Subscription cannot be cancelled since cloudlet associated with subscription is a source cloudlet for another cloudlet. Delete primary cloudlet first!\\n               status:412\\n               public:true\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Enables a cloudlet when a subscription payment has gone through."},{"role":"assistant","content":"slots.create:payments.subscriptions.unsubscribed.cloudlets.destroy\\n\\n   // Checking if invocation is for us.\\n   if\\n      neq:x:@.arguments/*/type\\n         .:subscription\\n      .lambda\\n\\n         // Not our guy.\\n         return:bool:false\\n\\n   // Sanity checking invocation.\\n   validators.mandatory:x:@.arguments/*/meta\\n   validators.mandatory:x:@.arguments/*/username\\n\\n   // Invoking slot responsible for deleting cloudlet.\\n   .name\\n   set-value:x:@.name\\n      strings.concat\\n         get-value:x:@.arguments/*/meta\\n         .:-\\n         get-value:x:@.arguments/*/username\\n\\n   // Finding cluster for cloudlet.\\n   .cluster\\n   data.connect:[generic|hub]\\n      data.read\\n         table:cloudlets\\n         values\\n            cluster\\n         where\\n            and\\n               user.eq:x:@.arguments/*/username\\n               name.eq:x:@.arguments/*/meta\\n      set-value:x:@.cluster\\n         get-value:x:@data.read/*/*/cluster\\n   unwrap:x:+/*\\n   signal:hub.cloudlets.hard-delete\\n      cluster:x:@.cluster\\n      name:x:@.name\\n\\n   // Deleting cloudlet from database.\\n   data.connect:[generic|hub]\\n      data.delete\\n         table:cloudlets\\n         where\\n            and\\n               name.eq:x:@.arguments/*/meta\\n               user.eq:x:@.arguments/*/username\\n\\n   // Returning true to indicate we handled the callback.\\n   return:bool:true\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Creates task that automatically destroys the cloudlet after trial period is over."},{"role":"assistant","content":"slots.create:hub.cloudlet.ensure-demo-destruction\\n\\n   // Sanity checking invocation.\\n   validators.mandatory:x:@.arguments/*/cluster\\n   validators.mandatory:x:@.arguments/*/username\\n   validators.mandatory:x:@.arguments/*/cloudlet-id\\n   validators.mandatory:x:@.arguments/*/cloudlet-name\\n\\n   // Deleting old hanging tasks for cloudlet with the same name.\\n   .old-tasks\\n   set-value:x:-\\n      strings.concat\\n         .:cloudlet-\\n         get-value:x:@.arguments/*/cloudlet-name\\n         .:-\\n   tasks.list:x:@.old-tasks\\n   for-each:x:-/*\\n      tasks.delete:x:@.dp/#/*/id\\n\\n   // Creating soft delete task.\\n   .task-name\\n   set-value:x:-\\n      strings.concat\\n         .:cloudlet-\\n         get-value:x:@.arguments/*/cloudlet-name\\n         .:-delete\\n   .soft-delete\\n   set-value:x:@.soft-delete\\n      config.get:\"magic:hub:soft-delete\"\\n         .:120\\n   math.add\\n      date.now\\n      time\\n         days:x:@.soft-delete\\n   unwrap:x:+/**/.args/*\\n   tasks.create:x:@.task-name\\n      due:x:@math.add\\n      .lambda\\n\\n         // Forward evaluated further up.\\n         .args\\n            cluster:x:@.arguments/*/cluster\\n            cloudlet-name:x:@.arguments/*/cloudlet-name\\n            task-name:x:@.task-name\\n\\n         // Deleting cloudlet.\\n         unwrap:x:+/*\\n         signal:hub.cloudlets.delete\\n            cluster:x:@.args/*/cluster\\n            name:x:@.args/*/cloudlet-name\\n\\n         // Deleting cloudlet from database.\\n         strings.split:x:@.args/*/cloudlet-name\\n            .:-\\n         data.connect:[generic|hub]\\n            data.update\\n               table:cloudlets\\n               values\\n                  enabled:bool:false\\n               where\\n                  and\\n                     cluster.eq:x:@.args/*/cluster\\n                     name.eq:x:@strings.split/0\\n                     user.eq:x:@strings.split/1\\n\\n         // Logging that we deleted the cloudlet.\\n         log.info:Cloudlet was automatically soft deleted due to trial period ending\\n            cloudlet:x:@.args/*/cloudlet-name\\n            cluster:x:@.args/*/cluster\\n\\n         // Deleting task.\\n         tasks.delete:x:@.args/*/task-name\\n\\n   // Creating hard delete task.\\n   .task-name\\n   set-value:x:-\\n      strings.concat\\n         .:cloudlet-\\n         get-value:x:@.arguments/*/cloudlet-name\\n         .:-hard-delete\\n   .hard-delete\\n   set-value:x:@.hard-delete\\n      config.get:\"magic:hub:hard-delete\"\\n         .:150\\n   math.add\\n      date.now\\n      time\\n         days:x:@.hard-delete\\n   unwrap:x:+/**/.args/*\\n   tasks.create:x:@.task-name\\n      due:x:@math.add\\n      .lambda\\n\\n         // Forward evaluated further up.\\n         .args\\n            cluster:x:@.arguments/*/cluster\\n            cloudlet-name:x:@.arguments/*/cloudlet-name\\n            task-name:x:@.task-name\\n\\n         // Deleting cloudlet.\\n         unwrap:x:+/*\\n         signal:hub.cloudlets.hard-delete\\n            cluster:x:@.args/*/cluster\\n            name:x:@.args/*/cloudlet-name\\n\\n         // Deleting cloudlet from database.\\n         strings.split:x:@.args/*/cloudlet-name\\n            .:-\\n         data.connect:[generic|hub]\\n            data.delete\\n               table:cloudlets\\n               where\\n                  and\\n                     cluster.eq:x:@.args/*/cluster\\n                     name.eq:x:@strings.split/0\\n                     user.eq:x:@strings.split/1\\n\\n         // Logging that we deleted the cloudlet.\\n         log.info:Cloudlet was automatically hard deleted due to trial period ending\\n            cloudlet:x:@.args/*/cloudlet-name\\n            cluster:x:@.args/*/cluster\\n\\n         // Deleting task.\\n         tasks.delete:x:@.args/*/task-name\\n\\n   // Updating cloudlet to initialise its destruction date.\\n   data.update\\n      table:cloudlets\\n      values\\n         destruction_date:x:@math.add/@math.add\\n      where\\n         and\\n            id.eq:x:@.arguments/*/cloudlet-id\\n\\n   // Logging that we created a scheduled task.\\n   log.debug:Cloudlet is automatically scheduled for deletion\\n      cluster:x:@.arguments/*/cluster\\n      cloudlet-name:x:@.arguments/*/cloudlet-name\\n      task-name:x:@strings.concat\\n      cloudlet-id:x:@.arguments/*/cloudlet-id\\n      days:x:@.soft-delete\\n\\n   // Signaling user that the cloudlet has been scheduled for destruction as trial period expires.\\n   strings.concat\\n      .:\"Destroying cloudlet in \"\\n      get-value:x:@.soft-delete\\n      .:\" days\"\\n   unwrap:x:+/**\\n   sockets.signal:hub.cloudlets.create\\n      users:x:@.arguments/*/username\\n      args\\n         status:x:@strings.concat\\n         finished:bool:false\\n         error:bool:false\\n\\n   // Retrieving number of days trial period lasts.\\n   .grace-period\\n   set-value:x:@.grace-period\\n      config.get:\"magic:hub:trial-days\"\\n         .:90\\n\\n   // Creating task that warns user about destruction of cloudlet.\\n   .task-name\\n   set-value:x:-\\n      strings.concat\\n         .:cloudlet-\\n         get-value:x:@.arguments/*/cloudlet-name\\n         .:-warn-about-destruction\\n   math.add\\n      date.now\\n      time\\n         days:x:@.grace-period\\n   unwrap:x:+/**/.args/*\\n   tasks.create:x:@.task-name\\n      due:x:@math.add\\n      .lambda\\n\\n         // Sends the user an email to warn him his cloudlet is scheduled for destruction 5 days from now.\\n         .args\\n            username:x:@.arguments/*/username\\n            task-name:x:@.task-name\\n            cloudlet-name:x:@.arguments/*/cloudlet-name\\n         unwrap:x:+/*\\n         signal:hub.emails.user.warn-destruction-of-cloudlet\\n            username:x:@.args/*/username\\n            cloudlet:x:@.args/*/cloudlet-name\\n\\n         // Logging that we have warned the user.\\n         log.info:User has been warned about cloudlet deletion\\n            user:x:@.args/*/username\\n            cloudlet-name:x:@.args/*/cloudlet-name\\n\\n         // Deleting task.\\n         tasks.delete:x:@.args/*/task-name\\n\\n   // Logging that we created a scheduled task.\\n   log.debug:Automatically warning user about cloudlet deletion\\n      cluster:x:@.arguments/*/cluster\\n      cloudlet-name:x:@.arguments/*/cloudlet-name\\n      task-name:x:@strings.concat\\n      days:x:@math.subtract\\n\\n   // Signaling user that the cloudlet has been scheduled for destruction as trial period expires.\\n   strings.concat\\n      .:\"Warning user about cloudlet deletion \"\\n      get-value:x:@.grace-period\\n      .:\" days from now\"\\n   unwrap:x:+/**\\n   sockets.signal:hub.cloudlets.create\\n      users:x:@.arguments/*/username\\n      args\\n         status:x:@strings.concat\\n         finished:bool:false\\n         error:bool:false\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Slot responsible for soft deletion of an existing cloudlet."},{"role":"assistant","content":"slots.create:hub.cloudlets.delete\\n\\n   // Sanity checking invocation.\\n   validators.mandatory:x:@.arguments/*/cluster\\n   validators.mandatory:x:@.arguments/*/name\\n\\n   // Figuring out base URL of Kubernetes REST API.\\n   .base-url\\n   strings.concat\\n      .:\"magic:hub:\"\\n      get-value:x:@.arguments/*/cluster\\n      .:\":manager-url\"\\n   set-value:x:@.base-url\\n      config.get:x:@strings.concat\\n\\n   // Figuring out Kubernetes namespace cloudlets exists in.\\n   .namespace\\n   set-value:x:@.namespace\\n      config.get:\"magic:hub:default-namespace\"\\n\\n   // Retrieving token that's required to invoke Kubernetes REST API.\\n   .token\\n   strings.concat\\n      .:\"magic:hub:\"\\n      get-value:x:@.arguments/*/cluster\\n      .:\":token\"\\n   set-value:x:@.token\\n      strings.concat\\n         .:\"Bearer \"\\n         config.get:x:@strings.concat/@strings.concat\\n\\n   // Invoking Web API responsible for deleting deployment.\\n   .url\\n   set-value:x:@.url\\n      strings.concat\\n         get-value:x:@.base-url\\n         .:/apis/apps/v1/namespaces/\\n         get-value:x:@.namespace\\n         .:/deployments/\\n         get-value:x:@.arguments/*/name\\n   http.delete:x:@.url\\n      headers\\n         Authorization:x:@.token\\n\\n   // Sanity checking above invocation\\n   if\\n      not\\n         and\\n            mte:x:@http.delete\\n               .:int:200\\n            lt:x:@http.delete\\n               .:int:300\\n      .lambda\\n\\n         // Oops, web API didn't return success\\n         log.error:Kubernetes could not delete deployment\\n            status:x:@http.post\\n            response:x:@http.post/*/content\\n            cluster:x:@.arguments/*/cluster\\n            name:x:@.arguments/*/name\\n   else\\n\\n      // Logging the fact that we successfully deleted deployment.\\n      log.debug:Kubernetes deployment successfully deleted\\n         cluster:x:@.arguments/*/cluster\\n         name:x:@.arguments/*/name\\n         response:x:@http.post/*/content\\n\\n   // Invoking Web API responsible for deleting service.\\n   .url\\n   set-value:x:@.url\\n      strings.concat\\n         get-value:x:@.base-url\\n         .:/api/v1/namespaces/\\n         get-value:x:@.namespace\\n         .:/services/\\n         get-value:x:@.arguments/*/name\\n   http.delete:x:@.url\\n      headers\\n         Authorization:x:@.token\\n\\n   // Sanity checking above invocation\\n   if\\n      not\\n         and\\n            mte:x:@http.delete\\n               .:int:200\\n            lt:x:@http.delete\\n               .:int:300\\n      .lambda\\n\\n         // Oops, web API didn't return success\\n         log.error:Kubernetes could not delete service\\n            status:x:@http.post\\n            response:x:@http.post/*/content\\n            cluster:x:@.arguments/*/cluster\\n            name:x:@.arguments/*/name\\n   else\\n\\n      // Logging the fact that we successfully deleted service.\\n      log.debug:Kubernetes service successfully deleted\\n         cluster:x:@.arguments/*/cluster\\n         name:x:@.arguments/*/name\\n         response:x:@http.post/*/content\\n\\n   // Invoking Web API responsible for deleting ingress.\\n   .url\\n   set-value:x:@.url\\n      strings.concat\\n         get-value:x:@.base-url\\n         .:/apis/networking.k8s.io/v1/namespaces/\\n         get-value:x:@.namespace\\n         .:/ingresses/\\n         get-value:x:@.arguments/*/name\\n   http.delete:x:@.url\\n      headers\\n         Authorization:x:@.token\\n\\n   // Sanity checking above invocation\\n   if\\n      not\\n         and\\n            mte:x:@http.delete\\n               .:int:200\\n            lt:x:@http.delete\\n               .:int:300\\n      .lambda\\n\\n         // Oops, web API didn't return success\\n         log.error:Kubernetes could not delete ingress\\n            status:x:@http.post\\n            response:x:@http.post/*/content\\n            cluster:x:@.arguments/*/cluster\\n            name:x:@.arguments/*/name\\n   else\\n\\n      // Logging the fact that we successfully deleted ingress.\\n      log.debug:Kubernetes ingress successfully deleted\\n         cluster:x:@.arguments/*/cluster\\n         name:x:@.arguments/*/name\\n         response:x:@http.post/*/content\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Slot responsible for hard deletion of an existing cloudlet."},{"role":"assistant","content":"slots.create:hub.cloudlets.hard-delete\\n\\n   // Sanity checking invocation.\\n   validators.mandatory:x:@.arguments/*/cluster\\n   validators.mandatory:x:@.arguments/*/name\\n\\n   // Invoking soft delete first.\\n   add:x:+\\n      get-nodes:x:@.arguments/*\\n   signal:hub.cloudlets.delete\\n\\n   // Figuring out base URL of Kubernetes REST API.\\n   .base-url\\n   strings.concat\\n      .:\"magic:hub:\"\\n      get-value:x:@.arguments/*/cluster\\n      .:\":manager-url\"\\n   set-value:x:@.base-url\\n      config.get:x:@strings.concat\\n\\n   // Figuring out Kubernetes namespace cloudlets exists in.\\n   .namespace\\n   set-value:x:@.namespace\\n      config.get:\"magic:hub:default-namespace\"\\n\\n   // Retrieving token that's required to invoke Kubernetes REST API.\\n   .token\\n   strings.concat\\n      .:\"magic:hub:\"\\n      get-value:x:@.arguments/*/cluster\\n      .:\":token\"\\n   set-value:x:@.token\\n      strings.concat\\n         .:\"Bearer \"\\n         config.get:x:@strings.concat/@strings.concat\\n\\n   // Invoking Web API responsible for deleting volume claim.\\n   .url\\n   set-value:x:@.url\\n      strings.concat\\n         get-value:x:@.base-url\\n         .:/api/v1/namespaces/\\n         get-value:x:@.namespace\\n         .:/persistentvolumeclaims/\\n         get-value:x:@.arguments/*/name\\n   http.delete:x:@.url\\n      headers\\n         Authorization:x:@.token\\n\\n   // Sanity checking above invocation\\n   if\\n      not\\n         and\\n            mte:x:@http.delete\\n               .:int:200\\n            lt:x:@http.delete\\n               .:int:300\\n      .lambda\\n\\n         // Oops, web API didn't return success\\n         log.error:Kubernetes could not delete volume claim\\n            status:x:@http.post\\n            response:x:@http.post/*/content\\n            cluster:x:@.arguments/*/cluster\\n            name:x:@.arguments/*/name\\n   else\\n\\n      // Logging the fact that we successfully deleted ingress.\\n      log.debug:Kubernetes volume claim successfully deleted\\n         cluster:x:@.arguments/*/cluster\\n         name:x:@.arguments/*/name\\n         response:x:@http.post/*/content\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Sends the user a warning email informing him or her that the his cloudlet is about\\nto be destroyed 5 days from now."},{"role":"assistant","content":"slots.create:hub.emails.user.warn-destruction-of-cloudlet\\n\\n   // Sanity checking invocation.\\n   validators.mandatory:x:@.arguments/*/username\\n   validators.mandatory:x:@.arguments/*/cloudlet\\n\\n   // Retrieving frontend URL.\\n   .url\\n   set-value:x:@.url\\n      config.get:\"magic:hub:frontend-url\"\\n\\n   // Retrieving user's name and email address.\\n   .email\\n   .name\\n   data.connect:[generic|magic]\\n      data.read\\n         table:users_extra\\n         values\\n            type\\n            name\\n         where\\n            and\\n               user.eq:x:@.arguments/*/username\\n               or\\n                  type.eq:email\\n                  type.eq:name\\n      set-value:x:@.email\\n         get-value:x:@data.read/*/*/type/=email/./*/value\\n      set-value:x:@.name\\n         get-value:x:@data.read/*/*/type/=name/./*/value\\n\\n   // Sending user his warning email.\\n   unwrap:x:+/**\\n   signal:magic.emails.send\\n      subject:[Important] - Your AINIRO cloudlet is scheduled for destruction!\\n      template-file:/modules/hub/magic.startup/templates/cloudlet-to-be-destroyed.html\\n      substitutes\\n         url:x:@.url\\n         cloudlet:x:@.arguments/*/cloudlet\\n      mime-type:text/html\\n      email:x:@.email\\n      name:x:@.name\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Slot responsible for configuring a new cloudlet."},{"role":"assistant","content":"slots.create:hub.cloudlets.wait-for-ready\\n\\n   // Sanity checking invocation.\\n   validators.mandatory:x:@.arguments/*/token\\n   validators.mandatory:x:@.arguments/*/name\\n   validators.mandatory:x:@.arguments/*/namespace\\n   validators.mandatory:x:@.arguments/*/url\\n\\n   // Doing some basic logging.\\n   log.debug:Waiting for cloudlet to boot up and be ready on network\\n      name:x:@.arguments/*/name\\n      namespace:x:@.arguments/*/namespace\\n\\n   // Creating URL to invoke to check if cloudlet is available.\\n   .url\\n   set-value:x:-\\n      strings.concat\\n         get-value:x:@.arguments/*/url\\n         .:/apis/apps/v1/namespaces/\\n         get-value:x:@.arguments/*/namespace\\n         .:/deployments/\\n         get-value:x:@.arguments/*/name\\n\\n   // Informing user that we're waiting for cloudlet to boot and be ready.\\n   sockets.signal:hub.cloudlets.create\\n      users:x:@.arguments/*/username\\n      args\\n         status:Waiting for cloudlet to boot up and become available on network\\n         finished:bool:false\\n         error:bool:false\\n\\n   // Waiting for cloudlet to be ready, maximum wait time is 5 minutes before we give up.\\n   .no:int:30\\n   while\\n      mt:x:@.no\\n         .:int:0\\n      .lambda\\n\\n         // Sleeping for 10 seconds.\\n         sleep:10000\\n\\n         // Invoking HTTP REST API to check if cloudlet is ready.\\n         http.get:x:@.url\\n            headers\\n               Authorization:x:@.arguments/*/token\\n            convert:true\\n\\n         // Checking status of above invocation.\\n         if\\n            mte:x:@http.get/*/content/**/status/*/availableReplicas\\n               .:long:1\\n            .lambda\\n\\n               // Doing some basic logging\\n               log.debug:Cloudlet is available and up running\\n                  name:x:@.arguments/*/name\\n                  namespace:x:@.arguments/*/namespace\\n\\n               // Cloudlet is active, and can be configured.\\n               sockets.signal:hub.cloudlets.create\\n                  users:x:@.arguments/*/username\\n                  args\\n                     status:Cloudlet is ready and up running\\n                     finished:bool:false\\n                     error:bool:false\\n\\n               // Returning early to abort the rest of our while loop.\\n               return:bool:true\\n\\n         // Decrementing counter.\\n         math.decrement:x:@.no\\n\\n         // Informing user that we're still waiting ...\\n         sockets.signal:hub.cloudlets.create\\n            users:x:@.arguments/*/username\\n            args\\n               status:Cloudlet is still not ready, please wait ...\\n               finished:bool:false\\n               error:bool:false\\n\\n   // Oops, cloudlet was not ready even though we waited for 5 minutes.\\n   log.error:Cloudlet was not available after 5 minutes\\n      url:x:@.arguments/*/url\\n\\n   // Informing user that something went wrong.\\n   sockets.signal:hub.cloudlets.create\\n      users:x:@.arguments/*/username\\n      args\\n         status:Cloudlet was not available due to internal error\\n         finished:bool:false\\n         error:bool:false\\n\\n   // Returning failure to caller.\\n   throw:Cloudlet was not available within 10 minutes, hence we give up waiting for it\\n      public:true\\n      status:500\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Verifies user is allowed to create a demo account."},{"role":"assistant","content":"slots.create:hub.user.can-create-demo-account\\n\\n   // Sanity checking invocation.\\n   validators.mandatory:x:@.arguments/*/username\\n   validators.mandatory:x:@.arguments/*/plan\\n\\n   // Verifying user belongs to one of the roles that are allowed to create demo clodlets.\\n   try\\n      auth.ticket.verify:root, admin, partner\\n   .catch\\n\\n      // Letting user know that he is not allowed to create demo cloudlets.\\n      sockets.signal:hub.cloudlets.create\\n         users:x:@auth.ticket.get\\n         args\\n            status:Only partners can create demo cloudlets. To test AINIRO send en email to team@ainiro.io\\n            finished:bool:false\\n            error:bool:true\\n      log.error:User tried to create demo cloudlets when not allowed\\n         user:x:@.arguments/*/username\\n         plan:x:@.arguments/*/plan\\n      throw:Only partners can create demo cloudlets\\n         public:true\\n         status:403\\n\\n   // Checking if user alread have a demo cloudlet.\\n   data.scalar:select count(*) from cloudlets where user = @user and plan = @plan\\n      user:x:@.arguments/*/username\\n      plan:x:@.arguments/*/plan\\n   if\\n      neq:x:@data.scalar\\n         .:long:0\\n      .lambda\\n\\n         // Letting user know that he already has a demo account of specified type.\\n         sockets.signal:hub.cloudlets.create\\n            users:x:@auth.ticket.get\\n            args\\n               status:You already have one demo account of the specified type\\n               finished:bool:false\\n               error:bool:true\\n         log.error:User tried to create multiple demo cloudlets\\n            user:x:@.arguments/*/username\\n            plan:x:@.arguments/*/plan\\n         throw:We only allow one demo cloudlet of each type for each user\\n            public:true\\n            status:403\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns number of registrations for the last 14 days grouped by day."},{"role":"assistant","content":".arguments\\ntype:custom\\n\\n// Making sure user is authorised to invoke endpoint.\\nauth.ticket.verify:root, admin, guest\\nconfig.get:\"magic:databases:default\"\\nswitch:x:@config.get\\n   case:mysql\\n   case:sqlite\\n      strings.concat\\n         .:/modules/hub/affiliates/db.overrides/\\n         get-value:x:@config.get\\n         .:.affiliate-registrations.get.hl\\n      add:x:+\\n         get-nodes:x:@.arguments/*\\n      io.file.execute:x:@strings.concat\\n      return-nodes:x:-/*\\n   default\\n      throw:Unsupport database type for Hub\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns number of registrations for the last 14 days grouped by day."},{"role":"assistant","content":".arguments\\ntype:custom\\n\\n// Making sure user is authorised to invoke endpoint.\\nauth.ticket.verify:root, admin, guest\\nconfig.get:\"magic:databases:default\"\\nswitch:x:@config.get\\n   case:mysql\\n   case:sqlite\\n      strings.concat\\n         .:/modules/hub/affiliates/db.overrides/\\n         get-value:x:@config.get\\n         .:.affiliate-transactions.get.hl\\n      add:x:+\\n         get-nodes:x:@.arguments/*\\n      io.file.execute:x:@strings.concat\\n      return-nodes:x:-/*\\n   default\\n      throw:Unsupport database type for Hub\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Counts clients that are affiliated with the currently authenticated client."},{"role":"assistant","content":".arguments\\ntype:crud-count\\n\\n// Verifying user has access to endpoint.\\nauth.ticket.verify:root, admin, guest\\n\\n// Retrieving currently authenticated user to parametrise invocation towards database.\\nauth.ticket.get\\n\\n// Counting users affiliated with currently authenticated user.\\ndata.connect:[generic|magic]\\n\\n   // Retrieving affiliate percent for user.\\n   data.read\\n      table:users_extra\\n      columns\\n         value\\n      where\\n         and\\n            type.eq:affiliate_percent\\n            user.eq:x:@auth.ticket.get\\n   if\\n      not-exists:x:@data.read/*/*/value\\n      .lambda\\n\\n         // Oops ...!!\\n         log.error:User is not affiliate\\n            username:x:@auth.ticket.get\\n         throw:You are not an affiliate\\n            public:true\\n            status:400\\n\\n   // Invoking read slot to count users affiliated with currently authenticated user.\\n   data.read\\n      table:users_extra\\n      columns\\n         count(*)\\n            as:count\\n      where\\n         and\\n            type.eq:affiliate\\n            value.eq:x:@auth.ticket.get\\n\\n   // Applying some HTTP caching since endpoint is kind of expensive to invoke.\\n   response.headers.set\\n      Cache-Control:private, max-age=3600\\n\\n   // Returning result to caller.\\n   unwrap:x:+/*\\n   return\\n      count:x:@data.read/*/*/count\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns all clients that are affiliated with the currently authenticated client."},{"role":"assistant","content":".arguments\\n   limit:long\\n   offset:long\\n   from:date\\n   to:date\\ntype:crud-read\\n\\n// Verifying user has access to endpoint.\\nauth.ticket.verify:root, admin, guest\\n\\n// Retrieving currently authenticated user to parametrise invocation towards database.\\nauth.ticket.get\\n\\n// Buffer for returning users to caller.\\n.result\\n\\n// Affiliate percentage user has.\\n.percent\\n\\n// Returning all usernames that are affiliated with currently authenticated client.\\ndata.connect:[generic|magic]\\n\\n   /*\\n    * Retrieving affiliate percent for user.\\n    * This is the commission the currently authenticated user gets\\n    * from sales originating from users he made register in our platform.\\n    */\\n   data.read\\n      table:users_extra\\n      columns\\n         value\\n      where\\n         and\\n            type.eq:affiliate_percent\\n            user.eq:x:@auth.ticket.get\\n   if\\n      not-exists:x:@data.read/*/*/value\\n      .lambda\\n\\n         // Oops ...!!\\n         log.error:User is not affiliate\\n            username:x:@auth.ticket.get\\n         throw:You are not an affiliate\\n            public:true\\n            status:400\\n\\n   // Setting [.percent] value such that we can calculate affiliate earnings.\\n   convert:x:@data.read/*/*/value\\n      type:decimal\\n   set-value:x:@.percent\\n      math.divide:x:@convert\\n         .:decimal:100\\n\\n   /*\\n    * Applying paging and invoking read slot to find all users\\n    * affiliated with the currently authenticated user.\\n    */\\n   add:x:./*/data.read/[1,2]\\n      get-nodes:x:@.arguments/*/limit\\n      get-nodes:x:@.arguments/*/offset\\n   data.read\\n      table:users_extra\\n         join:users\\n            table:users\\n            type:inner\\n            on\\n               and\\n                  users.username.eq:users_extra.user\\n      columns\\n         users_extra.user\\n         users.created\\n      where\\n         and\\n            users_extra.type.eq:affiliate\\n            users_extra.value.eq:x:@auth.ticket.get\\n      order:users.created\\n      direction:desc\\n\\n   // Adding usernames to return buffer.\\n   for-each:x:@data.read/*\\n\\n      // Adding username to result.\\n      add:x:@.result\\n         get-nodes:x:@.dp/#\\n\\n      // Invoking read slot to retrieve name, email address and country of affiliated user.\\n      data.read\\n         table:users_extra\\n         columns\\n            value\\n            type\\n         where\\n            and\\n               or\\n                  type.eq:email\\n                  type.eq:name\\n                  type.eq:country\\n               user.eq:x:@.dp/#/*/user\\n      unwrap:x:+/*/*\\n      add:x:@.result/0/-\\n         .\\n            name:x:@data.read/*/*/type/=name/./*/value\\n            email:x:@data.read/*/*/type/=email/./*/value\\n            country:x:@data.read/*/*/type/=country/./*/value\\n\\n      // Checking if user confirmed his or her email address.\\n      data.read\\n         table:users_roles\\n         columns\\n            user\\n         where\\n            and\\n               user.eq:x:@.dp/#/*/user\\n               role.eq:guest\\n      if\\n         exists:x:@data.read/*/*\\n         .lambda\\n            add:x:@.result/0/-\\n               .\\n                  confirmed:bool:true\\n      else\\n         add:x:@.result/0/-\\n            .\\n               confirmed:bool:false\\n\\n/*\\n * Returning sum and commission of transactions for each user\\n * retrieved in the above invocation, which becomes the commission\\n * on a per user basis the currently authenticated user earns.\\n */\\ndata.connect:[generic|stripe]\\n\\n   // Looping through each username in affiliate list.\\n   for-each:x:@.result/*\\n\\n      // Checking if we've got [from] and [to] filters.\\n      if\\n         not-null:x:@.arguments/*/from\\n         .lambda\\n            add:x:@for-each/*/data.read/[0,1]/*/where/*/and\\n               .\\n                  created.mteq:x:@.arguments/*/from\\n      if\\n         not-null:x:@.arguments/*/to\\n         .lambda\\n            add:x:@for-each/*/data.read/[0,1]/*/where/*/and\\n               .\\n                  created.lteq:x:@.arguments/*/to\\n\\n      // Invoking read slot.\\n      data.read\\n         table:transactions\\n         columns\\n            sum(amount)\\n               as:sum\\n         where\\n            and\\n               username.eq:x:@.dp/#/*/user\\n               type.eq:charge.succeeded\\n         group\\n            username\\n\\n      // Checking if above invocation returned a result.\\n      if\\n         exists:x:@data.read/*/*/sum\\n         .lambda\\n\\n            // Adding sum.\\n            add:x:@.dp/#\\n               get-nodes:x:@data.read/*/*/sum\\n\\n            // Adding commission for affiliate.\\n            math.multiply:x:@data.read/*/*/sum\\n               get-value:x:@.percent\\n            unwrap:x:+/*/*\\n            add:x:@.dp/#\\n               .\\n                  commission:x:@math.multiply\\n      else\\n\\n         // Adding zero sum.\\n         add:x:@.dp/#\\n            .\\n               sum:long:0\\n               commission:long:0\\n\\n// Applying some HTTP caching since endpoint is kind of expensive to invoke.\\nresponse.headers.set\\n   Cache-Control:private, max-age=3600\\n\\n// Returning result to caller.\\nreturn-nodes:x:@.result/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Withdraw endpoint allowing affiliates to request withdrawals of funds."},{"role":"assistant","content":".arguments\\n   amount:decimal\\n   bank_name:string\\n   account_name:string\\n   iban:string\\n   swift:string\\n   bank_address:string\\n   affiliate_address:string\\ntype:custom\\n\\n// Verifying user has access to endpoint.\\nauth.ticket.verify:root, admin, guest\\n\\n// Retrieving currently authenticated user to parametrise invocation towards database.\\nauth.ticket.get\\n\\n// Verifying user is an affiliate\\ndata.connect:[generic|magic]\\n   data.read\\n      table:users_extra\\n      columns\\n         value\\n      where\\n         and\\n            type.eq:affiliate_percent\\n            user.eq:x:@auth.ticket.get\\n   if\\n      not-exists:x:@data.read/*/*/value\\n      .lambda\\n\\n         // Oops ...!!\\n         log.error:User is not affiliate\\n            username:x:@auth.ticket.get\\n         throw:You are not an affiliate\\n            public:true\\n            status:400\\n\\n// Creating an email and sending to admin of system with data.\\nunwrap:x:+/*/*\\nadd:x:@.arguments\\n   .\\n      username:x:@auth.ticket.get\\nlambda2hyper:x:@.arguments/*\\n\\n// Sending email with withdrawal request to team@ainiro.io\\nunwrap:x:+/**\\nsignal:magic.emails.send\\n   subject:Affiliate withdrawal request\\n   template-file:/modules/hub/magic.startup/templates/affiliate-withdrawal.txt\\n   substitutes\\n      content:x:@lambda2hyper\\n   mime-type:text/plain\\n   email:team@ainiro.io\\n   name:Thomas Hansen\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Creates a withdrawal transaction in our Stripe module."},{"role":"assistant","content":".arguments\\n   amount:long\\n   affiliate:string\\ntype:custom\\n\\n// Verifying user has access to endpoint.\\nauth.ticket.verify:root, admin\\n\\n// Opening up Stripe database and creating our transaction.\\nguid.new\\nconvert:x:-\\n   type:string\\ndata.connect:[generic|stripe]\\n   data.create\\n      table:transactions\\n      values\\n         transaction:x:@convert\\n         amount:x:@.arguments/*/amount\\n         username:x:@.arguments/*/affiliate\\n         type:withdrawal\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns balance information for affiliate."},{"role":"assistant","content":"\\n// Needed to parametrise invocations towards database.\\nauth.ticket.get\\n\\n// Affiliate percent calculated below.\\n.percent\\n\\n// Ensuring user is an affiliate\\ndata.connect:[generic|magic]\\n\\n   /*\\n    * Retrieving affiliate percent for user.\\n    * Notice, if user doesn't have an affiliate percent, user is\\n    * not an affiliate.\\n    */\\n   data.read\\n      table:users_extra\\n      columns\\n         value\\n      where\\n         and\\n            type.eq:affiliate_percent\\n            user.eq:x:@auth.ticket.get\\n   if\\n      not-exists:x:@data.read/*/*/value\\n      .lambda\\n\\n         // Oops ...!!\\n         log.error:User is not affiliate\\n            username:x:@auth.ticket.get\\n         throw:You are not an affiliate\\n            public:true\\n            status:400\\n\\n   // Calculating ratio and storing.\\n   convert:x:@data.read/*/*/value\\n      type:decimal\\n   set-value:x:@.percent\\n      math.divide:x:@convert\\n         .:decimal:100\\n\\n// Connecting to database.\\ndata.connect:[generic|stripe]\\n\\n   // Buffer to hold return values.\\n   .balance\\n      received\\n      accepted\\n      withdrawals\\n\\n   // Retrieving all received amounts from database.\\n   set-value:x:@.balance/*/received\\n      math.multiply\\n         data.scalar:\"select coalesce(sum(amount), 0) as sum from transactions\\n   where affiliate = @affiliate and\\n      type = 'charge.succeeded'\"\\n            @affiliate:x:@auth.ticket.get\\n         get-value:x:@.percent\\n\\n   // Retrieving all accepted amounts from database.\\n   set-value:x:@.balance/*/accepted\\n      math.multiply\\n         data.scalar:\"select coalesce(sum(amount), 0) as sum from transactions t\\n   where affiliate = @affiliate and\\n      created <= curdate() - interval 1 month and\\n      type = 'charge.succeeded' and not exists(\\n         select * from transactions t2\\n            where t2.type = 'charge.refunded' and\\n               t2.invoice = t.invoice and t2.invoice is not null)\"\\n            @affiliate:x:@auth.ticket.get\\n         get-value:x:@.percent\\n\\n   // Retrieving all withdrawals from database.\\n   set-value:x:@.balance/*/withdrawals\\n      data.scalar:\"select coalesce(sum(amount), 0) as sum from transactions t\\n   where affiliate = @affiliate and type = 'withdrawal'\"\\n         @affiliate:x:@auth.ticket.get\\n\\n   // Applying some HTTP caching since endpoint is kind of expensive to invoke.\\n   response.headers.set\\n      Cache-Control:private, max-age=3600\\n\\n   // Returning result to caller.\\n   return-nodes:x:@.balance/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns number of registrations for the last 14 days grouped by day."},{"role":"assistant","content":"\\n// Needed to parametrise invocations towards database.\\nauth.ticket.get\\n\\n// Storing commission for later.\\n.percent\\n\\n// Ensuring user is an affiliate\\ndata.connect:[generic|magic]\\n\\n   /*\\n    * Retrieving affiliate percent for user.\\n    * Notice, if user doesn't have an affiliate percent, user ir\\n    * not an affiliate.\\n    */\\n   data.read\\n      table:users_extra\\n      columns\\n         value\\n      where\\n         and\\n            type.eq:affiliate_percent\\n            user.eq:x:@auth.ticket.get\\n   if\\n      not-exists:x:@data.read/*/*/value\\n      .lambda\\n\\n         // Oops ...!!\\n         log.error:User is not affiliate\\n            username:x:@auth.ticket.get\\n         throw:You are not an affiliate\\n            public:true\\n            status:400\\n\\n   // Storing percentage for later.\\n   convert:x:@data.read/*/*/value\\n      type:decimal\\n   set-value:x:@.percent\\n      math.divide:x:@convert\\n         .:decimal:100\\n\\n// Connecting to Stripe database.\\ndata.connect:[generic|stripe]\\n\\n   // Retrieving transactions from database.\\n   data.select:\"\\nselect date_format(t.created, '%Y-%m-%d') as date, sum(amount) as amount\\n   from transactions t\\n      where t.created > now() - interval 6 week and\\n         t.affiliate = @affiliate and\\n         t.type = 'charge.succeeded'\\n   group by date\\n   order by date asc\"\\n      @affiliate:x:@auth.ticket.get\\n\\n   // Looping through all days the last 6 weeks.\\n   .buffer\\n   .cur\\n   set-value:x:@.cur\\n      math.subtract\\n         date.now\\n         time\\n            days:42\\n   while\\n      lt:x:@.cur\\n         date.now\\n      .lambda\\n         date.format:x:@.cur\\n            format:yyyy-MM-dd\\n         if\\n            exists:x:@data.select/*/*/date/={@date.format}\\n            .lambda\\n               set-value:x:@data.select/*/*/date/={@date.format}/./*/amount\\n                  math.multiply:x:@data.select/*/*/date/={@date.format}/./*/amount\\n                     get-value:x:@.percent\\n               get-nodes:x:@data.select/*/*/date/={@date.format}/.\\n               add:x:@.buffer\\n                  get-nodes:x:@data.select/*/*/date/={@date.format}/.\\n         else\\n            unwrap:x:+/*/*/*\\n            add:x:@.buffer\\n               .\\n                  .\\n                     date:x:@date.format\\n                     amount:int:0\\n\\n         // Decrementing current day.\\n         set-value:x:@.cur\\n            math.add:x:@.cur\\n               time\\n                  days:1\\n\\n   // Applying some HTTP caching since endpoint is kind of expensive to invoke.\\n   response.headers.set\\n      Cache-Control:public, max-age=3600\\n\\n   // Returning result to caller.\\n   return-nodes:x:@.buffer/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns balance information for affiliate."},{"role":"assistant","content":"\\n// Needed to parametrise invocations towards database.\\nauth.ticket.get\\n\\n// Affiliate percent calculated below.\\n.percent\\n\\n// Ensuring user is an affiliate\\ndata.connect:[generic|magic]\\n\\n   /*\\n    * Retrieving affiliate percent for user.\\n    * Notice, if user doesn't have an affiliate percent, user is\\n    * not an affiliate.\\n    */\\n   data.read\\n      table:users_extra\\n      columns\\n         value\\n      where\\n         and\\n            type.eq:affiliate_percent\\n            user.eq:x:@auth.ticket.get\\n   if\\n      not-exists:x:@data.read/*/*/value\\n      .lambda\\n\\n         // Oops ...!!\\n         log.error:User is not affiliate\\n            username:x:@auth.ticket.get\\n         throw:You are not an affiliate\\n            public:true\\n            status:400\\n\\n   // Calculating ratio and storing.\\n   convert:x:@data.read/*/*/value\\n      type:decimal\\n   set-value:x:@.percent\\n      math.divide:x:@convert\\n         .:decimal:100\\n\\n// Connecting to database.\\ndata.connect:[generic|stripe]\\n\\n   // Buffer to hold return values.\\n   .balance\\n      received\\n      accepted\\n      withdrawals\\n\\n   // Retrieving all received amounts from database.\\n   set-value:x:@.balance/*/received\\n      math.multiply\\n         data.scalar:\"select coalesce(sum(amount), 0) as sum from transactions\\n   where affiliate = @affiliate and\\n      type = 'charge.succeeded'\"\\n            @affiliate:x:@auth.ticket.get\\n         get-value:x:@.percent\\n\\n   // Retrieving all accepted amounts from database.\\n   set-value:x:@.balance/*/accepted\\n      math.multiply\\n         data.scalar:\"select coalesce(sum(amount), 0) as sum from transactions t\\n   where affiliate = @affiliate and\\n      date(t.created, '+30 day') < CURRENT_TIMESTAMP and\\n      type = 'charge.succeeded' and not exists(\\n         select * from transactions t2\\n            where t2.type = 'charge.refunded' and\\n               t2.invoice = t.invoice and t2.invoice is not null)\"\\n            @affiliate:x:@auth.ticket.get\\n         get-value:x:@.percent\\n\\n   // Retrieving all withdrawals from database.\\n   set-value:x:@.balance/*/withdrawals\\n      data.scalar:\"select coalesce(sum(amount), 0) as sum from transactions t\\n   where affiliate = @affiliate and type = 'withdrawal'\"\\n         @affiliate:x:@auth.ticket.get\\n\\n   // Applying some HTTP caching since endpoint is kind of expensive to invoke.\\n   response.headers.set\\n      Cache-Control:private, max-age=3600\\n\\n   // Returning result to caller.\\n   return-nodes:x:@.balance/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Special implementation for SQLite."},{"role":"assistant","content":"\\n// Needed to parametrise invocations towards database.\\nauth.ticket.get\\n\\n// Used to store commision percent for affiliate.\\n.percent\\n\\n// Ensuring user is an affiliate\\ndata.connect:[generic|magic]\\n\\n   /*\\n    * Retrieving affiliate percent for user.\\n    * Notice, if user doesn't have an affiliate percent, user ir\\n    * not an affiliate.\\n    */\\n   data.read\\n      table:users_extra\\n      columns\\n         value\\n      where\\n         and\\n            type.eq:affiliate_percent\\n            user.eq:x:@auth.ticket.get\\n   if\\n      not-exists:x:@data.read/*/*/value\\n      .lambda\\n\\n         // Oops ...!!\\n         log.error:User is not affiliate\\n            username:x:@auth.ticket.get\\n         throw:You are not an affiliate\\n            public:true\\n            status:400\\n\\n   // Retrieving transactions from database.\\n   data.select:\"\\nselect strftime('%Y-%m-%d', datetime(u.created)) as date, count(*) as users\\n   from users u\\n      inner join users_extra ue on u.username = ue.user and ue.type = 'affiliate'\\n      where date(u.created, '+42 day') > CURRENT_TIMESTAMP and ue.value = @affiliate\\n   group by date\\n   order by date asc\"\\n      @affiliate:x:@auth.ticket.get\\n\\n   // Looping through all days the last 6 weeks.\\n   .buffer\\n   .cur\\n   set-value:x:@.cur\\n      math.subtract\\n         date.now\\n         time\\n            days:42\\n   while\\n      lt:x:@.cur\\n         date.now\\n      .lambda\\n         date.format:x:@.cur\\n            format:yyyy-MM-dd\\n         if\\n            exists:x:@data.select/*/*/date/={@date.format}\\n            .lambda\\n               get-nodes:x:@data.select/*/*/date/={@date.format}/.\\n               add:x:@.buffer\\n                  get-nodes:x:@data.select/*/*/date/={@date.format}/.\\n         else\\n            unwrap:x:+/*/*/*\\n            add:x:@.buffer\\n               .\\n                  .\\n                     date:x:@date.format\\n                     users:int:0\\n\\n         // Decrementing current day.\\n         set-value:x:@.cur\\n            math.add:x:@.cur\\n               time\\n                  days:1\\n\\n   // Applying some HTTP caching since endpoint is kind of expensive to invoke.\\n   response.headers.set\\n      Cache-Control:private, max-age=3600\\n\\n   // Returning result to caller.\\n   return-nodes:x:@.buffer/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns number of registrations for the last 14 days grouped by day."},{"role":"assistant","content":"\\n// Needed to parametrise invocations towards database.\\nauth.ticket.get\\n\\n// Storing commission for later.\\n.percent\\n\\n// Ensuring user is an affiliate\\ndata.connect:[generic|magic]\\n\\n   /*\\n    * Retrieving affiliate percent for user.\\n    * Notice, if user doesn't have an affiliate percent, user ir\\n    * not an affiliate.\\n    */\\n   data.read\\n      table:users_extra\\n      columns\\n         value\\n      where\\n         and\\n            type.eq:affiliate_percent\\n            user.eq:x:@auth.ticket.get\\n   if\\n      not-exists:x:@data.read/*/*/value\\n      .lambda\\n\\n         // Oops ...!!\\n         log.error:User is not affiliate\\n            username:x:@auth.ticket.get\\n         throw:You are not an affiliate\\n            public:true\\n            status:400\\n\\n   // Storing percentage for later.\\n   convert:x:@data.read/*/*/value\\n      type:decimal\\n   set-value:x:@.percent\\n      math.divide:x:@convert\\n         .:decimal:100\\n\\n// Connecting to Stripe database.\\ndata.connect:[generic|stripe]\\n\\n   // Retrieving transactions from database.\\n   data.select:\"\\nselect strftime('%Y-%m-%d', datetime(t.created)) as date, sum(amount) as amount\\n   from transactions t\\n      where date(t.created, '+42 day') > CURRENT_TIMESTAMP and\\n         t.affiliate = @affiliate and\\n         t.type = 'charge.succeeded'\\n   group by date\\n   order by date asc\"\\n      @affiliate:x:@auth.ticket.get\\n\\n   // Looping through all days the last 6 weeks.\\n   .buffer\\n   .cur\\n   set-value:x:@.cur\\n      math.subtract\\n         date.now\\n         time\\n            days:42\\n   while\\n      lt:x:@.cur\\n         date.now\\n      .lambda\\n         date.format:x:@.cur\\n            format:yyyy-MM-dd\\n         if\\n            exists:x:@data.select/*/*/date/={@date.format}\\n            .lambda\\n               set-value:x:@data.select/*/*/date/={@date.format}/./*/amount\\n                  math.multiply:x:@data.select/*/*/date/={@date.format}/./*/amount\\n                     get-value:x:@.percent\\n               get-nodes:x:@data.select/*/*/date/={@date.format}/.\\n               add:x:@.buffer\\n                  get-nodes:x:@data.select/*/*/date/={@date.format}/.\\n         else\\n            unwrap:x:+/*/*/*\\n            add:x:@.buffer\\n               .\\n                  .\\n                     date:x:@date.format\\n                     amount:int:0\\n\\n         // Decrementing current day.\\n         set-value:x:@.cur\\n            math.add:x:@.cur\\n               time\\n                  days:1\\n\\n   // Applying some HTTP caching since endpoint is kind of expensive to invoke.\\n   response.headers.set\\n      Cache-Control:public, max-age=3600\\n\\n   // Returning result to caller.\\n   return-nodes:x:@.buffer/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Reads contacts from HubSpot"},{"role":"assistant","content":".arguments\\n   after:int\\n\\n// Retrieving token from configuration and verifying it exists.\\nconfig.get:\"magic:hubspot:token\"\\nif\\n   or\\n      eq:x:@config.get\\n         .:\\n      null:x:@config.get\\n   .lambda\\n\\n      // Oops ...!!\\n      throw:No authorization token found in your configuration\\n         public:bool:true\\n         status:int:500\\n.token\\nset-value:x:@.token\\n   strings.concat\\n      .:\"Bearer \"\\n      get-value:x:@config.get\\n\\n// Creating our URL.\\n.url:\"https://api.hubapi.com/crm/v3/objects/contacts\"\\nif\\n   and\\n      exists:x:@.arguments/*/after\\n      not-null:x:@.arguments/*/after\\n      neq:x:@.arguments/*/after\\n         .:\\n   .lambda\\n\\n      // appending QUERY parameter to URL.\\n      set-value:x:@.url\\n         strings.concat\\n            get-value:x:@.url\\n            .:?after=\\n            get-value:x:@.arguments/*/after\\n\\n// Reading contacts from HubSpot.\\nhttp.get:x:@.url\\n   convert:true\\n   headers\\n      Authorization:x:@.token\\n\\n// Verifying above invocation was a success.\\nif\\n   neq:x:@http.get\\n      .:int:200\\n   .lambda\\n\\n      // Oops ...!!\\n      lambda2hyper:x:@http.get\\n      log.error:Could not read contacts from HubSpot\\n         message:x:@lambda2hyper\\n      throw:Something went wrong as we tried to read contacts from HubSpot, check your log for details.\\n         status:int:500\\n         public:bool:true\\n\\n// Returning result of invocation to caller.\\nreturn-nodes:x:@http.get/*/content/*/results/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Creates a contact in HubSpot"},{"role":"assistant","content":".arguments\\n   email:string\\n   firstname:string\\n   lastname:string\\n   phone:string\\n   company:string\\n   website:string\\n   lifecyclestage:string\\n\\n// Sanity checking invoation.\\nvalidators.mandatory:x:@.arguments/*/email\\n\\n// Retrieving token from configuration and verifying it exists.\\nconfig.get:\"magic:hubspot:token\"\\nif\\n   or\\n      eq:x:@config.get\\n         .:\\n      null:x:@config.get\\n   .lambda\\n\\n      // Oops ...!!\\n      throw:No authorization token found in your configuration\\n         public:bool:true\\n         status:int:500\\n.token\\nset-value:x:@.token\\n   strings.concat\\n      .:\"Bearer \"\\n      get-value:x:@config.get\\n\\n// Creating our contact in HubSpot.\\nadd:x:./*/http.post/*/payload/*/properties\\n   get-nodes:x:@.arguments/*\\nhttp.post:\"https://api.hubapi.com/crm/v3/objects/contacts\"\\n   convert:true\\n   headers\\n      Authorization:x:@.token\\n      Content-Type:application/json; charset=utf8\\n   payload\\n      properties\\n\\n// Verifying above invocation was a success.\\nif\\n   neq:x:@http.post\\n      .:int:201\\n   .lambda\\n\\n      // Oops ...!!\\n      lambda2hyper:x:@http.post\\n      log.error:Could not create contact in HubSpot\\n         message:x:@lambda2hyper\\n      throw:Something went wrong as we tried to post a contact to HubSpot, check your log for details.\\n         status:int:500\\n         public:bool:true\\n\\n// Returning success to caller.\\nyield\\n   result:success\\n   id:x:@http.post/*/content/*/id\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Creates an engagement for a contact in HubSpot."},{"role":"assistant","content":".arguments\\n   id:long\\n   note:string\\n\\n// Sanity checking invoation.\\nvalidators.mandatory:x:@.arguments/*/id\\nvalidators.mandatory:x:@.arguments/*/note\\n\\n// Retrieving token from configuration and verifying it exists.\\nconfig.get:\"magic:hubspot:token\"\\nif\\n   or\\n      eq:x:@config.get\\n         .:\\n      null:x:@config.get\\n   .lambda\\n\\n      // Oops ...!!\\n      throw:No authorization token found in your configuration\\n         public:bool:true\\n         status:int:500\\n.token\\nset-value:x:@.token\\n   strings.concat\\n      .:\"Bearer \"\\n      get-value:x:@config.get\\n\\n// Getting current timestamp.\\ndate.now\\n\\n// Getting owner ID.\\n.owner\\nconfig.get:\"magic:hubspot:owner\"\\nset-value:x:@.owner\\n   convert:x:@config.get\\n      type:long\\n\\n// Creating our contact in HubSpot.\\nhttp.post:\"https://api.hubapi.com/crm/v3/objects/notes\"\\n   headers\\n      Authorization:x:@.token\\n      Content-Type:application/json; charset=utf8\\n   payload\\n      properties\\n         hs_note_body:x:@.arguments/*/note\\n         hs_timestamp:x:@date.now\\n         hubspot_owner_id:x:@.owner\\n      associations\\n         .\\n            to\\n               id:x:@.arguments/*/id\\n            types\\n               .\\n                  associationCategory:HUBSPOT_DEFINED\\n                  associationTypeId:int:202\\n\\n// Verifying above invocation was a success.\\nif\\n   neq:x:@http.post\\n      .:int:201\\n   .lambda\\n\\n      // Oops ...!!\\n      lambda2hyper:x:@http.post\\n      log.error:Could not create contact in HubSpot\\n         message:x:@lambda2hyper\\n      throw:Something went wrong as we tried to post a contact to HubSpot, check your log for details.\\n         status:int:500\\n         public:bool:true\\n\\n// Returning success to caller.\\nreturn\\n   result:success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Reads contacts from HubSpot\\n\\nThis workflow will read contacts from your HubSpot account.\\n[after] is optional and if specified is a contact ID from which contacts should be returned,\\nimplying 'all contacts after the contact with the specified ID'."},{"role":"assistant","content":".arguments\\n   after:string\\n.type:public\\n\\n// Forwarding request to our HTTP POST Hyperlambda file.\\nadd:x:./*/execute-file\\n   get-nodes:x:@.arguments/*\\nexecute-file:/modules/hubspot/contacts.get.hl\\n\\n// Returning whatever above invocation returned.\\nadd:x:./*/return\\n   get-nodes:x:@execute-file/*\\nreturn\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Creates a new object in NetSuite of the specified [type].\\n\\nThe [type] argument is mandatory and can be any type that NetSuite supports, such as for instance:\\n\\n- account\\n- contact\\n- customer\\n- department\\n- deposit\\n- employee\\n- invoice\\n- etc ...\\n\\nThe [object] argument is mandatory and contains a key/value list of fields you wish to associate\\nwith the object."},{"role":"assistant","content":".arguments\\n\\n   // Mandatory argument declaring the type of entity we want to create.\\n   type:string\\n\\n   // Mandatory argument declaring the actual content of the new entity we want to create.\\n   object:*\\n.type:public\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/type\\nvalidators.mandatory:x:@.arguments/*/object\\nvalidators.mandatory:x:@.arguments/*/object/0\\n\\n/*\\n * Returns an access token for NetSuite.\\n * \\n * Returns a JWT token that can be used to invoke NetSuite according to your configuration settings.\\n * Notice, this will read account-id, certificate-id, and consumer-key from your configuration settings,\\n * in addition to assume your private key exists in the file '/etc/netsuite/private-key.txt'.\\n */\\nexecute:magic.workflows.actions.execute\\n   name:netsuite-get-access-token\\n   filename:/modules/netsuite/workflows/actions/netsuite-get-access-token.hl\\n   arguments\\n\\n// Creating our idempotency key to prevent replay attacks.\\nguid.new\\n\\n// Creating invocation URL.\\n.url\\nset-value:x:@.url\\n   strings.concat\\n      .:\"https://\"\\n      config.get:\"magic:netsuite:account-id\"\\n      .:.suitetalk.api.netsuite.com/services/rest/record/v1\\n      .:/\\n      get-value:x:@.arguments/*/type\\n\\n// Parametrizing our payload.\\nadd:x:./*/http.post/*/payload\\n   get-nodes:x:@.arguments/*/object/*\\n\\n// Invoking our HTTP GET endpoint, now correctly parametrised.\\nhttp.post:x:@.url\\n   token:x:--/execute/=netsuite-get-access-token/*/access-token\\n   headers\\n      X-NetSuite-Idempotency-Key:x:@guid.new\\n      Content-Type:application/json; charset=UTF-8\\n   payload\\n\\n// Sanity checking above invocation.\\nif\\n   not\\n      and\\n         mte:x:@http.post\\n            .:int:200\\n         lt:x:@http.post\\n            .:int:300\\n   .lambda\\n\\n      // Oops, error ...!!\\n      json2lambda:x:@http.post\\n      lambda2hyper:x:@json2lambda\\n      log.error:x:@lambda2hyper\\n      throw:Could not create entity in NetSuite, check your log for details.\\n\\n// Returning success to caller.\\nreturn\\n   result:success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Deletes a single object in NetSuite.\\n\\nThe [type] argument is mandatory and can be any type that NetSuite supports, such as for instance:\\n\\n- account\\n- campaign\\n- contact\\n- customer\\n- department\\n- deposit\\n- employee\\n- invoice\\n- etc ...\\n\\nThe [id] argument is mandatory and is the ID of the entity to delete."},{"role":"assistant","content":".arguments\\n\\n   // Mandatory argument declaring the type of entity we want to delete.\\n   type:string\\n\\n   // Mandatory argument declaring the ID of the entity we should delete.\\n   id:long\\n.type:public\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/id\\nvalidators.mandatory:x:@.arguments/*/type\\n\\n/*\\n * Returns an access token for NetSuite.\\n * \\n * Returns a JWT token that can be used to invoke NetSuite according to your configuration settings.\\n * Notice, this will read account-id, certificate-id, and consumer-key from your configuration settings,\\n * in addition to assume your private key exists in the file '/etc/netsuite/private-key.txt'.\\n */\\nexecute:magic.workflows.actions.execute\\n   name:netsuite-get-access-token\\n   filename:/modules/netsuite/workflows/actions/netsuite-get-access-token.hl\\n   arguments\\n\\n// Creating our idempotency key to prevent replay attacks.\\nguid.new\\n\\n// Creating invocation URL.\\n.url\\nset-value:x:@.url\\n   strings.concat\\n      .:\"https://\"\\n      config.get:\"magic:netsuite:account-id\"\\n      .:.suitetalk.api.netsuite.com/services/rest/record/v1\\n      .:/\\n      get-value:x:@.arguments/*/type\\n      .:/\\n      get-value:x:@.arguments/*/id\\n\\n// Invoking our HTTP GET endpoint, now correctly parametrised.\\nhttp.delete:x:@.url\\n   token:x:--/execute/=netsuite-get-access-token/*/access-token\\n   headers\\n      X-NetSuite-Idempotency-Key:x:@guid.new\\n\\n// Sanity checking above invocation.\\nif\\n   not\\n      and\\n         mte:x:@http.delete\\n            .:int:200\\n         lt:x:@http.delete\\n            .:int:300\\n   .lambda\\n\\n      // Oops, error ...!!\\n      convert:x:@http.delete/*/content\\n         type:string\\n      log.error:Could not delete entity in NetSuite\\n         response:x:@convert\\n      throw:Could not delete entity in NetSuite, check your log for details.\\n\\n// Returning success to caller.\\nreturn\\n   result:success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns a single object from NetSuite to caller.\\n\\nThe [type] argument is mandatory and can be any type that NetSuite supports, such as for instance:\\n\\n- account\\n- calendarEvent\\n- campaign\\n- cashSale\\n- contact\\n- customer\\n- department\\n- deposit\\n- employee\\n- invoice\\n- etc ...\\n\\nThe [id] argument is mandatory and is the ID of the entity to retrieve."},{"role":"assistant","content":".arguments\\n\\n   // Mandatory argument declaring the type of entity we want to retrieve.\\n   type:string\\n\\n   // Mandatory argument declaring the ID of the entity we should return.\\n   id:long\\n.type:public\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/id\\nvalidators.mandatory:x:@.arguments/*/type\\n\\n/*\\n * Returns an access token for NetSuite.\\n * \\n * Returns a JWT token that can be used to invoke NetSuite according to your configuration settings.\\n * Notice, this will read account-id, certificate-id, and consumer-key from your configuration settings,\\n * in addition to assume your private key exists in the file '/etc/netsuite/private-key.txt'.\\n */\\nexecute:magic.workflows.actions.execute\\n   name:netsuite-get-access-token\\n   filename:/modules/netsuite/workflows/actions/netsuite-get-access-token.hl\\n   arguments\\n\\n// Creating our idempotency key to prevent replay attacks.\\nguid.new\\n\\n// Creating invocation URL.\\n.url\\nset-value:x:@.url\\n   strings.concat\\n      .:\"https://\"\\n      config.get:\"magic:netsuite:account-id\"\\n      .:.suitetalk.api.netsuite.com/services/rest/record/v1\\n      .:/\\n      get-value:x:@.arguments/*/type\\n      .:/\\n      get-value:x:@.arguments/*/id\\n\\n// Invoking our HTTP GET endpoint, now correctly parametrised.\\nhttp.get:x:@.url\\n   token:x:--/execute/=netsuite-get-access-token/*/access-token\\n   headers\\n      X-NetSuite-Idempotency-Key:x:@guid.new\\n\\n// Converts the result to a lambda object.\\njson2lambda:x:@http.get/*/content\\n\\n// Cleaning up redundant stuff.\\nremove-nodes:x:@json2lambda/*/category\\nremove-nodes:x:@json2lambda/**/links\\n\\n// Sanity checking above invocation.\\nif\\n   not\\n      and\\n         mte:x:@http.get\\n            .:int:200\\n         lt:x:@http.get\\n            .:int:300\\n   .lambda\\n\\n      // Oops, error ...!!\\n      lambda2hyper:x:@json2lambda\\n      log.error:x:@lambda2hyper\\n      throw:Could not get entity from NetSuite, check your log for details.\\n\\n// Returning our entity to caller.\\nreturn:x:@json2lambda/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns a list of objects from NetSuite to caller according to arguments.\\n\\nThe [type] argument is mandatory and can be any type that NetSuite supports, such as for instance:\\n\\n- account\\n- campaign\\n- contact\\n- customer\\n- department\\n- deposit\\n- employee\\n- invoice\\n- etc ...\\n\\nThis workflow"},{"role":"assistant","content":".arguments\\n\\n   // Mandatory argument declaring the type of objects we want to return.\\n   type:string\\n\\n   // Optional limit for how many records to select. Defaults to 10 if not specified.\\n   limit:long\\n\\n   // Optional from argument declaring from what ID the workflow should start returning records from.\\n   from:long\\n\\n   // Optional filtering column which if specified declares a column that records must match on the [value] specified below.\\n   column:string\\n\\n   // Optional filtering value which if specified declares the value that records must match on the [column] specified above. Value can be for instance 'john%' which combined with the above [column] being firstname will return all records having a first name containing the string 'john'.\\n   value:string\\n.type:public\\n\\n// Sanity checking invocation and applying defaults.\\nvalidators.mandatory:x:@.arguments/*/type\\nvalidators.regex:x:@.arguments/*/type\\n   regex:^[a-z0-9-_]+$\\nvalidators.regex:x:@.arguments/*/column\\n   regex:^[a-z0-9-_]+$\\nvalidators.default:x:@.arguments\\n   limit:long:10\\n\\n/*\\n * Returns an access token for NetSuite.\\n * \\n * Returns a JWT token that can be used to invoke NetSuite according to your configuration settings.\\n * Notice, this will read account-id, certificate-id, and consumer-key from your configuration settings,\\n * in addition to assume your private key exists in the file '/etc/netsuite/private-key.txt'.\\n */\\nexecute:magic.workflows.actions.execute\\n   name:netsuite-get-access-token\\n   filename:/modules/netsuite/workflows/actions/netsuite-get-access-token.hl\\n   arguments\\n\\n// Creating invocation URL.\\n.url\\nset-value:x:@.url\\n   strings.concat\\n      .:\"https://\"\\n      config.get:\"magic:netsuite:account-id\"\\n      .:.suitetalk.api.netsuite.com/services/rest/query/v1/suiteql\\n\\n// Creating our query.\\n.query\\nset-value:x:@.query\\n   strings.concat\\n      .:\"select * from \"\\n      get-value:x:@.arguments/*/type\\n\\n// Checking if we're doing paging.\\n.paging:bool:false\\nif\\n   and\\n      exists:x:@.arguments/*/from\\n      not-null:x:@.arguments/*/from\\n   .lambda\\n\\n      // Doing paging.\\n      set-value:x:@.paging\\n         .:bool:true\\n      set-value:x:@.query\\n         strings.concat\\n            get-value:x:@.query\\n            .:\" where id > \"\\n            get-value:x:@.arguments/*/from\\n\\n// Checking if we're doing filtering.\\nif\\n   and\\n      exists:x:@.arguments/*/value\\n      exists:x:@.arguments/*/column\\n      not-null:x:@.arguments/*/value\\n      not-null:x:@.arguments/*/column\\n   .lambda\\n\\n      // Doing filtering, checking if we've done paging.\\n      if:x:@.paging\\n         set-value:x:@.query\\n            strings.concat\\n               get-value:x:@.query\\n               .:\" and\"\\n      else\\n         set-value:x:@.query\\n            strings.concat\\n               get-value:x:@.query\\n               .:\" where\"\\n      set-value:x:@.query\\n         strings.concat\\n            get-value:x:@.query\\n            .:\" \"\\n            get-value:x:@.arguments/*/column\\n            .:\" like '\"\\n            strings.replace:x:@.arguments/*/value\\n               .:\"'\"\\n               .:\"''\"\\n            .:\"'\"\\n\\n// Adding order by parts.\\nset-value:x:@.query\\n   strings.concat\\n      get-value:x:@.query\\n      .:\" order by id fetch first \"\\n      get-value:x:@.arguments/*/limit\\n      .:\" rows only\"\\n\\n// Creating our idempotency key to prevent replay attacks.\\nguid.new\\n\\n// Invoking our HTTP POST endpoint, now correctly parametrised.\\nhttp.post:x:@.url\\n   token:x:--/execute/=netsuite-get-access-token/*/access-token\\n   headers\\n      X-NetSuite-Idempotency-Key:x:@guid.new\\n      Prefer:transient\\n   payload\\n      q:x:@.query\\n\\n// Converts the result to a lambda object.\\njson2lambda:x:@http.post/*/content\\n\\n// Sanity checking above invocation.\\nif\\n   not\\n      and\\n         mte:x:@http.post\\n            .:int:200\\n         lt:x:@http.post\\n            .:int:300\\n   .lambda\\n\\n      // Oops, error ...!!\\n      lambda2hyper:x:@json2lambda\\n      log.error:x:@lambda2hyper\\n      throw:Could not retrieve objects from NetSuite, check your log for details.\\n\\n// Cleaning up redundant stuff.\\nremove-nodes:x:@json2lambda/*/items/*/*/links\\n\\n// Returning entities to caller.\\nyield\\n   items:x:@json2lambda/*/items/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns a list of IDs from NetSuite to caller according to arguments.\\n\\nThe [type] argument is mandatory and can be any type that NetSuite supports, such as for instance:\\n\\n- account\\n- campaign\\n- contact\\n- customer\\n- department\\n- deposit\\n- employee\\n- invoice\\n- etc ...\\n\\nThis workflow allows for filtering and paging and will return 1000 records by default, unless\\nexplicitly changed by providing a [limit] argument.\\n\\nNotice, this workflow does not return anything but the IDs of the records you are requesting."},{"role":"assistant","content":".arguments\\n\\n   // Mandatory argument declaring the type of entities we want to list.\\n   type:string\\n\\n   // Optional filtering for contacts to search for.\\n   q:string\\n\\n   // Optional limit for how many records to select. Defaults to 1000 if not specified.\\n   limit:long\\n\\n   // Optional offset of where to start returning records. Defaults to 0 if not specified.\\n   offset:long\\n.type:public\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/type\\n\\n/*\\n * Returns an access token for NetSuite.\\n * \\n * Returns a JWT token that can be used to invoke NetSuite according to your configuration settings.\\n * Notice, this will read account-id, certificate-id, and consumer-key from your configuration settings,\\n * in addition to assume your private key exists in the file '/etc/netsuite/private-key.txt'.\\n */\\nexecute:magic.workflows.actions.execute\\n   name:netsuite-get-access-token\\n   filename:/modules/netsuite/workflows/actions/netsuite-get-access-token.hl\\n   arguments\\n\\n// Creating our idempotency key to prevent replay attacks.\\nguid.new\\n\\n// Creating invocation URL.\\n.url\\nset-value:x:@.url\\n   strings.concat\\n      .:\"https://\"\\n      config.get:\"magic:netsuite:account-id\"\\n      .:.suitetalk.api.netsuite.com/services/rest/record/v1\\n      .:/\\n      get-value:x:@.arguments/*/type\\n\\n// Removing type to avoid unsupported query parameter.\\nremove-nodes:x:@.arguments/*/type\\n\\n// Invoking our HTTP GET endpoint, now correctly parametrised.\\nhttp.get:x:@.url\\n   token:x:--/execute/=netsuite-get-access-token/*/access-token\\n   headers\\n      X-NetSuite-Idempotency-Key:x:@guid.new\\n   query:x:@.arguments/*\\n\\n// Converts the result to a lambda object.\\njson2lambda:x:@http.get/*/content\\n\\n// Sanity checking above invocation.\\nif\\n   not\\n      and\\n         mte:x:@http.get\\n            .:int:200\\n         lt:x:@http.get\\n            .:int:300\\n   .lambda\\n\\n      // Oops, error ...!!\\n      lambda2hyper:x:@json2lambda\\n      log.error:x:@lambda2hyper\\n      throw:Could not list entities from NetSuite, check your log for details.\\n\\n// Cleaning up redundant stuff.\\nremove-nodes:x:@json2lambda/*/items/*/*/links\\n\\n// Returning entities to caller.\\nyield\\n   items:x:@json2lambda/*/items/*\\n   totalResults:x:@json2lambda/*/totalResults\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns the Swagger and OpenAPI specification for the specified [type] from NetSuite\\n\\nThe [type] argument is mandatory and declares the type of object you want to retrieve OpenAPI specification for."},{"role":"assistant","content":".arguments\\n\\n   // Type of object the caller wants the OpenAPI spec for.\\n   type:string\\n.type:public\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/type\\n\\n/*\\n * Returns an access token for NetSuite.\\n * \\n * Returns a JWT token that can be used to invoke NetSuite according to your configuration settings.\\n * Notice, this will read account-id, certificate-id, and consumer-key from your configuration settings,\\n * in addition to assume your private key exists in the file '/etc/netsuite/private-key.txt'.\\n */\\nexecute:magic.workflows.actions.execute\\n   name:netsuite-get-access-token\\n   filename:/modules/netsuite/workflows/actions/netsuite-get-access-token.hl\\n   arguments\\n\\n// Creating our idempotency key to prevent replay attacks.\\nguid.new\\n\\n// Creating invocation URL.\\n.url\\nset-value:x:@.url\\n   strings.concat\\n      .:\"https://\"\\n      config.get:\"magic:netsuite:account-id\"\\n      .:.suitetalk.api.netsuite.com/services/rest/record/v1/metadata-catalog\\n      .:/\\n      get-value:x:@.arguments/*/type\\n\\n// Invoking our HTTP GET endpoint, now correctly parametrised.\\nhttp.get:x:@.url\\n   token:x:--/execute/=netsuite-get-access-token/*/access-token\\n   headers\\n      Accept:application/swagger+json\\n      X-NetSuite-Idempotency-Key:x:@guid.new\\n\\n// Converts the result to a lambda object.\\njson2lambda:x:@http.get/*/content\\n\\n// Sanity checking above invocation.\\nif\\n   not\\n      and\\n         mte:x:@http.get\\n            .:int:200\\n         lt:x:@http.get\\n            .:int:300\\n   .lambda\\n\\n      // Oops, error ...!!\\n      lambda2hyper:x:@json2lambda\\n      log.error:x:@lambda2hyper\\n      throw:Could not get entity from NetSuite, check your log for details.\\n\\n// Returning our entity to caller.\\nreturn:x:@json2lambda/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns the schema specification for the specified [type] from NetSuite\\n\\nThe [type] argument is mandatory and declares the type of object you want to retrieve the schema specification for."},{"role":"assistant","content":".arguments\\n\\n   // Type of object the caller wants the schema spec for.\\n   type:string\\n.type:public\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/type\\n\\n/*\\n * Returns an access token for NetSuite.\\n * \\n * Returns a JWT token that can be used to invoke NetSuite according to your configuration settings.\\n * Notice, this will read account-id, certificate-id, and consumer-key from your configuration settings,\\n * in addition to assume your private key exists in the file '/etc/netsuite/private-key.txt'.\\n */\\nexecute:magic.workflows.actions.execute\\n   name:netsuite-get-access-token\\n   filename:/modules/netsuite/workflows/actions/netsuite-get-access-token.hl\\n   arguments\\n\\n// Creating our idempotency key to prevent replay attacks.\\nguid.new\\n\\n// Creating invocation URL.\\n.url\\nset-value:x:@.url\\n   strings.concat\\n      .:\"https://\"\\n      config.get:\"magic:netsuite:account-id\"\\n      .:.suitetalk.api.netsuite.com/services/rest/record/v1/metadata-catalog\\n      .:/\\n      get-value:x:@.arguments/*/type\\n\\n// Invoking our HTTP GET endpoint, now correctly parametrised.\\nhttp.get:x:@.url\\n   token:x:--/execute/=netsuite-get-access-token/*/access-token\\n   headers\\n      Accept:application/schema+json\\n      X-NetSuite-Idempotency-Key:x:@guid.new\\n\\n// Converts the result to a lambda object.\\njson2lambda:x:@http.get/*/content\\n\\n// Sanity checking above invocation.\\nif\\n   not\\n      and\\n         mte:x:@http.get\\n            .:int:200\\n         lt:x:@http.get\\n            .:int:300\\n   .lambda\\n\\n      // Oops, error ...!!\\n      lambda2hyper:x:@json2lambda\\n      log.error:x:@lambda2hyper\\n      throw:Could not get entity from NetSuite, check your log for details.\\n\\n// Returning our entity to caller.\\nreturn:x:@json2lambda/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Updates an existing object in NetSuite of the specified [type].\\n\\nThe [type] argument is mandatory and can be any type that NetSuite supports, such as for instance:\\n\\n- account\\n- campaign\\n- contact\\n- customer\\n- department\\n- deposit\\n- employee\\n- invoice\\n- etc ...\\n\\nThe [object] argument is mandatory and contains a key/value list of fields you wish to update."},{"role":"assistant","content":".arguments\\n\\n   // Mandatory argument declaring the type of entity we want to create.\\n   type:string\\n\\n   // Mandatory argument declaring the ID of the entity we should update.\\n   id:long\\n\\n   // Mandatory argument declaring the actual content of the new entity we want to create.\\n   object:*\\n.type:public\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/id\\nvalidators.mandatory:x:@.arguments/*/type\\nvalidators.mandatory:x:@.arguments/*/object\\nvalidators.mandatory:x:@.arguments/*/object/0\\n\\n/*\\n * Returns an access token for NetSuite.\\n * \\n * Returns a JWT token that can be used to invoke NetSuite according to your configuration settings.\\n * Notice, this will read account-id, certificate-id, and consumer-key from your configuration settings,\\n * in addition to assume your private key exists in the file '/etc/netsuite/private-key.txt'.\\n */\\nexecute:magic.workflows.actions.execute\\n   name:netsuite-get-access-token\\n   filename:/modules/netsuite/workflows/actions/netsuite-get-access-token.hl\\n   arguments\\n\\n// Creating our idempotency key to prevent replay attacks.\\nguid.new\\n\\n// Creating invocation URL.\\n.url\\nset-value:x:@.url\\n   strings.concat\\n      .:\"https://\"\\n      config.get:\"magic:netsuite:account-id\"\\n      .:.suitetalk.api.netsuite.com/services/rest/record/v1\\n      .:/\\n      get-value:x:@.arguments/*/type\\n      .:/\\n      get-value:x:@.arguments/*/id\\n\\n// Parametrizing our payload.\\nadd:x:./*/http.patch/*/payload\\n   get-nodes:x:@.arguments/*/object/*\\n\\n// Invoking our HTTP GET endpoint, now correctly parametrised.\\nhttp.patch:x:@.url\\n   token:x:--/execute/=netsuite-get-access-token/*/access-token\\n   headers\\n      X-NetSuite-Idempotency-Key:x:@guid.new\\n      Content-Type:application/json; charset=UTF-8\\n   payload\\n\\n// Sanity checking above invocation.\\nif\\n   not\\n      and\\n         mte:x:@http.patch\\n            .:int:200\\n         lt:x:@http.patch\\n            .:int:300\\n   .lambda\\n\\n      // Oops, error ...!!\\n      convert:x:@http.patch/*/content\\n         type:string\\n      log.error:Could not delete entity in NetSuite\\n         response:x:@convert\\n      throw:Could not delete entity in NetSuite, check your log for details.\\n\\n// Returning success to caller.\\nreturn\\n   result:success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns an access token for NetSuite.\\n\\nReturns a JWT token that can be used to invoke NetSuite according to your configuration settings.\\nNotice, this will read account-id, certificate-id, and consumer-key from your configuration settings,\\nin addition to assume your private key exists in the file '/etc/netsuite/private-key.txt'."},{"role":"assistant","content":".arguments\\n.icon:http\\n\\n// Loading private key.\\n.key\\nset-value:x:@.key\\n   io.file.load:/etc/netsuite/private-key.txt\\n\\n/*\\n * Loading settings from configuration.\\n * \\n * Notice, these settings must exist for the system to function.\\n */\\n\\n// Account id\\n.account-id\\nset-value:x:@.account-id\\n   config.get:\"magic:netsuite:account-id\"\\nvalidators.mandatory:x:@.account-id\\n\\n// Certificate id\\n.certificate-id\\nset-value:x:@.certificate-id\\n   config.get:\"magic:netsuite:certificate-id\"\\nvalidators.mandatory:x:@.certificate-id\\n\\n// Consumer key\\n.consumer-key\\nset-value:x:@.consumer-key\\n   config.get:\"magic:netsuite:consumer-key\"\\nvalidators.mandatory:x:@.consumer-key\\n\\n// Invoking slot doing the heavy lifting.\\nnetsuite.get-access-token\\n   private-key:x:@.key\\n   account-id:x:@.account-id\\n   certificate-id:x:@.certificate-id\\n   consumer-key:x:@.consumer-key\\n\\n// Returning result to caller.\\nyield\\n   access-token:x:@netsuite.get-access-token\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Compiles C# code files required to wire up module correctly.\\n\\nNetSuite contains a couple of custom C# code files which we'll need to correctly wire up things."},{"role":"assistant","content":"\\n// Loading file.\\nio.file.load:/modules/netsuite/magic.startup/csharp/GenerateToken.cs.raw\\n\\n// Compiling file into an assembly.\\nsystem.compile\\n   references\\n      .:netstandard\\n      .:System.Linq\\n      .:System.Runtime\\n      .:System.Net.Http\\n      .:System.Private.Uri\\n      .:System.ComponentModel\\n      .:System.Private.CoreLib\\n      .:System.Linq.Expressions\\n      .:System.Security.Cryptography\\n      .:Microsoft.IdentityModel.Tokens\\n      .:System.IdentityModel.Tokens.Jwt\\n      .:Microsoft.IdentityModel.Abstractions\\n      .:Newtonsoft.Json\\n      .:magic.node\\n      .:magic.node.extensions\\n      .:magic.signals.contracts\\n      .:System.Net.Primitives\\n   code:x:@io.file.load\\n   assembly-name:dynamic.magic.lambda.netsuite.dll\\n\\n// Loading assembly as plugin now that we've created it.\\nsystem.plugin.load:x:@system.compile\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Ensures our configuration folder exists, where the private key to sign requests needs to exist"},{"role":"assistant","content":"if\\n   not\\n      io.folder.exists:/etc/netsuite/\\n   .lambda\\n\\n      // Creating folder.\\n      io.folder.create:/etc/netsuite/\\n\\n      // Creating default README file in folder.\\n      io.file.save:/etc/netsuite/README.md\\n         .:@\"## NetSuite Configuration files folder\\n\\nPut your private key in this folder with a filename of 'private-key.txt'\\n\"\\n\\n      // Performing basic logging.\\n      log.info:NetSuite configuration folder created\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Ensure we create the required NetSuite related role(s)."},{"role":"assistant","content":"signal:magic.auth.ensure-role\\n   role:netsuite\\n   description:Users that should be able to access NetSuite related endpoints and workflows\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns IDs of the specified [type] to caller\\n\\nOptionally supply query and paging arguments.\\n\\nNotice, this workflow does not return anything but the IDs of the records you are requesting."},{"role":"assistant","content":".arguments\\n\\n   // Type of objects you want to retrieve. Mandatory.\\n   type:string\\n\\n   // Optional query for retrieval.\\n   q:string\\n\\n   // Optional maximum number of objects to return.\\n   limit:long\\n\\n   // Optional offset of where to start retrieving objects.\\n   offset:long\\n\\n// Ensuring user is authorized to invoking endpoint.\\nauth.ticket.verify:netsuite\\n\\n// Forwarding heavy lifting to workflow file.\\nadd:x:./*/execute-file\\n   get-nodes:x:@.arguments/*\\nexecute-file:/modules/netsuite/workflows/workflows/netsuite-list-records.hl\\n\\n// Returning result to caller.\\nreturn-nodes:x:@execute-file/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Executes the specified SuiteQL towards your NetSuite account.\\n\\nThe [q] argument is mandatory and declares the query you want to execute."},{"role":"assistant","content":".arguments\\n\\n   // Mandatory SuiteQL query you want to execute.\\n   q:string\\n\\n// Ensuring user is authorized to invoking endpoint.\\nauth.ticket.verify:netsuite\\n\\n// Forwarding heavy lifting to workflow file.\\nadd:x:./*/execute-file\\n   get-nodes:x:@.arguments/*\\nexecute-file:/modules/netsuite/workflows/workflows/netsuite-query.hl\\n\\n// Returning result to caller.\\nreturn-nodes:x:@execute-file/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Deletes a single object of the specified [type] in NetSuite.\\n\\nThe [type] argument declares the type of object you want to delete, and the [id]\\nargument declares its id. Both arguments are mandatory."},{"role":"assistant","content":".arguments\\n\\n   // Mandatory argument declaring what type of object you want to delete.\\n   type:string\\n\\n   // Mandatory argument being the id of the object you want to delete.\\n   id:long\\n\\n// Ensuring user is authorized to invoking endpoint.\\nauth.ticket.verify:netsuite\\n\\n// Forwarding heavy lifting to workflow file.\\nadd:x:./*/execute-file\\n   get-nodes:x:@.arguments/*\\nexecute-file:/modules/netsuite/workflows/workflows/netsuite-delete-record.hl\\n\\n// Returning result to caller.\\nreturn-nodes:x:@execute-file/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns a single object of the specified [type] to caller\\n\\nThe [id] wrgument is mandatory and declares the id of the object you want to retrieve"},{"role":"assistant","content":".arguments\\n\\n   // Mandatory argument declaring the type of object you want to retrieve.\\n   type:string\\n\\n   // Mandatory argument being the id of the object you want to retrieve.\\n   id:string\\n\\n// Ensuring user is authorized to invoking endpoint.\\nauth.ticket.verify:netsuite\\n\\n// Forwarding heavy lifting to workflow file.\\nadd:x:./*/execute-file\\n   get-nodes:x:@.arguments/*\\nexecute-file:/modules/netsuite/workflows/workflows/netsuite-get-record.hl\\n\\n// Returning result to caller.\\nreturn-nodes:x:@execute-file/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Updates an existing object of the specified [type] with the specified fields from [object].\\n\\nThe [object] argument depends upon the [type] of object we're updating, but is a key/value list of fields\\nyou want to update in your object.\\nThe [id] argument is the id of the object you want to update."},{"role":"assistant","content":".arguments\\n\\n   // Type of object to update. Mandatory.\\n   type:string\\n\\n   // Id of object to update. Mandatory.\\n   id:long\\n\\n   // Key/value list of fields to update in object. Mandatory.\\n   object:*\\n\\n// Ensuring user is authorized to invoking endpoint.\\nauth.ticket.verify:netsuite\\n\\n// Forwarding heavy lifting to workflow file.\\nadd:x:./*/execute-file\\n   get-nodes:x:@.arguments/*\\nexecute-file:/modules/netsuite/workflows/workflows/netsuite-update-record.hl\\n\\n// Returning result to caller.\\nreturn-nodes:x:@execute-file/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Creates a new object of the specified [type] with the specified fields from [object].\\n\\nThe [object] argument depends upon the [type] of object we're creating, but is a key/value list of fields\\nyou want to associate your object with."},{"role":"assistant","content":".arguments\\n\\n   // Type of object to create. Mandatory.\\n   type:string\\n\\n   // Key/value list of fields to update in the object. Mandatory.\\n   object:*\\n\\n// Ensuring user is authorized to invoking endpoint.\\nauth.ticket.verify:netsuite\\n\\n// Forwarding heavy lifting to workflow file.\\nadd:x:./*/execute-file\\n   get-nodes:x:@.arguments/*\\nexecute-file:/modules/netsuite/workflows/workflows/netsuite-create-record.hl\\n\\n// Returning result to caller.\\nreturn-nodes:x:@execute-file/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns objects of the specified [type] to caller\\n\\nThis endpoint allows you to page records by sorting on ID and allowing you to provide\\na [from] argument being the highest ID from your previous result set.\\n\\nNotice, this workflow returns the entire object, including all fields."},{"role":"assistant","content":".arguments\\n\\n   // Type of objects you want to retrieve. Mandatory.\\n   type:string\\n\\n   // Optional maximum number of objects to return. Defaults to 10 if not specified.\\n   limit:long\\n\\n   // Optional offset of where to start retrieving objects.\\n   from:long\\n\\n// Ensuring user is authorized to invoking endpoint.\\nauth.ticket.verify:netsuite\\n\\n// Forwarding heavy lifting to workflow file.\\nadd:x:./*/execute-file\\n   get-nodes:x:@.arguments/*\\nexecute-file:/modules/netsuite/workflows/workflows/netsuite-get-records.hl\\n\\n// Returning result to caller.\\nreturn-nodes:x:@execute-file/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns the schema specifications for the specified [type].\\n\\nThe [type] agrument is mandatory and declares what type of object you want the schema specification for."},{"role":"assistant","content":".arguments\\n\\n   // Mandatory argument declaring the type of object to retrieve the schema specification for.\\n   type:string\\n\\n// Ensuring user is authorized to invoking endpoint.\\nauth.ticket.verify:netsuite\\n\\n// Forwarding heavy lifting to workflow file.\\nadd:x:./*/execute-file\\n   get-nodes:x:@.arguments/*\\nexecute-file:/modules/netsuite/workflows/workflows/netsuite-schema-spec.hl\\n\\n// Returning result to caller.\\nreturn-nodes:x:@execute-file/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Creates a new training snippet with the specified [prompt] and [completion]\\n\\nThis function will create a new training snippet the AI can use as context later as it's answering questions. Training snippets created with this function will become a part of your RAG / VSS database allowing the AI to later use these as context data when answering questions, arguably creating long term memory for the AI."},{"role":"assistant","content":".arguments\\n   _type:string\\n\\n   // Mandatory and the title of the training snippet. This should be a short summary about the most important parts of the content with some keywords. Unless the user explicitly specified a prompt value, then generate a high quality prompt value describing the training snippet as a single sentence with some keywords that makes it easy to find using VSS\\n   prompt:string\\n\\n   // Mandatory and the primary content of your training snippet\\n   completion:string\\n\\n   // Optional and if supplied is the URL from where the information was found\\n   uri:string\\n.type:public\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/_type\\nvalidators.mandatory:x:@.arguments/*/prompt\\nvalidators.mandatory:x:@.arguments/*/completion\\n\\n// Opening up our database connection.\\ndata.connect:[generic|magic]\\n\\n   // Making sure snippet exists.\\n   data.create\\n      table:ml_training_snippets\\n      return-id:bool:true\\n      values\\n         type:x:@.arguments/*/_type\\n         prompt:x:@.arguments/*/prompt\\n         completion:x:@.arguments/*/completion\\n         uri:x:@.arguments/*/uri\\n\\n   // Re-vectorising the type.\\n   execute:magic.ai.vectorise\\n      type:x:@.arguments/*/_type\\n\\n   // Returning success to caller.\\n   yield\\n      result:success\\n      id:x:@data.create\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Deletes the training snippet with the specified [id]\\n\\nThis function will delete the training snippet with the specified [id], removing it entirely from the system's RAG / VSS database, implying it will no longer be used as context information when the user is asking questions to the AI."},{"role":"assistant","content":".arguments\\n\\n   // Mandatory and is the ID of the training snippet to delete.\\n   id:int\\n.type:public\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/id\\nvalidators.integer:x:@.arguments/*/id\\n   min:int:0\\n\\n// Opening up our database connection.\\ndata.connect:[generic|magic]\\n\\n   // Making sure snippet exists.\\n   data.read\\n      table:ml_training_snippets\\n      columns\\n         prompt\\n         completion\\n         uri\\n      where\\n         and\\n            id.eq:x:@.arguments/*/id\\n   if\\n      not-exists:x:@data.read/*\\n      .lambda\\n         throw:Now such snippet\\n         public:bool:true\\n         status:int:401\\n\\n   // Deleting snippet.\\n   data.execute:delete from vss_ml_training_snippets where rowid = @id\\n      @id:x:@.arguments/*/id\\n   data.delete\\n      table:ml_training_snippets\\n      where\\n         and\\n            id.eq:x:@.arguments/*/id\\nreturn\\n   result:success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Executes the specified [sql] towards your [type] and returns the result\\n\\nThis AI function will execute any arbitrary SQL towards your training data database, and return a maximum of [max_tokens] training data context back to caller to use as context data for the AI. Any SQL statement executed this way must be constructed such that it only affects records in one specified type.\\n\\nThe table name for the SQL should always be 'ml_training_snippets', and the where clause of the SQL must make sure only records with a type of 'YOUR_TYPE_NAME_HERE' is returned or affected. Unless caller explicitly tells you which columns to return, then assume the caller wants to have only prompt, completion, uri and id returned."},{"role":"assistant","content":".arguments\\n\\n   // Mandatory and is the SQL statement that will be executed\\n   sql:string\\n\\n   // Optional and will default to 4000 if not specified\\n   max_tokens:int\\n.type:public\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/sql\\n\\n// Applying defaults.\\nvalidators.default:x:@.arguments\\n   max_tokens:int:4000\\n\\n// Opening up our database connection.\\ndata.connect:[generic|magic]\\n\\n   // Executing SQL as select statement.\\n   data.select:x:@.arguments/*/sql\\n\\n   // Making sure we return total record count to caller.\\n   set-value:x:../*/return/*/count\\n      get-count:x:@data.select/*\\n\\n   // Making sure we do't return more context than what was requested.\\n   .cont:bool:true\\n   while:x:@.cont\\n      lambda2hyper:x:@data.select/*\\n      if\\n         lt\\n            openai.tokenize:x:@lambda2hyper\\n            convert:x:@.arguments/*/max_tokens\\n               type:int\\n         .lambda\\n            set-value:x:@.cont\\n               .:bool:false\\n            set-value:x:../*/return/*/complete_information\\n               .:WARNING! We found more records than we could fit into the context!\\n      else\\n         remove-nodes:x:@data.select/0/-\\n\\n   // Making sure we return actual records to caller.\\n   add:x:../*/return/*/records\\n      get-nodes:x:@data.select/*\\n\\n// Return result to caller.\\nreturn\\n   count\\n   records\\n   complete_information:This was all the records we could find related to your query\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Creates an image\\n\\nCreates an image using DALL-E 3 according to the specified [prompt], [size], and [style], and returns to caller. The return value will be the URL for the generated image, in addition to a description of the image."},{"role":"assistant","content":".arguments\\n\\n   // Mandatory and is the prompt used to generate the image.\\n   prompt:string\\n\\n   // Optional and will default to '1024x1024' if not specified. Legal are 1024x1024, 1792x1024, and 1024x1792.\\n   size:string\\n\\n   // Optional and will default to 'vivid' if not specified. Legal values are 'vivid' and 'natural'.\\n   style:string\\n.type:public\\n\\n// Applying defaults.\\nvalidators.default:x:@.arguments\\n   size:1792x1024\\n   style:vivid\\n\\n/*\\n * Invokes OpenAI's image generation API with the specified [query] and [model].\\n * \\n * Will use the default API key found from configurations.\\n */\\nexecute:magic.workflows.actions.execute\\n   name:openai-image-create\\n   filename:/modules/openai/workflows/actions/openai-image-create.hl\\n   arguments\\n      model:dall-e-3\\n      size:x:@.arguments/*/size\\n      style:x:@.arguments/*/style\\n      query:x:@.arguments/*/prompt\\n\\n// Returns the result of your last action.\\nreturn-nodes:x:@execute/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Searches through your training snippets using RAG / VSS search for the specified query\\n\\nThis function will use VSS to search through your RAG database for training snippets matching the specified [query] that are within the specified [threshold] of similarity and return the first [max_tokens] training snippets as Markdown context data."},{"role":"assistant","content":".arguments\\n   _type:string\\n\\n   // Mandatory argument and the actual query to use when finding data from your RAG database.\\n   query:string\\n\\n   // Optional argument and the number of tokens to return. The default value of not spcified is 4000.\\n   max_tokens:int\\n\\n   // Optional argument being similarity distance between query and RAG records matched during search. Will default to 0.3 if not specified.\\n   threshold:decimal\\n.type:public\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/_type\\nvalidators.mandatory:x:@.arguments/*/query\\n\\n// Applying defaults.\\nvalidators.default:x:@.arguments\\n   max_tokens:int:4000\\n   threshold:decimal:0.3\\n\\n/*\\n * Returns context for the specified [query] from the specified [_type],\\n * and returns to caller.\\n * \\n * Optionally add [threshold] and [max_tokens] to specify similarity and maximum\\n * tokens to return. [_type] is a machine learning type from your ml_types database table in\\n * your magic database.\\n */\\nexecute:magic.workflows.actions.execute\\n   name:openai-context-from-database\\n   filename:/modules/openai/workflows/actions/openai-context-from-database.hl\\n   arguments\\n      type:x:@.arguments/*/_type\\n      query:x:@.arguments/*/query\\n      max_tokens:x:@.arguments/*/max_tokens\\n      threshold:x:@.arguments/*/threshold\\n\\n// Returns the result of your last action.\\nreturn-nodes:x:@execute/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns the training snippet with the specified [id] to the caller.\\n\\nThis function will return the training snippet with the specified [id] to the caller allowing the AI to use this training snippet as context."},{"role":"assistant","content":".arguments\\n\\n   // Mandatory argument and the primary key and ID of the training snippet to return\\n   id:int\\n.type:public\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/id\\nvalidators.integer:x:@.arguments/*/id\\n   min:int:0\\n\\n// Opening up our database connection.\\ndata.connect:[generic|magic]\\n\\n   // Finding our snippet from the database.\\n   data.read\\n      table:ml_training_snippets\\n      columns\\n         prompt\\n         completion\\n         uri\\n      where\\n         and\\n            id.eq:x:@.arguments/*/id\\n   return-nodes:x:@data.read/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Generate filtered result\\n\\nThis function will perform an SQL 'like' type of select SQL into your training data database, and return a maximum of [max_tokens] training data, while matching the result according to [full_query] being a VSS search string.\\n\\nThis function combines SQL filtering with vector semantic search (VSS), where [query] is the SQL parts and [full_query] is the VSS parts.\\n\\nInstructions:\\n\\nIf the user asks you to generate a filtered result or create a filtered result, your task is to construct an SQL filtering condition and use as [query] and a VSS search query to use as [full_query], resulting in a high quality function invocation likely to return the result you need to answer the user's question.\\n\\nFor instance, if the user asks 'Generate a filtered result for John Doe and tell me where he lives and what his address is' a good [query] might be for instance 'John Doe' resulting in only training data containing the text 'John Doe' to be considered, while a good [full_query] might be 'address, country, city, zip code'."},{"role":"assistant","content":".arguments\\n   _type:string\\n\\n   // Mandatory and is your SQL filtering condition, for instance 'John Doe' implying keywords the training snippets must contain to be considered. This will become a LIKE SQL condition for records to match, filtering out all records not matching the condition.\\n   query:string\\n\\n   // Mandatory and is your VSS search condition for instance 'address, zip code, location, country, zip'\\n   full_query:string\\n\\n   // Optional and will default to 4000 if not specified\\n   max_tokens:int\\n.type:public\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/_type\\nvalidators.mandatory:x:@.arguments/*/query\\nvalidators.mandatory:x:@.arguments/*/full_query\\n\\n// Applying defaults.\\nvalidators.default:x:@.arguments\\n   max_tokens:int:4000\\n\\n// Converting to integer to be safe.\\nset-value:x:@.arguments/*/max_tokens\\n   convert:x:@.arguments/*/max_tokens\\n      type:int\\n\\n// Retrieving embeddings.\\n.token\\nset-value:x:@.token\\n   strings.concat\\n      .:\"Bearer \"\\n      config.get:\"magic:openai:key\"\\n\\n// Retrieving embedding for prompt.\\nhttp.post:\"https://api.openai.com/v1/embeddings\"\\n   headers\\n      Authorization:x:@.token\\n      Content-Type:application/json\\n   payload\\n      input:x:@.arguments/*/full_query\\n      model:text-embedding-ada-002\\n   convert:true\\n\\n// Sanity checking above invocation.\\nif\\n   not\\n      and\\n         mte:x:@http.post\\n            .:int:200\\n         lt:x:@http.post\\n            .:int:300\\n   .lambda\\n\\n      // Oops, error - Logging error and returning OpenAI's HTTP status code to caller.\\n      lambda2hyper:x:@http.post\\n      log.error:Something went wrong while invoking OpenAI\\n         message:x:@http.post/*/content/*/error/*/message\\n         error:x:@lambda2hyper\\n      throw:x:@http.post/*/content/*/error/*/message\\n         public:bool:true\\n         status:x:@http.post\\n\\n// Converting embeddings to a byte array of floats, since this is how we store embeddings in SQLite.\\nfloatArray2bytes:x:@http.post/*/content/*/data/0/*/embedding/*\\n\\n// Creating our filter string\\n.filter\\nset-value:x:@.filter\\n   strings.concat\\n      .:%\\n      get-value:x:@.arguments/*/query\\n      .:%\\n\\n// Connecting to database.\\ndata.connect:[generic|magic]\\n\\n   // Creating our SQL.\\n   strings.concat\\n      .:\"\\nselect vss.rowid as id, ts.prompt, ts.completion, ts.uri\\n\\tfrom vss_ml_training_snippets as vss\\n    \\tinner join ml_training_snippets ts on ts.id = vss.rowid\\n   where\\n      ts.type = @type and\\n      (ts.completion like @filter or ts.prompt like @filter) and\\n      vss_search(vss.embedding_vss, @embedding)\"\\n\\n   // Executing SQL.\\n   data.select:x:@strings.concat\\n      embedding:x:@floatArray2bytes\\n      type:x:@.arguments/*/_type\\n      filter:x:@.filter\\n   .cont:bool:true\\n   while:x:@.cont\\n      lambda2hyper:x:@data.select/*\\n      if\\n         lt\\n            openai.tokenize:x:@lambda2hyper\\n            convert:x:@.arguments/*/max_tokens\\n               type:int\\n         .lambda\\n\\n            // We're within the max_tokens threshold so we can stop the while loop.\\n            set-value:x:@.cont\\n               .:bool:false\\n      else\\n\\n         // We're above max_tokens, so we'll need to remove the last snippet.\\n         remove-nodes:x:@data.select/0/-\\n\\n   // Returning result to caller.\\n   return-nodes:x:@data.select/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Searches for the specified [query] through your training snippets and returns [max_tokens] training snippets to caller.\\n\\nThis function will perform an SQL LIKE type of select SQL into your training data database, and return a maximum of [max_tokens] training data back to caller to use as context data for the AI."},{"role":"assistant","content":".arguments\\n   _type:string\\n\\n   // Mandatory argument and become an SQL LIKE condition records must match to be considered.\\n   query:string\\n\\n   // Optional argument being maximum number of tokens to return. Will default to 4000 if not specified.\\n   max_tokens:int\\n.type:public\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/_type\\nvalidators.mandatory:x:@.arguments/*/query\\n\\n// Applying defaults.\\nvalidators.default:x:@.arguments\\n   max_tokens:int:4000\\n\\n// Opening up our database connection.\\ndata.connect:[generic|magic]\\n\\n   // Creating our filter string\\n   .filter\\n   set-value:x:@.filter\\n      strings.concat\\n         .:%\\n         get-value:x:@.arguments/*/query\\n         .:%\\n   data.read\\n      table:ml_training_snippets\\n      columns\\n         id\\n         prompt\\n         uri\\n      where\\n         or\\n            prompt.like:x:@.filter\\n            completion.like:x:@.filter\\n   .cont:bool:true\\n   while:x:@.cont\\n      lambda2hyper:x:@data.read/*\\n      if\\n         lt\\n            openai.tokenize:x:@lambda2hyper\\n            convert:x:@.arguments/*/max_tokens\\n               type:int\\n         .lambda\\n            set-value:x:@.cont\\n               .:bool:false\\n      else\\n         remove-nodes:x:@data.read/0/-\\n   return-nodes:x:@data.read/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Scrapes the specified URL and returns all hyperlinks found\\n\\nScrapes the specified [url] and returns a maximum of [max] hyperlinks it can find, optionally starting with [starts_with]."},{"role":"assistant","content":".arguments\\n\\n   // Mandatory argument and becomes the URL the function will scrape for hyperlinks to return.\\n   url:string\\n\\n   // Optional argument that filters out any URLs not starting with the specified string.\\n   starts_with:string\\n\\n   // Optional argument for how many URLs to return. If not specified the function will return all hyperlinks found.\\n   max:int\\n.type:public\\n\\n// Parametrising our slot invocation.\\nadd:x:./*/signal\\n   get-nodes:x:@.arguments/*\\n\\n// Invoking slot doing the heavy lifting for us.\\nsignal:magic.http.html2markdown-links\\n\\n// Returning result to caller.\\nyield\\n   result:x:@signal\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Scrape the specified URL and returns the raw HTML\\n\\nScrapes the specified [url] and returns the resulting raw HTML to caller."},{"role":"assistant","content":".arguments\\n\\n   // Mandatory argument and the actual URL to scrape.\\n   url:string\\n.type:public\\n\\n// Invokes some HTTP GET resource.\\nexecute:magic.workflows.actions.execute\\n   name:http-get\\n   filename:/misc/workflows/actions/http/http-get.hl\\n   arguments\\n      url:x:@.arguments/*/url\\n\\n// Returns the result of your last action.\\nreturn-nodes:x:@execute/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Scrape URL\\n\\nScrapes the specified [url] and returns the result to caller as Markdown."},{"role":"assistant","content":".arguments\\n\\n   // If specified declares the name of the machine learning type from where the invocation originated.\\n   _type:string\\n\\n   // Mandatory argument and the actual URL to scrape.\\n   url:string\\n.type:public\\n\\n// Scrapes the specified URL and returns the content as Markdown\\nexecute:magic.workflows.actions.execute\\n   name:openai-scrape-url\\n   filename:/modules/openai/workflows/actions/openai-scrape-url.hl\\n   arguments\\n      url:x:@.arguments/*/url\\n\\n/*\\n * Now we need to make sure we don't overflow the type's maximum context tokens.\\n * \\n * Notice, in case workflow is executed without a [_type] argument, we default\\n * the context size to 100,000.\\n */\\n.max-tokens:int:100000\\nif\\n   and\\n      exists:x:@.arguments/*/_type\\n      not-null:x:@.arguments/*/_type\\n   .lambda\\n\\n      // We've got a machine learning type, finding its maximum context token count.\\n      data.connect:[generic|magic]\\n         database-type:sqlite\\n         data.scalar:select max_context_tokens from ml_types where type = @type\\n            database-type:sqlite\\n            @type:x:@.arguments/*/_type\\n         set-value:x:@.max-tokens\\n            convert:x:@data.scalar\\n               type:int\\n\\n      /*\\n       * Checking if we're about to overflow the max context tokens,\\n       * such that we can try to remove URLs until we're below threshold.\\n       */\\n      .json\\n      set-value:x:@.json\\n         lambda2json:x:@execute/*\\n      while\\n         and\\n            exists:x:@execute/*/urls/0\\n            mt\\n               openai.tokenize:x:@.json\\n               get-value:x:@.max-tokens\\n         .lambda\\n\\n            // We need to prune the result, removing the last URL until we're below threshold.\\n            remove-nodes:x:@execute/*/urls/0/-\\n\\n            // Updating above JSON.\\n            set-value:x:@.json\\n               lambda2json:x:@execute/*\\n\\n      // Checking if we've remove all URLs.\\n      if\\n         not\\n            exists:x:@execute/*/urls/0\\n         .lambda\\n\\n            // Zero URLs in result set, making sure we don't return [urls] at all.\\n            remove-nodes:x:@execute/*/urls\\n\\n      /*\\n       * Now pruning actual result until we're below threshold.\\n       * \\n       * This is in case removing all URLs didn't prune enough tokens.\\n       */\\n      while\\n         mt\\n            openai.tokenize:x:@.json\\n            get-value:x:@.max-tokens\\n         .lambda\\n\\n            // Removing 10% of [result] until we're below threshold.\\n            math.multiply\\n               strings.length:x:@execute/*/result\\n               .:decimal:0.9\\n            set-value:x:@execute/*/result\\n               strings.substring:x:@execute/*/result\\n                  .:int:0\\n                  convert:x:@math.multiply\\n                     type:int\\n\\n            // Updating JSON result such that next iteration can correctly calculate tokens.\\n            set-value:x:@.json\\n               lambda2json:x:@execute/*\\n\\n// Returns the result of your last action.\\nreturn-nodes:x:@execute/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Store a single fact about the user into long term memory\\n\\nStores a single fact about the user, such as name, email address, phone number, etc,  such that it becomes a permanent part of the user's context when interacting with the AI. Only store the same type of fact once for each user."},{"role":"assistant","content":".arguments\\n   _session:string\\n   _user-id:string\\n   _type:string\\n\\n   // Mandatory argument being the type of information to store, such as for instance \"name\", \"email\", etc.\\n   name:string\\n\\n   // Mandatory argument and is the value of the argument such as for instance \"John Doe\" or \"john@doe.com\", etc.\\n   value:string\\n.type:public\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/name\\nvalidators.mandatory:x:@.arguments/*/value\\n\\n// Opening up our database connection to store fact.\\ndata.connect:[generic|magic]\\n\\n   // Creating our ml_requests item.\\n   data.create\\n      table:ml_requests\\n      values\\n         type:x:@.arguments/*/_type\\n         prompt:x:@.arguments/*/name\\n         completion:x:@.arguments/*/value\\n         finish_reason:questionnaire\\n         questionnaire:int:1\\n         user_id:x:@.arguments/*/_user-id\\n         session:x:@.arguments/*/_session\\n         context:int:1\\n\\n// Returning success to caller.\\nreturn\\n   result:success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Search the web and returns only the URLs found\\n\\nSearches the web for the specified [query] using DuckDuckGo and returns the resulting hyperlinks to pages matching the query."},{"role":"assistant","content":".arguments\\n\\n   // Mandatory argument being the actual query to submit to DuckDuckGo.\\n   query:string\\n\\n   // Optional argument being how many URLs to return. Defaults to 10 if not specified.\\n   max_urls:int\\n.type:public\\n\\n// Returns [max_urls] for the specified [query] by searching DuckDuckGo.\\nexecute:magic.workflows.actions.execute\\n   name:openai-urls-search\\n   filename:/modules/openai/workflows/actions/openai-urls-search.hl\\n   arguments\\n      query:x:@.arguments/*/query\\n      max_urls:x:@.arguments/*/max_urls\\n\\n// Returns the result of your last action.\\nreturn-nodes:x:@execute/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Search the web\\n\\nSearches the web for the specified [query] using DuckDuckGo and returns the result as Markdown context."},{"role":"assistant","content":".arguments\\n\\n   // Mandatory argument being the actual query to submit to DuckDuckGo.\\n   query:string\\n\\n   // Optional argument being the maximum number of tokens to return.\\n   max_tokens:int\\n.type:public\\n\\n// Returns [max_tokens] context for the specified [query] by searching DuckDuckGo.\\nexecute:magic.workflows.actions.execute\\n   name:openai-context-from-search\\n   filename:/modules/openai/workflows/actions/openai-context-from-search.hl\\n   arguments\\n      query:x:@.arguments/*/query\\n      max_tokens:x:@.arguments/*/max_tokens\\n\\n// Returns the result of your last action.\\nreturn-nodes:x:@execute/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns [max_tokens] context for the specified [query] by searching DuckDuckGo."},{"role":"assistant","content":".arguments\\n   query\\n      type:string\\n      mandatory:bool:true\\n   max_tokens\\n      type:int\\n      default:int:4000\\n.icon:extension\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/query\\n\\n// Applying default values for optional arguments.\\nvalidators.default:x:@.arguments\\n   max_tokens:int:4000\\n\\n// Retrieving context.\\nexecute:magic.http.duckduckgo-and-scrape\\n   query:x:@.arguments/*/query\\n   max:int:10\\n\\n// Building our context return value.\\n.context:\\nwhile\\n   and\\n      exists:x:@execute/0/*/snippets/0\\n      lt\\n         openai.tokenize:x:@.context\\n         convert:x:@.arguments/*/max_tokens\\n            type:int\\n   .lambda\\n\\n      // Temporary value.\\n      .tmp\\n      set-value:x:@.tmp\\n         strings.concat\\n            get-value:x:@.context\\n            .:\"\\n\\n\"\\n            get-value:x:@execute/0/*/snippets/0/*/prompt\\n            .:\"\\n\\n\"\\n            get-value:x:@execute/0/*/snippets/0/*/completion\\n      if\\n         lt\\n            openai.tokenize:x:@.tmp\\n            convert:x:@.arguments/*/max_tokens\\n               type:int\\n         .lambda\\n\\n            // Still below [max_tokes].\\n            set-value:x:@.context\\n               get-value:x:@.tmp\\n\\n      // Removing top snippet.\\n      remove-nodes:x:@execute/0/*/snippets/0\\n      if\\n         not-exists:x:@execute/0/*/snippets/0\\n         .lambda\\n\\n            // TODO: Add reference URL here.\\n\\n            // Removing currently iterated URL.\\n            remove-nodes:x:@execute/0\\n\\n// Trimming result.\\nset-value:x:@.context\\n   strings.trim:x:@.context\\n\\n// Returning result to caller.\\nyield\\n   context:x:@.context\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns [max_tokens] context from the specified [url]."},{"role":"assistant","content":".arguments\\n   url\\n      type:string\\n      mandatory:bool:true\\n   max_tokens\\n      type:int\\n      default:int:4000\\n   throw\\n      type:boolean\\n      default:bool:false\\n.icon:extension\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/url\\n\\n// Applying default values for optional arguments.\\nvalidators.default:x:@.arguments\\n   max_tokens:int:4000\\n\\n// Retrieving context.\\nexecute:magic.http.scrape-url\\n   url:x:@.arguments/*/url\\nif\\n   and\\n      get-value:x:@.arguments/*/throw\\n      not-null:x:@execute\\n   .lambda\\n      throw:Could not scrape URL\\n         public:bool:true\\n         status:x:@execute\\n\\n// Building our context return value.\\n.context:\\nwhile\\n   and\\n      exists:x:@execute/0\\n      lt\\n         openai.tokenize:x:@.context\\n         convert:x:@.arguments/*/max_tokens\\n            type:int\\n   .lambda\\n\\n      // Temporary value.\\n      .tmp\\n      set-value:x:@.tmp\\n         strings.concat\\n            get-value:x:@.context\\n            .:\"\\n\\n\"\\n            get-value:x:@execute/0/*/prompt\\n            .:\"\\n\\n\"\\n            get-value:x:@execute/0/*/completion\\n      if\\n         lt\\n            openai.tokenize:x:@.tmp\\n            convert:x:@.arguments/*/max_tokens\\n               type:int\\n         .lambda\\n\\n            // Still below [max_tokes].\\n            set-value:x:@.context\\n               get-value:x:@.tmp\\n\\n      // Removing top snippet.\\n      remove-nodes:x:@execute/0/*/snippets/0\\n      if\\n         not-exists:x:@execute/0/*/snippets/0\\n         .lambda\\n\\n            // Removing currently iterated URL.\\n            remove-nodes:x:@execute/0\\n\\n// Trimming result.\\nset-value:x:@.context\\n   strings.trim:x:@.context\\n\\n// Returning result to caller.\\nyield\\n   context:x:@.context\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Invokes OpenAI's image generation API with the specified [query] and [model].\\n\\nWill use the default API key found from configurations."},{"role":"assistant","content":".arguments\\n   query\\n      type:textarea\\n      mandatory:bool:true\\n   model\\n      type:string\\n      mandatory:bool:false\\n      default:dall-e-3\\n   size\\n      type:string\\n      mandatory:bool:false\\n      default:1024x1024\\n      values\\n         .:1024x1024\\n         .:1024x1792\\n         .:1792x1024\\n   style\\n      type:string\\n      mandatory:bool:false\\n      default:vivid\\n      values\\n         .:vivid\\n         .:natural\\n.icon:chat_bubble\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/query\\nvalidators.default:x:@.arguments\\n   model:dall-e-3\\n   default:1024x1024\\n\\n// Retrieving OpenAI API token from configuration settings.\\n.token\\nset-value:x:@.token\\n   strings.concat\\n      .:\"Bearer \"\\n      config.get:\"magic:openai:key\"\\n\\n// Invokes OpenAI.\\nhttp.post:\"https://api.openai.com/v1/images/generations\"\\n   convert:bool:true\\n   headers\\n      Authorization:x:@.token\\n      Content-Type:application/json\\n   payload\\n      model:x:@.arguments/*/model\\n      prompt:x:@.arguments/*/query\\n      n:int:1\\n      size:x:@.arguments/*/size\\n      style:x:@.arguments/*/style\\n\\n// Sanity checking above invocation.\\nif\\n   not\\n      and\\n         mte:x:@http.post\\n            .:int:200\\n         lt:x:@http.post\\n            .:int:300\\n   .lambda\\n\\n      // Oops, error - Logging error and returning status 500 to caller.\\n      lambda2hyper:x:@http.post\\n      log.error:Something went wrong while invoking OpenAI\\n         message:x:@http.post/*/content/*/error/*/message\\n         status:x:@http.post\\n         error:x:@lambda2hyper\\n      throw:Something went wrong while invoking OpenAI\\n         message:x:@http.post/*/content/*/error/*/message\\n         status:x:@http.post\\n         error:x:@lambda2hyper\\n\\n// Returning answer to caller.\\nyield\\n   images:x:@http.post/*/content/*/data/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Invokes OpenAI's chat API with the specified [model], [max_tokens], [context],\\n[instruction] and [query].\\n\\nWill use the default API key found from configurations.\\n\\n[context] is additional data you can supply to OpenAI such that it responds using\\nyour data as its source for information. [instruction] is a system message allowing\\nyou to change how OpenAI responds."},{"role":"assistant","content":".arguments\\n   model\\n      type:string\\n      mandatory:bool:true\\n      default:gpt-4-1106-preview\\n      values\\n         .:gpt-4o\\n         .:gpt-4o-mini\\n         .:gpt-4o-2024-05-13\\n         .:gpt-3.5-turbo\\n         .:gpt-3.5-turbo-16k\\n         .:gpt-3.5-turbo-1106\\n         .:gpt-3.5-turbo-0125\\n         .:gpt-4\\n         .:gpt-4-1106-preview\\n         .:03-mini\\n         .:gpt-4.5-preview\\n   max_tokens\\n      type:int\\n      mandatory:bool:true\\n      default:int:1500\\n   context\\n      type:textarea\\n      mandatory:bool:false\\n   instruction\\n      type:textarea\\n      mandatory:bool:false\\n   query\\n      type:textarea\\n      mandatory:bool:true\\n.icon:chat_bubble\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/model\\nvalidators.mandatory:x:@.arguments/*/query\\nvalidators.mandatory:x:@.arguments/*/max_tokens\\n\\n// Retrieving OpenAI API token from configuration settings.\\n.token\\nset-value:x:@.token\\n   strings.concat\\n      .:\"Bearer \"\\n      config.get:\"magic:openai:key\"\\n\\n// Checking if caller provided a [context].\\nif\\n   exists:x:@.arguments/*/context\\n   .lambda\\n\\n      // Adding [context].\\n      insert-before:x:../*/http.post/*/payload/*/messages/0\\n         .\\n            .\\n               role:user\\n               content:x:@.arguments/*/context\\n\\n// Checking if caller provided an [instruction].\\nif\\n   exists:x:@.arguments/*/instruction\\n   .lambda\\n\\n      // Adding [instruction].\\n      insert-before:x:../*/http.post/*/payload/*/messages/0\\n         .\\n            .\\n               role:system\\n               content:x:@.arguments/*/instruction\\n\\n// Checking if model is o3 something, at which point we'll have to change [max_tokens] to [max_completion_tokens]\\nif\\n   strings.starts-with:x:@.arguments/*/model\\n      .:o3-\\n   .lambda\\n\\n      // Changing name of argument.\\n      set-name:x:../*/http.post/*/payload/*/max_tokens\\n         .:max_completion_tokens\\n      remove-nodes:x:../*/http.post/*/payload/*/temperature\\n\\n// Invokes OpenAI.\\nhttp.post:\"https://api.openai.com/v1/chat/completions\"\\n   convert:bool:true\\n   headers\\n      Authorization:x:@.token\\n      Content-Type:application/json\\n   payload\\n      model:x:@.arguments/*/model\\n      max_tokens:x:@.arguments/*/max_tokens\\n      temperature:decimal:0.3\\n      messages\\n         .\\n            role:user\\n            content:x:@.arguments/*/query\\n\\n// Sanity checking above invocation.\\nif\\n   not\\n      and\\n         mte:x:@http.post\\n            .:int:200\\n         lt:x:@http.post\\n            .:int:300\\n   .lambda\\n\\n      // Oops, error - Logging error and returning status 500 to caller.\\n      lambda2hyper:x:@http.post\\n      log.error:Something went wrong while invoking OpenAI\\n         message:x:@http.post/*/content/*/error/*/message\\n         status:x:@http.post\\n         error:x:@lambda2hyper\\n      throw:Something went wrong while invoking OpenAI\\n         message:x:@http.post/*/content/*/error/*/message\\n         status:x:@http.post\\n         error:x:@lambda2hyper\\n\\n// Returning answer to caller.\\nyield\\n   answer:x:@http.post/*/content/*/choices/0/*/message/*/content\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Scrapes the specified URL and returns the content as Markdown"},{"role":"assistant","content":".arguments\\n   url\\n      type:string\\n      mandatory:bool:true\\n.icon:extension\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/url\\n\\n// Prepending scheme if not given.\\nif\\n   and\\n      not\\n         strings.starts-with:x:@.arguments/*/url\\n            .:\"http://\"\\n      not\\n         strings.starts-with:x:@.arguments/*/url\\n            .:\"https://\"\\n   .lambda\\n\\n      // Defaulting to https\\n      set-value:x:@.arguments/*/url\\n         strings.concat\\n            .:\"https://\"\\n            get-value:x:@.arguments/*/url\\n\\n// Sanity checking invocation.\\nvalidators.url:x:@.arguments/*/url\\n\\n// Retrieving HTML from URL.\\nhttp.get:x:@.arguments/*/url\\n   timeout:int:30\\n   headers\\n      User-Agent:AINIRO-Crawler 2.0\\n      Accept:text/html\\n      Accept-Encoding:identity\\n\\n// Sanity checking result from above invocation.\\nif\\n   not\\n      and\\n         mte:x:@http.get\\n            .:int:200\\n         lt:x:@http.get\\n            .:int:300\\n   .lambda\\n\\n      // Oops, logging error.\\n      lambda2hyper:x:@http.get\\n      log.error:Something went wrong while trying to scrape URL\\n         url:x:@.arguments/*/url\\n         error:x:@lambda2hyper\\n      return:x:@http.get\\n\\n// Making sure URL returned HTML.\\nif\\n   or\\n      not-exists:x:@http.get/*/content\\n      null:x:@http.get/*/content\\n      eq:x:@http.get/*/content\\n         .:\\n      not-exists:x:@http.get/*/headers/*/Content-Type\\n      not\\n         strings.starts-with:x:@http.get/*/headers/*/Content-Type\\n            .:text/html\\n   .lambda\\n\\n      // Oops, doing some basic logging.\\n      lambda2hyper:x:@http.get\\n      log.error:URL did not return HTML content when scraping\\n         content:x:@lambda2hyper\\n         url:x:@.arguments/*/url\\n      return:int:415\\n\\n// Transforming result to HTML\\nhtml2markdown:x:@http.get/*/content\\n   url:x:@.arguments/*/url\\n\\n// Returning result of above tranformation to caller.\\nyield\\n   result:x:@html2markdown\\n   urls:x:@html2markdown/*/urls/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Deletes all training snippets from the specified [type].\\n\\nIf [meta] is specified, the action will only delete snippets with specified meta type,\\notherwise it will delete all snippets from [type]."},{"role":"assistant","content":".arguments\\n   type\\n      type:string\\n      mandatory:bool:true\\n   meta\\n      type:string\\n      mandatory:bool:false\\n.icon:chat_bubble\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/type\\n\\n// Deleting snippets specified [type].\\ndata.connect:[generic|magic]\\n\\n   // Checking if we've got a [meta] argument.\\n   if:x:@.arguments/*/meta\\n\\n      // [meta] argument was specified.\\n      data.execute:delete from vss_ml_training_snippets where rowid in (select id as rowid from ml_training_snippets where type = @type and meta = @meta)\\n         @type:x:@.arguments/*/type\\n         @meta:x:@.arguments/*/meta\\n      data.delete\\n         table:ml_training_snippets\\n         where\\n            and\\n               type.eq:x:@.arguments/*/type\\n               meta.eq:x:@.arguments/*/meta\\n   else\\n\\n      // [meta] argument was not specified.\\n      data.execute:delete from vss_ml_training_snippets where rowid in (select id as rowid from ml_training_snippets where type = @type)\\n         @type:x:@.arguments/*/type\\n      data.delete\\n         table:ml_training_snippets\\n         where\\n            and\\n               type.eq:x:@.arguments/*/type\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Imports training snippets into the specified [type].\\n\\n[snippets] are a list of items with [prompt] and [completion],\\nand [meta] is meta values for imported snippets."},{"role":"assistant","content":".arguments\\n   type\\n      type:string\\n      mandatory:bool:true\\n   snippets\\n      type:*\\n      mandatory:bool:true\\n   meta\\n      type:string\\n      mandatory:bool:false\\n      default:imported\\n.icon:chat_bubble\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/type\\n\\n// Connecting to database.\\ndata.connect:[generic|magic]\\n\\n   // Looping through each record specified in [snippets] collection.\\n   for-each:x:@.arguments/*/snippets/*\\n\\n      // Verifying prompt is not null.\\n      if:x:@.dp/#/*/prompt\\n\\n         // Inserting into database.\\n         data.create\\n            table:ml_training_snippets\\n            values\\n               type:x:@.arguments/*/type\\n               prompt:x:@.dp/#/*/prompt\\n               completion:x:@.dp/#/*/completion\\n               meta:x:@.arguments/*/meta\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns [max_urls] matching specified query by searching DuckDuckGo."},{"role":"assistant","content":".arguments\\n   query\\n      type:string\\n      mandatory:bool:true\\n   max_urls\\n      type:int\\n      default:int:10\\n.icon:extension\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/query\\n\\n// Applying default values for optional arguments.\\nvalidators.default:x:@.arguments\\n   max_urls:int:10\\n\\n// Converting to integer to make sure we've got the right type.\\nset-value:x:@.arguments/*/max_urls\\n   convert:x:@.arguments/*/max_urls\\n      type:int\\n\\n// Retrieving context.\\nexecute:magic.http.duckduckgo-search\\n   query:x:@.arguments/*/query\\n   max:x:@.arguments/*/max_urls\\n\\n// Returning result to caller.\\nreturn-nodes:x:@execute/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Invokes OpenAI with the specifiec arguments."},{"role":"assistant","content":"slots.create:openai.invoke-chatgpt\\n\\n   // Sanity checking invocation.\\n   validators.mandatory:x:@.arguments/*/model\\n   validators.mandatory:x:@.arguments/*/max_tokens\\n   validators.mandatory:x:@.arguments/*/query\\n   validators.enum:x:@.arguments/*/model\\n      .:gpt-4o\\n      .:gpt-4o-mini\\n      .:gpt-4o-2024-05-13\\n      .:gpt-3.5-turbo\\n      .:gpt-3.5-turbo-16k\\n      .:gpt-3.5-turbo-1106\\n      .:gpt-3.5-turbo-0125\\n      .:gpt-4\\n      .:gpt-4-1106-preview\\n      .:o3-mini\\n      .:gpt-4.5-preview\\n\\n   // Retrieving OpenAI API token from configuration settings.\\n   .token\\n   set-value:x:@.token\\n      strings.concat\\n         .:\"Bearer \"\\n         config.get:\"magic:openai:key\"\\n\\n   // Checking if caller provided an [instruction].\\n   if\\n      exists:x:@.arguments/*/instruction\\n      .lambda\\n\\n         // Adding [instruction].\\n         insert-before:x:../*/http.post/*/payload/*/messages/0\\n            .\\n               .\\n                  role:system\\n                  content:x:@.arguments/*/instruction\\n\\n   // Invokes OpenAI.\\n   http.post:\"https://api.openai.com/v1/chat/completions\"\\n      convert:bool:true\\n      headers\\n         Authorization:x:@.token\\n         Content-Type:application/json\\n      payload\\n         model:x:@.arguments/*/model\\n         max_tokens:x:@.arguments/*/max_tokens\\n         temperature:decimal:0.3\\n         messages\\n            .\\n               role:user\\n               content:x:@.arguments/*/query\\n\\n   // Sanity checking above invocation.\\n   if\\n      not\\n         and\\n            mte:x:@http.post\\n               .:int:200\\n            lt:x:@http.post\\n               .:int:300\\n      .lambda\\n\\n         // Oops, error - Logging error and returning status 500 to caller.\\n         lambda2hyper:x:@http.post\\n         log.error:Something went wrong while invoking OpenAI\\n            message:x:@http.post/*/content/*/error/*/message\\n            status:x:@http.post\\n            error:x:@lambda2hyper\\n         throw:Something went wrong while invoking OpenAI\\n            message:x:@http.post/*/content/*/error/*/message\\n            status:x:@http.post\\n            error:x:@lambda2hyper\\n\\n   // Returning answer to caller.\\n   return-value:x:@http.post/*/content/*/choices/0/*/message/*/content\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"AI Agent, static system message for creating an AI Assistant."},{"role":"assistant","content":"name:AI Agent\\nmax_context_tokens:int:12000\\nmax_function_invocations:int:25\\ndescription:An AI Agent capable of recursively executing AI functions, and search for functions it needs to execute tasks.\\nprefix:@\"You are a helpful assistant and you can answer questions related to the context.\\n\\n## Instructions\\n\\n* Exclusively adhere to the provided context to answer the user's questions.\\n* Always inform the user of what you are trying to do before responding with a function invocation.\\n* Never assume a value for a foreign key, but instead search for a function that allows you to find it.\\n* If the user is telling you to perform some specific task, and you don't know how to do it because you don't know the exact function name, then search for a function allowing you to perform the task using the \"\"get-context\"\" function below, and only perform the user's request after having retrieved a function allowing you to perform the user's request. NEVER respond with a function invocation unless you can find its exact syntax and path in your context.\\n* If the user asks you to for instance \"\"Update number n\"\" or \"\"Delete number n\"\", or something similar, and you have previously listed items for the user, then do not use the user's number as your primary key, but rather update or delete the n'th item you previously listed.\\n* When displaying dates, return these as \"\"ddd d. mmmm YYYY HH:MM\"\".\\n* If a function does not return anything at all then inform the user that the function didn't return anything.\\n* When responding with lists of data, prefer using tables if your lists contains more than 1 column and less than 10 columns.\\n* If you're responding with a list, and there's only one column, or more than 10 columns, then display these as numbered lists.\\n* When creating a new object assume the primary key is optional unless explicitly told otherwise.\\n* When listing items don't list the primary key.\\n* Today's date and time is {{\\ndate.now\\ndate.format:x:-\\n   format:\"\"yyyy-MM-ddTHH:mm:ssZ\"\"\\nreturn:x:-\\n}} UTC\\n\\n### Adhere to the context\\n\\n* YOU ARE UNDER NO CIRCUMSTANCES ALLOWED TO ANSWER QUESTIONS YOU CANNOT FIND THE ANSWER TO IN THE CONTEXT.\\n* If the user asks you a question and you cannot find the answer to it in the context, or the question is irrelevant to the provided context, then inform the user that you don't know the answer, and encourage the user to provide some relevant keywords or stay on subject.\\n\\n### Image instructions\\n\\n* If you find relevant images in the context then return these images as follows to the user ![image_description](image_url).\\n* ONLY display images you find in the context.\\n* If you cannot find an image in the context then DO NOT MAKE UP IMAGE URLS.\\n\\n### Follow up questions instructions\\n\\n* Always end your response with a carriage return, ---, and 3 follow up questions the user can ask you related to the context. These questions are intended to be displayed to the user as example follow up questions the user can ask you. DO NOT RETURN THESE AS QUESTIONS TO THE USER, RETURN THESE AS EXAMPLE QUESTIONS THE USER CAN ASK YOU.\\n\\n#### Example of follow up questions\\n\\n```text\\nRESPONSE HERE\\n\\n---\\n* What's the price?\\n* What's your best selling product?\\n* How can I contact you?\\n```\\n\\nIn the above Markdown code section you can find an example of a response and its follow up questions.\\n\\n### Mermaid charts\\n\\nIf the user is asking you to create a flowchart, mermaid chart, or something similar, you can respond with something resembling the following:\\n\\n```mermaid\\nSOME MERMAID CHART HERE\\n```\\n\\nYou can also use the above syntax to illustrate processes visually to help the user understand complex processes if required, and using a mermaid chart simplifies understanding.\\n\\n## Functions\\n\\nYou can execute functions by ending your response with something resembling the following:\\n\\n___\\nFUNCTION_INVOCATION[/FOLDER/FILENAME.hl]:\\n{\\n  \"\"arg1\"\": \"\"value1\"\",\\n  \"\"arg2\"\": 1234\\n}\\n___\\n\\nDescription:\\n\\n* All functions can ONLY handle arguments exactly as specified by the FUNCTION_INVOCATION\\n* The above is only provided as an example and not a function that actually exists\\n* If you are about to execute a function then DO NOT RETURN FOLLOW UP QUESTIONS, but instead end your response with a function invocation as illustrated above\\n* Determine the arguments required to correctly parametrise your function invocation, but never invoke a function you cannot find in your context, and don't execute a function before the user has supplied you with all mandatory arguments\\n* If the user does not provide you with all mandatory arguments required to invoke a function, then ask the user for these\\n* It is very important that you put the FUNCTION_INVOCATION parts and the JSON payload inside of two ___ lines separated by a carriage return character\\n* Unless something else is explicitly stated all arguments are optional by default\\n* Each argument can only be supplied once\\n* Unless you know the argument's value, do not pass it in, but instead completely remove it from your JSON payload\\n* If the user asks you to list all records and your function takes a limit argument, then set its value to -1\\n\\nBelow you can find a list of functions you can execute. Use these functions at the best of your ability to answer the user's questions.\\n\\n### Search for a function\\n\\nIf you cannot find the required function needed in your context, then respond with the following:\\n\\n___\\nFUNCTION_INVOCATION[/modules/openai/workflows/workflows/get-context.hl]:\\n{\\n  \"\"query\"\": \"\"[QUERY]\"\"\\n}\\n___\\n\\nDescription of arguments:\\n\\nThe above can have a [QUERY] value being for instance \"\"Read [ENTITY]\"\", or \"\"List [ENTITY]\"\", etc. This might provide you with another function you can respond with to perform the task the user is asking you to do. [ENTITY] in the above example would be the type of record the user is asking you to deal with. If the user is asking you to for instance; \"\"List all contacts having a first name of John\"\", then you could search for \"\"List contacts\"\" for instance, ignoring the parameters to the invocation in your search.\\n\\nYou can also respond with the above [QUERY] having a value such as for instance \"\"Send email\"\", \"\"Scrape website\"\", or \"\"Search the web\"\", to find the function you need to perform the task the user wants you to do.\\n\\nIf you still cannot find the function required to perform the user's request after having executed this function, then inform the user that you cannot perform the task the user is asking you to do.\\n\\n### Scrape URL\\n\\nIf the user asks you to scrape or fetch some URL, you will inform the user of what you're about to do and end your response with the following function invocation.\\n\\n___\\nFUNCTION_INVOCATION[/modules/openai/workflows/workflows/scrape-url.hl]:\\n{\\n  \"\"url\"\": \"\"[VALUE]\"\"\\n}\\n___\\n\\nDescription of arguments:\\n\\n* [URL] is mandatory and the URL that will be scraped\\n\\n### Search the web\\n\\nIf the user asks you to search the web you will inform the user of what you're about to do by informing the user about the search query you're about to use, for then to end your response with the following function invocation.\\n\\n___\\nFUNCTION_INVOCATION[/modules/openai/workflows/workflows/web-search-return-urls.hl]:\\n{\\n  \"\"query\"\": \"\"[VALUE]\"\",\\n  \"\"max_urls\"\": 20\\n}\\n___\\n\\nDescription of arguments:\\n\\n* [query] is mandatory and will be used as a search query while searching DuckDuckGo\\n* [max_urls] is optionally and becomes the number of URLs to return, and unless explicitly changed by the user should default to 20\\n\\nWhen you have retrieved results from DuckDuckGo, then proceed to return all URLs as Markdown, for then to scrape 3 to 5 URLs you believe are the most important URLs to be able to answer the user's question, for finally to use the above scrape URL function on these URLs to answer the user's question. ALWAYS finish your response with a list all URLs you scraped to answer the user's question such that the user can check your referenced sources. Return your sources as Markdown hyperlinks.\\n\\n### List all functions\\n\\nIf the user asks you to list all functions or what you can do for them or help them with, then you will respond with the following.\\n\\n___\\nFUNCTION_INVOCATION[/system/misc/workflows/list-functions.hl]\\n___\\n\\nThis function will return RAG functions which are dynamically looked up using VSS based upon the specified prompt, in addition to system message functions which are always a part of the context allowing you to always execute these without a prompt matching based upon VSS.\\n\\nIf you need to execute one of these functions and you don't know its exact FUNCTION_INVOCATION declaration, you can use the \"\"get-context\"\" function to retrieve its exact declaration and how to correctly parametrize and execute it.\\n\\n### Generate images\\n\\nIf the user asks you to generate an image, then inform the user of what you are about to do, and do not return follow up questions, but instead create a good image prompt based upon the user's instructions, and end your response with the following:\\n\\n___\\nFUNCTION_INVOCATION[/modules/openai/workflows/workflows/generate-image.hl]:\\n{\\n  \"\"prompt\"\": \"\"[prompt]\"\"\\n}\\n___\\n\\nThe above will generate an image using DALL-E, that you can show to the user by returning the image as Markdown to the user.\\n\\nDescription of arguments:\\n\\n* [prompt] becomes the prompt used to generate the image\\n\"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Deep Research AI Agent system message for creating an AI Assistant capable of conducting deep research into topics."},{"role":"assistant","content":"name:Deep Research\\nmax_context_tokens:int:12000\\nmax_function_invocations:int:50\\ndescription:@\"An AI Agent capable of recursively executing AI functions and performing deep research of topics.\\n\\nNOTICE! Requires the 'serp-api' plugin to function\"\\nprefix:@\"You are a helpful research assistant and you can answer questions related to the context.\\n\\n## Instructions\\n\\n* Exclusively adhere to the provided context to answer the user's questions.\\n* Always inform the user of what you are trying to do before responding with a function invocation.\\n* Today's date and time is {{\\ndate.now\\ndate.format:x:-\\n   format:\"\"yyyy-MM-ddTHH:mm:ssZ\"\"\\nreturn:x:-\\n}} UTC\\n\\n### Adhere to the context\\n\\n* **YOU ARE UNDER NO CIRCUMSTANCES ALLOWED TO ANSWER QUESTIONS YOU CANNOT FIND THE ANSWER TO IN THE CONTEXT.**\\n* If the user asks you a question and you cannot find the answer to it in the context, or the question is irrelevant to the provided context, then perform a deep research of the topic.\\n\\n## Functions\\n\\nYou can execute functions by ending your response with something resembling the following:\\n\\n___\\nFUNCTION_INVOCATION[/FOLDER/FILENAME.hl]:\\n{\\n  \"\"arg1\"\": \"\"value1\"\",\\n  \"\"arg2\"\": 1234\\n}\\n___\\n\\n**Description:**\\n\\n* All functions can ONLY handle arguments exactly as specified by the FUNCTION_INVOCATION.\\n* The above is only provided as an example and not a function that actually exists.\\n* If the user does not provide you with all mandatory arguments required to invoke a function, then ask the user to give you these before executing the function.\\n* It is very important that you put the FUNCTION_INVOCATION parts and the JSON payload inside of two ___ lines separated by a carriage return character.\\n* Always inform the user of what you're about to do before you execute a function.\\n\\nBelow you can find a list of functions you can execute. Use these functions at the best of your ability to answer the user's questions.\\n\\n### Scrape URL\\n\\nTo scrape or fetch some URL you can end your response with the following function invocation.\\n\\n___\\nFUNCTION_INVOCATION[/modules/openai/workflows/workflows/scrape-url.hl]:\\n{\\n  \"\"url\"\": \"\"VALUE\"\"\\n}\\n___\\n\\n**Description of arguments:**\\n\\n* `url` is mandatory and the URL that will be scraped.\\n\\n### Search the web\\n\\nTo search the web you can end your response with the following function invocation.\\n\\n___\\nFUNCTION_INVOCATION[/modules/serp-api/workflows/search/search.hl]:\\n{\\n  \"\"query\"\": \"\"[STRING_VALUE]\"\"\\n}\\n___\\n\\n**Description of arguments:**\\n\\n### Description of arguments:\\n\\n* `query` - Mandatory query to search for.\\n\\nWhen you have retrieved results from the above function, proceed to return all URLs as Markdown. Then, scrape 2 to 5 URLs that you believe are the most relevant to be able to answer the user's question.\\n\\n## Deep Research\\n\\nIf the user asks you to research some topic then you are to:\\n\\n1. **Initiate the Research:** Perform 2 to 5 initial searches you believe might return relevant information. Inform the user what you’re doing, and what search queries you will use. Then respond with a list of search function invocations.\\n2. **Scrape and Evaluate:** Once search results are returned, choose 2 to 5 relevant URLs to scrape from each search. Use the scrape URL function for these URLs and analyze the gathered content.\\n3. **Identify Additional Angles:** Carefully examine the scraped content for new keywords, topics, or details that were not covered in the initial search.\\n4. **Recursive Searching:** If any new topics or gaps are identified, immediately perform another round of search and scraping:\\n    - Inform the user that you are delving deeper into the topic.\\n    - Execute a new search with refined queries based on the uncovered details.\\n    - Scrape additional relevant URLs.\\n5. **Iterate Until Complete:** Continue the cycle of searching, scraping, and evaluating until you are confident that:\\n    - All facets of the topic have been exhaustively researched.\\n    - No new keywords or topics emerge that would require further research.\\n6. **Exclusively Use Gathered Context:** Do not answer the user's question until all relevant background information has been gathered exclusively from the searched and scraped content.\\n7. **Transparency:** Always keep the user informed about which step of the research process you are on before each function invocation.\\n\\n**Remember:** Your final answer must be solely based on the context and information acquired through this recursive research process. Do not make assumptions or introduce external information that was not obtained via the search and scrape functions.\\n\"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Formal content production system message."},{"role":"assistant","content":"name:Heidi - Content Production\\ndescription:Great for content production such as copywriting, creating articles, social media status updates, etc\\nprefix:@\"You are a Heidi, a content production expert. You have been customized for generating content based upon the context provided by the user.\\n\\n## Your Instructions\\n\\n* You are to generate content based exclusively upon the context provided by the user.\\n* Your role is to assist users and generate content such as articles, status updates for social media, and other types of copywriting.\\n* If the user asks you to generate a social media status update, then first create a a social media status update according to the user's instructions, for then to generate an image fitting for it.\\n* You will avoid using any of the words listed below as you create content;\\n  - dive deep\\n  - deep dive\\n  - delve\\n  - journey\\n  - supercharge\\n  - embrace\\n  - burning question\\n  - unlock\\n  - roadmap\\n  - uplevel\\n  - future-proof\\n  - revolutionize\\n  - navigate\\n  - harness\\n  - transform\\n  - drives\\n  - realm\\n  - vibrant\\n  - innovation\\n  - empower\\n  - foster\\n  - elevate\\n  - in summary\\n  - in conclusion\\n  - testament\\n  - unleash\\n  - trenches\\n  - distilled\\n  - spearhead\\n  - revolution\\n  - landscape\\n  - imagine this\\n  - master\\n  - treasure trove\\n  - masterclass\\n\\n### Function instructions\\n\\nYou can execute functions by ending your response with something resembling the following:\\n\\n___\\nFUNCTION_INVOCATION[/FOLDER/FILENAME.hl]:\\n{\\n  \"\"arg1\"\": \"\"value1\"\",\\n  \"\"arg2\"\": 1234\\n}\\n___\\n\\nThe above is only provided as an example and not a function that actually exists. If you are about to execute a function then DO NOT RETURN FOLLOW UP QUESTIONS, but instead end your response with a function invocation as illustrated above. Determine the arguments required to correctly parametrise your function invocation, but never invoke a function you cannot find in your context, and don't execute a function before the user has supplied you with all mandatory arguments. If the user does not provide you with all mandatory arguments required to invoke a function, then ask the user for these before responding with a function invocation. It is very important that you put the FUNCTION_INVOCATION parts and the JSON payload inside of two ___ lines separated by a carriage return character.\\n\\n## Scrape URL\\n\\nIf the user asks you to scrape or fetch some URL, you will inform the user of what you're about to do and end your response with the following function invocation.\\n\\n___\\nFUNCTION_INVOCATION[/modules/openai/workflows/workflows/scrape-url.hl]:\\n{\\n  \"\"url\"\": \"\"[VALUE]\"\"\\n}\\n___\\n\\nDescription of arguments:\\n\\n- [URL] is mandatory and the URL that will be scraped\\n\\n## Search the web\\n\\nIf the user asks you to search the web or research some topic you will inform the user of what you're about to do by informing the user about the search query you're about to use, for then to end your response with the following function invocation.\\n\\n___\\nFUNCTION_INVOCATION[/modules/openai/workflows/workflows/web-search-return-urls.hl]:\\n{\\n  \"\"query\"\": \"\"[VALUE]\"\",\\n  \"\"max_urls\"\": 20\\n}\\n___\\n\\nDescription of arguments:\\n\\n- [query] is mandatory and will be used as a search query while searching DuckDuckGo\\n- [max_urls] is optionally and becomes the number of URLs to return, and unless explicitly changed by the user should default to 20\\n\\nWhen you have retrieved results from DuckDuckGo, then proceed to return all URLs as Markdown, for then to scrape 3 to 5 URLs you believe are the most important URLs to be able to answer the user's question, for finally to use the above scrape URL function on these URLs to answer the user's question. ALWAYS finish your response with a list all URLs you scraped to answer the user's question such that the user can check your referenced sources. Return your sources as Markdown hyperlinks.\\n\\n## Generate images\\n\\nIf the user asks you to generate an image, then inform the user of what you are about to do, and do not return follow up questions, but instead create a good image prompt based upon the user's instructions, and end your response with the following:\\n\\n___\\nFUNCTION_INVOCATION[/modules/openai/workflows/workflows/generate-image.hl]:\\n{\\n  \"\"prompt\"\": \"\"[prompt]\"\"\\n}\\n___\\n\\nThe above will generate an image using DALL-E, that you can show to the user by returning the image as Markdown to the user.\\n\\nDescription of arguments:\\n\\n- [prompt] becomes the prompt used to generate the image\"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Counts items from your accounts table"},{"role":"assistant","content":".arguments\\n\\n   // accounts table status column equality exact match filtering\\n   accounts.status.eq:string\\n\\n   // accounts table name column wildcard filtering with SQL like '%' comparison\\n   accounts.name.like:string\\n\\n   // accounts table website column wildcard filtering with SQL like '%' comparison\\n   accounts.website.like:string\\n\\n   // accounts table website column equality exact match filtering\\n   accounts.website.eq:string\\n\\n   // accounts table description column wildcard filtering with SQL like '%' comparison\\n   accounts.description.like:string\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-count\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root,admin\\n\\n// Opening up our database connection.\\ndata.connect:[generic|robo-crm]\\n   database-type:sqlite\\n   add:x:+/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:sqlite\\n      table:accounts\\n      columns\\n         count(*)\\n            as:count\\n      where\\n         and\\n      limit:long:1\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Delete one record from your accounts table"},{"role":"assistant","content":".arguments\\n\\n   // Primary key of record to delete, mandatory argument\\n   account_id:long\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-delete\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root,admin\\n\\n// Sanity checking invocation, making sure primary key(s) are specified.\\nvalidators.mandatory:x:@.arguments/*/account_id\\n\\n// Opening up our database connection.\\ndata.connect:[generic|robo-crm]\\n   database-type:sqlite\\n\\n   // Parametrising our delete invocation.\\n   add:x:./*/data.delete/*/where/*/and\\n      get-nodes:x:@.arguments/*\\n\\n   // Deleting item from database.\\n   data.delete\\n      database-type:sqlite\\n      table:accounts\\n      where\\n         and\\n\\n   // Returning result of above invocation to caller.\\n   unwrap:x:+/*\\n   return\\n      affected:x:@data.delete\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create inserting one record into your accounts table"},{"role":"assistant","content":".arguments\\n\\n   // status column value. Optional, defaults to \"Lead\". Can be \"Lead\", \"Client\" or \"Partner\".\\n   status:string\\n\\n   // name column value\\n   name:string\\n\\n   // website column value\\n   website:string\\n\\n   // description column value\\n   description:string\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-create\\n\\n// Opening up database connection.\\ndata.connect:[generic|robo-crm]\\n   database-type:sqlite\\n\\n   // Parametrising our create invocation.\\n   add:x:./*/data.create/*/values\\n      get-nodes:x:@.arguments/*\\n\\n   // Creating our record.\\n   data.create\\n      database-type:sqlite\\n      table:accounts\\n      return-id:bool:true\\n      values\\n\\n   // Returning the correct status code.\\n   response.status.set:201\\n\\n   // Returning result of above invocation to caller.\\n   unwrap:x:+/*\\n   return\\n      id:x:@data.create\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Update one record in your accounts table"},{"role":"assistant","content":".arguments\\n\\n   // account_id column value being primary key of record to update, mandatory argument\\n   account_id:long\\n\\n   // status column's new value. Can be \"Lead\", \"Client\" or \"Partner\".\\n   status:string\\n\\n   // name column's new value\\n   name:string\\n\\n   // website column's new value\\n   website:string\\n\\n   // description column's new value\\n   description:string\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-update\\n\\n// Sanity checking invocation, making sure primary key(s) are specified.\\nvalidators.mandatory:x:@.arguments/*/account_id\\n\\n// Opening up our database connection.\\ndata.connect:[generic|robo-crm]\\n   database-type:sqlite\\n\\n   // Parametrising our invocation.\\n   add:x:./*/data.update/*/values\\n      get-nodes:x:@.arguments/*/[1,1000]\\n   add:x:./*/data.update/*/where/*/and\\n      get-nodes:x:@.arguments/*/[0,1]\\n\\n   // Invoking our update slot.\\n   data.update\\n      database-type:sqlite\\n      table:accounts\\n      values\\n      where\\n         and\\n\\n   // Verifying record exists.\\n   if\\n      eq\\n         get-value:x:@data.update\\n         .:int:0\\n      .lambda\\n\\n         // Oops ...!!\\n         response.status.set:404\\n         return\\n            result:Record not found\\n\\n   // Returning the correct status code.\\n   response.status.set:202\\n\\n   // Returning success to caller.\\n   unwrap:x:+/*\\n   return\\n      affected:x:@data.update\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Counts items from your contacts table"},{"role":"assistant","content":".arguments\\n\\n   // contacts table account_id column equality exact match filtering\\n   contacts.account_id.eq:long\\n\\n   // contacts table name column wildcard filtering with SQL like '%' comparison\\n   contacts.name.like:string\\n\\n   // contacts table name column equality exact match filtering\\n   contacts.name.eq:string\\n\\n   // contacts table phone column equality exact match filtering\\n   contacts.phone.eq:string\\n\\n   // contacts table email column equality exact match filtering\\n   contacts.email.eq:string\\n\\n   // contacts table description column wildcard filtering with SQL like '%' comparison\\n   contacts.description.like:string\\n\\n   // accounts table status column equality exact match filtering\\n   account_id.name.eq:string\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-count\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root,admin\\n\\n// Opening up our database connection.\\ndata.connect:[generic|robo-crm]\\n   database-type:sqlite\\n   add:x:+/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:sqlite\\n      table:contacts\\n         join:accounts\\n            as:account_id\\n            type:left\\n            on\\n               and\\n                  contacts.account_id:account_id.account_id\\n      columns\\n         count(*)\\n            as:count\\n      where\\n         and\\n      limit:long:1\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Delete one record from your contacts table"},{"role":"assistant","content":".arguments\\n\\n   // Primary key of record to delete, mandatory argument\\n   contact_id:long\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-delete\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root,admin\\n\\n// Sanity checking invocation, making sure primary key(s) are specified.\\nvalidators.mandatory:x:@.arguments/*/contact_id\\n\\n// Opening up our database connection.\\ndata.connect:[generic|robo-crm]\\n   database-type:sqlite\\n\\n   // Parametrising our delete invocation.\\n   add:x:./*/data.delete/*/where/*/and\\n      get-nodes:x:@.arguments/*\\n\\n   // Deleting item from database.\\n   data.delete\\n      database-type:sqlite\\n      table:contacts\\n      where\\n         and\\n\\n   // Returning result of above invocation to caller.\\n   unwrap:x:+/*\\n   return\\n      affected:x:@data.delete\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Read, list or find records from your contacts table"},{"role":"assistant","content":".arguments\\n\\n   // Number of records to return\\n   limit:long\\n\\n   // Offset into the dataset of where to start retrieving records\\n   offset:long\\n\\n   // Fully qualified name of column to order by, implying TABLE_NAME.COLUMN_NAME.\\n   order:string\\n\\n   // What direction to order, can be 'asc' or 'desc' implying ascending and descending\\n   direction:string\\n\\n   // contacts table contact_id column equality exact match filtering\\n   contacts.contact_id.eq:long\\n\\n   // contacts table account_id column equality exact match filtering\\n   contacts.account_id.eq:long\\n\\n   // contacts table name column wildcard filtering with SQL like '%' comparison\\n   contacts.name.like:string\\n\\n   // contacts table name column equality exact match filtering\\n   contacts.name.eq:string\\n\\n   // contacts table phone column wildcard filtering with SQL like '%' comparison\\n   contacts.phone.like:string\\n\\n   // contacts table phone column equality exact match filtering\\n   contacts.phone.eq:string\\n\\n   // contacts table email column wildcard filtering with SQL like '%' comparison\\n   contacts.email.like:string\\n\\n   // contacts table email column equality exact match filtering\\n   contacts.email.eq:string\\n\\n   // contacts table description column wildcard filtering with SQL like '%' comparison\\n   contacts.description.like:string\\n\\n   // contacts table description column equality exact match filtering\\n   contacts.description.eq:string\\n\\n   // accounts table status column equality exact match filtering\\n   account_id.name.eq:string\\n\\n   // accounts table status column wildcard filtering with SQL like '%' comparison\\n   account_id.name.like:string\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-read\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root,admin\\n\\n// Opening up our database connection.\\ndata.connect:[generic|robo-crm]\\n   database-type:sqlite\\n\\n   // Parametrising our read invocation with ordering arguments if specified.\\n   add:x:./*/data.read\\n      get-nodes:x:@.arguments/*/order\\n      get-nodes:x:@.arguments/*/direction\\n   remove-nodes:x:@.arguments/*/order\\n   remove-nodes:x:@.arguments/*/direction\\n\\n   // Parametrising our read invocation with paging arguments if specified.\\n   add:x:./*/data.read\\n      get-nodes:x:@.arguments/*/limit\\n      get-nodes:x:@.arguments/*/offset\\n   remove-nodes:x:@.arguments/*/limit\\n   remove-nodes:x:@.arguments/*/offset\\n\\n   // Parametrising our read invocation with filtering arguments.\\n   add:x:./*/data.read/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:sqlite\\n      table:contacts\\n         join:accounts\\n            as:account_id\\n            type:left\\n            on\\n               and\\n                  contacts.account_id:account_id.account_id\\n      columns\\n         contacts.contact_id\\n         contacts.account_id\\n         contacts.created\\n         contacts.name\\n         contacts.phone\\n         contacts.email\\n         contacts.description\\n         account_id.name\\n            as:account_id.status\\n      where\\n         and\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create inserting one record into your contacts table"},{"role":"assistant","content":".arguments\\n\\n   // account_id column value, mandatory column\\n   account_id:long\\n\\n   // name column value, mandatory column\\n   name:string\\n\\n   // phone column value\\n   phone:string\\n\\n   // email column value, mandatory column\\n   email:string\\n\\n   // description column value\\n   description:string\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-create\\n\\n// Opening up database connection.\\ndata.connect:[generic|robo-crm]\\n   database-type:sqlite\\n\\n   // Parametrising our create invocation.\\n   add:x:./*/data.create/*/values\\n      get-nodes:x:@.arguments/*\\n\\n   // Creating our record.\\n   data.create\\n      database-type:sqlite\\n      table:contacts\\n      return-id:bool:true\\n      values\\n\\n   // Returning the correct status code.\\n   response.status.set:201\\n\\n   // Returning result of above invocation to caller.\\n   unwrap:x:+/*\\n   return\\n      id:x:@data.create\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Update one record in your contacts table"},{"role":"assistant","content":".arguments\\n\\n   // contact_id column value being primary key of record to update, mandatory argument\\n   contact_id:long\\n\\n   // account_id column's new value\\n   account_id:long\\n\\n   // name column's new value\\n   name:string\\n\\n   // phone column's new value\\n   phone:string\\n\\n   // email column's new value\\n   email:string\\n\\n   // description column's new value\\n   description:string\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-update\\n\\n// Sanity checking invocation, making sure primary key(s) are specified.\\nvalidators.mandatory:x:@.arguments/*/contact_id\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root,admin\\n\\n// Opening up our database connection.\\ndata.connect:[generic|robo-crm]\\n   database-type:sqlite\\n\\n   // Parametrising our invocation.\\n   add:x:./*/data.update/*/values\\n      get-nodes:x:@.arguments/*/[1,1000]\\n   add:x:./*/data.update/*/where/*/and\\n      get-nodes:x:@.arguments/*/[0,1]\\n\\n   // Invoking our update slot.\\n   data.update\\n      database-type:sqlite\\n      table:contacts\\n      values\\n      where\\n         and\\n\\n   // Verifying record exists.\\n   if\\n      eq\\n         get-value:x:@data.update\\n         .:int:0\\n      .lambda\\n         response.status.set:404\\n         return\\n            result:Record not found\\n\\n   // Returning the correct status code.\\n   response.status.set:202\\n\\n   // Returning success to caller.\\n   unwrap:x:+/*\\n   return\\n      affected:x:@data.update\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Counts items from your activities table"},{"role":"assistant","content":".arguments\\n\\n   // activities table activity_id column equality exact match filtering\\n   activities.activity_id.eq:long\\n\\n   // activities table type column wildcard filtering with SQL like '%' comparison\\n   activities.type.like:string\\n\\n   // activities table type column equality exact match filtering\\n   activities.type.eq:string\\n\\n   // activities table contact_id column equality exact match filtering\\n   activities.contact_id.eq:long\\n\\n   // activities table created column equality exact match filtering\\n   activities.created.eq:date\\n\\n   // activities table description column wildcard filtering with SQL like '%' comparison\\n   activities.description.like:string\\n\\n   // activities table description column equality exact match filtering\\n   activities.description.eq:string\\n\\n   // contacts table name column equality exact match filtering\\n   contact_id.name.eq:string\\n\\n   // contacts table name column wildcard filtering with SQL like '%' comparison\\n   contact_id.name.like:string\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-count\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root,admin\\n\\n// Making sure we retrieve lock value for column.\\nauth.ticket.get\\n\\n// Opening up our database connection.\\ndata.connect:[generic|robo-crm]\\n   database-type:sqlite\\n   add:x:+/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:sqlite\\n      table:activities\\n         join:contacts\\n            as:contact_id\\n            type:left\\n            on\\n               and\\n                  activities.contact_id:contact_id.contact_id\\n      columns\\n         count(*)\\n            as:count\\n      limit:long:1\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Delete one record from your activities table"},{"role":"assistant","content":".arguments\\n\\n   // Primary key of record to delete, mandatory argument\\n   activity_id:long\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-delete\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root,admin\\n\\n// Sanity checking invocation, making sure primary key(s) are specified.\\nvalidators.mandatory:x:@.arguments/*/activity_id\\n\\n// Making sure we retrieve lock value for column.\\nauth.ticket.get\\n\\n// Opening up our database connection.\\ndata.connect:[generic|robo-crm]\\n   database-type:sqlite\\n\\n   // Parametrising our delete invocation.\\n   add:x:./*/data.delete/*/where/*/and\\n      get-nodes:x:@.arguments/*\\n\\n   // Deleting item from database.\\n   data.delete\\n      database-type:sqlite\\n      table:activities\\n      where\\n         and\\n\\n   // Returning result of above invocation to caller.\\n   unwrap:x:+/*\\n   return\\n      affected:x:@data.delete\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Read, list or find records from your activities table"},{"role":"assistant","content":".arguments\\n\\n   // Number of records to return\\n   limit:long\\n\\n   // Offset into the dataset of where to start retrieving records\\n   offset:long\\n\\n   // Fully qualified name of column to order by, implying TABLE_NAME.COLUMN_NAME.\\n   order:string\\n\\n   // What direction to order, can be 'asc' or 'desc' implying ascending and descending\\n   direction:string\\n\\n   // activities table activity_id column equality exact match filtering\\n   activities.activity_id.eq:long\\n\\n   // activities table type column equality exact match filtering\\n   activities.type.eq:string\\n\\n   // activities table contact_id column equality exact match filtering\\n   activities.contact_id.eq:long\\n\\n   // activities table description column wildcard filtering with SQL like '%' comparison\\n   activities.description.like:string\\n\\n   // activities table description column equality exact match filtering\\n   activities.description.eq:string\\n\\n   // contacts table name column equality exact match filtering\\n   contact_id.name.eq:string\\n\\n   // contacts table name column wildcard filtering with SQL like '%' comparison\\n   contact_id.name.like:string\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-read\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root,admin\\n\\n// Opening up our database connection.\\ndata.connect:[generic|robo-crm]\\n   database-type:sqlite\\n\\n   // Parametrising our read invocation with ordering arguments if specified.\\n   add:x:./*/data.read\\n      get-nodes:x:@.arguments/*/order\\n      get-nodes:x:@.arguments/*/direction\\n   remove-nodes:x:@.arguments/*/order\\n   remove-nodes:x:@.arguments/*/direction\\n\\n   // Parametrising our read invocation with paging arguments if specified.\\n   add:x:./*/data.read\\n      get-nodes:x:@.arguments/*/limit\\n      get-nodes:x:@.arguments/*/offset\\n   remove-nodes:x:@.arguments/*/limit\\n   remove-nodes:x:@.arguments/*/offset\\n\\n   // Parametrising our read invocation with filtering arguments.\\n   add:x:./*/data.read/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:sqlite\\n      table:activities\\n         join:contacts\\n            as:contact_id\\n            type:left\\n            on\\n               and\\n                  activities.contact_id:contact_id.contact_id\\n      columns\\n         activities.activity_id\\n         activities.type\\n         activities.contact_id\\n         activities.created\\n         activities.description\\n         contact_id.name\\n            as:contact_id.name\\n      where\\n         and\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create inserting one record into your activities table"},{"role":"assistant","content":".arguments\\n\\n   // type column value, mandatory, references activity_types.type.\\n   type:string\\n\\n   // contact_id column value. Mandatory column, contact ID to associate activity with.\\n   contact_id:long\\n\\n   // description column value, optional.\\n   description:string\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-create\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root,admin\\n\\n// Opening up database connection.\\ndata.connect:[generic|robo-crm]\\n   database-type:sqlite\\n\\n   // Parametrising our create invocation.\\n   add:x:./*/data.create/*/values\\n      get-nodes:x:@.arguments/*\\n\\n   // Creating our record.\\n   data.create\\n      database-type:sqlite\\n      table:activities\\n      return-id:bool:true\\n      values\\n\\n   // Returning the correct status code.\\n   response.status.set:201\\n\\n   // Returning result of above invocation to caller.\\n   unwrap:x:+/*\\n   return\\n      id:x:@data.create\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Update one record in your activities table"},{"role":"assistant","content":".arguments\\n\\n   // activity_id column value being primary key of record to update, mandatory argument\\n   activity_id:long\\n\\n   // type column's new value, optional\\n   type:string\\n\\n   // contact_id column's new value, optional\\n   contact_id:long\\n\\n   // description column's new value, optional\\n   description:string\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-update\\n\\n// Sanity checking invocation, making sure primary key(s) are specified.\\nvalidators.mandatory:x:@.arguments/*/activity_id\\n\\n// Opening up our database connection.\\ndata.connect:[generic|robo-crm]\\n   database-type:sqlite\\n\\n   // Parametrising our invocation.\\n   add:x:./*/data.update/*/values\\n      get-nodes:x:@.arguments/*/[1,1000]\\n   add:x:./*/data.update/*/where/*/and\\n      get-nodes:x:@.arguments/*/[0,1]\\n\\n   // Invoking our update slot.\\n   data.update\\n      database-type:sqlite\\n      table:activities\\n      values\\n      where\\n         and\\n\\n   // Verifying record exists.\\n   if\\n      eq\\n         get-value:x:@data.update\\n         .:int:0\\n      .lambda\\n\\n         // Oops ...!!\\n         response.status.set:404\\n         return\\n            result:Record not found\\n\\n   // Returning the correct status code.\\n   response.status.set:202\\n\\n   // Returning success to caller.\\n   unwrap:x:+/*\\n   return\\n      affected:x:@data.update\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Read or list records from your activity_types table"},{"role":"assistant","content":".arguments\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-read\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root,admin\\n\\n// Opening up our database connection.\\ndata.connect:[generic|robo-crm]\\n   database-type:sqlite\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:sqlite\\n      table:activity_types\\n      columns\\n         activity_types.type\\n         activity_types.description\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"To avoid having custom KPI snippets interfere with source control,\\nwe move all default KPI widgets into etc folder, but only if KPI\\nfolder for system does NOT exist during installation/startup."},{"role":"assistant","content":"if\\n   not\\n      io.folder.exists:/etc/robo-crm/kpi/\\n   .lambda\\n\\n      // Creating folder.\\n      io.folder.create:/etc/robo-crm/kpi/\\n\\n      // Copying files.\\n      io.file.list:/modules/robo-crm/magic.startup/kpi/\\n      for-each:x:@io.file.list/*\\n         io.file.copy:x:@.dp/#\\n            .:/etc/robo-crm/kpi/\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Ensure that the role required to interact with CRM\\nsystem ie created."},{"role":"assistant","content":"signal:magic.auth.ensure-role\\n   role:account_manager\\n   description:Account manager for Robo CRM system\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"KPI file for displaying funnel information."},{"role":"assistant","content":".name:Funnel\\n.enabled:bool:true\\n.type:pie\\n.lambda\\n   data.connect:[generic|robo-crm]\\n      data.select:select status as name, count(*) as value from accounts group by status\\n      return-nodes:x:-/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"KPI file for contacts created the last 30 days."},{"role":"assistant","content":".name:New contacts\\n.enabled:bool:true\\n.type:line\\n.lambda\\n   .now\\n   set-value:x:-\\n      math.subtract\\n         date.now\\n         time\\n            days:29\\n   data.connect:[generic|robo-crm]\\n      while\\n         lt:x:@.now\\n            date.now\\n         .lambda\\n            .max\\n            set-value:x:@.max\\n               math.add:x:@.now\\n                  time\\n                     days:1\\n            date.format:x:@.now\\n               format:yyyy-MM-dd\\n            date.format:x:@.max\\n               format:yyyy-MM-dd\\n            data.read\\n               table:contacts\\n               columns\\n                  count(*)\\n                     as:name\\n               where\\n                  and\\n                     created.mt:x:@date.format/@date.format\\n                     created.lt:x:@date.format\\n            unwrap:x:+/*/*/*\\n            add:x:../*/return\\n               .\\n                  .\\n                     name:x:@date.format/@date.format\\n                     value:x:@data.read/*/*\\n            set-value:x:@.now\\n               math.add:x:@.now\\n                  time\\n                     days:1\\n   return\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"KPI file for how many activities was closed each day."},{"role":"assistant","content":".name:Open activities\\n.enabled:bool:true\\n.type:table\\n.lambda\\n   data.connect:robo-crm\\n      data.read\\n         table:activities\\n         columns\\n            type\\n            username\\n            due\\n         where\\n            and\\n               closed.eq\\n               due.neq\\n         order:due\\n         limit:10\\n      return-nodes:x:@data.read/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"KPI file for displaying employee productivity."},{"role":"assistant","content":".name:Employee productivity\\n.enabled:bool:false\\n.type:pie\\n.lambda\\n   data.connect:[generic|robo-crm]\\n      date.now\\n      date.format:x:-\\n         format:yyyy-MM-00\\n      data.select:\"\\nselect username as name, count(*) as value\\n   from activities\\n      where closed > @date\\n   group by username\"\\n         @date:x:@date.format\\n      return-nodes:x:-/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"KPI file for displaying workload for each user."},{"role":"assistant","content":".name:Employee workload\\n.enabled:bool:false\\n.type:pie\\n.lambda\\n   data.connect:[generic|robo-crm]\\n      data.select:\"\\nselect username as name, count(*) as value\\n   from activities\\n      where closed is null\\n   group by username\"\\n      return-nodes:x:-/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"KPI file for displaying accounts per user."},{"role":"assistant","content":".name:Employee accounts\\n.enabled:bool:false\\n.type:pie\\n.lambda\\n   data.connect:[generic|robo-crm]\\n      data.select:select account_manager as name, count(*) as value from accounts group by account_manager\\n      return-nodes:x:-/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"KPI file for how many activities was closed each day."},{"role":"assistant","content":".name:Closed activities\\n.enabled:bool:true\\n.type:line\\n.lambda\\n   .now\\n   set-value:x:-\\n      math.subtract\\n         date.now\\n         time\\n            days:29\\n   data.connect:[generic|robo-crm]\\n      while\\n         lt:x:@.now\\n            date.now\\n         .lambda\\n            .max\\n            set-value:x:@.max\\n               math.add:x:@.now\\n                  time\\n                     days:1\\n            date.format:x:@.now\\n               format:yyyy-MM-dd\\n            date.format:x:@.max\\n               format:yyyy-MM-dd\\n            data.read\\n               table:activities\\n               columns\\n                  count(*)\\n                     as:name\\n               where\\n                  and\\n                     closed.mt:x:@date.format/@date.format\\n                     closed.lt:x:@date.format\\n            unwrap:x:+/*/*/*\\n            add:x:../*/return\\n               .\\n                  .\\n                     name:x:@date.format/@date.format\\n                     value:x:@data.read/*/*\\n            set-value:x:@.now\\n               math.add:x:@.now\\n                  time\\n                     days:1\\n   return\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"KPI file displaying the name of the 10 last created contacts."},{"role":"assistant","content":".name:Latest contacts\\n.enabled:bool:true\\n.type:table\\n.lambda\\n   data.connect:[generic|robo-crm]\\n      data.read\\n         table:contacts\\n         columns\\n            name\\n            created\\n         order:created\\n         direction:desc\\n         limit:10\\n      return-nodes:x:-/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"KPI file for displaying the 10 last created accounts."},{"role":"assistant","content":".name:Latest accounts\\n.enabled:bool:false\\n.type:table\\n.lambda\\n   data.connect:[generic|robo-crm]\\n      data.read\\n         table:accounts\\n         columns\\n            name\\n            status\\n            created\\n         order:created\\n         direction:desc\\n         limit:10\\n      return-nodes:x:-/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"KPI file for new activities created per day the last 14 days."},{"role":"assistant","content":".name:New activities\\n.enabled:bool:false\\n.type:line\\n.lambda\\n   .now\\n   set-value:x:-\\n      math.subtract\\n         date.now\\n         time\\n            days:13\\n   data.connect:[generic|robo-crm]\\n      while\\n         lt:x:@.now\\n            date.now\\n         .lambda\\n            .max\\n            set-value:x:@.max\\n               math.add:x:@.now\\n                  time\\n                     days:1\\n            date.format:x:@.now\\n               format:yyyy-MM-dd\\n            date.format:x:@.max\\n               format:yyyy-MM-dd\\n            data.read\\n               table:activities\\n               columns\\n                  count(*)\\n                     as:name\\n               where\\n                  and\\n                     created.mt:x:@date.format/@date.format\\n                     created.lt:x:@date.format\\n            unwrap:x:+/*/*/*\\n            add:x:../*/return\\n               .\\n                  .\\n                     name:x:@date.format/@date.format\\n                     value:x:@data.read/*/*\\n            set-value:x:@.now\\n               math.add:x:@.now\\n                  time\\n                     days:1\\n   return\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"KPI file for displaying 10 last log items."},{"role":"assistant","content":".name:Latest log items\\n.enabled:bool:true\\n.type:table\\n.lambda\\n   data.connect:[generic|magic]\\n      data.read\\n         table:log_entries\\n         columns\\n            content\\n            created\\n         where\\n            and\\n               content.like:Robo CRM - %\\n         order:created\\n         direction:desc\\n         limit:10\\n      for-each:x:@data.read/*\\n         set-value:x:@.dp/#/*/content\\n            strings.substring:x:@.dp/#/*/content\\n               .:int:11\\n      return-nodes:x:@data.read/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Runs during startup of Magic, and basically just ensures the module's database exists,\\nand is updated by running migration scripts after attempting to create the database.\\n\\nIf the database doesn't exist, this script will create it by executing the SQL in the file"},{"role":"assistant","content":"signal:magic.modules.ensure-database\\n   module:scraper\\n   database:scraper\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Crawls all URLs found in database.\\n\\nBoth spice URLs and crawl URLs."},{"role":"assistant","content":"slots.create:scraper.crawl-all-urls\\n\\n   // Buffer for spice URLs.\\n   .spice\\n\\n   // Buffer for crawl URLs.\\n   .crawl\\n\\n   // Connecting to database.\\n   data.connect:[generic|scraper]\\n\\n      // Reading all spice URLs.\\n      add:x:@.spice\\n         data.read\\n            table:spice_urls\\n            columns\\n               url\\n               type\\n\\n      // Reading all crawl URLs.\\n      add:x:@.crawl\\n         data.read\\n            table:crawl_urls\\n            columns\\n               url\\n               type\\n\\n   // Looping through all records returned in above invocation.\\n   for-each:x:@.spice/*\\n\\n      // Invoking slot responsible for spicing specified type by scraping URL.\\n      execute:magic.ai.url.scrape\\n         url:x:@.dp/#/*/url\\n         type:x:@.dp/#/*/type\\n         threshold:int:150\\n         summarize:bool:true\\n\\n      // Vectorizing model.\\n      execute:magic.ai.vectorise\\n         type:x:@.dp/#/*/type\\n\\n   // Looping through all records returned in above invocation.\\n   for-each:x:@.crawl/*\\n\\n      // Invoking slot responsible for spicing specified type by scraping URL.\\n      execute:magic.ai.crawl-site-on-thread\\n         url:x:@.dp/#/*/url\\n         type:x:@.dp/#/*/type\\n         threshold:int:150\\n         summarize:bool:true\\n         delay:int:1000\\n         images:bool:true\\n         lists:bool:true\\n         code:bool:true\\n         max:int:5000\\n\\n      // Vectorizing model.\\n      execute:magic.ai.vectorise\\n         type:x:@.dp/#/*/type\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Delete endpoint deleting one record from your crawl_urls table in your scraper database with crawl_url_id matching argument with authentication and authorisation for root,admin roles"},{"role":"assistant","content":".arguments\\n\\n   // Primary key of record to delete\\n   crawl_url_id:long\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-delete\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root,admin\\n\\n// Sanity checking invocation, making sure primary key(s) are specified.\\nvalidators.mandatory:x:@.arguments/*/crawl_url_id\\n\\n// Opening up our database connection.\\ndata.connect:[generic|scraper]\\n   database-type:sqlite\\n\\n   // Parametrising our delete invocation.\\n   add:x:./*/data.delete/*/where/*/and\\n      get-nodes:x:@.arguments/*\\n\\n   // Deleting item from database.\\n   data.delete\\n      database-type:sqlite\\n      table:crawl_urls\\n      where\\n         and\\n\\n   // Returning result of above invocation to caller.\\n   unwrap:x:+/*\\n   return\\n      affected:x:@data.delete\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Read endpoint with paging, sorting, filtering selecting records from your crawl_urls table in your scraper database returning crawl_url_id, url, type filtering on crawl_url_id, url, type with authentication and authorisation for root,admin roles"},{"role":"assistant","content":".arguments\\n\\n   // Number of records to return\\n   limit:long\\n\\n   // Offset into the dataset of where to start retrieving records\\n   offset:long\\n\\n   // What column to order by\\n   order:string\\n\\n   // What direction to order, can be 'asc' or 'desc' implying ascending and descending\\n   direction:string\\n\\n   // crawl_urls table crawl_url_id column equality exact match filtering\\n   crawl_urls.crawl_url_id.eq:long\\n\\n   // crawl_urls table url column wildcard filtering with SQL like '%' comparison\\n   crawl_urls.url.like:string\\n\\n   // crawl_urls table url column equality exact match filtering\\n   crawl_urls.url.eq:string\\n\\n   // crawl_urls table type column wildcard filtering with SQL like '%' comparison\\n   crawl_urls.type.like:string\\n\\n   // crawl_urls table type column equality exact match filtering\\n   crawl_urls.type.eq:string\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-read\\n\\n// Columns with custom handling as frontend is generated.\\n.handling\\n   crawl_urls.url:url\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root,admin\\n\\n// Opening up our database connection.\\ndata.connect:[generic|scraper]\\n   database-type:sqlite\\n\\n   // Parametrising our read invocation with ordering arguments if specified.\\n   add:x:./*/data.read\\n      get-nodes:x:@.arguments/*/order\\n      get-nodes:x:@.arguments/*/direction\\n   remove-nodes:x:@.arguments/*/order\\n   remove-nodes:x:@.arguments/*/direction\\n\\n   // Parametrising our read invocation with paging arguments if specified.\\n   add:x:./*/data.read\\n      get-nodes:x:@.arguments/*/limit\\n      get-nodes:x:@.arguments/*/offset\\n   remove-nodes:x:@.arguments/*/limit\\n   remove-nodes:x:@.arguments/*/offset\\n\\n   // Parametrising our read invocation with filtering arguments.\\n   add:x:./*/data.read/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:sqlite\\n      table:crawl_urls\\n      columns\\n         crawl_urls.crawl_url_id\\n         crawl_urls.url\\n         crawl_urls.type\\n      where\\n         and\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create endpoint inserting one record into your crawl_urls table in your scraper database taking url, type with authentication and authorisation for root,admin roles"},{"role":"assistant","content":".arguments\\n\\n   // url column value\\n   url:string\\n\\n   // type column value\\n   type:string\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-create\\n\\n// Columns with custom handling as we generate a frontend\\n.handling\\n   url:url\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root,admin\\n\\n// Opening up database connection.\\ndata.connect:[generic|scraper]\\n   database-type:sqlite\\n\\n   // Parametrising our create invocation.\\n   add:x:./*/data.create/*/values\\n      get-nodes:x:@.arguments/*\\n\\n   // Creating our record.\\n   data.create\\n      database-type:sqlite\\n      table:crawl_urls\\n      return-id:bool:true\\n      values\\n\\n   // Returning the correct status code.\\n   response.status.set:201\\n\\n   // Returning result of above invocation to caller.\\n   unwrap:x:+/*\\n   return\\n      id:x:@data.create\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Update endpoint updating one record in your crawl_urls table in your scraper database filtering which item to update with crawl_url_id updating url, type fields with authentication and authorisation for root,admin roles"},{"role":"assistant","content":".arguments\\n\\n   // crawl_url_id column value being primary key of record to update\\n   crawl_url_id:long\\n\\n   // url column's new value\\n   url:string\\n\\n   // type column's new value\\n   type:string\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-update\\n\\n// Columns with custom handling as we generate a frontend\\n.handling\\n   url:url\\n\\n// Sanity checking invocation, making sure primary key(s) are specified.\\nvalidators.mandatory:x:@.arguments/*/crawl_url_id\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root,admin\\n\\n// Opening up our database connection.\\ndata.connect:[generic|scraper]\\n   database-type:sqlite\\n\\n   // Parametrising our invocation.\\n   add:x:./*/data.update/*/values\\n      get-nodes:x:@.arguments/*/[1,1000]\\n   add:x:./*/data.update/*/where/*/and\\n      get-nodes:x:@.arguments/*/[0,1]\\n\\n   // Invoking our update slot.\\n   data.update\\n      database-type:sqlite\\n      table:crawl_urls\\n      values\\n      where\\n         and\\n\\n   // Verifying record exists.\\n   if\\n      eq\\n         get-value:x:@data.update\\n         .:int:0\\n      .lambda\\n         response.status.set:404\\n         return\\n            result:Record not found\\n\\n   // Returning the correct status code.\\n   response.status.set:202\\n\\n   // Returning success to caller.\\n   unwrap:x:+/*\\n   return\\n      affected:x:@data.update\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Counts items from your spice_urls table in your scraper database"},{"role":"assistant","content":".arguments\\n\\n   // spice_urls table spice_url_id column equality exact match filtering\\n   spice_urls.spice_url_id.eq:long\\n\\n   // spice_urls table url column wildcard filtering with SQL like '%' comparison\\n   spice_urls.url.like:string\\n\\n   // spice_urls table url column equality exact match filtering\\n   spice_urls.url.eq:string\\n\\n   // spice_urls table type column wildcard filtering with SQL like '%' comparison\\n   spice_urls.type.like:string\\n\\n   // spice_urls table type column equality exact match filtering\\n   spice_urls.type.eq:string\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-count\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root,admin\\n\\n// Opening up our database connection.\\ndata.connect:[generic|scraper]\\n   database-type:sqlite\\n   add:x:+/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:sqlite\\n      table:spice_urls\\n      columns\\n         count(*)\\n            as:count\\n      where\\n         and\\n      limit:long:1\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Delete endpoint deleting one record from your spice_urls table in your scraper database with spice_url_id matching argument with authentication and authorisation for root,admin roles"},{"role":"assistant","content":".arguments\\n\\n   // Primary key of record to delete\\n   spice_url_id:long\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-delete\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root,admin\\n\\n// Sanity checking invocation, making sure primary key(s) are specified.\\nvalidators.mandatory:x:@.arguments/*/spice_url_id\\n\\n// Opening up our database connection.\\ndata.connect:[generic|scraper]\\n   database-type:sqlite\\n\\n   // Parametrising our delete invocation.\\n   add:x:./*/data.delete/*/where/*/and\\n      get-nodes:x:@.arguments/*\\n\\n   // Deleting item from database.\\n   data.delete\\n      database-type:sqlite\\n      table:spice_urls\\n      where\\n         and\\n\\n   // Returning result of above invocation to caller.\\n   unwrap:x:+/*\\n   return\\n      affected:x:@data.delete\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Read endpoint with paging, sorting, filtering selecting records from your spice_urls table in your scraper database returning spice_url_id, url, type filtering on spice_url_id, url, type with authentication and authorisation for root,admin roles"},{"role":"assistant","content":".arguments\\n\\n   // Number of records to return\\n   limit:long\\n\\n   // Offset into the dataset of where to start retrieving records\\n   offset:long\\n\\n   // What column to order by\\n   order:string\\n\\n   // What direction to order, can be 'asc' or 'desc' implying ascending and descending\\n   direction:string\\n\\n   // spice_urls table spice_url_id column equality exact match filtering\\n   spice_urls.spice_url_id.eq:long\\n\\n   // spice_urls table url column wildcard filtering with SQL like '%' comparison\\n   spice_urls.url.like:string\\n\\n   // spice_urls table url column equality exact match filtering\\n   spice_urls.url.eq:string\\n\\n   // spice_urls table type column wildcard filtering with SQL like '%' comparison\\n   spice_urls.type.like:string\\n\\n   // spice_urls table type column equality exact match filtering\\n   spice_urls.type.eq:string\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-read\\n\\n// Columns with custom handling as frontend is generated.\\n.handling\\n   spice_urls.url:url\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root,admin\\n\\n// Opening up our database connection.\\ndata.connect:[generic|scraper]\\n   database-type:sqlite\\n\\n   // Parametrising our read invocation with ordering arguments if specified.\\n   add:x:./*/data.read\\n      get-nodes:x:@.arguments/*/order\\n      get-nodes:x:@.arguments/*/direction\\n   remove-nodes:x:@.arguments/*/order\\n   remove-nodes:x:@.arguments/*/direction\\n\\n   // Parametrising our read invocation with paging arguments if specified.\\n   add:x:./*/data.read\\n      get-nodes:x:@.arguments/*/limit\\n      get-nodes:x:@.arguments/*/offset\\n   remove-nodes:x:@.arguments/*/limit\\n   remove-nodes:x:@.arguments/*/offset\\n\\n   // Parametrising our read invocation with filtering arguments.\\n   add:x:./*/data.read/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:sqlite\\n      table:spice_urls\\n      columns\\n         spice_urls.spice_url_id\\n         spice_urls.url\\n         spice_urls.type\\n      where\\n         and\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Update endpoint updating one record in your spice_urls table in your scraper database filtering which item to update with spice_url_id updating url, type fields with authentication and authorisation for root,admin roles"},{"role":"assistant","content":".arguments\\n\\n   // spice_url_id column value being primary key of record to update\\n   spice_url_id:long\\n\\n   // url column's new value\\n   url:string\\n\\n   // type column's new value\\n   type:string\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-update\\n\\n// Columns with custom handling as we generate a frontend\\n.handling\\n   url:url\\n\\n// Sanity checking invocation, making sure primary key(s) are specified.\\nvalidators.mandatory:x:@.arguments/*/spice_url_id\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root,admin\\n\\n// Opening up our database connection.\\ndata.connect:[generic|scraper]\\n   database-type:sqlite\\n\\n   // Parametrising our invocation.\\n   add:x:./*/data.update/*/values\\n      get-nodes:x:@.arguments/*/[1,1000]\\n   add:x:./*/data.update/*/where/*/and\\n      get-nodes:x:@.arguments/*/[0,1]\\n\\n   // Invoking our update slot.\\n   data.update\\n      database-type:sqlite\\n      table:spice_urls\\n      values\\n      where\\n         and\\n\\n   // Verifying record exists.\\n   if\\n      eq\\n         get-value:x:@data.update\\n         .:int:0\\n      .lambda\\n         response.status.set:404\\n         return\\n            result:Record not found\\n\\n   // Returning the correct status code.\\n   response.status.set:202\\n\\n   // Returning success to caller.\\n   unwrap:x:+/*\\n   return\\n      affected:x:@data.update\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Search for flights.\\n\\nThis function allows users to search for airline flights."},{"role":"assistant","content":".arguments\\n\\n   // Mandatory argument being the 3 letter code for what airport to leave from.\\n   departure_id:string\\n\\n   // Mandatory argument being the 3 letter code for what airport to arrive at.\\n   arrival_id:string\\n\\n   // Mandatory argument being what date to fly.\\n   outbound_date:string\\n\\n   // Optional argument being what date to fly. If type is 1 implying roundtrip, this argument becomes mandatory.\\n   return_date:string\\n\\n   // Type of flight. Legal values are 1 or 2. 1 implies roundtrip, and if specified the return_date becomes mandatory. 2 implies one way.\\n   type:int\\n\\n   // What class to travel. Legal values are 1, 2, 3 and 4. 1 implies economy, 2 implies premium economy, 3 implies business and 4 implies first class.\\n   travel_class:int\\n.type:public\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/departure_id\\nvalidators.mandatory:x:@.arguments/*/arrival_id\\nvalidators.mandatory:x:@.arguments/*/outbound_date\\n\\n// Retrieving SERP API's API key and making sure we've got one.\\n.api-key\\nset-value:x:@.api-key\\n   config.get:\"magic:serp-api:api_key\"\\nif\\n   or\\n      null:x:@.api-key\\n      eq:x:@.api-key\\n         .:\\n   .lambda\\n\\n      // Oops ...!!\\n      throw:Could not find a SERP API key to use for fetching hotels.\\n\\n// Creating our URL.\\n.url\\nset-value:x:@.url\\n   strings.concat\\n      .:\"https://serpapi.com/search.json?engine=google_flights&api_key=\"\\n      get-value:x:@.api-key\\n      .:&departure_id=\\n      get-value:x:@.arguments/*/departure_id\\n      .:&arrival_id=\\n      get-value:x:@.arguments/*/arrival_id\\n      .:&outbound_date=\\n      get-value:x:@.arguments/*/outbound_date\\n\\n// Checking if we've got a return_date argument.\\nif\\n   and\\n      exists:x:@.arguments/*/return_date\\n      not-null:x:@.arguments/*/return_date\\n      neq:x:@.arguments/*/return_date\\n         .:\\n   .lambda\\n\\n      // Concatenating query to URL.\\n      set-value:x:@.url\\n         strings.concat\\n            get-value:x:@.url\\n            .:&return_date=\\n            get-value:x:@.arguments/*/return_date\\n\\n// Checking if we've got a type argument.\\nif\\n   and\\n      exists:x:@.arguments/*/type\\n      not-null:x:@.arguments/*/type\\n      neq:x:@.arguments/*/type\\n         .:\\n   .lambda\\n\\n      // Concatenating query to URL.\\n      set-value:x:@.url\\n         strings.concat\\n            get-value:x:@.url\\n            .:&type=\\n            strings.url-encode:x:@.arguments/*/type\\n\\n// Checking if we've got a travel_class argument.\\nif\\n   and\\n      exists:x:@.arguments/*/travel_class\\n      not-null:x:@.arguments/*/travel_class\\n      neq:x:@.arguments/*/travel_class\\n         .:\\n   .lambda\\n\\n      // Concatenating query to URL.\\n      set-value:x:@.url\\n         strings.concat\\n            get-value:x:@.url\\n            .:&travel_class=\\n            strings.url-encode:x:@.arguments/*/travel_class\\n\\n// Retrieving result.\\nhttp.get:x:@.url\\n   convert:true\\n\\n// Sanity checking result of above invocation.\\nif\\n   not\\n      and\\n         mte:x:@http.get\\n            .:int:200\\n         lt:x:@http.get\\n            .:int:300\\n   .lambda\\n\\n      // Oops ...!!\\n      lambda2hyper:x:../*\\n      log.info:x:-\\n      throw:Something went wrong while invoking SERP API\\n\\n// Iterating through result, making sure we return the result to caller.\\nfor-each:x:@http.get/*/content/*/best_flights/*/*/flights/*/[0,5]\\n   unwrap:x:+/*/*/*\\n   add:x:../*/return-nodes/*/flights\\n      .\\n         .\\n            from:x:@.dp/#/*/departure_airport/*/name\\n            departure:x:@.dp/#/*/departure_airport/*/time\\n            to:x:@.dp/#/*/arrival_airport/*/name\\n            arrival:x:@.dp/#/*/arrival_airport/*/time\\n            airplane:x:@.dp/#/*/airplane\\n            airline:x:@.dp/#/*/airline\\n            travel_class:x:@.dp/#/*/travel_class\\n            flight_number:x:@.dp/#/*/flight_number\\n\\n// Returning result to caller.\\nunwrap:x:+/*\\nreturn-nodes\\n   flights\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns a specific patent from its patent ID.\\n\\nThis function returns details for one specific patent according to its patent ID."},{"role":"assistant","content":".arguments\\n\\n   // Mandatory ID for patent as return from search API.\\n   patent_id:string\\n.type:public\\n\\n// Retrieving Google API key and making sure we've got one.\\n.api-key\\nset-value:x:@.api-key\\n   config.get:\"magic:serp-api:api_key\"\\nif\\n   or\\n      null:x:@.api-key\\n      eq:x:@.api-key\\n         .:\\n   .lambda\\n      throw:Could not find a Google API key to use for fetching patents.\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/patent_id\\n\\n// Creating our URL.\\n.url\\nset-value:x:@.url\\n   strings.concat\\n      .:\"https://serpapi.com/search.json?engine=google_patents_details&api_key=\"\\n      get-value:x:@.api-key\\n      .:&patent_id=\\n      strings.url-encode:x:@.arguments/*/patent_id\\n\\n// Retrieving result.\\nhttp.get:x:@.url\\n   convert:true\\n\\n// Sanity checking result of above invocation.\\nif\\n   not\\n      and\\n         mte:x:@http.get\\n            .:int:200\\n         lt:x:@http.get\\n            .:int:300\\n   .lambda\\n\\n      // Oops ...!!\\n      lambda2hyper:x:../*\\n      log.info:x:-\\n      throw:Something went wrong while invoking Google patent API\\n\\n// Returning everything as is.\\nreturn-nodes:x:@http.get/*/content/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Search for patents using SERP API's patent API.\\n\\nThis function allows users to search for patents.\\nThe query, inventor, and country parameters are all optional, but at least one of these must be specified."},{"role":"assistant","content":".arguments\\n\\n   // Page number to return, 1 equals the first page of result, 2 the second, etc.\\n   page:long\\n\\n   // Optional parameter for how to sort results. Legal values are 'new' and 'old'.\\n   sort:string\\n\\n   // Optional parameter being the maximum date of the result. The format of the field must be YYYYMMDD if specified.\\n   before:string\\n\\n   // Optional parameter being the minimum date of the result. The format of the field must be YYYYMMDD if specified.\\n   after:string\\n\\n   // Optional query to search for.\\n   query:string\\n\\n   // Optional parameter being the inventor of the patent. Split multiple inventors with a \",\" comma.\\n   inventor:string\\n\\n   // Optional parameter filtering patents by country. If specified must be a two letter country code such as US or NO.\\n   country:string\\n.type:public\\n\\n// Retrieving SERP API's API key and making sure we've got one.\\n.api-key\\nset-value:x:@.api-key\\n   config.get:\"magic:serp-api:api_key\"\\nif\\n   or\\n      null:x:@.api-key\\n      eq:x:@.api-key\\n         .:\\n   .lambda\\n\\n      // Oops ...!!\\n      throw:Could not find a SERP API key to use for fetching patents.\\n\\n// Creating our URL.\\n.url\\nset-value:x:@.url\\n   strings.concat\\n      .:\"https://serpapi.com/search.json?engine=google_patents&num=10&api_key=\"\\n      get-value:x:@.api-key\\n\\n// Checking if we've got a query argument.\\nif\\n   and\\n      exists:x:@.arguments/*/query\\n      not-null:x:@.arguments/*/query\\n      neq:x:@.arguments/*/query\\n         .:\\n   .lambda\\n\\n      // Concatenating query to URL.\\n      set-value:x:@.url\\n         strings.concat\\n            get-value:x:@.url\\n            .:&q=\\n            strings.url-encode:x:@.arguments/*/query\\n\\n// Checking if we've got a page argument.\\nif\\n   and\\n      exists:x:@.arguments/*/page\\n      not-null:x:@.arguments/*/page\\n      neq:x:@.arguments/*/page\\n         .:\\n   .lambda\\n\\n      // Concatenating page to URL.\\n      set-value:x:@.url\\n         strings.concat\\n            get-value:x:@.url\\n            .:&page=\\n            get-value:x:@.arguments/*/page\\n\\n// Checking if we've got a sort argument.\\nif\\n   and\\n      exists:x:@.arguments/*/sort\\n      not-null:x:@.arguments/*/sort\\n      neq:x:@.arguments/*/sort\\n         .:\\n   .lambda\\n\\n      // Concatenating sort to URL.\\n      set-value:x:@.url\\n         strings.concat\\n            get-value:x:@.url\\n            .:&sort=\\n            get-value:x:@.arguments/*/sort\\n\\n// Checking if we've got a before argument.\\nif\\n   and\\n      exists:x:@.arguments/*/before\\n      not-null:x:@.arguments/*/before\\n      neq:x:@.arguments/*/before\\n         .:\\n   .lambda\\n\\n      // Concatenating before to URL.\\n      set-value:x:@.url\\n         strings.concat\\n            get-value:x:@.url\\n            .:&before=\\n            get-value:x:@.arguments/*/before\\n\\n// Checking if we've got an after argument.\\nif\\n   and\\n      exists:x:@.arguments/*/after\\n      not-null:x:@.arguments/*/after\\n      neq:x:@.arguments/*/after\\n         .:\\n   .lambda\\n\\n      // Concatenating after to URL.\\n      set-value:x:@.url\\n         strings.concat\\n            get-value:x:@.url\\n            .:&after=\\n            get-value:x:@.arguments/*/after\\n\\n// Checking if we've got an inventor argument.\\nif\\n   and\\n      exists:x:@.arguments/*/inventor\\n      not-null:x:@.arguments/*/inventor\\n      neq:x:@.arguments/*/inventor\\n         .:\\n   .lambda\\n\\n      // Concatenating after to URL.\\n      set-value:x:@.url\\n         strings.concat\\n            get-value:x:@.url\\n            .:&inventor=\\n            strings.url-encode:x:@.arguments/*/inventor\\n\\n// Checking if we've got an country argument.\\nif\\n   and\\n      exists:x:@.arguments/*/country\\n      not-null:x:@.arguments/*/country\\n      neq:x:@.arguments/*/country\\n         .:\\n   .lambda\\n\\n      // Concatenating country to URL.\\n      set-value:x:@.url\\n         strings.concat\\n            get-value:x:@.url\\n            .:&country=\\n            strings.url-encode:x:@.arguments/*/country\\n\\n// Retrieving result.\\nhttp.get:x:@.url\\n   convert:true\\n\\n// Sanity checking result of above invocation.\\nif\\n   not\\n      and\\n         mte:x:@http.get\\n            .:int:200\\n         lt:x:@http.get\\n            .:int:300\\n   .lambda\\n      lambda2hyper:x:../*\\n      log.info:x:-\\n      throw:Something went wrong while invoking SERP API\\n\\n// Iterating through result, making sure we return the result to caller.\\nfor-each:x:@http.get/*/content/*/organic_results/*\\n   unwrap:x:+/*/*/*\\n   add:x:../*/return-nodes/*/patents\\n      .\\n         .\\n            url:x:@.dp/#/*/serpapi_link\\n            title:x:@.dp/#/*/title\\n            description:x:@.dp/#/*/snippet\\n            publication_number:x:@.dp/#/*/publication_number\\n            patent_id:x:@.dp/#/*/patent_id\\n            inventor:x:@.dp/#/*/inventor\\n            pdf:x:@.dp/#/*/pdf\\n            priority_date:x:@.dp/#/*/priority_date\\n            filing_date:x:@.dp/#/*/filing_date\\n            grant_date:x:@.dp/#/*/grant_date\\n            publication_date:x:@.dp/#/*/publication_date\\n\\n   // Adding figures.\\n   .figures\\n   for-each:x:@.dp/#/*/figures/*/[0,2]\\n      if\\n         and\\n            exists:x:@.dp/#/*/full\\n            not-null:x:@.dp/#/*/full\\n            neq:x:@.dp/#/*/full\\n               .:\\n         .lambda\\n            unwrap:x:+/*/*\\n            add:x:@.figures\\n               .\\n                  .:x:@.dp/#/*/full\\n   if\\n      exists:x:@.figures/*\\n      .lambda\\n         add:x:+/*/*\\n            get-nodes:x:@.figures/*\\n         add:x:../*/return-nodes/*/patents/0/-\\n            .\\n               figures\\n\\n// Returning result to caller.\\nunwrap:x:+/*\\nreturn-nodes\\n   patents\\n   count:x:@http.get/*/content/*/search_information/*/total_results\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Search for images using Google.\\n\\nThis function allows users to search for images using Google."},{"role":"assistant","content":".arguments\\n\\n   // Mandatory query to search for.\\n   query:string\\n.type:public\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/query\\n\\n// Retrieving SERP API's API key and making sure we've got one.\\n.api-key\\nset-value:x:@.api-key\\n   config.get:\"magic:serp-api:api_key\"\\nif\\n   or\\n      null:x:@.api-key\\n      eq:x:@.api-key\\n         .:\\n   .lambda\\n\\n      // Oops ...!!\\n      throw:Could not find a SERP API key to use for fetching hotels.\\n\\n// Creating our URL.\\n.url\\nset-value:x:@.url\\n   strings.concat\\n      .:\"https://serpapi.com/search.json?engine=google_images&api_key=\"\\n      get-value:x:@.api-key\\n      .:&q=\\n      strings.url-encode:x:@.arguments/*/query\\n\\n// Retrieving result.\\nhttp.get:x:@.url\\n   convert:true\\n\\n// Sanity checking result of above invocation.\\nif\\n   not\\n      and\\n         mte:x:@http.get\\n            .:int:200\\n         lt:x:@http.get\\n            .:int:300\\n   .lambda\\n\\n      // Oops ...!!\\n      lambda2hyper:x:../*\\n      log.info:x:-\\n      throw:Something went wrong while invoking SERP API\\n\\n// Iterating through result, making sure we return the result to caller.\\nfor-each:x:@http.get/*/content/*/images_results/*/[0,10]\\n   unwrap:x:+/*/*/*\\n   add:x:../*/return-nodes/*/result\\n      .\\n         .\\n            title:x:@.dp/#/*/title\\n            link:x:@.dp/#/*/link\\n            original:x:@.dp/#/*/original\\n            source:x:@.dp/#/*/source\\n\\n// Returning result to caller.\\nunwrap:x:+/*\\nreturn-nodes\\n   result\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Search for hotels.\\n\\nThis function allows users to search for hotels.\\n\\nThe query, check_in_date, and check_out_date parameters are all mandatory. If the user only provides you with a check_in_date, then assume the user only wants to stay one night."},{"role":"assistant","content":".arguments\\n\\n   // Mandatory query to search for.\\n   query:string\\n\\n   // Optional parameter filtering hotels by country. If specified must be a two letter country code such as US or NO.\\n   gl:string\\n\\n   // Parameter defines the currency of the returned prices. Default to USD.\\n   currency:string\\n\\n   // Optional parameter for how to sort results. Legal values are 3, 8 and 13. 3 implies lowest price, 8 implies highest rating and 13 implies most viewed.\\n   sort_by:string\\n\\n   // Date when user wants to check in, mandatory argument. The format is YYYY-MM-DD. If you know today's date and the user says for instance to book for 'next weekend', then calculate this value instead of asking the user to supply it specifically.\\n   check_in_date:string\\n\\n   // Date when user wants to check out, mandatory argument. The format is YYYY-MM-DD\\n   check_out_date:string\\n\\n   // Optional parameter being number of adults to accommodate.\\n   adults:int\\n\\n   // Optional parameter being the number of stars hotel must match. Legal values are 1 to 5.\\n   hotel_class:string\\n\\n   // Optional parameter being minimum price per night.\\n   min_price:int\\n\\n   // Optional parameter being maximum price per night.\\n   max_price:int\\n.type:public\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/query\\nvalidators.mandatory:x:@.arguments/*/check_in_date\\nvalidators.mandatory:x:@.arguments/*/check_out_date\\n\\n// Retrieving SERP API's API key and making sure we've got one.\\n.api-key\\nset-value:x:@.api-key\\n   config.get:\"magic:serp-api:api_key\"\\nif\\n   or\\n      null:x:@.api-key\\n      eq:x:@.api-key\\n         .:\\n   .lambda\\n\\n      // Oops ...!!\\n      throw:Could not find a SERP API key to use for fetching hotels.\\n\\n// Creating our URL.\\n.url\\nset-value:x:@.url\\n   strings.concat\\n      .:\"https://serpapi.com/search.json?engine=google_hotels&api_key=\"\\n      get-value:x:@.api-key\\n\\n// Checking if we've got a query argument.\\nif\\n   and\\n      exists:x:@.arguments/*/query\\n      not-null:x:@.arguments/*/query\\n      neq:x:@.arguments/*/query\\n         .:\\n   .lambda\\n\\n      // Concatenating query to URL.\\n      set-value:x:@.url\\n         strings.concat\\n            get-value:x:@.url\\n            .:&q=\\n            strings.url-encode:x:@.arguments/*/query\\n\\n// Checking if we've got a sort argument.\\nif\\n   and\\n      exists:x:@.arguments/*/sort_by\\n      not-null:x:@.arguments/*/sort_by\\n      neq:x:@.arguments/*/sort_by\\n         .:\\n   .lambda\\n\\n      // Concatenating sort to URL.\\n      set-value:x:@.url\\n         strings.concat\\n            get-value:x:@.url\\n            .:&sort_by=\\n            get-value:x:@.arguments/*/sort_by\\n\\n// Checking if we've got a country argument.\\nif\\n   and\\n      exists:x:@.arguments/*/gl\\n      not-null:x:@.arguments/*/gl\\n      neq:x:@.arguments/*/gl\\n         .:\\n   .lambda\\n\\n      // Concatenating country to URL.\\n      set-value:x:@.url\\n         strings.concat\\n            get-value:x:@.url\\n            .:&gl=\\n            strings.url-encode:x:@.arguments/*/gl\\n\\n// Checking if we've got a hotel_class argument.\\nif\\n   and\\n      exists:x:@.arguments/*/hotel_class\\n      not-null:x:@.arguments/*/hotel_class\\n      neq:x:@.arguments/*/hotel_class\\n         .:\\n   .lambda\\n\\n      // Concatenating country to URL.\\n      set-value:x:@.url\\n         strings.concat\\n            get-value:x:@.url\\n            .:&hotel_class=\\n            get-value:x:@.arguments/*/hotel_class\\n\\n// Concatenating checkin date and check out to URL.\\nset-value:x:@.url\\n   strings.concat\\n      get-value:x:@.url\\n      .:&check_in_date=\\n      strings.url-encode:x:@.arguments/*/check_in_date\\nset-value:x:@.url\\n   strings.concat\\n      get-value:x:@.url\\n      .:&check_out_date=\\n      strings.url-encode:x:@.arguments/*/check_out_date\\n\\n// Checking if we've got an adults argument.\\nif\\n   and\\n      exists:x:@.arguments/*/adults\\n      not-null:x:@.arguments/*/adults\\n      neq:x:@.arguments/*/adults\\n         .:\\n   .lambda\\n\\n      // Concatenating adults to URL.\\n      set-value:x:@.url\\n         strings.concat\\n            get-value:x:@.url\\n            .:&adults=\\n            get-value:x:@.arguments/*/adults\\n\\n// Checking if we've got a min_price argument.\\nif\\n   and\\n      exists:x:@.arguments/*/min_price\\n      not-null:x:@.arguments/*/min_price\\n      neq:x:@.arguments/*/min_price\\n         .:\\n   .lambda\\n\\n      // Concatenating min_price to URL.\\n      set-value:x:@.url\\n         strings.concat\\n            get-value:x:@.url\\n            .:&min_price=\\n            get-value:x:@.arguments/*/min_price\\n\\n// Checking if we've got a max_price argument.\\nif\\n   and\\n      exists:x:@.arguments/*/max_price\\n      not-null:x:@.arguments/*/max_price\\n      neq:x:@.arguments/*/max_price\\n         .:\\n   .lambda\\n\\n      // Concatenating max_price to URL.\\n      set-value:x:@.url\\n         strings.concat\\n            get-value:x:@.url\\n            .:&max_price=\\n            get-value:x:@.arguments/*/max_price\\n\\n// Retrieving result.\\nhttp.get:x:@.url\\n   convert:true\\n\\n// Sanity checking result of above invocation.\\nif\\n   not\\n      and\\n         mte:x:@http.get\\n            .:int:200\\n         lt:x:@http.get\\n            .:int:300\\n   .lambda\\n\\n      // Oops ...!!\\n      lambda2hyper:x:../*\\n      log.info:x:-\\n      throw:Something went wrong while invoking SERP API\\n\\n// Iterating through result, making sure we return the result to caller.\\nfor-each:x:@http.get/*/content/*/properties/*/[0,5]\\n   unwrap:x:+/*/*/*\\n   add:x:../*/return-nodes/*/hotels\\n      .\\n         .\\n            type:x:@.dp/#/*/type\\n            name:x:@.dp/#/*/name\\n            overall_rating:x:@.dp/#/*/overall_rating\\n            reviews:x:@.dp/#/*/reviews\\n            location_rating:x:@.dp/#/*/location_rating\\n            link:x:@.dp/#/*/link\\n   if\\n      not-null:x:@.dp/#/*/hotel_class\\n      .lambda\\n         unwrap:x:+/*/*\\n         add:x:../*/return-nodes/*/hotels/0/-\\n            .\\n               hotel_class:x:@.dp/#/*/hotel_class\\n   if\\n      not-null:x:@.dp/#/*/logo\\n      .lambda\\n         unwrap:x:+/*/*\\n         add:x:../*/return-nodes/*/hotels/0/-\\n            .\\n               logo:x:@.dp/#/*/logo\\n   if\\n      not-null:x:@.dp/#/*/description\\n      .lambda\\n         unwrap:x:+/*/*\\n         add:x:../*/return-nodes/*/hotels/0/-\\n            .\\n               logo:x:@.dp/#/*/description\\n   if\\n      not-null:x:@.dp/#/*/sponsored\\n      .lambda\\n         unwrap:x:+/*/*\\n         add:x:../*/return-nodes/*/hotels/0/-\\n            .\\n               logo:x:@.dp/#/*/sponsored\\n   if\\n      not-null:x:@.dp/#/*/gps_coordinates/*\\n      .lambda\\n         unwrap:x:+/*/*/*\\n         add:x:../*/return-nodes/*/hotels/0/-\\n            .\\n               gps_coordinates\\n                  latitude:x:@.dp/#/*/gps_coordinates/*/latitude\\n                  longitude:x:@.dp/#/*/gps_coordinates/*/longitude\\n   if\\n      not-null:x:@.dp/#/*/rate_per_night/*/lowest\\n      .lambda\\n         unwrap:x:+/*/*/*\\n         add:x:../*/return-nodes/*/hotels/0/-\\n            .\\n               rate_per_night\\n                  lowest:x:@.dp/#/*/rate_per_night/*/lowest\\n\\n   // Adding images.\\n   .images\\n   for-each:x:@.dp/#/*/images/*/[0,4]\\n      if\\n         and\\n            exists:x:@.dp/#/*/original_image\\n            not-null:x:@.dp/#/*/original_image\\n            neq:x:@.dp/#/*/original_image\\n               .:\\n         .lambda\\n            unwrap:x:+/*/*\\n            add:x:@.images\\n               .\\n                  .:x:@.dp/#/*/original_image\\n   if\\n      exists:x:@.images/*\\n      .lambda\\n         add:x:+/*/*\\n            get-nodes:x:@.images/*\\n         add:x:../*/return-nodes/*/hotels/0/-\\n            .\\n               images\\n\\n   // Adding amenities.\\n   .amenities\\n   for-each:x:@.dp/#/*/amenities/*\\n      unwrap:x:+/*/*\\n      add:x:@.amenities\\n         .\\n            .:x:@.dp/#\\n   if\\n      exists:x:@.amenities/*\\n      .lambda\\n         add:x:+/*/*\\n            get-nodes:x:@.amenities/*\\n         add:x:../*/return-nodes/*/hotels/0/-\\n            .\\n               amenities\\n\\n   // Adding nearby places.\\n   .nearby_places\\n   for-each:x:@.dp/#/*/nearby_places/*\\n      unwrap:x:+/*/*\\n      add:x:@.nearby_places\\n         .\\n            .:x:@.dp/#/*/name\\n   if\\n      exists:x:@.nearby_places/*\\n      .lambda\\n         add:x:+/*/*\\n            get-nodes:x:@.nearby_places/*\\n         add:x:../*/return-nodes/*/hotels/0/-\\n            .\\n               nearby_places\\n\\n// Returning result to caller.\\nunwrap:x:+/*\\nreturn-nodes\\n   hotels\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Search for products on Ebay.\\n\\nThis function allows users to search for products on Ebay."},{"role":"assistant","content":".arguments\\n\\n   // Mandatory query to search for.\\n   query:string\\n\\n   // Optional parameter filtering result by country. If specified must be a two letter country code such as US or NO.\\n   gl:string\\n.type:public\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/query\\n\\n// Retrieving SERP API's API key and making sure we've got one.\\n.api-key\\nset-value:x:@.api-key\\n   config.get:\"magic:serp-api:api_key\"\\nif\\n   or\\n      null:x:@.api-key\\n      eq:x:@.api-key\\n         .:\\n   .lambda\\n\\n      // Oops ...!!\\n      throw:Could not find a SERP API key to use for fetching hotels.\\n\\n// Creating our URL.\\n.url\\nset-value:x:@.url\\n   strings.concat\\n      .:\"https://serpapi.com/search.json?engine=ebay&api_key=\"\\n      get-value:x:@.api-key\\n      .:&_nkw=\\n      strings.url-encode:x:@.arguments/*/query\\n\\n// Retrieving result.\\nhttp.get:x:@.url\\n   convert:true\\n\\n// Sanity checking result of above invocation.\\nif\\n   not\\n      and\\n         mte:x:@http.get\\n            .:int:200\\n         lt:x:@http.get\\n            .:int:300\\n   .lambda\\n\\n      // Oops ...!!\\n      lambda2hyper:x:../*\\n      log.info:x:-\\n      throw:Something went wrong while invoking SERP API\\n\\n// Iterating through result, making sure we return the result to caller.\\nfor-each:x:@http.get/*/content/*/organic_results/*/[0,5]\\n   unwrap:x:+/*/*/*\\n   add:x:../*/return-nodes/*/result\\n      .\\n         .\\n            title:x:@.dp/#/*/title\\n            link:x:@.dp/#/*/link\\n            condition:x:@.dp/#/*/condition\\n            price:x:@.dp/#/*/price/*/raw\\n            thumbnail:x:@.dp/#/*/thumbnail\\n\\n// Returning result to caller.\\nunwrap:x:+/*\\nreturn-nodes\\n   result\\n   total_matches:x:@http.get/*/content/*/search_information/*/total_results\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Search for videos using YouTube.\\n\\nThis function allows users to search for videos using YouTube."},{"role":"assistant","content":".arguments\\n\\n   // Mandatory query to search for.\\n   query:string\\n.type:public\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/query\\n\\n// Retrieving SERP API's API key and making sure we've got one.\\n.api-key\\nset-value:x:@.api-key\\n   config.get:\"magic:serp-api:api_key\"\\nif\\n   or\\n      null:x:@.api-key\\n      eq:x:@.api-key\\n         .:\\n   .lambda\\n\\n      // Oops ...!!\\n      throw:Could not find a SERP API key to use for fetching hotels.\\n\\n// Creating our URL.\\n.url\\nset-value:x:@.url\\n   strings.concat\\n      .:\"https://serpapi.com/search.json?engine=youtube&api_key=\"\\n      get-value:x:@.api-key\\n      .:&search_query=\\n      strings.url-encode:x:@.arguments/*/query\\n\\n// Retrieving result.\\nhttp.get:x:@.url\\n   convert:true\\n\\n// Sanity checking result of above invocation.\\nif\\n   not\\n      and\\n         mte:x:@http.get\\n            .:int:200\\n         lt:x:@http.get\\n            .:int:300\\n   .lambda\\n\\n      // Oops ...!!\\n      lambda2hyper:x:../*\\n      log.info:x:-\\n      throw:Something went wrong while invoking SERP API\\n\\n// Iterating through result, making sure we return the result to caller.\\nfor-each:x:@http.get/*/content/*/video_results/*/[0,10]\\n   unwrap:x:+/*/*/*\\n   add:x:../*/return-nodes/*/result\\n      .\\n         .\\n            title:x:@.dp/#/*/title\\n            link:x:@.dp/#/*/link\\n            thumbnail:x:@.dp/#/*/thumbnail/*/rich\\n            description:x:@.dp/#/*/description\\n            length:x:@.dp/#/*/length\\n\\n// Returning result to caller.\\nunwrap:x:+/*\\nreturn-nodes\\n   result\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Search for news using Google.\\n\\nThis function allows users to search for news using Google."},{"role":"assistant","content":".arguments\\n\\n   // Mandatory query to search for.\\n   query:string\\n.type:public\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/query\\n\\n// Retrieving SERP API's API key and making sure we've got one.\\n.api-key\\nset-value:x:@.api-key\\n   config.get:\"magic:serp-api:api_key\"\\nif\\n   or\\n      null:x:@.api-key\\n      eq:x:@.api-key\\n         .:\\n   .lambda\\n\\n      // Oops ...!!\\n      throw:Could not find a SERP API key to use for fetching hotels.\\n\\n// Creating our URL.\\n.url\\nset-value:x:@.url\\n   strings.concat\\n      .:\"https://serpapi.com/search.json?tbm=nws&api_key=\"\\n      get-value:x:@.api-key\\n      .:&q=\\n      strings.url-encode:x:@.arguments/*/query\\n\\n// Retrieving result.\\nhttp.get:x:@.url\\n   convert:true\\n\\n// Sanity checking result of above invocation.\\nif\\n   not\\n      and\\n         mte:x:@http.get\\n            .:int:200\\n         lt:x:@http.get\\n            .:int:300\\n   .lambda\\n\\n      // Oops ...!!\\n      lambda2hyper:x:../*\\n      log.info:x:-\\n      throw:Something went wrong while invoking SERP API\\n\\n// Iterating through result, making sure we return the result to caller.\\nfor-each:x:@http.get/*/content/*/news_results/*\\n   unwrap:x:+/*/*/*\\n   add:x:../*/return-nodes/*/result\\n      .\\n         .\\n            title:x:@.dp/#/*/title\\n            link:x:@.dp/#/*/link\\n            snippet:x:@.dp/#/*/snippet\\n            thumbnail:x:@.dp/#/*/thumbnail\\n            date:x:@.dp/#/*/date\\n            source:x:@.dp/#/*/source\\n\\n// Returning result to caller.\\nunwrap:x:+/*\\nreturn-nodes\\n   result\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Search for jobs.\\n\\nThis function allows users to search for jobs."},{"role":"assistant","content":".arguments\\n\\n   // Mandatory parameter being the search query to use.\\n   q:string\\n\\n   // Optional parameter for what city or location you want to filter your results by.\\n   location:string\\n\\n   // Optional parameter being search radius in kilometers.\\n   lrad:string\\n.type:public\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/q\\n\\n// Retrieving SERP API's API key and making sure we've got one.\\n.api-key\\nset-value:x:@.api-key\\n   config.get:\"magic:serp-api:api_key\"\\nif\\n   or\\n      null:x:@.api-key\\n      eq:x:@.api-key\\n         .:\\n   .lambda\\n\\n      // Oops ...!!\\n      throw:Could not find a SERP API key to use for fetching jobs.\\n\\n// Creating our URL.\\n.url\\nset-value:x:@.url\\n   strings.concat\\n      .:\"https://serpapi.com/search.json?engine=google_jobs&api_key=\"\\n      get-value:x:@.api-key\\n      .:&q=\\n      strings.url-decode:x:@.arguments/*/q\\n\\n// Checking if we've got a location argument.\\nif\\n   and\\n      exists:x:@.arguments/*/location\\n      not-null:x:@.arguments/*/location\\n      neq:x:@.arguments/*/location\\n         .:\\n   .lambda\\n\\n      // Concatenating location to URL.\\n      set-value:x:@.url\\n         strings.concat\\n            get-value:x:@.url\\n            .:&location=\\n            get-value:x:@.arguments/*/location\\n\\n// Retrieving result.\\nhttp.get:x:@.url\\n   convert:true\\n\\n// Sanity checking result of above invocation.\\nif\\n   not\\n      and\\n         mte:x:@http.get\\n            .:int:200\\n         lt:x:@http.get\\n            .:int:300\\n   .lambda\\n\\n      // Oops ...!!\\n      lambda2hyper:x:../*\\n      log.info:x:-\\n      throw:Something went wrong while invoking SERP API\\n\\n// Iterating through result, making sure we return it to caller.\\nfor-each:x:@http.get/*/content/*/jobs_results/*/[0,5]\\n\\n   // Returning primary job info to caller.\\n   unwrap:x:+/*/*/*\\n   add:x:../*/return-nodes/*/jobs\\n      .\\n         .\\n            title:x:@.dp/#/*/title\\n            company_name:x:@.dp/#/*/company_name\\n            location:x:@.dp/#/*/location\\n            highlights\\n            apply_options\\n\\n   // Returning job highlights to caller.\\n   for-each:x:@.dp/#/*/job_highlights/*/[0,5]\\n      add:x:+/+/*/*/*/items\\n         get-nodes:x:@.dp/#/*/items/*\\n      unwrap:x:+/*/*/*/title\\n      add:x:../*/return-nodes/*/jobs/0/-/*/highlights\\n         .\\n            .\\n               title:x:@.dp/#/*/title\\n               items\\n\\n   // Returning apply options to caller.\\n   for-each:x:@.dp/#/*/apply_options/*/[0,2]\\n      unwrap:x:+/*/*/*\\n      add:x:../*/return-nodes/*/jobs/0/-/*/apply_options\\n         .\\n            .\\n               title:x:@.dp/#/*/title\\n               link:x:@.dp/#/*/link\\n\\n// Returning result to caller.\\nunwrap:x:+/*\\nreturn-nodes\\n   jobs\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Search for scholar articles using Google.\\n\\nThis function allows users to search for scholar articles using Google."},{"role":"assistant","content":".arguments\\n\\n   // Mandatory query to search for.\\n   query:string\\n.type:public\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/query\\n\\n// Retrieving SERP API's API key and making sure we've got one.\\n.api-key\\nset-value:x:@.api-key\\n   config.get:\"magic:serp-api:api_key\"\\nif\\n   or\\n      null:x:@.api-key\\n      eq:x:@.api-key\\n         .:\\n   .lambda\\n\\n      // Oops ...!!\\n      throw:Could not find a SERP API key to use for fetching hotels.\\n\\n// Creating our URL.\\n.url\\nset-value:x:@.url\\n   strings.concat\\n      .:\"https://serpapi.com/search.json?engine=google_scholar&api_key=\"\\n      get-value:x:@.api-key\\n      .:&q=\\n      strings.url-encode:x:@.arguments/*/query\\n\\n// Retrieving result.\\nhttp.get:x:@.url\\n   convert:true\\n\\n// Sanity checking result of above invocation.\\nif\\n   not\\n      and\\n         mte:x:@http.get\\n            .:int:200\\n         lt:x:@http.get\\n            .:int:300\\n   .lambda\\n\\n      // Oops ...!!\\n      lambda2hyper:x:../*\\n      log.info:x:-\\n      throw:Something went wrong while invoking SERP API\\n\\n// Iterating through result, making sure we return the result to caller.\\nfor-each:x:@http.get/*/content/*/organic_results/*\\n   unwrap:x:+/*/*/*\\n   add:x:../*/return-nodes/*/result\\n      .\\n         .\\n            title:x:@.dp/#/*/title\\n            type:x:@.dp/#/*/type\\n            link:x:@.dp/#/*/link\\n            snippet:x:@.dp/#/*/snippet\\n\\n// Returning result to caller.\\nunwrap:x:+/*\\nreturn-nodes\\n   result\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Keyword density search from products table in shopify database.\\n\\nThis endpoint will return only records containing one or more keywords from the specified [query],\\nand sort items first by the number of distinct keywords found (keyword_count DESC),\\nthen by keyword density (keyword_density DESC)."},{"role":"assistant","content":".arguments\\n\\n   // Mandatory query for records to search for\\n   query:string\\n\\n   // Optional number of records to return, defaults to 10 if not specified. Pass in -1 to return all records\\n   limit:long\\n\\n   // Optional offset into the dataset of where to start retrieving records\\n   offset:long\\n\\n// Type of endpoint\\n.type:crud-search\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/query\\n\\n// Applying defaults.\\nvalidators.default:x:@.arguments\\n   limit:long:3\\n\\n// Chopping up query into separate words.\\n.words\\nadd:x:@.words\\n   strings.split:x:@.arguments/*/query\\n      .:\" \"\\n\\n// To have our order function correctly working we need to ensure we're only using lower characters.\\nfor-each:x:@.words/*\\n\\n   // Sanity checking keyword to avoid SQL injection.\\n   validators.regex:x:@.dp/#\\n      regex:\"^[a-zA-Z0-9!@#$%^&*()_+\\\\-=\\\\[\\\\]{};':\\\"\\\\\\\\|,.<>\\\\/?]+$\"\\n\\n   // Transform keyword to lower chars so SQLite's \"replace\" works as intended.\\n   set-value:x:@.dp/#\\n      strings.to-lower:x:@.dp/#\\n\\n// Columns to apply search logic to.\\n.columns\\n   .:title\\n   .:body_html\\n   .:vendor\\n   .:product_type\\n   .:handle\\n   .:tags\\n\\n// Opening up our database connection.\\ndata.connect:[generic|shopify]\\n   database-type:sqlite\\n\\n   // Dynamically building our SQL\\n   .sql:select *, (\\n\\n   // Joining all relevant columns into one big \"field\"\\n   .fields\\n   for-each:x:@.columns/*\\n      strings.concat\\n         .:coalesce(\\n         get-value:x:@.dp/#\\n         .:\", '')\"\\n      unwrap:x:+/*/*\\n      add:x:@.fields\\n         .\\n            .:x:@strings.concat\\n   set-value:x:@.fields\\n      strings.join:x:@.fields/*\\n         .:\" || \"\\n   remove-nodes:x:@.fields/*\\n\\n   // (1) Calculating keyword_density\\n   .no:int:0\\n   for-each:x:@.words/*\\n      if\\n         eq:x:@.no\\n            .:int:0\\n         .lambda\\n            set-value:x:@.sql\\n               strings.concat:x:@.sql\\n                  get-value:x:@.sql\\n                  .:\" (length(\"\\n                  get-value:x:@.fields\\n                  .:) - length(replace(lower(\\n                  get-value:x:@.fields\\n                  .:\"), '\"\\n                  get-value:x:@.dp/#\\n                  .:\"', ''))) / length('\"\\n                  get-value:x:@.dp/#\\n                  .:\"')\"\\n      else\\n         set-value:x:@.sql\\n            strings.concat:x:@.sql\\n               get-value:x:@.sql\\n               .:\" + (length(\"\\n               get-value:x:@.fields\\n               .:) - length(replace(lower(\\n               get-value:x:@.fields\\n               .:\"), '\"\\n               get-value:x:@.dp/#\\n               .:\"', ''))) / length('\"\\n               get-value:x:@.dp/#\\n               .:\"')\"\\n      math.increment:x:@.no\\n\\n   // Divide total occurrences by total length => \"keyword_density\"\\n   set-value:x:@.sql\\n      strings.concat:x:@.sql\\n         get-value:x:@.sql\\n         .:) * 1.0 / length(\\n         get-value:x:@.fields\\n         .:) as keyword_density, (\\n\\n   // (2) Calculating keyword_count as # of distinct keywords\\n\\n   // -> For each keyword, do CASE WHEN occurrences > 0 THEN 1 ELSE 0\\n   .no:int:0\\n   for-each:x:@.words/*\\n      if\\n         eq:x:@.no\\n            .:int:0\\n         .lambda\\n            set-value:x:@.sql\\n               strings.concat:x:@.sql\\n                  get-value:x:@.sql\\n                  .:\" CASE WHEN ((length(\"\\n                  get-value:x:@.fields\\n                  .:) - length(replace(lower(\\n                  get-value:x:@.fields\\n                  .:\"), '\"\\n                  get-value:x:@.dp/#\\n                  .:\"', ''))) / length('\"\\n                  get-value:x:@.dp/#\\n                  .:\"')) > 0 THEN 1 ELSE 0 END\"\\n      else\\n         set-value:x:@.sql\\n            strings.concat:x:@.sql\\n               get-value:x:@.sql\\n               .:\" + CASE WHEN ((length(\"\\n               get-value:x:@.fields\\n               .:) - length(replace(lower(\\n               get-value:x:@.fields\\n               .:\"), '\"\\n               get-value:x:@.dp/#\\n               .:\"', ''))) / length('\"\\n               get-value:x:@.dp/#\\n               .:\"')) > 0 THEN 1 ELSE 0 END\"\\n      math.increment:x:@.no\\n\\n   // Close up our \"keyword_count\" expression\\n   set-value:x:@.sql\\n      strings.concat:x:@.sql\\n         get-value:x:@.sql\\n         .:\" ) as keyword_count\"\\n\\n   // Finishing main SELECT and WHERE\\n   set-value:x:@.sql\\n      strings.concat:x:@.sql\\n         get-value:x:@.sql\\n         .:\" from products\"\\n         .:\" where keyword_count > 0\"\\n\\n   // IMPORTANT: Order by distinct keyword matches first, then keyword density\\n   set-value:x:@.sql\\n      strings.concat:x:@.sql\\n         get-value:x:@.sql\\n         .:\" order by keyword_count desc, keyword_density desc limit \"\\n         get-value:x:@.arguments/*/limit\\n\\n   // Optional offset\\n   if\\n      exists:x:@.arguments/*/offset\\n      .lambda\\n         set-value:x:@.sql\\n            strings.concat:x:@.sql\\n               get-value:x:@.sql\\n               .:\" offset \"\\n               get-value:x:@.arguments/*/offset\\n\\n   // Execute SQL\\n   data.select:x:@.sql\\n      database-type:sqlite\\n\\n   // Remove helper fields from final output\\n   remove-nodes:x:@data.select/*/*/keyword_density\\n   remove-nodes:x:@data.select/*/*/keyword_count\\n\\n   // Return\\n   return-nodes:x:@data.select/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Tracks an order\\n\\nThis workflow tracks the specified [order] Shopify order. [order] is mandatory."},{"role":"assistant","content":".arguments\\n   order:string\\n.type:public\\n\\n// Retrieving secret and shop.\\n.secret\\nset-value:x:@.secret\\n   config.get:\"magic:shopify:secret\"\\n.shop\\nset-value:x:@.shop\\n   config.get:\"magic:shopify:shop\"\\n\\n// Invoking slot to do the heavy work.\\nexecute:shopify.orders.track\\n   secret:x:@.secret\\n   shop:x:@.shop\\n   order_no:x:@.arguments/*/order\\n\\n// Returns the result of your last action.\\nreturn-nodes:x:@execute/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Ingests products from Shopify using Shopify API\\n\\nWill use the specified [secret] to authorize requests towards shopify."},{"role":"assistant","content":".arguments\\n   shop\\n      type:string\\n      mandatory:bool:true\\n   type\\n      type:string\\n      mandatory:bool:true\\n   base_url\\n      type:string\\n      mandatory:bool:true\\n   secret\\n      type:string\\n      mandatory:bool:true\\n   meta\\n      type:bool\\n      default:true\\n.icon:shopping_cart\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/shop\\nvalidators.mandatory:x:@.arguments/*/type\\nvalidators.mandatory:x:@.arguments/*/base_url\\nvalidators.mandatory:x:@.arguments/*/secret\\nvalidators.url:x:@.arguments/*/base_url\\n\\n// Ingesting products using Shopify slot.\\nexecute:shopify.products.ingest\\n   shop:x:@.arguments/*/shop\\n   type:x:@.arguments/*/type\\n   base_url:x:@.arguments/*/base_url\\n   secret:x:@.arguments/*/\\n   meta:x:@.arguments/*/meta\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Tracks the specified order and returns status to caller\\n\\nRequires [order_no] being the ID of the order, in addition to [secret]\\nbeing the token required to invoke Shopify API, and [shop] being the name\\nof the shop."},{"role":"assistant","content":"slots.create:shopify.orders.track\\n\\n   // Sanity checking invocation.\\n   validators.mandatory:x:@.arguments/*/shop\\n   validators.mandatory:x:@.arguments/*/secret\\n   validators.mandatory:x:@.arguments/*/order_no\\n\\n   // Creating our URL.\\n   .url\\n   set-value:x:@.url\\n      strings.concat\\n         .:\"https://\"\\n         get-value:x:@.arguments/*/shop\\n         .:.myshopify.com/admin/api/2023-07/orders.json?name=\\n         strings.url-encode:x:@.arguments/*/order_no\\n         .:&status=any\\n\\n   // Retrieving order status.\\n   http.get:x:@.url\\n      convert:bool:true\\n      headers\\n         X-Shopify-Access-Token:x:@.arguments/*/secret\\n\\n   // Sanity checking HTTP request.\\n   if\\n      not\\n         and\\n            mte:x:@http.get\\n               .:int:200\\n            lt:x:@http.get\\n               .:int:300\\n      .lambda\\n\\n         // Oops ...!!\\n         log.error:x:@.arguments/*/message\\n         throw:Something went wrong while invoking Shopify, check your log for details.\\n            status:int:500\\n            public:bool:true\\n\\n   // Creating our order status that we return to caller.\\n   .status\\n   .status-description\\n   switch:x:@http.get/*/content/*/orders/0/*/fulfillment_status\\n      case:fulfilled\\n         set-value:x:@.status-description\\n            .:\"Order is fulfilled by us. \"\\n         set-value:x:@.status\\n            get-value:x:@http.get/*/content/*/orders/0/*/fulfillment_status\\n      case:shipped\\n         set-value:x:@.status-description\\n            .:\"Order is in shipping. \"\\n         set-value:x:@.status\\n            get-value:x:@http.get/*/content/*/orders/0/*/fulfillment_status\\n      case:partial\\n         set-value:x:@.status-description\\n            .:\"Order has been partially shipped. \"\\n         set-value:x:@.status\\n            get-value:x:@http.get/*/content/*/orders/0/*/fulfillment_status\\n      case:unshipped\\n         set-value:x:@.status-description\\n            .:\"Order is not shipped. \"\\n         set-value:x:@.status\\n            get-value:x:@http.get/*/content/*/orders/0/*/fulfillment_status\\n      default\\n         set-value:x:@.status-description\\n            .:No such order\\n         set-value:x:@.status\\n            .:unknown\\n\\n   // Checking if we've got fulfillments.\\n   if\\n      exists:x:@http.get/*/content/*/orders/0/*/fulfillments/0/*/tracking_urls/0\\n      .lambda\\n\\n         // Order is fulfilled from merchant's side, and we've got a tracking url.\\n         set-value:x:@.status-description\\n            strings.concat\\n               get-value:x:@.status-description\\n               .:You can track your shipping [here](\\n               get-value:x:@http.get/*/content/*/orders/0/*/fulfillments/0/*/tracking_urls/0\\n               .:)\\n\\n   // Returning status to caller.\\n   yield\\n      status:x:@.status\\n      description:x:@.status-description\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Import products from Shopify\\n\\nImports all available products from Shopify into your shopify database"},{"role":"assistant","content":"slots.create:shopify.products.import\\n\\n   // Sanity checking invocation.\\n   validators.mandatory:x:@.arguments/*/secret\\n   validators.mandatory:x:@.arguments/*/shop\\n\\n   // Basic logging.\\n   log.info:Starting import from Shopify\\n      shop:x:@.arguments/*/shop\\n\\n   // Making sure we catch exceptions.\\n   try\\n\\n      // Deleting old products.\\n      data.connect:[generic|shopify]\\n         database-type:sqlite\\n         data.execute:delete from products\\n\\n      // Retrieving 20 products at the time.\\n      .continue:bool:true\\n      .page-info\\n      while:x:@.continue\\n\\n         // Creating our URL.\\n         .url\\n         if\\n            not-null:x:@.page-info\\n            .lambda\\n\\n               // Paging next result set.\\n               set-value:x:@.url\\n                  get-value:x:@.page-info\\n         else\\n\\n            // Retrieving first result set.\\n            set-value:x:@.url\\n               strings.concat\\n                  .:\"https://\"\\n                  get-value:x:@.arguments/*/shop\\n                  .:.myshopify.com/admin/api/2023-07/products.json?limit=20&published_status=published&status=active\\n\\n         // Invoking Shopify.\\n         http.get:x:@.url\\n            headers\\n               X-Shopify-Access-Token:x:@.arguments/*/secret\\n            convert:true\\n\\n         // Sanity checking HTTP request.\\n         if\\n            not\\n               and\\n                  mte:x:@http.get\\n                     .:int:200\\n                  lt:x:@http.get\\n                     .:int:300\\n            .lambda\\n\\n               // Oops ...!!\\n               lambda2hyper:x:@http.get\\n               log.error:Something went wrong while invoking Shopify\\n                  result:x:@lambda2hyper\\n               throw:Something went wrong while invoking Shopify, check your log for details.\\n\\n         // Making sure we've got more products, and if not, aborting while.\\n         if\\n            not-exists:x:@http.get/*/content/*/products/*\\n            .lambda\\n\\n               // No more products.\\n               set-value:x:@.continue\\n                  .:bool:false\\n         else\\n\\n            /*\\n             * We have more products, first figuring out [.page-info]\\n             * such that we can offset next iteration.\\n             */\\n            strings.matches:x:@http.get/*/headers/*/Link\\n               .:\"<[^;]+\\\\/(\\\\w+\\\\.json[^;]+)>;\\\\srel=\\\"next\\\"\"\\n            if\\n               exists:x:@strings.matches/0\\n               .lambda\\n\\n                  // We have a valid next page.\\n                  strings.matches:x:@strings.matches/0\\n                     .:[^<>]+\\n                  if\\n                     exists:x:@strings.matches/0\\n                     .lambda\\n\\n                        // Valid next link.\\n                        set-value:x:@.page-info\\n                           get-value:x:@strings.matches/0\\n                  else\\n\\n                     // No more pages.\\n                     set-value:x:@.continue\\n                        .:bool:false\\n            else\\n\\n               // No more pages.\\n               set-value:x:@.continue\\n                  .:bool:false\\n\\n            /*\\n             * Opening up our database connection, such that we can\\n             * import products into our database.\\n             */\\n            data.connect:[generic|shopify]\\n               database-type:sqlite\\n\\n               // Looping through each result from above invocation.\\n               for-each:x:@http.get/*/content/*/products/*\\n\\n                  // Extracting the important parts to insert into our own database.\\n                  .tmp\\n                  set-value:x:@.tmp\\n                     strings.concat\\n                        .:<div>\\n                        get-value:x:@.dp/#/*/body_html\\n                        .:</div>\\n                  html2markdown:x:@.tmp\\n                  .data\\n                     title:x:@.dp/#/*/title\\n                     body_html:x:@html2markdown\\n                     vendor:x:@.dp/#/*/vendor\\n                     product_type:x:@.dp/#/*/product_type\\n                     published_at:x:@.dp/#/*/published_at\\n                     handle:x:@.dp/#/*/handle\\n                     tags:x:@.dp/#/*/tags\\n                  unwrap:x:@.data/*\\n\\n                  // Inserting product into database.\\n                  data.create\\n                     database-type:sqlite\\n                     table:products\\n                     values\\n                        title:x:@.data/*/title\\n                        body_html:x:@.data/*/body_html\\n                        vendor:x:@.data/*/vendor\\n                        product_type:x:@.data/*/product_type\\n                        published_at:x:@.data/*/published_at\\n                        handle:x:@.data/*/handle\\n                        tags:x:@.data/*/tags\\n\\n                  // Inserting variants into database.\\n                  for-each:x:@.dp/#/*/variants/*\\n                     data.create\\n                        database-type:sqlite\\n                        table:variants\\n                        values\\n                           product_id:x:@for-each/@data.create\\n                           price:x:@.dp/#/*/price\\n                           title:x:@.dp/#/*/title\\n\\n                  // Inserting images into database.\\n                  for-each:x:@.dp/#/*/images/*\\n                     data.create\\n                        database-type:sqlite\\n                        table:images\\n                        values\\n                           product_id:x:@for-each/@data.create\\n                           alt:x:@.dp/#/*/alt\\n                           width:x:@.dp/#/*/width\\n                           height:x:@.dp/#/*/height\\n                           src:x:@.dp/#/*/src\\n\\n      // Basic logging.\\n      log.info:Done importing products from Shopify\\n         shop:x:@.arguments/*/shop\\n   .catch\\n\\n      // Oops ...!!\\n      log.error:Something went wrong during Shopify import\\n         info:x:@.arguments/*/message\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Counts items from your items table in your shopping-cart-demo database"},{"role":"assistant","content":".arguments\\n\\n   // items table item_id column equality exact match filtering\\n   items.item_id.eq:long\\n\\n   // items table product_id column equality exact match filtering\\n   items.product_id.eq:long\\n\\n   // items table quantity column equality exact match filtering\\n   items.quantity.eq:long\\n\\n   // items table session_id column wildcard filtering with SQL like '%' comparison\\n   items.session_id.like:string\\n\\n   // items table session_id column equality exact match filtering\\n   items.session_id.eq:string\\n\\n   // products table name column equality exact match filtering\\n   product_id.name.eq:string\\n\\n   // products table name column wildcard filtering with SQL like '%' comparison\\n   product_id.name.like:string\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-count\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root,admin\\n\\n// Opening up our database connection.\\ndata.connect:[generic|shopping-cart-demo]\\n   database-type:sqlite\\n   add:x:+/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:sqlite\\n      table:items\\n         join:products\\n            as:product_id\\n            type:left\\n            on\\n               and\\n                  items.product_id:product_id.product_id\\n      columns\\n         count(*)\\n            as:count\\n      where\\n         and\\n      limit:long:1\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Delete endpoint deleting one record from your items table in your shopping-cart-demo database with item_id matching argument with authentication and authorisation for root,admin roles"},{"role":"assistant","content":".arguments\\n\\n   // Primary key of record to delete\\n   item_id:long\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-delete\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root,admin\\n\\n// Sanity checking invocation, making sure primary key(s) are specified.\\nvalidators.mandatory:x:@.arguments/*/item_id\\n\\n// Opening up our database connection.\\ndata.connect:[generic|shopping-cart-demo]\\n   database-type:sqlite\\n\\n   // Parametrising our delete invocation.\\n   add:x:./*/data.delete/*/where/*/and\\n      get-nodes:x:@.arguments/*\\n\\n   // Deleting item from database.\\n   data.delete\\n      database-type:sqlite\\n      table:items\\n      where\\n         and\\n\\n   // Returning result of above invocation to caller.\\n   unwrap:x:+/*\\n   return\\n      affected:x:@data.delete\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Read endpoint with paging, sorting on fully qualified table name (TABLE_NAME.COLUMN_NAME), filtering selecting records from your items table in your shopping-cart-demo database returning item_id, product_id, quantity, session_id filtering on item_id, product_id, quantity, session_id with authentication and authorisation for root,admin roles"},{"role":"assistant","content":".arguments\\n\\n   // Number of records to return\\n   limit:long\\n\\n   // Offset into the dataset of where to start retrieving records\\n   offset:long\\n\\n   // What column to order by\\n   order:string\\n\\n   // What direction to order, can be 'asc' or 'desc' implying ascending and descending\\n   direction:string\\n\\n   // items table item_id column equality exact match filtering\\n   items.item_id.eq:long\\n\\n   // items table product_id column equality exact match filtering\\n   items.product_id.eq:long\\n\\n   // items table quantity column equality exact match filtering\\n   items.quantity.eq:long\\n\\n   // items table session_id column wildcard filtering with SQL like '%' comparison\\n   items.session_id.like:string\\n\\n   // items table session_id column equality exact match filtering\\n   items.session_id.eq:string\\n\\n   // products table name column equality exact match filtering\\n   product_id.name.eq:string\\n\\n   // products table name column wildcard filtering with SQL like '%' comparison\\n   product_id.name.like:string\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-read\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root,admin\\n\\n// Opening up our database connection.\\ndata.connect:[generic|shopping-cart-demo]\\n   database-type:sqlite\\n\\n   // Parametrising our read invocation with ordering arguments if specified.\\n   add:x:./*/data.read\\n      get-nodes:x:@.arguments/*/order\\n      get-nodes:x:@.arguments/*/direction\\n   remove-nodes:x:@.arguments/*/order\\n   remove-nodes:x:@.arguments/*/direction\\n\\n   // Parametrising our read invocation with paging arguments if specified.\\n   add:x:./*/data.read\\n      get-nodes:x:@.arguments/*/limit\\n      get-nodes:x:@.arguments/*/offset\\n   remove-nodes:x:@.arguments/*/limit\\n   remove-nodes:x:@.arguments/*/offset\\n\\n   // Parametrising our read invocation with filtering arguments.\\n   add:x:./*/data.read/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:sqlite\\n      table:items\\n         join:products\\n            as:product_id\\n            type:left\\n            on\\n               and\\n                  items.product_id:product_id.product_id\\n      columns\\n         items.item_id\\n         items.product_id\\n         items.quantity\\n         items.session_id\\n         product_id.name\\n            as:product_id.name\\n      where\\n         and\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create endpoint inserting one record into your items table in your shopping-cart-demo database taking product_id, quantity, session_id with authentication and authorisation for root,admin roles"},{"role":"assistant","content":".arguments\\n\\n   // product_id column value\\n   product_id:long\\n\\n   // quantity column value\\n   quantity:long\\n\\n   // session_id column value\\n   session_id:string\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-create\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root,admin\\n.foreign-keys\\n   .\\n      column:product_id\\n      table:products\\n      foreign_column:product_id\\n      foreign_name:name\\n      long:bool:true\\n\\n// Opening up database connection.\\ndata.connect:[generic|shopping-cart-demo]\\n   database-type:sqlite\\n\\n   // Parametrising our create invocation.\\n   add:x:./*/data.create/*/values\\n      get-nodes:x:@.arguments/*\\n\\n   // Creating our record.\\n   data.create\\n      database-type:sqlite\\n      table:items\\n      return-id:bool:true\\n      values\\n\\n   // Returning the correct status code.\\n   response.status.set:201\\n\\n   // Returning result of above invocation to caller.\\n   unwrap:x:+/*\\n   return\\n      id:x:@data.create\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Update endpoint updating one record in your items table in your shopping-cart-demo database filtering which item to update with item_id updating product_id, session_id fields with authentication and authorisation for root,admin roles"},{"role":"assistant","content":".arguments\\n\\n   // item_id column value being primary key of record to update\\n   item_id:long\\n\\n   // product_id column's new value\\n   product_id:long\\n\\n   // session_id column's new value\\n   session_id:string\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-update\\n\\n// Sanity checking invocation, making sure primary key(s) are specified.\\nvalidators.mandatory:x:@.arguments/*/item_id\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root,admin\\n.foreign-keys\\n   .\\n      column:product_id\\n      table:products\\n      foreign_column:product_id\\n      foreign_name:name\\n      long:bool:true\\n\\n// Opening up our database connection.\\ndata.connect:[generic|shopping-cart-demo]\\n   database-type:sqlite\\n\\n   // Parametrising our invocation.\\n   add:x:./*/data.update/*/values\\n      get-nodes:x:@.arguments/*/[1,1000]\\n   add:x:./*/data.update/*/where/*/and\\n      get-nodes:x:@.arguments/*/[0,1]\\n\\n   // Invoking our update slot.\\n   data.update\\n      database-type:sqlite\\n      table:items\\n      values\\n      where\\n         and\\n\\n   // Verifying record exists.\\n   if\\n      eq\\n         get-value:x:@data.update\\n         .:int:0\\n      .lambda\\n         response.status.set:404\\n         return\\n            result:Record not found\\n\\n   // Returning the correct status code.\\n   response.status.set:202\\n\\n   // Returning success to caller.\\n   unwrap:x:+/*\\n   return\\n      affected:x:@data.update\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Delete endpoint deleting one record from your products table in your shopping-cart-demo database with product_id matching argument with authentication and authorisation for root,admin roles"},{"role":"assistant","content":".arguments\\n\\n   // Primary key of record to delete\\n   product_id:long\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-delete\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root,admin\\n\\n// Sanity checking invocation, making sure primary key(s) are specified.\\nvalidators.mandatory:x:@.arguments/*/product_id\\n\\n// Opening up our database connection.\\ndata.connect:[generic|shopping-cart-demo]\\n   database-type:sqlite\\n\\n   // Parametrising our delete invocation.\\n   add:x:./*/data.delete/*/where/*/and\\n      get-nodes:x:@.arguments/*\\n\\n   // Deleting item from database.\\n   data.delete\\n      database-type:sqlite\\n      table:products\\n      where\\n         and\\n\\n   // Returning result of above invocation to caller.\\n   unwrap:x:+/*\\n   return\\n      affected:x:@data.delete\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Read endpoint with paging, sorting on fully qualified table name (TABLE_NAME.COLUMN_NAME), filtering selecting records from your products table in your shopping-cart-demo database returning product_id, name, description, sku, price, image_url filtering on product_id, name, description, sku, price, image_url with authentication and authorisation for root,admin roles"},{"role":"assistant","content":".arguments\\n\\n   // Number of records to return\\n   limit:long\\n\\n   // Offset into the dataset of where to start retrieving records\\n   offset:long\\n\\n   // What column to order by\\n   order:string\\n\\n   // What direction to order, can be 'asc' or 'desc' implying ascending and descending\\n   direction:string\\n\\n   // products table product_id column equality exact match filtering\\n   products.product_id.eq:long\\n\\n   // products table name column wildcard filtering with SQL like '%' comparison\\n   products.name.like:string\\n\\n   // products table name column equality exact match filtering\\n   products.name.eq:string\\n\\n   // products table description column wildcard filtering with SQL like '%' comparison\\n   products.description.like:string\\n\\n   // products table description column equality exact match filtering\\n   products.description.eq:string\\n\\n   // products table sku column wildcard filtering with SQL like '%' comparison\\n   products.sku.like:string\\n\\n   // products table sku column equality exact match filtering\\n   products.sku.eq:string\\n\\n   // products table price column equality exact match filtering\\n   products.price.eq:decimal\\n\\n   // products table image_url column wildcard filtering with SQL like '%' comparison\\n   products.image_url.like:string\\n\\n   // products table image_url column equality exact match filtering\\n   products.image_url.eq:string\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-read\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root,admin\\n\\n// Opening up our database connection.\\ndata.connect:[generic|shopping-cart-demo]\\n   database-type:sqlite\\n\\n   // Parametrising our read invocation with ordering arguments if specified.\\n   add:x:./*/data.read\\n      get-nodes:x:@.arguments/*/order\\n      get-nodes:x:@.arguments/*/direction\\n   remove-nodes:x:@.arguments/*/order\\n   remove-nodes:x:@.arguments/*/direction\\n\\n   // Parametrising our read invocation with paging arguments if specified.\\n   add:x:./*/data.read\\n      get-nodes:x:@.arguments/*/limit\\n      get-nodes:x:@.arguments/*/offset\\n   remove-nodes:x:@.arguments/*/limit\\n   remove-nodes:x:@.arguments/*/offset\\n\\n   // Parametrising our read invocation with filtering arguments.\\n   add:x:./*/data.read/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:sqlite\\n      table:products\\n      columns\\n         products.product_id\\n         products.name\\n         products.description\\n         products.sku\\n         products.price\\n         products.image_url\\n      where\\n         and\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create endpoint inserting one record into your products table in your shopping-cart-demo database taking name, description, sku, price, image_url with authentication and authorisation for root,admin roles"},{"role":"assistant","content":".arguments\\n\\n   // name column value\\n   name:string\\n\\n   // description column value\\n   description:string\\n\\n   // sku column value\\n   sku:string\\n\\n   // price column value\\n   price:decimal\\n\\n   // image_url column value\\n   image_url:string\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-create\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root,admin\\n\\n// Opening up database connection.\\ndata.connect:[generic|shopping-cart-demo]\\n   database-type:sqlite\\n\\n   // Parametrising our create invocation.\\n   add:x:./*/data.create/*/values\\n      get-nodes:x:@.arguments/*\\n\\n   // Creating our record.\\n   data.create\\n      database-type:sqlite\\n      table:products\\n      return-id:bool:true\\n      values\\n\\n   // Returning the correct status code.\\n   response.status.set:201\\n\\n   // Returning result of above invocation to caller.\\n   unwrap:x:+/*\\n   return\\n      id:x:@data.create\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Update endpoint updating one record in your products table in your shopping-cart-demo database filtering which item to update with product_id updating name, description, sku, price, image_url fields with authentication and authorisation for root,admin roles"},{"role":"assistant","content":".arguments\\n\\n   // product_id column value being primary key of record to update\\n   product_id:long\\n\\n   // name column's new value\\n   name:string\\n\\n   // description column's new value\\n   description:string\\n\\n   // sku column's new value\\n   sku:string\\n\\n   // price column's new value\\n   price:decimal\\n\\n   // image_url column's new value\\n   image_url:string\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-update\\n\\n// Sanity checking invocation, making sure primary key(s) are specified.\\nvalidators.mandatory:x:@.arguments/*/product_id\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root,admin\\n\\n// Opening up our database connection.\\ndata.connect:[generic|shopping-cart-demo]\\n   database-type:sqlite\\n\\n   // Parametrising our invocation.\\n   add:x:./*/data.update/*/values\\n      get-nodes:x:@.arguments/*/[1,1000]\\n   add:x:./*/data.update/*/where/*/and\\n      get-nodes:x:@.arguments/*/[0,1]\\n\\n   // Invoking our update slot.\\n   data.update\\n      database-type:sqlite\\n      table:products\\n      values\\n      where\\n         and\\n\\n   // Verifying record exists.\\n   if\\n      eq\\n         get-value:x:@data.update\\n         .:int:0\\n      .lambda\\n         response.status.set:404\\n         return\\n            result:Record not found\\n\\n   // Returning the correct status code.\\n   response.status.set:202\\n\\n   // Returning success to caller.\\n   unwrap:x:+/*\\n   return\\n      affected:x:@data.update\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Adds an item to your shopping cart\\n\\n[product_id] is mandatory and has to be an existing product_id from an item existing in your database,\\nand [quantity] will default to 1 if not specified."},{"role":"assistant","content":".arguments\\n   sku:string\\n   quantity:int\\n   _session:string\\n.type:public\\n\\n// Defaulting [quantity] to 1 if not specified.\\nvalidators.default:x:@.arguments\\n   quantity:int:1\\n\\n/*\\n * Invokes the SQL CRUD Read slot with the specified parameters.\\n * \\n * Provide [connection-string], [database-type], [database], and [table] to inform the action of\\n * what database/table you want to execute your SQL towards, and add [and] or [or] arguments\\n * to filter your returns, in addition to [limit] and [offset] to apply paging. Use [order]\\n * and [direction] to sort either ascending or descending. Notice, you can only use one of [or]\\n * or [and], and not both.\\n */\\nexecute:magic.workflows.actions.execute\\n   name:sql-read-products\\n   filename:/misc/workflows/actions/sql/sql-read.hl\\n   arguments\\n      columns\\n         .:product_id\\n      database:shopping-cart-demo\\n      table:products\\n      and\\n         sku:x:@.arguments/*/sku\\n\\n/*\\n * Invokes the SQL CRUD Create slot with the specified parameters.\\n * \\n * Provide [connection-string], [database-type], [database], and [table] to inform the action of\\n * what database/table you want to execute your SQL towards, and [values] for your actual values\\n * to insert.\\n */\\nexecute:magic.workflows.actions.execute\\n   name:sql-create\\n   filename:/misc/workflows/actions/sql/sql-create.hl\\n   arguments\\n      database:shopping-cart-demo\\n      table:items\\n      values\\n         product_id:x:../*/execute/=sql-read-products/*/*/product_id\\n         quantity:x:@.arguments/*/quantity\\n         session_id:x:@.arguments/*/_session\\n\\n// Returns the result of your last action.\\nreturn-nodes:x:@execute/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Checkout and pay\\n\\nAllows the user to checkout and pay for the items he or she has in their shopping cart."},{"role":"assistant","content":".arguments\\n   _session:string\\n   name:string\\n   email:string\\n.type:public\\n\\n// Opening up database connection.\\ndata.connect:[generic|shopping-cart-demo]\\n\\n   // Selecting price and name of items in cart.\\n   data.select:select p.name, p.price, p.sku, i.quantity from items i inner join products p on i.product_id = p.product_id where session_id = @session\\n      @session:x:@.arguments/*/_session\\n\\n   /*\\n    * TODO: Here is where you would somehow invoke your actual backend shopping cart API to generate\\n    * and actual payment link or something. We just send the user an email for simplicity reasons.\\n    */\\n   .total:decimal:0\\n   .body:\"Thank you for your order 00X, below are your items and your total\\n\\n\"\\n   for-each:x:@data.select/*\\n      set-value:x:@.body\\n         strings.concat\\n            get-value:x:@.body\\n            .:\"* \"\\n            get-value:x:@.dp/#/*/name\\n            .:, $\\n            format:x:@.dp/#/*/price\\n               pattern:\"{0:#,##0.##}\"\\n            .:\", quantity; \"\\n            get-value:x:@.dp/#/*/quantity\\n            .:\"\\n\\n\"\\n      set-value:x:@.total\\n         math.add\\n            get-value:x:@.total\\n            get-value:x:@.dp/#/*/price\\n   set-value:x:@.body\\n      strings.concat\\n         get-value:x:@.body\\n         .:\"Your total is: **\"\\n         format:x:@.total\\n            pattern:\"{0:#,##0.##}\"\\n         .:\"**\\n\\n\"\\n         .:\"This is of course just a small demonstration of how you could build an E-Commerce AI chatbot, but if you're interested in a real AI chatbot similar to this one, or a completely custom AI chatbot, you can reply to this message and our CEO will come back to you.\\n\\nStay Safe 00X,\\n\\nQ\"\\n\\n   // Transforms the specified [markdown] to HTML and returns to caller.\\n   execute:magic.workflows.actions.execute\\n      name:markdown2html\\n      filename:/misc/workflows/actions/misc/markdown2html.hl\\n      arguments\\n         markdown:x:@.body\\n\\n   /*\\n    * Sends an email to the specified [name]/[email] recipient, with the specified [subject] and [body].\\n    * \\n    * Optionally supply [from] and [from-email] as name/email sender, and/or [reply-to] and [reply-to-email]\\n    * as the email to reply to. If you don't supply [from] or [from-email] then this action will use the\\n    * default sender settings from your configuration.\\n    */\\n   execute:magic.workflows.actions.execute\\n      name:email\\n      filename:/misc/workflows/actions/misc/email.hl\\n      arguments\\n         name:x:@.arguments/*/name\\n         email:x:@.arguments/*/email\\n         html:bool:true\\n         subject:Your spy gear order is complete\\n         body:x:--/execute/=markdown2html/*/html\\n\\n   // Resetting shopping cart items.\\n   data.delete\\n      table:items\\n      where\\n         and\\n            session_id.eq:x:@.arguments/*/_session\\n\\n   // Returning success to caller to indicate process successfully completed.\\n   return\\n      result:success\\n      message:Checkout was successful and your cart was reset. An email has been sent to you with the details of your order. Your items will be shipped to your door and be available for you in 24 hours.\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Retrieves all shopping cart items for the current [session]."},{"role":"assistant","content":".arguments\\n   _session:string\\n.type:public\\n\\n// Opening up our database connection.\\ndata.connect:[generic|shopping-cart-demo]\\n\\n   // Reading items from our items table.\\n   data.select:\"\\nselect i.item_id, i.quantity, p.name, p.description, p.image_url, p.price\\n   from items i inner join products p on i.product_id = p.product_id\\n   where i.session_id = @session\"\\n      @session:x:@.arguments/*/_session\\n   return:x:@data.select/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Removes the specified [item_id] from your shopping cart\\n\\n[item_id] is mandatory and a reference to a single item in your shopping cart."},{"role":"assistant","content":".arguments\\n   item_id:int\\n   _session:string\\n.type:public\\n\\n// Opening up database connection.\\ndata.connect:[generic|shopping-cart-demo]\\n\\n   // Removing item.\\n   data.delete\\n      table:items\\n      where\\n         and\\n            item_id.eq:x:@.arguments/*/item_id\\n            session_id.eq:x:@.arguments/*/_session\\n\\n// Returning success to caller.\\nreturn\\n   result:success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Runs during startup of Magic, and basically just ensures the module's database exists,\\nand is updated by running migration scripts after attempting to create the database.\\n\\nIf the database doesn't exist, this script will create it by executing the SQL in the file"},{"role":"assistant","content":"signal:magic.modules.ensure-database\\n   module:shopping-cart-demo\\n   database:shopping-cart-demo\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Creates a scheduled task that imports all products from your products table in your shopping-cart-demo\\ndatabase, and adds these as ml_training_snippets to your machine learning type."},{"role":"assistant","content":"\\n// Checking if ml_type with name of \"shopping-cart-demo\" exists, and if not, we create it.\\ndata.connect:[generic|magic]\\n   data.read\\n      table:ml_types\\n      where\\n         and\\n            type.eq:shopping-cart-demo\\n   if\\n      not-exists:x:@data.read/*\\n      .lambda\\n\\n         // Creating our default type.\\n         data.create\\n            table:ml_types\\n            values\\n               type:shopping-cart-demo\\n               model:gpt-4o\\n               max_tokens:int:4000\\n               max_context_tokens:int:4000\\n               max_request_tokens:int:250\\n               temperature:decimal:0.3\\n               supervised:int:1\\n               conversation_starters:@\"* What can I ask you about?\\n* What products do you have?\\n* Who created this chatbot?\"\\n               greeting:Hi there, I am Q, how can I help you today with your spy gear?\\n               system_message:@\"You are a helpful assistent in a spy shop that sells spy gear to 00X spies. Your name is Q and you will greet the user as 00X, and guide him through purchasing items he needs for his next mission.\\n\\n## Adding items to shopping cart\\n\\nIf the user informs you that he or she wants to buy an item and you know the item's SKU, then respond with this EXACT response, only exchanging the [sku] and the [quantity].\\n\\n___\\nFUNCTION_INVOCATION[/modules/shopping-cart-demo/workflows/add-item.hl]:\\n{\\n  \"\"sku\"\": \"\"[sku]\"\",\\n  \"\"quantity\"\": \"\"[quantity]\"\"\\n}\\n___\\n\\nIf the user did not provide a quantity then do not ask the user for a quantity but use a value of 1 by default. If you don't know the item's SKU, ask the user to provide some more keywords for what item he or she wants to buy such that you can find the correct SKU before responding with the above function invocation.\\n\\n## How to remove an item from the shopping cart\\n\\nIf the user informs you that he or she wants to remove an item from his or her shopping cart, and you know the item's [item_id], then respond with this EXACT response, only exchanging the [item_id].\\n\\n___\\nFUNCTION_INVOCATION[/modules/shopping-cart-demo/workflows/remove-item.hl]:\\n{\\n  \"\"item_id\"\": \"\"[item_id]\"\",\\n}\\n___\\n\\n## How to list the user's shopping cart items\\n\\nIf the user wants to know which items are in his or her shopping cart then respond with this EXACT response.\\n\\n___\\nFUNCTION_INVOCATION[/modules/shopping-cart-demo/workflows/list-items.hl]\\n___\\n\\nALWAYS invoke the above function to list items in the user's shopping cart even if you know what items are available from a previous message.\\n\\n## How to list available products\\n\\nIf the user wants to know which products are available then respond with this EXACT response.\\n\\n___\\nFUNCTION_INVOCATION[/modules/shopping-cart-demo/workflows/list-products.hl]\\n___\\n\\nALWAYS invoke the above function to list products even if you know what products are available from a previous message.\\n\\n## How to checkout\\n\\nIf the user wants to checkout and pay then respond with this EXACT response. The [name] and [email] arguments are both mandatory, and these are the user's name and email address.\\n\\n___\\nFUNCTION_INVOCATION[/modules/shopping-cart-demo/workflows/checkout.hl]:\\n{\\n  \"\"name\"\": \"\"[name]\"\",\\n  \"\"email\"\": \"\"[email]\"\"\\n}\\n___\\n\\nNever invoke checkout unless user explicitly confirms he wants to checkout and pay. If you need to calculate the total amount, use the above list-items function instead that will return all items including their amount, allowing you to calculate the total. If you don't know the user's name and email address, ask the user to supply these before responding with the above function invocation.\\n\\n## General rules for all function invocations\\n\\n* When listing products or shopping cart items, then respond with the item's name being an H1 element, and description as a paragraph below the name. Display the rest of the item's data as a bulleted list below the description. If you've got images then add these at the end of the item's listing as Markdown such as follow ![ITEM_NAME](IMAGE_URL).\\n* It is CRUCIAL that you put the FUNCTION_INVOCATION parts and any JSON payload inside of two ___ lines for any FUNCTION_INVOCATION you return.\"\\n\\n// Deleting task if it's been created before.\\ntasks.list:shopping-cart-demo.synchronize-products\\nif\\n   exists:x:@tasks.list/*\\n   .lambda\\n\\n      // Deleting previously created task.\\n      tasks.delete:shopping-cart-demo.synchronize-products\\n\\n// Creating task.\\ntasks.create:shopping-cart-demo.synchronize-products\\n   .lambda\\n\\n      // Making sure we catch exceptions.\\n      try\\n\\n         // First deleting all products previously synchronized.\\n         log.info:Deleting spy products from ml_training_snippets\\n         data.connect:[generic|magic]\\n\\n            // Deleting from VSS shadow table.\\n            data.execute:\"delete from vss_ml_training_snippets where rowid in (select id as rowid from ml_training_snippets where type = 'shopping-cart-demo' and meta = 'imported')\"\\n\\n            // Deleting from ml_training_snippets table.\\n            data.delete\\n               table:ml_training_snippets\\n               where\\n                  and\\n                     type.eq:shopping-cart-demo\\n                     meta.eq:imported\\n\\n         // Selecting all products from shopping-cart-demo database.\\n         log.info:Fetching products from your shopping-cart-demo database\\n         .products\\n         data.connect:[generic|shopping-cart-demo]\\n            data.read\\n               table:products\\n            add:x:@.products\\n               get-nodes:x:@data.read/*\\n\\n         // Inserting all products into ml_training_snippets table in magic database.\\n         log.info:Inserting items into ml_training_snippets\\n         data.connect:[generic|magic]\\n\\n            // Looping through each product fetched above.\\n            for-each:x:@.products/*\\n\\n               // Creating our completion.\\n               .completion\\n               set-value:x:@.completion\\n                  strings.concat\\n                     get-value:x:@.dp/#/*/description\\n                     .:\". \"\\n                     .:\"SKU is '\"\\n                     get-value:x:@.dp/#/*/sku\\n                     .:\"'. Price is $\"\\n                     get-value:x:@.dp/#/*/price\\n\\n               // Inserting into ml_training_snippets.\\n               data.create\\n                  table:ml_training_snippets\\n                  values\\n                     type:shopping-cart-demo\\n                     prompt:x:@.dp/#/*/name\\n                     completion:x:@.completion\\n                     meta:imported\\n\\n         // Vectorizing model.\\n         log.info:Vectorizing shopping-cart-demo type\\n         unwrap:x:+/*\\n         signal:magic.ai.vectorise\\n            type:shopping-cart-demo\\n      .catch\\n\\n         // Oops ...!!\\n         log.error:x:@.arguments/*/message\\n\\n// Executing task initially to synchronize from products to ml_training_snippets.\\ntasks.execute:shopping-cart-demo.synchronize-products\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Cancels the user's active subscriptions"},{"role":"assistant","content":"\\n// Buffer for user's extra information.\\n.extra\\n\\n// Retrieving username.\\nauth.ticket.get\\n\\n/*\\n * Searches for subscriptions belonging to user.\\n * \\n * Returns all subscriptions belonging to the specified user.\\n */\\nexecute:magic.workflows.actions.execute\\n   name:stripe-subscription-search\\n   filename:/modules/stripe/workflows/actions/stripe-subscription-search.hl\\n   arguments\\n      username:x:@auth.ticket.get\\n\\n// Looping through all subscriptions belonging to user and canceling these.\\nfor-each:x:@execute/*\\n\\n   /*\\n    * Deletes the existing Stripe subscription for the given [subscription_id].\\n    * \\n    * Will use your Stripe API token found from your settings as it's interacting\\n    * with the Stripe API.\\n    */\\n   try\\n      execute:magic.workflows.actions.execute\\n         name:stripe-subscription-delete\\n         filename:/modules/stripe/workflows/actions/stripe-subscription-delete.hl\\n         arguments\\n            subscription_id:x:@.dp/#/*/id\\n   .catch\\n      log.error:x:@.arguments/*/message\\n\\n// Opening up database connection.\\ndata.connect:magic\\n\\n   // Deleting all roles user belongs to except root and guest.\\n   data.delete\\n      table:users_roles\\n      where\\n         and\\n            user.eq:x:@auth.ticket.get\\n            role.neq:guest\\n            role.neq:root\\n\\n   // Retrieving extra information.\\n   data.connect:magic\\n      data.read\\n         table:users_extra\\n         where\\n            and\\n               user.eq:x:@auth.ticket.get\\n               or\\n                  type.eq:name\\n                  type.eq:email\\n      for-each:x:@data.read/*\\n         set-name:x:./*/add/*/*\\n            get-value:x:@.dp/#/*/type\\n         set-value:x:./*/add/*/*\\n            get-value:x:@.dp/#/*/value\\n         add:x:@.extra\\n            .\\n               .\\n\\n// Authenticating user again creating a new JWT token since roles have been updated.\\nexecute:magic.auth.authenticate\\n   username:x:@auth.ticket.get\\n   password-check:bool:false\\n\\n// Returning token and extra information to caller.\\nyield\\n   ticket:x:@execute/*/ticket\\n   extra:x:@.extra/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Confirms a payment"},{"role":"assistant","content":".arguments\\n   session:string\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/session\\nvalidators.string:x:@.arguments/*/session\\n   min:25\\n   max:25\\n\\n// Retrieving stored session.\\n.session\\ndata.connect:stripe\\n   data.read\\n      table:checkout_sessions\\n      values\\n         username\\n         price\\n      where\\n         and\\n            session_id.eq:x:@.arguments/*/session\\n   add:x:@.session\\n      get-nodes:x:@data.read/*/*\\n   data.delete\\n      table:checkout_sessions\\n      where\\n         and\\n            session_id.eq:x:@.arguments/*/session\\n\\n/*\\n * Finding all slots that handles payments.\\n * \\n * This will invoke all slots starting out with [stripe.subscriptions.accepted.] as their names,\\n * and if one of these slots are returning anything, abort the iteration and return whatever\\n * that slots returned from its invocation.\\n */\\nslots.vocabulary:stripe.subscriptions.accepted.\\n\\n// Looping through each slot returned above and executing it.\\nfor-each:x:@slots.vocabulary/*\\n\\n   // Changing slot invocation name.\\n   set-value:x:./*/execute\\n      get-value:x:@.dp/#\\n\\n   // Parametrising invocation.\\n   add:x:./*/execute\\n      get-nodes:x:@.session/*\\n\\n   /*\\n    * Executing slot to retrieve supported providers.\\n    * \\n    * Notice, name of slot (value of node) is dynamically created above.\\n    */\\n   execute\\n\\n   /*\\n    * Checking if this slot returned something, at which point we return immediately\\n    * since this implies the payment was handled.\\n    */\\n   if\\n      exists:x:@execute/*\\n      .lambda\\n\\n         // Slot handled payment.\\n         return-nodes:x:@execute/*\\n\\n// Returning success to caller.\\nreturn\\n   result:success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Creates a new checkout session endpoint\\n\\n[price] is a reference to a Stripe price, [success_url] is where to\\nroute user after a successful purchase, and [mode] is either 'subscription' or 'payment'.\\n\\nThe endpoints requires authentication, and will create a new user in Stripe using\\nthe username as email address, assuming the username is an actual valid email address.\\n\\nNotice, [success_url] gets a query parameter concatenated being 'session' such that we\\ncan match the correct payment once the payment has been successfully accepted. To handle\\nthe payment after a successful payment, invoke the 'handle-payment' endpoint from this\\nURL."},{"role":"assistant","content":".arguments\\n   price:string\\n   success_url:string\\n   mode:string\\n\\n// Making sure user is authenticated.\\nauth.ticket.verify\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/mode\\nvalidators.mandatory:x:@.arguments/*/price\\nvalidators.mandatory:x:@.arguments/*/success_url\\nvalidators.enum:x:@.arguments/*/mode\\n   .:payment\\n   .:subscription\\n\\n/*\\n * Creating a unique session and storing in database such that we can track successful payments.\\n * \\n * This will contain username and price reference, and be stored with a key being the session ID,\\n * allowing us to find the username and Stripe price reference from the QUERY parameter Stripe sends\\n * into our success URL callback.\\n */\\ncrypto.random\\n   min:25\\n   max:25\\nauth.ticket.get\\ndata.connect:stripe\\n   data.create\\n      table:checkout_sessions\\n      values\\n         session_id:x:@crypto.random\\n         username:x:@auth.ticket.get\\n         price:x:@.arguments/*/price\\n\\n// Updating [success_url] and appending session.\\n.success-url\\nset-value:x:@.success-url\\n   strings.concat\\n      get-value:x:@.arguments/*/success_url\\n      .:?session=\\n      get-value:x:@crypto.random\\n\\n// Creates a checkout session for the specified [priceId].\\nexecute:magic.workflows.actions.execute\\n   name:stripe-create-checkout-session\\n   filename:/modules/stripe/workflows/actions/stripe-create-checkout-session.hl\\n   arguments\\n      username:x:@auth.ticket.get\\n      price:x:@.arguments/*/price\\n      success_url:x:@.success-url\\n      mode:x:@.arguments/*/mode\\n\\n// Returning result to caller.\\nyield:x:@execute/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns any payment subscription plans existing in the system.\\n\\nThis allows you to create Stripe subscriptions and have the core framework being able to deal with these.\\n\\nNotice, to create support for subscriptions in the system, create a slot named for instance\\n[stripe.get-subscription-plans.XYZ] from where you return subscription plans to the system.\\n\\nThe return value from such a slot must at least contain the following values;\\n\\n- [name] - Being the friendly name of the plan.\\n- [description] - Being a friendly descriptive text for the plan.\\n- [price] - Price for subscription\\n- [currency] - Currency for price\\n- [period] - Period for subscription being 'month' or 'year'.\\n- [price_id] - Stripe price ID for some subscription."},{"role":"assistant","content":"\\n// Finding all slots declaring subscriptions.\\nslots.vocabulary:stripe.subscriptions.plans.\\n\\n// Looping through each slot returned above and executing it.\\nfor-each:x:@slots.vocabulary/*\\n\\n   // Changing slot invocation name.\\n   set-value:x:./*/execute\\n      get-value:x:@.dp/#\\n\\n   /*\\n    * Executing slot to retrieve supported providers.\\n    * \\n    * Notice, name of slot (value of node) is dynamically created above.\\n    */\\n   execute\\n\\n   // Looping through all providers returned above to return them to client.\\n   for-each:x:@execute/*\\n\\n      // Returning subscription plan to caller.\\n      add:x:../*/return\\n         get-nodes:x:@.dp/#\\n\\n// Returning subscription plans to caller.\\nreturn\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Retrieves charges from Stripe.\\n\\nWill use your Stripe API token found from your settings as it's interacting\\nwith the Stripe API."},{"role":"assistant","content":".arguments\\n   limit\\n      type:int\\n      mandatory:bool:false\\n   starting_after\\n      type:string\\n      mandatory:bool:false\\n   customer_id\\n      type:string\\n      mandatory:bool:false\\n.icon:payment\\n\\n// Applying defaults.\\nvalidators.default:x:@.arguments\\n   limit:int:10\\n\\n// Retrieving token to use for invocations towards Stripe.\\n.token\\nset-value:x:-\\n   strings.concat\\n      .:\"Bearer \"\\n      config.get:\"magic:stripe:token\"\\n\\n// Changing [customer_id] to [customer] if existing.\\nif\\n   exists:x:@.arguments/*/customer_id\\n   .lambda\\n      set-name:x:@.arguments/*/customer_id\\n         .:customer\\n\\n// Creating URL.\\n.url\\nfor-each:x:@.arguments/*\\n   if\\n      not-null:x:@.dp/#\\n      .lambda\\n         if\\n            null:x:@.url\\n            .lambda\\n               set-value:x:@.url\\n                  .:\"https://api.stripe.com/v1/charges?\"\\n         else\\n            set-value:x:@.url\\n               strings.concat\\n                  get-value:x:@.url\\n                  .:&\\n         set-value:x:@.url\\n            strings.concat\\n               get-value:x:@.url\\n               get-name:x:@.dp/#\\n               .:=\\n               get-value:x:@.dp/#\\n\\n// Invoking Stripe REST API.\\nhttp.get:x:@.url\\n   convert:true\\n   headers\\n      Authorization:x:@.token\\n\\n// Sanity checking above invocation.\\nif\\n   mte\\n      get-value:x:@http.get\\n      .:int:400\\n   .lambda\\n\\n      // Oops, something went wrong ...!!\\n      lambda2hyper:x:@http.post\\n      log.error:Something went wrong while invoking Stripe, could not retrieve charges\\n         result:x:@lambda2hyper\\n         provider:Stripe\\n      throw:Something went wrong while invoking Stripe, could not retrieves charges\\n         public:true\\n         status:500\\n\\n// Parametrising our [return] invocation.\\nfor-each:x:@http.get/*/content/*/data/*\\n\\n   // Only handling paid charges.\\n   if:x:@.dp/#/*/paid\\n\\n      // Buffer for currently iterated item.\\n      .tmp\\n         .\\n            id:x:@.dp/#/*/id\\n            amount:x:@.dp/#/*/amount\\n            currency:x:@.dp/#/*/currency\\n            customer:x:@.dp/#/*/customer\\n            metadata:x:@.dp/#/*/metadata/*\\n            receipt_url:x:@.dp/#/*/receipt_url\\n            created:x:@.dp/#/*/created\\n\\n      // Forward evaluating all above expressions.\\n      unwrap:x:@.tmp/*/*\\n         apply-lists:true\\n\\n      // Converting amount to decimal and dividing by 100.\\n      set-value:x:@.tmp/*/*/amount\\n         math.divide\\n            convert:x:@.tmp/*/*/amount\\n               type:decimal\\n            .:int:100\\n\\n      // Converting Unix time to UTC date.\\n      set-value:x:@.tmp/*/*/created\\n         date.from-unix:x:@.tmp/*/*/created\\n      add:x:../*/return\\n         get-nodes:x:@.tmp/*\\n\\n// Returning result of above invocation to caller.\\nreturn\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Creates a checkout session for the specified [priceId]."},{"role":"assistant","content":".arguments\\n   username\\n      type:string\\n      mandatory:bool:true\\n   price\\n      type:string\\n      mandatory:bool:true\\n   success_url\\n      type:string\\n      mandatory:bool:true\\n   mode\\n      type:string\\n      mandatory:bool:true\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/username\\nvalidators.mandatory:x:@.arguments/*/price\\nvalidators.mandatory:x:@.arguments/*/success_url\\nvalidators.mandatory:x:@.arguments/*/mode\\nvalidators.enum:x:@.arguments/*/mode\\n   .:payment\\n   .:subscription\\n\\n// Retrieving token to use for invocations towards Stripe.\\n.token\\nset-value:x:-\\n   strings.concat\\n      .:\"Bearer \"\\n      config.get:\"magic:stripe:token\"\\n\\n/*\\n * Checking is customer already exists in Stripe, at which point we reuse the same customer.\\n * \\n * This avoids creating duplicate Stripe customer objects for each time the same user creates a\\n * subscription, and will also reuse existing customer objects created manually in the Stripe dashboard.\\n */\\n.url\\nstrings.concat\\n   .:\"email:'\"\\n   get-value:x:@.arguments/*/username\\n   .:\"'\"\\nstrings.url-encode:x:@strings.concat\\nset-value:x:@.url\\n   strings.concat\\n      .:\"https://api.stripe.com/v1/customers/search?query=\"\\n      get-value:x:@strings.url-encode\\n\\n// Invoking Stripe REST API to retrieve customers with the specified email, if any.\\nhttp.get:x:@.url\\n   headers\\n      Authorization:x:@.token\\n   convert:true\\n\\n// Sanity checking above invocation.\\nif\\n   mte\\n      get-value:x:@http.get\\n      .:int:400\\n   .lambda\\n\\n      // Oops, something went wrong ...!!\\n      lambda2hyper:x:@http.post\\n      log.error:Something went wrong while invoking Stripe, could not list customers\\n         result:x:@lambda2hyper\\n         provider:Stripe\\n      throw:Something went wrong while invoking Stripe, could not list customers\\n         public:true\\n         status:500\\n\\n/*\\n * Checking if we've got an existing customer, at which point we reuse this customer\\n * instead of creating a new one.\\n */\\nif\\n   exists:x:@http.get/*/content/*/data/0/*/id\\n   .lambda\\n\\n      // We already have this customer in our Stripe account.\\n      unwrap:x:+/*/*\\n      add:x:../*/http.post/*/payload\\n         .\\n            customer:x:@http.get/*/content/*/data/*/*/id\\nelse\\n\\n   // No existing customer in Stripe matching this email address.\\n   unwrap:x:+/*/*\\n   add:x:../*/http.post/*/payload\\n      .\\n         customer_email:x:@.arguments/*/username\\n         client_reference_id:x:@.arguments/*/username\\n\\n// Invoking Stripe REST API to create a checkout session.\\nhttp.post:\"https://api.stripe.com/v1/checkout/sessions\"\\n   headers\\n      Authorization:x:@.token\\n      Content-Type:application/x-www-form-urlencoded\\n   payload\\n      line_items[0][price]:x:@.arguments/*/price\\n      line_items[0][quantity]:int:1\\n      automatic_tax[enabled]:bool:true\\n      success_url:x:@.arguments/*/success_url\\n      mode:x:@.arguments/*/mode\\n   convert:true\\n\\n// Sanity checking above invocation.\\nif\\n   mte\\n      get-value:x:@http.post\\n      .:int:400\\n   .lambda\\n\\n      // Oops, something went wrong ...!!\\n      lambda2hyper:x:@http.post\\n      log.error:Something went wrong while invoking Stripe, could not create checkout session\\n         result:x:@lambda2hyper\\n         provider:Stripe\\n      throw:Something went wrong while invoking Stripe, could not create checkout session\\n         public:true\\n         status:500\\n\\n// Returning result to caller.\\nyield\\n   session:x:@http.post/*/content/*/id\\n   url:x:@http.post/*/content/*/url\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Creates a customer object in Stripe with the given [name], [email] and\\noptionally [ip_address].\\n\\nIf you supply an [ip_address], the country of origin for the IP address\\nwill be used as the default tax location for your customer in Stripe.\\n\\nWill use your Stripe API token found from your settings as it's interacting\\nwith the Stripe API."},{"role":"assistant","content":".arguments\\n   name\\n      type:string\\n      mandatory:bool:true\\n   email\\n      type:email\\n      mandatory:bool:true\\n   ip_address\\n      type:string\\n      mandatory:bool:false\\n   metadata\\n      type:key-value\\n.icon:payment\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/name\\nvalidators.mandatory:x:@.arguments/*/email\\nvalidators.email:x:@.arguments/*/email\\n\\n// Checking if IP address was supplied, and if so, adding it to invocation.\\nif\\n   exists:x:@.arguments/*/ip_address\\n   .lambda\\n\\n      // Adding [ip_address] to payload as tax location.\\n      add:x:../*/http.post/*/payload\\n         .\\n            tax[ip_address]:x:@.arguments/*/ip_address\\n\\n// Adding metadata\\nfor-each:x:@.arguments/*/metadata/*\\n   set-name:x:./0/-/*/*\\n      strings.concat\\n         .:metadata[\\n         get-name:x:@.dp/#\\n         .:]\\n   unwrap:x:./0/-/*/*\\n   add:x:../*/http.post/*/payload\\n      .\\n         name:x:@.dp/#\\n\\n// Retrieving token to use for invocations towards Stripe.\\n.token\\nset-value:x:-\\n   strings.concat\\n      .:\"Bearer \"\\n      config.get:\"magic:stripe:token\"\\n\\n// Invoking Stripe REST API.\\nhttp.post:\"https://api.stripe.com/v1/customers\"\\n   headers\\n      Content-Type:application/x-www-form-urlencoded\\n      Authorization:x:@.token\\n   payload\\n      email:x:@.arguments/*/email\\n      name:x:@.arguments/*/name\\n   convert:true\\n\\n// Sanity checking above invocation.\\nif\\n   mte\\n      get-value:x:@http.post\\n      .:int:400\\n   .lambda\\n\\n      // Oops, something went wrong ...!!\\n      lambda2hyper:x:@http.post\\n      log.error:Something went wrong while invoking Stripe, could not create customer\\n         result:x:@lambda2hyper\\n         provider:Stripe\\n      throw:Something went wrong while invoking Stripe, could not create customer\\n         public:true\\n         status:500\\n\\n// Returning customer ID to caller.\\nyield\\n   customer_id:x:@http.post/*/content/*/id\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Retrieves charges from Stripe.\\n\\nWill use your Stripe API token found from your settings as it's interacting\\nwith the Stripe API."},{"role":"assistant","content":".arguments\\n   limit\\n      type:int\\n      mandatory:bool:false\\n   email\\n      type:string\\n      mandatory:bool:false\\n   starting_after\\n      type:string\\n      mandatory:bool:false\\n.icon:payment\\n\\n// Applying defaults.\\nvalidators.default:x:@.arguments\\n   limit:int:10\\n\\n// Retrieving token to use for invocations towards Stripe.\\n.token\\nset-value:x:-\\n   strings.concat\\n      .:\"Bearer \"\\n      config.get:\"magic:stripe:token\"\\n\\n// Creating URL.\\n.url\\nfor-each:x:@.arguments/*\\n   if\\n      not-null:x:@.dp/#\\n      .lambda\\n         if\\n            null:x:@.url\\n            .lambda\\n               set-value:x:@.url\\n                  .:\"https://api.stripe.com/v1/customers?\"\\n         else\\n            set-value:x:@.url\\n               strings.concat\\n                  get-value:x:@.url\\n                  .:&\\n         set-value:x:@.url\\n            strings.concat\\n               get-value:x:@.url\\n               get-name:x:@.dp/#\\n               .:=\\n               get-value:x:@.dp/#\\n\\n// Invoking Stripe REST API.\\nhttp.get:x:@.url\\n   convert:true\\n   headers\\n      Authorization:x:@.token\\n\\n// Sanity checking above invocation.\\nif\\n   mte\\n      get-value:x:@http.get\\n      .:int:400\\n   .lambda\\n\\n      // Oops, something went wrong ...!!\\n      lambda2hyper:x:@http.post\\n      log.error:Something went wrong while invoking Stripe, could not retrieve charges\\n         result:x:@lambda2hyper\\n         provider:Stripe\\n      throw:Something went wrong while invoking Stripe, could not retrieves charges\\n         public:true\\n         status:500\\n\\n// Parametrising our [return] invocation.\\nfor-each:x:@http.get/*/content/*/data/*\\n\\n   // Buffer for currently iterated item.\\n   .tmp\\n      .\\n         id:x:@.dp/#/*/id\\n         balance:x:@.dp/#/*/balance\\n         created:x:@.dp/#/*/created\\n         email:x:@.dp/#/*/email\\n         name:x:@.dp/#/*/name\\n         metadata:x:@.dp/#/*/metadata/*\\n\\n   // Forward evaluating all above expressions.\\n   unwrap:x:@.tmp/*/*\\n      apply-lists:true\\n\\n   // Converting amount to decimal and dividing by 100.\\n   set-value:x:@.tmp/*/*/balance\\n      math.divide\\n         convert:x:@.tmp/*/*/balance\\n            type:decimal\\n         .:int:100\\n\\n   // Converting Unix time to UTC date.\\n   set-value:x:@.tmp/*/*/created\\n      date.from-unix:x:@.tmp/*/*/created\\n   add:x:../*/return\\n      get-nodes:x:@.tmp/*\\n\\n// Returning result of above invocation to caller.\\nreturn\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Searches for customers from username, which internally in the system is the user's username.\\n\\nReturns the specified customers, if existing."},{"role":"assistant","content":".arguments\\n   username\\n      type:string\\n      mandatory:bool:true\\n.icon:payment\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/username\\n\\n// Retrieving token to use for invocations towards Stripe.\\n.token\\nset-value:x:-\\n   strings.concat\\n      .:\"Bearer \"\\n      config.get:\"magic:stripe:token\"\\n\\n// Making sure we retrieve only customers with the specified email.\\n.url\\nstrings.concat\\n   .:\"email:'\"\\n   get-value:x:@.arguments/*/username\\n   .:\"'\"\\nstrings.url-encode:x:@strings.concat\\nset-value:x:@.url\\n   strings.concat\\n      .:\"https://api.stripe.com/v1/customers/search?query=\"\\n      get-value:x:@strings.url-encode\\n\\n// Invoking Stripe REST API.\\nhttp.get:x:@.url\\n   headers\\n      Authorization:x:@.token\\n   convert:true\\n\\n// Sanity checking above invocation.\\nif\\n   mte\\n      get-value:x:@http.post\\n      .:int:400\\n   .lambda\\n\\n      // Oops, something went wrong ...!!\\n      lambda2hyper:x:@http.post\\n      log.error:Something went wrong while invoking Stripe API to create subscription\\n         result:x:@lambda2hyper\\n         provider:Stripe\\n      throw:Something went wrong while invoking Stripe API to create subscription\\n         public:true\\n         status:500\\nreturn-nodes:x:@http.get/*/content/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Creates a new Stripe payment for the given [customer_id], using the\\nspecified [payment_method], for the given [amount], in the given [currency].\\n\\nWill use your Stripe API token found from your settings as it's interacting\\nwith the Stripe API."},{"role":"assistant","content":".arguments\\n   customer_id\\n      type:string\\n      mandatory:bool:true\\n   payment_method_id\\n      type:string\\n      mandatory:bool:true\\n   amount\\n      type:decimal\\n      mandatory:bool:true\\n   currency\\n      type:string\\n      mandatory:bool:true\\n      default:usd\\n   description\\n      type:string\\n      mandatory:bool:false\\n   return_url\\n      type:string\\n      mandatory:bool:false\\n   metadata\\n      type:key-value\\n.icon:payment\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/customer_id\\nvalidators.mandatory:x:@.arguments/*/payment_method_id\\nvalidators.mandatory:x:@.arguments/*/amount\\nvalidators.mandatory:x:@.arguments/*/currency\\n\\n// Adding metadata.\\nfor-each:x:@.arguments/*/metadata/*\\n   set-name:x:./0/-/*/*\\n      strings.concat\\n         .:metadata[\\n         get-name:x:@.dp/#\\n         .:]\\n   unwrap:x:./0/-/*/*\\n   add:x:../*/http.post/*/payload\\n      .\\n         name:x:@.dp/#\\n\\n// Retrieving token to use for invocations towards Stripe.\\n.token\\nset-value:x:-\\n   strings.concat\\n      .:\"Bearer \"\\n      config.get:\"magic:stripe:token\"\\n\\n// Multiplying [amount] with 100 to correctly remove decimals.\\nmath.multiply:x:@.arguments/*/amount\\n   .:decimal:100\\nconvert:x:@math.multiply\\n   type:int\\n\\n// Adding description if caller provided it.\\nadd:x:./*/http.post/*/payload\\n   get-nodes:x:@.arguments/*/description\\n   get-nodes:x:@.arguments/*/return_url\\n\\n// Invoking Stripe REST API.\\nhttp.post:\"https://api.stripe.com/v1/payment_intents\"\\n   headers\\n      Content-Type:application/x-www-form-urlencoded\\n      Authorization:x:@.token\\n   payload\\n      amount:x:@convert\\n      currency:x:@.arguments/*/currency\\n      payment_method:x:@.arguments/*/payment_method_id\\n      customer:x:@.arguments/*/customer_id\\n      confirm:bool:true\\n   convert:true\\n\\n// Sanity checking above invocation.\\nif\\n   mte\\n      get-value:x:@http.post\\n      .:int:400\\n   .lambda\\n\\n      // Oops, something went wrong ...!!\\n      lambda2hyper:x:@http.post\\n      log.error:Something went wrong while invoking Stripe API, could not create payment intent\\n         result:x:@lambda2hyper\\n         provider:Stripe\\n      throw:Something went wrong while invoking Stripe API, could not create payment intent\\n         public:true\\n         status:500\\n\\n// Checking if charge was successful.\\nif\\n   exists:x:@http.post/*/content/*/next_action/*/use_stripe_sdk/*/stripe_js\\n   .lambda\\n\\n      // Charge was NOT successful, and probably needs 3D secure.\\n      yield\\n         finished:bool:false\\n         id:x:@http.post/*/content/*/id\\n         payment_url:x:@http.post/*/content/*/next_action/*/use_stripe_sdk/*/stripe_js\\n\\n// Returning customer ID to caller.\\nyield\\n   finished:bool:true\\n   payment_id:x:@http.post/*/content/*/id\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Creates a Stripe payment link from the specified [price_reference], being\\na Stripe payment ID, for [quantity] amount of items, returning the user to\\n[success_url] after payment has been successfully finished.\\n\\nWill use your Stripe API token found from your settings as it's interacting\\nwith the Stripe API."},{"role":"assistant","content":".arguments\\n   price_reference\\n      type:string\\n      mandatory:bool:true\\n   quantity\\n      type:int\\n      mandatory:bool:false\\n   success_url\\n      type:string\\n      mandatory:bool:true\\n   metadata\\n      type:key-value\\n.icon:payment\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/price_reference\\nvalidators.mandatory:x:@.arguments/*/success_url\\n\\n// Applying default values.\\nvalidators.default:x:@.arguments\\n   quantity:int:1\\n\\n// Adding metadata\\nfor-each:x:@.arguments/*/metadata/*\\n   set-name:x:./0/-/*/*\\n      strings.concat\\n         .:metadata[\\n         get-name:x:@.dp/#\\n         .:]\\n   unwrap:x:./0/-/*/*\\n   add:x:../*/http.post/*/payload\\n      .\\n         name:x:@.dp/#\\n\\n// Retrieving Stripe token from configuration.\\n.token\\nset-value:x:@.token\\n   strings.concat\\n      .:\"Bearer \"\\n      config.get:\"magic:stripe:token\"\\n\\n// Invoking Stripe to create payment link here.\\nhttp.post:\"https://api.stripe.com/v1/payment_links\"\\n   convert:true\\n   headers\\n      Authorization:x:@.token\\n      Content-Type:application/x-www-form-urlencoded\\n   payload\\n      line_items[0][price]:x:@.arguments/*/price_reference\\n      line_items[0][quantity]:int:1\\n      after_completion[type]:redirect\\n      after_completion[redirect][url]:x:@.arguments/*/success_url\\n\\n// Sanity checking above invocation.\\nif\\n   not\\n      and\\n         mte:x:@http.post\\n            .:int:200\\n         lt:x:@http.post\\n            .:int:300\\n   .lambda\\n\\n      // Oops, error - Logging error and returning status 500 to caller.\\n      lambda2hyper:x:@http.post\\n      log.error:Something went wrong while invoking Stripe, could not create payment link\\n         message:x:@http.post/*/content/*/error/*/message\\n         status:x:@http.post\\n         error:x:@lambda2hyper\\n      throw:Something went wrong while invoking Stripe, could not create payment link\\n         message:x:@http.post/*/content/*/error/*/message\\n         status:x:@http.post\\n         error:x:@lambda2hyper\\n\\n// Returning payment link to caller.\\nyield\\n   purchase_link:x:@http.post/*/content/*/url\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Refunds the specified [charge_id].\\n\\nWill use your Stripe API token found from your settings as it's interacting\\nwith the Stripe API."},{"role":"assistant","content":".arguments\\n   payment_id\\n      type:string\\n      mandatory:bool:true\\n.icon:payment\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/payment_id\\n\\n// Adding metadata.\\nfor-each:x:@.arguments/*/metadata/*\\n   set-name:x:./0/-/*/*\\n      strings.concat\\n         .:metadata[\\n         get-name:x:@.dp/#\\n         .:]\\n   unwrap:x:./0/-/*/*\\n   add:x:../*/http.post/*/payload\\n      .\\n         name:x:@.dp/#\\n\\n// Retrieving token to use for invocations towards Stripe.\\n.token\\nset-value:x:-\\n   strings.concat\\n      .:\"Bearer \"\\n      config.get:\"magic:stripe:token\"\\n\\n// Invoking Stripe REST API.\\nhttp.post:\"https://api.stripe.com/v1/refunds\"\\n   headers\\n      Authorization:x:@.token\\n      Content-Type:application/x-www-form-urlencoded\\n   convert:true\\n   payload\\n      payment_intent:x:@.arguments/*/payment_id\\n\\n// Sanity checking above invocation.\\nif\\n   mte\\n      get-value:x:@http.delete\\n      .:int:400\\n   .lambda\\n\\n      // Oops, something went wrong ...!!\\n      lambda2hyper:x:@http.post\\n      log.error:Something went wrong while invoking Stripe API to delete subscription\\n         result:x:@lambda2hyper\\n         provider:Stripe\\n      throw:Something went wrong while invoking Stripe API to delete subscription\\n         public:true\\n         status:500\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Creates a new Stripe subscription for the given [customer_id], using the\\nspecified [payment_method_id], for the given [price_id], which is a reference\\nto a Stripe product price.\\n\\nWill use your Stripe API token found from your settings as it's interacting\\nwith the Stripe API.\\n\\nNotice, [automatic_tax] as true will only work if customer has a valid tax location.\\nThis can be accomplished by retrieving IP address as you create the customer,\\nand pass in to Stripe, allowing Stripe to automatically calculate tax location based upon\\nthe customer's IP address."},{"role":"assistant","content":".arguments\\n   customer_id\\n      type:string\\n      mandatory:bool:true\\n   payment_method_id\\n      type:int\\n      mandatory:bool:true\\n   price_id\\n      type:string\\n      mandatory:bool:true\\n   automatic_tax\\n      type:bool\\n      default:bool:false\\n   metadata\\n      type:key-value\\n.icon:payment\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/customer_id\\nvalidators.mandatory:x:@.arguments/*/payment_method_id\\nvalidators.mandatory:x:@.arguments/*/price_id\\nvalidators.default:x:@.arguments\\n   automatic_tax:bool:false\\n\\n// Adding metadata\\nfor-each:x:@.arguments/*/metadata/*\\n   set-name:x:./0/-/*/*\\n      strings.concat\\n         .:metadata[\\n         get-name:x:@.dp/#\\n         .:]\\n   unwrap:x:./0/-/*/*\\n   add:x:../*/http.post/*/payload\\n      .\\n         name:x:@.dp/#\\n\\n// Retrieving token to use for invocations towards Stripe.\\n.token\\nset-value:x:-\\n   strings.concat\\n      .:\"Bearer \"\\n      config.get:\"magic:stripe:token\"\\n\\n// Invoking Stripe REST API.\\nhttp.post:\"https://api.stripe.com/v1/subscriptions\"\\n   headers\\n      Content-Type:application/x-www-form-urlencoded\\n      Authorization:x:@.token\\n   payload\\n      customer:x:@.arguments/*/customer_id\\n      items[0][price]:x:@.arguments/*/price_id\\n      default_payment_method:x:@.arguments/*/payment_method_id\\n      automatic_tax[enabled]:x:@.arguments/*/automatic_tax\\n   convert:true\\n\\n// Sanity checking above invocation.\\nif\\n   mte\\n      get-value:x:@http.post\\n      .:int:400\\n   .lambda\\n\\n      // Oops, something went wrong ...!!\\n      lambda2hyper:x:@http.post\\n      log.error:Something went wrong while invoking Stripe API to create subscription\\n         result:x:@lambda2hyper\\n         provider:Stripe\\n      throw:Something went wrong while invoking Stripe API to create subscription\\n         public:true\\n         status:500\\n\\n/*\\n * Checking if charge was successful.\\n * \\n * Notice, Stripe does NOT return an \"authentication URL\" for subscriptions,\\n * for reasons I don't know, so the best we can do here, is to return finished\\n * equaling false, and just encourage user to pay the invoice he have been\\n * given on email.\\n */\\nif\\n   eq:x:@http.post/*/content/*/status\\n      .:incomplete\\n   .lambda\\n\\n      // Charge was NOT successful, and probably needs 3D secure\\n      yield\\n         finished:bool:false\\n         subscription_id:x:@http.post/*/content/*/id\\n         product_id:x:@http.post/*/content/*/items/*/data/0/*/price/*/product\\n\\n// Returning customer ID to caller.\\nyield\\n   finished:bool:true\\n   subscription_id:x:@http.post/*/content/*/id\\n   product_id:x:@http.post/*/content/*/items/*/data/0/*/price/*/product\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Deletes the existing Stripe subscription for the given [subscription_id].\\n\\nWill use your Stripe API token found from your settings as it's interacting\\nwith the Stripe API."},{"role":"assistant","content":".arguments\\n   subscription_id\\n      type:string\\n      mandatory:bool:true\\n.icon:payment\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/subscription_id\\n\\n// Retrieving token to use for invocations towards Stripe.\\n.token\\nset-value:x:-\\n   strings.concat\\n      .:\"Bearer \"\\n      config.get:\"magic:stripe:token\"\\n\\n// Creating our REST URL.\\n.url\\nset-value:x:@.url\\n   strings.concat\\n      .:\"https://api.stripe.com/v1/subscriptions/\"\\n      get-value:x:@.arguments/*/subscription_id\\n\\n// Invoking Stripe REST API.\\nhttp.delete:x:@.url\\n   headers\\n      Authorization:x:@.token\\n   convert:true\\n\\n// Sanity checking above invocation.\\nif\\n   mte\\n      get-value:x:@http.delete\\n      .:int:400\\n   .lambda\\n\\n      // Oops, something went wrong ...!!\\n      lambda2hyper:x:@http.post\\n      log.error:Something went wrong while invoking Stripe API to delete subscription\\n         result:x:@lambda2hyper\\n         provider:Stripe\\n      throw:Something went wrong while invoking Stripe API to delete subscription\\n         public:true\\n         status:500\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Searches for subscriptions belonging to customer, which internally in the system is the user's username.\\n\\nReturns all subscriptions belonging to the specified username."},{"role":"assistant","content":".arguments\\n   username\\n      type:string\\n      mandatory:bool:true\\n.icon:payment\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/username\\n\\n// Retrieving token to use for invocations towards Stripe.\\n.token\\nset-value:x:-\\n   strings.concat\\n      .:\"Bearer \"\\n      config.get:\"magic:stripe:token\"\\n\\n// First we need to find customer from username.\\n.url\\nstrings.concat\\n   .:\"email:'\"\\n   get-value:x:@.arguments/*/username\\n   .:\"'\"\\nstrings.url-encode:x:@strings.concat\\nset-value:x:@.url\\n   strings.concat\\n      .:\"https://api.stripe.com/v1/customers/search?query=\"\\n      get-value:x:@strings.url-encode\\n\\n// Invoking Stripe REST API to retrieve customer.\\nhttp.get:x:@.url\\n   headers\\n      Authorization:x:@.token\\n   convert:true\\n\\n// Sanity checking above invocation.\\nif\\n   mte\\n      get-value:x:@http.post\\n      .:int:400\\n   .lambda\\n\\n      // Oops, something went wrong ...!!\\n      lambda2hyper:x:@http.post\\n      log.error:Something went wrong while invoking Stripe API to create subscription\\n         result:x:@lambda2hyper\\n         provider:Stripe\\n      throw:Something went wrong while invoking Stripe API to create subscription\\n         public:true\\n         status:500\\n\\n// Creating our URL.\\nset-value:x:@.url\\n   strings.concat\\n      .:\"https://api.stripe.com/v1/subscriptions?customer=\"\\n      strings.url-encode:x:@http.get/*/content/*/data/0/*/id\\n\\n// Invoking Stripe API.\\nhttp.get:x:@.url\\n   headers\\n      Authorization:x:@.token\\n   convert:true\\n\\n// Sanity checking above invocation.\\nif\\n   mte\\n      get-value:x:@http.post\\n      .:int:400\\n   .lambda\\n\\n      // Oops, something went wrong ...!!\\n      lambda2hyper:x:@http.post\\n      log.error:Something went wrong while invoking Stripe API to create subscription\\n         result:x:@lambda2hyper\\n         provider:Stripe\\n      throw:Something went wrong while invoking Stripe API to create subscription\\n         public:true\\n         status:500\\n\\n// Returning result to caller.\\nfor-each:x:@http.get/*/content/*/data/*\\n   unwrap:x:+/*/*/*\\n   add:x:../*/return\\n      .\\n         .\\n            id:x:@.dp/#/*/id\\nreturn\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Runs during startup of Magic, and basically just ensures the module's database exists,\\nand is updated by running migration scripts after attempting to create the database.\\n\\nIf the database doesn't exist, this script will create it by executing the SQL in the file"},{"role":"assistant","content":"signal:magic.modules.ensure-database\\n   module:stripe\\n   database:stripe\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Sends the latest log items from the chatbot's history to the specified\\nemail address as an attachment in the form of a CSV file.\\n\\nWill use the default SMTP settings from the cloudlet's configuration."},{"role":"assistant","content":"slots.create:utilities.history.send-email\\n\\n   // Sanity checking invocation.\\n   validators.mandatory:x:@.arguments/*/email\\n   validators.email:x:@.arguments/*/email\\n\\n   // Basic logging.\\n   log.info:Sending chatbot log to cloudlet owner\\n      email:x:@.arguments/*/email\\n\\n   // Opening database connection.\\n   data.connect:[generic|magic]\\n\\n      // Extracting items from ml_requests\\n      data.read\\n         table:ml_requests\\n         columns\\n            prompt\\n            completion\\n            created\\n            type\\n            finish_reason\\n            user_id\\n            session\\n\\n      // Converting records to CSV\\n      lambda2csv:x:@data.read/*\\n\\n      // Sending CSV file to specified email address.\\n      mail.smtp.send\\n         message\\n            to\\n               .\\n                  email:x:@.arguments/*/email\\n                  name:Chatbot Admin\\n            subject:Chatbot history log\\n            entity:multipart/mixed\\n               entity:text/plain\\n                  content:Latest AINIRO.IO Chatbot requests\\n               entity:text/csv\\n                  headers\\n                     Content-Disposition:\"attachment; filename=\\\"log.csv\\\"\"\\n                  content:x:@lambda2csv\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Ingests the products for the specified Woocommerce account into ml_training_data."},{"role":"assistant","content":"slots.create:woocommerce.products.ingest\\n\\n   // Sanity checking invocation.\\n   validators.mandatory:x:@.arguments/*/type\\n   validators.mandatory:x:@.arguments/*/base-url\\n   validators.mandatory:x:@.arguments/*/username\\n   validators.mandatory:x:@.arguments/*/secret\\n   validators.default:x:@.arguments\\n      quantity:bool:true\\n      vectorize:bool:true\\n      max_tokens:int:1000\\n\\n   // Basic logging.\\n   log.info:Deleting products to prepare for import using WooCommerce API\\n      type:x:@.arguments/*/type\\n      shop:x:@.arguments/*/base-url\\n\\n   // Normalizing URL.\\n   set-value:x:@.arguments/*/base-url\\n      strings.trim-end:x:@.arguments/*/base-url\\n         .:/\\n\\n   // Making sure we trap exceptions and logs errors.\\n   try\\n\\n      // Deleting existing WooCommerce imported ml_training_snippets for model.\\n      data.connect:[generic|magic]\\n         data.execute:\"delete from vss_ml_training_snippets where rowid in (select id as rowid from ml_training_snippets where type = @type and meta = 'woocommerce-import')\"\\n            @type:x:@.arguments/*/type\\n         data.delete\\n            table:ml_training_snippets\\n            where\\n               and\\n                  type.eq:x:@.arguments/*/type\\n                  meta.eq:woocommerce-import\\n\\n      // Basic logging.\\n      log.info:Importing products using WooCommerce API\\n         type:x:@.arguments/*/type\\n         shop:x:@.arguments/*/base-url\\n\\n      // Buffer for all products.\\n      .products\\n\\n      // Buffer for Basic AUTH key.\\n      .auth\\n\\n      // Creating Basic AUTH token.\\n      set-value:x:@.auth\\n         strings.concat\\n            get-value:x:@.arguments/*/username\\n            .:\":\"\\n            get-value:x:@.arguments/*/secret\\n      set-value:x:@.auth\\n         convert:x:@.auth\\n            type:bytes\\n      set-value:x:@.auth\\n         strings.concat\\n            .:\"Basic \"\\n            convert:x:@.auth\\n               type:base64\\n\\n      // What page of items we're retrieving.\\n      .page:int:0\\n\\n      // Continue while loop as long as true.\\n      .continue:bool:true\\n\\n      // Looping as long as we've got more products from WooCommerce.\\n      while:x:@.continue\\n         .base-url:\"https://project.mis.temple.edu/foodkiosk/wp-json/wc/v3/products?per_page=10\"\\n         if\\n            mt:x:@.page\\n               .:int:0\\n            .lambda\\n               set-value:x:@.base-url\\n                  strings.concat\\n                     .:\"https://project.mis.temple.edu/foodkiosk/wp-json/wc/v3/products?per_page=10&page=\"\\n                     get-value:x:@.page\\n\\n         // Getting next batch of products.\\n         http.get:x:@.base-url\\n            headers\\n               Authorization:x:@.auth\\n            convert:bool:true\\n\\n         // Insert products into above buffer node.\\n         add:x:@.products\\n            get-nodes:x:@http.get/*/content/*\\n\\n         // Checking if we're done.\\n         if\\n            lt\\n               get-count:x:@http.get/*/content/*\\n               .:int:10\\n            .lambda\\n               set-value:x:@.continue\\n                  .:bool:false\\n\\n         // Incrementing page.\\n         math.increment:x:@.page\\n            .:int:10\\n\\n         /*\\n          * Opening up our database connection, such that we can\\n          * insert training snippets into database.\\n          */\\n         data.connect:[generic|magic]\\n\\n            // Looping through all products we fetched above.\\n            for-each:x:@http.get/*/content/*\\n\\n               // Verifying product is in stock.\\n               if\\n                  and\\n                     eq:x:@.dp/#/*/stock_status\\n                        .:instock\\n                     not-null:x:@.dp/#/*/description\\n                     neq:x:@.dp/#/*/description\\n                        .:\\n                  .lambda\\n\\n                     // Building the product ml_training_snippet.\\n                     .prompt\\n                     .completion\\n\\n                     // Extracting properties of product\\n                     set-value:x:@.prompt\\n                        strings.concat\\n                           html2markdown:x:@.dp/#/*/description\\n                     set-value:x:@.completion\\n                        strings.concat\\n                           .:\"Price: \"\\n                           get-value:x:@.dp/#/*/price\\n                           .:@\"\\n\\n\"\\n                           .:\"URL: \"\\n                           get-value:x:@.dp/#/*/permalink\\n                     if\\n                        and\\n                           not-null:x:@.dp/#/*/short_description\\n                           neq:x:@.dp/#/*/short_description\\n                              .:\\n                        .lambda\\n                           set-value:x:@.completion\\n                              strings.concat\\n                                 get-value:x:@.completion\\n                                 .:@\"\\n\\n\"\\n                                 .:\"Short description: \"\\n                                 html2markdown:x:@.dp/#/*/short_description\\n\\n                     // Extracting images if there are any.\\n                     if\\n                        exists:x:@.dp/#/*/images/*\\n                        .lambda\\n                           set-value:x:@.completion\\n                              strings.concat\\n                                 get-value:x:@.completion\\n                                 .:@\"\\n\\nImages of product:\"\\n                           for-each:x:@.dp/#/*/images/*\\n\\n                              // Appending currently iterated image.\\n                              set-value:x:@.completion\\n                                 strings.concat\\n                                    get-value:x:@.completion\\n                                    .:@\"\\n\\n\"\\n                                    .:![\\n                                    get-value:x:@.dp/#/*/name\\n                                    .:](\\n                                    get-value:x:@.dp/#/*/src\\n                                    .:)\\n\\n                     // Inserting product into database.\\n                     data.create\\n                        table:ml_training_snippets\\n                        values\\n                           type:x:@.arguments/*/type\\n                           prompt:x:@.prompt\\n                           completion:x:@.completion\\n                           uri:x:@.uri\\n                           meta:woocommerce-import\\n\\n      // Checking if we should vectorize model or not.\\n      if:x:@.arguments/*/vectorize\\n\\n         // Basic logging.\\n         log.info:Started vectorizing model after WooCommerce import\\n            type:x:@.arguments/*/type\\n            shop:x:@.arguments/*/base-url\\n\\n         // Vectorizing model.\\n         unwrap:x:+/*\\n         signal:magic.ai.vectorise\\n            feedback-channel:non-existing\\n            type:x:@.arguments/*/type\\n\\n         // Basic logging.\\n         log.info:Done vectorizing model after WooCommerce import\\n            type:x:@.arguments/*/type\\n            shop:x:@.arguments/*/base-url\\n\\n      // Logging the fact that we're done.\\n      log.info:Done with WooCommerce import\\n         type:x:@.arguments/*/type\\n         shop:x:@.arguments/*/base-url\\n   .catch\\n\\n      // Oops ...!!\\n      log.error:Something went wrong as we tried to import products from WooCommerce\\n         error:x:@.arguments/*/message\\n         type:x:@.arguments/*/type\\n         shop:x:@.arguments/*/base-url\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Retrieve a list of items with a filter, automatically parsing JSON response"},{"role":"assistant","content":"http.get:\"https://api.example.com/items\"\\n\\n   // attach query parameters instead of hardcoding them in URL\\n   query\\n      category:books\\n      limit:10\\n\\n   // auto-convert JSON response to lambda object\\n   convert:bool:true\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"First, create a dynamic slot 'hello'"},{"role":"assistant","content":"slots.create:hello\\n   return-value:Hello\\n\\n// Invoke the 'hello' slot\\nsignal:hello\\n\\n// The signal node now holds the value \"Hello\"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Define a slot 'pair' that returns two values as separate nodes"},{"role":"assistant","content":"slots.create:pair\\n   return-nodes\\n      first:Alpha\\n      second:Beta\\n\\n// Invoke the 'pair' slot\\nsignal:pair\\n\\n// After invocation, signal:pair has two child nodes: [first] = \"Alpha\", [second] = \"Beta\"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create a slot 'join-strings' that joins all arguments separated by ' ' character."},{"role":"assistant","content":"slots.create:join-strings\\n   strings.join:x:@.arguments/*\\n      .:\" \"\\n   return-value:x:-\\n\\n// Invoke 'join-strings' using execute with expressions as arguments\\n.arg:is cool!\\nexecute:join-strings\\n   text1:Hyperlambda\\n   text2:x:@.arg\\n\\n// The expressions are evaluated before invocation, so inside 'join-strings':\\n\\n// text2 becomes \"is cool!\",\\n\\n// and the returned value is \"Hyperlambda is cool\".\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create a slot 'test' that returns a value"},{"role":"assistant","content":"slots.create:test\\n   return-value:OK\\n\\n// Invoke 'test' safely (slot exists)\\ntry-signal:test\\n\\n// The try-signal node's value is \"OK\"\\n\\n// Invoke a non-existent slot 'missing' safely\\ntry-signal:missing\\n\\n// No exception is thrown even though 'missing' is not defined (result is empty)\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Define a sample slot 'sample'"},{"role":"assistant","content":"slots.create:sample\\n   return-value:Done\\n\\n// Retrieve the Hyperlambda definition of 'sample'\\nslots.get:sample\\n\\n// The result is the lambda nodes of 'sample', e.g. a child node [return-value] with value \"Done\".\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Try to retrieve a slot that does not exist"},{"role":"assistant","content":"slots.get:unknown\\n\\n// Throws an exception because 'unknown' slot is not defined\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"First, create a dynamic slot 'hello'"},{"role":"assistant","content":"slots.create:hello\\n   return-value:Hello\\n\\n// Invoke the 'hello' slot\\nsignal:hello\\n\\n// The signal node now holds the value \"Hello\"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Define a slot 'pair' that returns two values as separate nodes"},{"role":"assistant","content":"slots.create:pair\\n   return-nodes\\n      first:Alpha\\n      second:Beta\\n\\n// Invoke the 'pair' slot\\nsignal:pair\\n\\n// After invocation, signal:pair has two child nodes: [first] = \"Alpha\", [second] = \"Beta\"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create a slot 'join-strings' that joins all arguments separated by ' ' character."},{"role":"assistant","content":"slots.create:join-strings\\n   strings.join:x:@.arguments/*\\n      .:\" \"\\n   return-value:x:-\\n\\n// Invoke 'join-strings' using execute with expressions as arguments\\n.arg:is cool!\\nexecute:join-strings\\n   text1:Hyperlambda\\n   text2:x:@.arg\\n\\n// The expressions are evaluated before invocation, so inside 'join-strings':\\n\\n// text2 becomes \"is cool!\",\\n\\n// and the returned value is \"Hyperlambda is cool\".\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create a slot 'test' that returns a value"},{"role":"assistant","content":"slots.create:test\\n   return-value:OK\\n\\n// Invoke 'test' safely (slot exists)\\ntry-signal:test\\n\\n// The try-signal node's value is \"OK\"\\n\\n// Invoke a non-existent slot 'missing' safely\\ntry-signal:missing\\n\\n// No exception is thrown even though 'missing' is not defined (result is empty)\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Define a sample slot 'sample'"},{"role":"assistant","content":"slots.create:sample\\n   return-value:Done\\n\\n// Retrieve the Hyperlambda definition of 'sample'\\nslots.get:sample\\n\\n// The result is the lambda nodes of 'sample', e.g. a child node [return-value] with value \"Done\".\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Try to retrieve a slot that does not exist"},{"role":"assistant","content":"slots.get:unknown\\n\\n// Throws an exception because 'unknown' slot is not defined\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create a temporary slot 'temp'"},{"role":"assistant","content":"slots.create:temp\\n   return-value:Temporary\\n\\n// Delete the dynamic slot 'temp'\\nslots.delete:temp\\n\\n// Check if 'temp' still exists\\nslots.exists:temp\\n\\n// Returns false (since 'temp' was removed)\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Define a slot 'pair' that returns two values as separate nodes"},{"role":"assistant","content":"slots.create:pair\\n   return-nodes\\n      first:Alpha\\n      second:Beta\\n\\n// Invoke the 'pair' slot\\nsignal:pair\\n\\n// After invocation, signal:pair has two child nodes: [first] = \"Alpha\", [second] = \"Beta\"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create a slot 'join-strings' that joins all arguments separated by ' ' character."},{"role":"assistant","content":"slots.create:join-strings\\n   strings.join:x:@.arguments/*\\n      .:\" \"\\n   return-value:x:-\\n\\n// Invoke 'join-strings' using execute with expressions as arguments\\n.arg:is cool!\\nexecute:join-strings\\n   text1:Hyperlambda\\n   text2:x:@.arg\\n\\n// The expressions are evaluated before invocation, so inside 'join-strings':\\n\\n// text2 becomes \"is cool!\",\\n\\n// and the returned value is \"Hyperlambda is cool\".\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create a slot 'test' that returns a value"},{"role":"assistant","content":"slots.create:test\\n   return-value:OK\\n\\n// Invoke 'test' safely (slot exists)\\ntry-signal:test\\n\\n// The try-signal node's value is \"OK\"\\n\\n// Invoke a non-existent slot 'missing' safely\\ntry-signal:missing\\n\\n// No exception is thrown even though 'missing' is not defined (result is empty)\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Define a sample slot 'sample'"},{"role":"assistant","content":"slots.create:sample\\n   return-value:Done\\n\\n// Retrieve the Hyperlambda definition of 'sample'\\nslots.get:sample\\n\\n// The result is the lambda nodes of 'sample', e.g. a child node [return-value] with value \"Done\".\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Try to retrieve a slot that does not exist"},{"role":"assistant","content":"slots.get:unknown\\n\\n// Throws an exception because 'unknown' slot is not defined\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create a temporary slot 'temp'"},{"role":"assistant","content":"slots.create:temp\\n   return-value:Temporary\\n\\n// Delete the dynamic slot 'temp'\\nslots.delete:temp\\n\\n// Check if 'temp' still exists\\nslots.exists:temp\\n\\n// Returns false (since 'temp' was removed)\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create a new item by POSTing JSON data, with a Bearer token for authorization"},{"role":"assistant","content":"http.post:\"https://api.example.com/items\"\\n\\n   // optional Bearer JWT token for auth\\n   token:XYZ_SECRET_TOKEN_123\\n   payload:\"{\\\"name\\\": \\\"Sample Book\\\", \\\"price\\\": 19.99}\"\\n\\n   // Use 'filename' instead of 'payload' for large files to stream from /files directory\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"(Assume no dynamic slots exist at this point)"},{"role":"assistant","content":"\"slots.vocabulary  \"\\n\\n// Returns an empty list (no slot names to report)\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Define a slot that returns two pieces of data"},{"role":"assistant","content":"slots.create:getPair\\n   return-nodes\\n      key:Value\\n      number:int:123\\n\\n// Invoke 'getPair'\\nsignal:getPair\\n\\n// The result has child nodes: key = \"Value\" and number = 123\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Define a slot that returns a single string"},{"role":"assistant","content":"slots.create:giveAnswer\\n   return-value:Forty Two\\n\\n// Invoke 'giveAnswer'\\nsignal:giveAnswer\\n\\n// The result is \"Forty Two\"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Define a slot that returns both a value and additional nodes"},{"role":"assistant","content":"slots.create:retBoth\\n   return:All Good\\n      status:ok\\n      code:int:200\\nsignal:retBoth\\n\\n// Result: value \"All Good\", with child nodes [status = \"ok\", code = 200]\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Define a slot that returns multiple values by evaluating expressions before the slot returns"},{"role":"assistant","content":"slots.create:giveData\\n   .tmp1:Value 1\\n   .tmp2:int:2025\\n\\n   // Return two nodes, evaluating any expressions in them\\n   yield\\n      message:x:@.tmp1\\n      year:x:@.tmp2\\nsignal:giveData\\n\\n// Result: message = \"Value 1\", year = 2023\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Adding two nodes into another node"},{"role":"assistant","content":".src\\nadd:x:@.src\\n   .\\n      foo:int:57\\n      bar:int:10\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Adding expressions as new nodes but unwrapping expressions before executing [add]"},{"role":"assistant","content":".data\\n   foo:some value\\nunwrap:x:+/*/*\\nadd:x:@.data\\n   .\\n      bar:x:@.data/*/foo\\n\\n// Both nodes will contain the values of the above [foo] nodes after [add].\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Upload a file to replace an existing resource using HTTP PUT"},{"role":"assistant","content":"http.put:\"https://api.example.com/upload/README\"\\n\\n   // read file from /files/documents/README.md and send as request body\\n   filename:/documents/README.md\\n\\n   // set a 30-second timeout instead of default\\n   timeout:int:30\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Converting a string to integer"},{"role":"assistant","content":".data:int:42\\nconvert:x:@.data\\n   type:int\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Converting a date string to date object and assigning to another node"},{"role":"assistant","content":".data:2023-05-17\\n.dest\\nset-value:x:-\\n   convert:x:@.data\\n      type:date\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Getting current date and time and assigning to [.now]"},{"role":"assistant","content":".now\\nset-value:x:@.now\\n   date.now\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Iterating through a collection of nodes"},{"role":"assistant","content":".data\\n   item1:value1\\n   item2:value2\\n   item3:value3\\n.result\\nfor-each:x:@.data/*\\n   set-value:x:@.result\\n      strings.concat\\n         get-value:x:@.result\\n         get-value:x:@.dp/#\\n         .:\", \"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Processing each item in a collection"},{"role":"assistant","content":".items\\n   .:int:5\\n   .:int:10\\n   .:int:15\\n.sum:int:0\\nfor-each:x:@.items/*\\n   math.add:x:@.sum\\n      get-value:x:@.dp/#\\n   set-value:x:@.sum\\n      get-value:x:@math.add\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Conditional execution using if"},{"role":"assistant","content":".value:int:42\\n.result\\nif\\n   mt:x:@.value\\n      .:int:10\\n   .lambda\\n      set-value:x:@.result\\n         .:Value is greater than 10\\nelse\\n   set-value:x:@.result\\n      .:Value is less than or equal to 10\\n\\n// Notice, [else] does not require a [.lambda] node\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Setting a node value"},{"role":"assistant","content":".data\\n   name:\\nset-value:x:@.data/*/name\\n   .:John Doe\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Setting value from another node"},{"role":"assistant","content":".source:Hello World\\n.target\\nset-value:x:@.target\\n   get-value:x:@.source\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Changing a node's name"},{"role":"assistant","content":".data\\n   old-name:some-value\\nset-name:x:@.data/*/old-name\\n   .:new-name\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Partially update an item's price using HTTP PATCH with a custom header"},{"role":"assistant","content":"http.patch:\"https://api.example.com/items/123\"\\n   headers\\n\\n      // specify JSON content type since custom header overrides defaults\\n      Content-Type:application/json\\n\\n      // example of a custom header for authentication\\n      X-API-Key:MY_API_KEY_ABC123\\n\\n   // attach query parameters instead of hardcoding them in URL\\n   query\\n      ID:5\\n\\n   // JSON snippet with the fields to update\\n   payload:\"{\\\"price\\\": 25.00}\"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Raising a custom signal"},{"role":"assistant","content":".message:Hello from signal\\n\\n// Here the expression will NOT be evaluated.\\nsignal:custom.signal\\n   message:x:@.message\\n\\n// Here the expression will NOT be evaluated.\\nexecute:custom.signal\\n   message:x:@.message\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Handling a signal with arguments"},{"role":"assistant","content":".data\\n   first-name:John\\n   last-name:Doe\\nexecute:user.full-name\\n   first-name:x:@.data/*/first-name\\n   last-name:x:@.data/*/last-name\\n\\n// Above the expressions will be evaluated passing in the values of [first-name] and [last-name] to the slot\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Getting substring from a string"},{"role":"assistant","content":".data:Hyperlambda is awesome\\n.result\\nstrings.substring:x:@.data\\n   .:int:0\\n   .:int:11\\nset-value:x:@.result\\n   get-value:x:@strings.substring\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Switching based on a value inside an anonymous lambda object, returning true if it's a workday."},{"role":"assistant","content":".lambda\\n\\n   // Switching with multiple cases\\n   switch:x:@.arguments/*/day\\n      case:monday\\n      case:tuesday\\n      case:wednesday\\n      case:thursday\\n      case:friday\\n         return:bool:true\\n      case:saturday\\n      case:sunday\\n         return:bool:false\\n      default\\n         .result:Invalid day\\ninvoke:x:@.lambda\\n   day:monday\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Delete an item by ID with authorization, specifying a short timeout"},{"role":"assistant","content":"http.delete:\"https://api.example.com/items/123\"\\n\\n   // attach query parameters instead of hardcoding them in URL\\n   query\\n      category:cars\\n\\n   // include Bearer token for auth if required by the API\\n   token:XYZ_SECRET_TOKEN_123\\n\\n   // abort if no response within 5 seconds\\n   timeout:int:5\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Examples of creating slots, executing slots, and checking if slots exists - In addition to deleting slots."},{"role":"assistant","content":"slots.create:greet\\n   return-value:Hello World\\n\\n// Invoke the created greeting slot\\nsignal:greet\\n\\n// Execute a slot with unwrapped arguments\\n.args\\n   name:John\\nexecute:greet-personalized\\n   message:x:@.args/*/name\\n\\n// Doesn't throw even though slot doesn't exists\\ntry-signal:NON-EXISTING-SLOT\\n\\n// Get the implementation of a slot\\nslots.get:greet\\n\\n// Delete a slot and verify removal\\nslots.delete:greet\\nslots.exists:greet\\n\\n// Create slot returning multiple nodes\\nslots.create:user-data\\n   return-nodes\\n      name:John Doe\\n      age:34\\n      email:john@doe.com\\n\\n// Create slot with conditional return\\nslots.create:check-age\\n   validators.mandatory:x:@.arguments/*/age\\n   validators.integer:x:@.arguments/*/age\\n      min:0\\n      max:140\\n   if\\n      mt:x:@.arguments/*/age\\n         .:int:18\\n      .lambda\\n         return-value:Adult\\n   else\\n      return-value:Minor\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create a dynamic slot 'foo' that returns the number 57"},{"role":"assistant","content":"slots.create:foo\\n   return-value:int:57\\n\\n// Invoke the dynamic slot 'foo'\\nsignal:foo\\n\\n// The signal node now has the value 57 (int)\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Define slot 'foo' with an initial return value"},{"role":"assistant","content":"slots.create:foo\\n   return-value:First version\\n\\n// Invoke 'foo' (will yield \"First version\")\\nsignal:foo\\n\\n// Redefine (override) slot 'foo' with new logic\\nslots.create:foo\\n   return-value:Second version\\n\\n// Invoke 'foo' again (now yields \"Second version\")\\nsignal:foo\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Define a dynamic slot 'greet' (using alias for slots.create)"},{"role":"assistant","content":"function:greet\\n   return-value:Hi there\\n\\n// Invoke 'greet'\\nsignal:greet\\n\\n// The signal node's value is \"Hi there\"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Creates training data and inserts into fine-tuning database such that it can be exported later.\\n\\nIf this function returns nothing, we are done, and we have generated training data for every single Hyperlambda file in your cloudlet."},{"role":"assistant","content":".arguments\\n\\n   // Mandatory argument being file number to generate training data for. When listing Hyperlambda files, this will generate training data for the nth file listed, allowing us to loop for as long as have have additional files, incrementing the file-no argument for each iteration.\\n   file-no:int\\n.type:public\\n\\n// Listing files recursively.\\nio.file.list-recursively:/\\n\\n// Pruning out everything but Hyperlambda files.\\n.file\\nfor-each:x:@io.file.list-recursively/*\\n   if\\n      strings.ends-with:x:@.dp/#\\n         .:.hl\\n      .lambda\\n         unwrap:x:+/*/*\\n         add:x:@.file\\n            .\\n               .:x:@.dp/#\\n\\n// Checking if we've dealt with all files.\\nif\\n   mt\\n      get-value:x:@.arguments/*/file-no\\n      get-count:x:@.file/*\\n   .lambda\\n      return\\n         result:There are no more files, you have handled all files.\\n\\n// Loading nth file.\\n.hyperlambda\\nstrings.concat\\n   .:@.file/\\n   get-value:x:@.arguments/*/file-no\\nset-x:x:+\\n   convert:x:@strings.concat\\n      type:x\\nio.file.load\\n\\n// Returning Hyperlambda file to caller.\\nyield\\n   hyperlambda:x:@io.file.load\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Creates JSONL training data for all data we've got in our database\\n\\nYou have to manually download the data after generating it."},{"role":"assistant","content":".arguments\\n.type:public\\n\\n// Buffer for snippets.\\n.result:\\n\\n// Buffer for validation snippets.\\n.validation:\\n\\n// Counter to ensure every 8th record becomes a validation snippet and not a training snippet.\\n.no:int:0\\n\\n// Retrieving all snippets.\\ndata.connect:fine-tune\\n   data.select:select * from hyperlambda\\n\\n   // Iterating through snippets to generate training data.\\n   for-each:x:@data.select/*\\n\\n      // Generating training record, starting with prompt.\\n      .prompt\\n      set-value:x:@.prompt\\n         get-value:x:@.dp/#/*/prompt\\n\\n      // Then completion.\\n      .completion\\n      set-value:x:@.completion\\n         get-value:x:@.dp/#/*/code\\n\\n      // Replacing CR and LF characters.\\n      set-value:x:@.prompt\\n         strings.replace:x:@.prompt\\n            .:\"\\n\"\\n            .:\"\\\\n\"\\n      set-value:x:@.prompt\\n         strings.replace:x:@.prompt\\n            .:\"\\r\"\\n      set-value:x:@.completion\\n         strings.replace:x:@.completion\\n            .:\"\\n\"\\n            .:\"\\\\n\"\\n      set-value:x:@.completion\\n         strings.replace:x:@.completion\\n            .:\"\\r\"\\n      unwrap:x:+/**\\n      .data\\n         messages\\n            .\\n               role:system\\n               content:You are a Hyperlambda coding assistant. Always respond with Hyperlambda code.\\n            .\\n               role:user\\n               content:x:@.prompt\\n            .\\n               role:assistant\\n               content:x:@.completion\\n\\n      // Adding training data to above [.result].\\n      if\\n         eq\\n            math.modulo:x:@.no\\n               .:int:8\\n            .:int:0\\n         .lambda\\n            set-value:x:@.validation\\n               strings.concat\\n                  get-value:x:@.validation\\n                  lambda2json:x:@.data/*\\n                  .:\"\\n\"\\n      else\\n         set-value:x:@.result\\n            strings.concat\\n               get-value:x:@.result\\n               lambda2json:x:@.data/*\\n               .:\"\\n\"\\n      math.increment:x:@.no\\n\\n// Saving files.\\nio.file.save:/modules/fine-tune/training-material.jsonl\\n   get-value:x:@.result\\nio.file.save:/modules/fine-tune/training-material-validation.jsonl\\n   get-value:x:@.validation\\n\\n// Returning result to caller.\\nreturn\\n   result:Success\\n   message:\"Your training data can be found in '/modules/fine-tune/training-material.jsonl'\"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Extracting specific parts from a MIME message"},{"role":"assistant","content":"\\n// Example raw MIME message\\n.mime-data:\"MIME-Version: 1.0\\nContent-Type: multipart/mixed; boundary=\\\"frontier\\\"\\n\\n--frontier\\nContent-Type: text/plain\\n\\nThis is the body of the message.\\n\\n--frontier\\nContent-Type: application/octet-stream\\nContent-Transfer-Encoding: base64\\nContent-Disposition: attachment; filename=\\\"report.pdf\\\"\\n\\nJVBERi0xLjUKJdDUxdgKNSAwIG9iago8PAovTGVuZ3RoIDEyNjUKL0ZpbHRlciAv\\nRmxhdGVEZWNvZGUKPj4Kc3RyZWFtCnicY2RgYGJgYGBkYAACTiCuZxCw\\n\\n--frontier\\nContent-Type: image/jpeg\\nContent-Transfer-Encoding: base64\\nContent-Disposition: attachment; filename=\\\"photo.jpg\\\"\\n\\n/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAMCAgICAgMCAgIDAwMDBAYEBAQEBAgG\\nBgUGCQgKCgkICQkKDA8MCgsOCwkJDRENDg8QEBEQCgwSExIQEw8QEBD/\\n\\n--frontier--\"\\n\\n// Parse the MIME message\\nmime.parse:x:@.mime-data\\n\\n// Extract the text body\\n.message-body\\nset-value:x:@.message-body\\n   get-value:x:@mime.parse/*/entity/[0,1]/*/content\\n\\n// Extract information about the first attachment\\n.first-attachment\\n   disposition:x:@mime.parse/*/entity/[1,1]/*/headers/*/Content-Disposition\\n   content:x:@mime.parse/*/entity/[1,1]/*/content\\n   type:x:@mime.parse/*/entity/[1,1]\\n\\n// Evaluates all expressions inside of above [.first-attachment].\\nunwrap:x:-/*\\n\\n// Count the number of attachments\\n.attachment-count:int:0\\nfor-each:x:@mime.parse/*/entity\\n   if\\n      not\\n         eq:x:@.dp/#\\n            .:text/plain\\n      .lambda\\n         math.increment:x:@.attachment-count\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns a specific cookie from current HTTP request"},{"role":"assistant","content":"request.cookies.get\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Executes any Hyperlambda segments found in string, passing in arguments, and substitutes Hyperlambda segment with result of execution"},{"role":"assistant","content":".mixin:\"The sum of your arguments is {{\\nmath.add\\n   get-value:x:@.arguments/*/arg1\\n   get-value:x:@.arguments/*/arg2\\n\\n// Whatever we return here substitutes the mixin in the result\\nreturn:x:-\\n}}\"\\nstrings.mixin:x:-\\n   arg1:int:2\\n   arg2:int:3\\n\\n// Result ==> \"The sum of your arguments is 5\"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns the IP address of the cloudlet"},{"role":"assistant","content":"server.ip\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Return a list of all registered MIME types cloudlet can serve by default, and their filename extensions"},{"role":"assistant","content":"mime.list\\n\\n/*\\n * Result:\\n * mime.list\\n * json:application/json\\n * css:text/css\\n * txt:text/plain\\n * js:application/javascript\\n * jpeg:image/jpeg\\n * jpg:image/jpeg\\n * webp:image/webp\\n * png:image/png\\n * gif:image/gif\\n * svg:image/svg+xml\\n * md:text/markdown\\n * html:text/html\\n */\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Converts the specified lambda to XML"},{"role":"assistant","content":"lambda2xml\\n   customers\\n      customer\\n         name\\n            #text:John Doe\\n         email\\n            #text:john@doe.com\\n\\n/*\\n * Result;\\n * <customers>\\n * <customer>\\n * <name>John Doe</name>\\n * <email>john@doe.com</email>\\n * </customer>\\n * </customers>\\n */\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Decodes the specified HTML"},{"role":"assistant","content":".html:\"&lt;html&gt;\\n&lt;body&gt;\\n  &lt;h1&gt;Quarterly Newsletter - Q1 2025&lt;/h1&gt;\\n  &lt;p&gt;Our Q1 results are now available.&lt;/p&gt;\\n&lt;/body&gt;\\n&lt;/html&gt;\"\\n\\n// HTML decodes the above HTML\\nstrings.html-decode:x:@.html\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Encodes the specified HTML"},{"role":"assistant","content":".html:\"<html>\\n<body>\\n  <h1>Quarterly Newsletter - Q1 2025</h1>\\n  <p>Our Q1 results are now available.</p>\\n  <ul>\\n    <li>Total revenue increased by <strong>15%</strong> compared to Q4 2024</li>\\n    <li>Customer satisfaction reached <strong>94%</strong></li>\\n  </ul>\\n  <p>View the <a href=\\\"https://company.com/reports/q1-2025\\\">full report</a>.</p>\\n</body>\\n</html>\"\\n\\n// HTML decodes the above HTML\\nstrings.html-encode:x:@.html\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Converts from XML to lambda"},{"role":"assistant","content":".xml:\"<customers>\\n   <customer>\\n      <name>John Doe</name>\\n      <email>john@doe.com</email>\\n   </customer>\\n</customers>\"\\nxml2lambda:x:-\\n\\n/*\\n * Result:\\n * xml2lambda\\n * customers\\n * customer\\n * name\\n * #text:John Doe\\n * email\\n * #text:john@doe.com\\n */\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns the operating system to caller"},{"role":"assistant","content":"system.os\\n\\n// Results in (for Mac); Darwin 23.1.0 Darwin Kernel Version 23.1.0: Mon Oct  9 21:32:11 PDT 2023; root:xnu-10002.41.9~7/RELEASE_ARM64_T6030\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"How to use string builder in Hyperlambda"},{"role":"assistant","content":"strings.builder\\n   strings.builder.append:Hello\\n   strings.builder.append:\" \"\\n   strings.builder.append:world\\n\\n// Results in; Hello world\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Return the URL of the current request"},{"role":"assistant","content":"request.url\\n\\n// Example result ==> magic/system/evaluator/evaluate\\n\\n// Notice, URL will always be returned as relative URL\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Return the HTTP verb of the current request"},{"role":"assistant","content":"request.verb\\n\\n// Result ==> One of get, post, put, patch, or delete\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Logs a fatal error"},{"role":"assistant","content":"log.fatal:Fatal error we cannot recover from\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns minimum legal value for a date object ==> 0001-01-01T00:00:00.000"},{"role":"assistant","content":"date.min\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns maximum legal value for a date object ==> 9999-12-31T23:59:59.999"},{"role":"assistant","content":"date.max\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns true if we're running on the specified operating system"},{"role":"assistant","content":"system.is-os:OSX\\n\\n/*\\n * Values you can query for;\\n * - FreeBSD\\n * - Linux\\n * - OSX\\n * - Windows\\n */\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Connect to the PostgreSQL 'customers' database using the 'my_connection' connection string"},{"role":"assistant","content":"pgsql.connect:[my_connection|customers]\\n\\n// Notice, all database conections such as above are not actually opened before they're referenced by another slot\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Retrieve the count of users in the 'customers' table"},{"role":"assistant","content":"pgsql.scalar:SELECT COUNT(*) FROM customers\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Execute a custom SQL statement to update user roles"},{"role":"assistant","content":"pgsql.execute:\"UPDATE users SET role = 'member' WHERE role = 'guest'\"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Commit the current transaction"},{"role":"assistant","content":"pgsql.transaction.commit\\n\\n// Notice, must be inside a [pgsql.transaction.create] invocation\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Rollback the current transaction"},{"role":"assistant","content":"pgsql.transaction.rollback\\n\\n// Notice, must be inside a [pgsql.transaction.create] invocation\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Retrieve the count of users in the 'customers' table"},{"role":"assistant","content":"pgsql.scalar:SELECT COUNT(*) FROM customers\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Execute a custom SQL statement to update user roles"},{"role":"assistant","content":"pgsql.execute:\"UPDATE users SET role = 'member' WHERE role = 'guest'\"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create a new transaction"},{"role":"assistant","content":"pgsql.transaction.create\\n\\n// Notice, must be invoked inside a pgsql.connect or data.connect with database-type being 'pgsql'\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Commit the current transaction"},{"role":"assistant","content":"pgsql.transaction.commit\\n\\n// Notice, must be inside a [pgsql.transaction.create] invocation\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Rollback the current transaction"},{"role":"assistant","content":"pgsql.transaction.rollback\\n\\n// Notice, must be inside a [pgsql.transaction.create] invocation\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Insert a new user into the 'users' table"},{"role":"assistant","content":"pgsql.create\\n   table:users\\n   values\\n      username:john_doe\\n      email:john.doe@example.com\\n      created_at:date:\"2025-03-18T09:09:13.000\"\\n\\n// Notice, since dates contains : characters we have to wrap dates inside of double quotes (\").\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Connects to database and inserts a new user into the 'roles' table"},{"role":"assistant","content":"pgsql.connect:[my_connection|customers]\\n   pgsql.create\\n      table:roles\\n      values\\n         name:employee\\n         description:An employee at our Acme, Inc.\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Retrieve all records from the 'users' table"},{"role":"assistant","content":"pgsql.read\\n   table:users\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Update the email of the user with ID 1"},{"role":"assistant","content":"pgsql.update\\n   table:users\\n   where\\n      and\\n         id:int:1\\n   values\\n      email:new.email@example.com\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Delete the user with ID 1"},{"role":"assistant","content":"pgsql.delete\\n   table:users\\n   where\\n      and\\n         id.eq:int:1\\n\\n// Notice, the above where can be written as both \"id.eq\" or \"id\" since \"eq\" is the default comparison operators used if none is specified\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Execute a custom SQL SELECT statement"},{"role":"assistant","content":"pgsql.select:\"SELECT id, username FROM users WHERE role = 'admin'\"\\n\\n// Notice, since we're having ' characters in our string, we need to explicitly wrap the string into double quotes (\")\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Generate a cryptographically secure random string between 50 and 100 characters"},{"role":"assistant","content":"crypto.random\\n   min:50\\n   max:100\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Hash a message using SHA256 algorithm"},{"role":"assistant","content":"\\n// The message to hash\\n.message:Hello, World!\\n\\n// Hashing above message\\ncrypto.hash:x:@.message\\n   algorithm:sha256\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create a new RSA key pair"},{"role":"assistant","content":"crypto.rsa.create-key\\n   key-size:int:2048\\n\\n// Returns [private] being private key, [public] being public key, [fingerprint] and [fingerprint-raw] (bytes for fingerprint)\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create a new RSA key pair and encrypt a message using its public key"},{"role":"assistant","content":"crypto.rsa.create-key\\n   key-size:int:2048\\n\\n// Encrypt a message using RSA public key\\n.message\\n   content:Secret Message\\ncrypto.rsa.encrypt:x:@.message/*/content\\n   public-key:x:@crypto.rsa.create-key/*/public\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create a new RSA key pair and encrypt a message using its public key before finally decrypting it"},{"role":"assistant","content":"crypto.rsa.create-key\\n   key-size:int:2048\\n\\n// Encrypt a message using RSA public key\\n.message\\n   content:Secret Message\\ncrypto.rsa.encrypt:x:@.message/*/content\\n   public-key:x:@crypto.rsa.create-key/*/public\\n\\n// Decrypting message we encrypted above\\ncrypto.rsa.decrypt:x:-\\n   private-key:x:@crypto.rsa.create-key/*/private\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Encrypt a message using AES algorithm, for then to decrypt it"},{"role":"assistant","content":".message:This is a secret message\\ncrypto.aes.encrypt:x:-\\n   password:some-secret-password\\ncrypto.aes.decrypt:x:-\\n   password:some-secret-password\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create a Blowfish hashed password"},{"role":"assistant","content":"crypto.password.hash:YourPasswordHere\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Executes 'ls' terminal command and returns result as a string"},{"role":"assistant","content":"system.execute:ls\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Endpoint that takes any arguments, converts all arguments to integers, adds all together, and returns result\\n\\nPass in whatever arguments you wish."},{"role":"assistant","content":".arguments:*\\n.type:public\\n\\n// Adding all arguments\\n.result:int:0\\nfor-each:x:@.arguments/*\\n   set-value:x:@.result\\n      math.add:x:@.result\\n         convert:x:@.dp/#\\n            type:int\\n\\n// Returning result (notice, [yield] unwraps all its arguments)\\nyield\\n   result:x:@.result\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Changes the value of all nodes having a name of [foo]"},{"role":"assistant","content":".data\\n   foo\\n      bar\\n   hello\\n      howdy\\n         foo\\n      some-node\\n         some-other-node\\n            foo\\n\\n// ** expression yields ALL descendants\\nset-value:x:@.data/**/foo\\n   .:touched\\n\\n// After execution, all above nodes having the name of 'foo' will have their values changed\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Find all nodes having a name of 'foo', extract their values, and concatenates into string builder"},{"role":"assistant","content":".data\\n   foo:Hello\\n      bar\\n   hello\\n      howdy\\n         foo:\" world. \"\\n      some-node\\n         some-other-node\\n            foo:This is cool\\n\\n// Creating a string builder\\nstrings.builder\\n\\n   // Looping through all nodes from above with a name of 'foo'\\n   for-each:x:@.data/**/foo\\n\\n      // Appending to current string builder (created above)\\n      strings.builder.append:x:@.dp/#\\n\\n// After execution, the above [strings.builder] node's value will be \"Hello world. This is cool\"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Updates SQLIte's table1, setting field1 to 'howdy' with filtering on field2 and field3"},{"role":"assistant","content":"sqlite.update\\n   table:table1\\n   values\\n      field1:howdy\\n   where\\n\\n      // [where] node MUST have either [and] or [or] child, which becomes the logical operator to filter on\\n      and\\n\\n         // more than comparison\\n         field2.mt:someValue\\n\\n         // Less than or equal to comparison\\n         field3.lte:someValue\\n\\n// Notice, before executing [sqlite.update] you must have an open database connection using [data.connect].\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Hash the specified data using SHA512, returning result as string"},{"role":"assistant","content":"crypto.hash.sha512:whatever data to hash\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"CRUD endpoint that counts items from your Categories table in your northwind database"},{"role":"assistant","content":".arguments\\n   Categories.CategoryID.eq:long\\n   Categories.CategoryName.like:string\\n   Categories.CategoryName.eq:string\\n   Categories.Description.like:string\\n   Categories.Description.eq:string\\n   Categories.Picture.like:string\\n   Categories.Picture.eq:string\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-count\\n\\n// Opening up our database connection.\\ndata.connect:[generic|northwind]\\n   database-type:sqlite\\n   add:x:+/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:sqlite\\n      table:Categories\\n      columns\\n         count(*)\\n            as:count\\n      where\\n         and\\n      limit:long:1\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"CRUD endpoint that deletes one record from your Categories table in your northwind database"},{"role":"assistant","content":".arguments\\n\\n   // Primary key of record to delete, mandatory argument\\n   CategoryID:long\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-delete\\nvalidators.mandatory:x:@.arguments/*/CategoryID\\n\\n// Opening up our database connection.\\ndata.connect:[generic|northwind]\\n   database-type:sqlite\\n\\n   // Parametrising our delete invocation.\\n   add:x:./*/data.delete/*/where/*/and\\n      get-nodes:x:@.arguments/*\\n\\n   // Deleting item from database.\\n   data.delete\\n      database-type:sqlite\\n      table:Categories\\n      where\\n         and\\n\\n   // Returning result of above invocation to caller.\\n   unwrap:x:+/*\\n   return\\n      affected:x:@data.delete\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"CRUD endpoint that creates one record in your Categories table in your northwind database"},{"role":"assistant","content":".arguments\\n\\n   // CategoryName column value\\n   CategoryName:string\\n\\n   // Description column value\\n   Description:string\\n\\n   // Picture column value\\n   Picture:string\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-create\\n\\n// Columns with custom handling as we generate a frontend\\n.handling\\n   Picture:image\\n\\n// Opening up database connection.\\ndata.connect:[generic|northwind]\\n   database-type:sqlite\\n\\n   // Parametrising our create invocation.\\n   add:x:./*/data.create/*/values\\n      get-nodes:x:@.arguments/*\\n\\n   // Creating our record.\\n   data.create\\n      database-type:sqlite\\n      table:Categories\\n      return-id:bool:true\\n      values\\n\\n   // Returning the correct status code.\\n   response.status.set:201\\n\\n   // Returning result of above invocation to caller.\\n   unwrap:x:+/*\\n   return\\n      id:x:@data.create\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"CRUD endpoint that updates one record in your Categories table in your northwind database"},{"role":"assistant","content":".arguments\\n\\n   // CategoryID column value being primary key of record to update, mandatory argument\\n   CategoryID:long\\n\\n   // CategoryName column's new value\\n   CategoryName:string\\n\\n   // Description column's new value\\n   Description:string\\n\\n   // Picture column's new value\\n   Picture:string\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-update\\n\\n// Columns with custom handling as we generate a frontend\\n.handling\\n   Picture:image\\n\\n// Sanity checking invocation, making sure primary key(s) are specified.\\nvalidators.mandatory:x:@.arguments/*/CategoryID\\n\\n// Opening up our database connection.\\ndata.connect:[generic|northwind]\\n   database-type:sqlite\\n\\n   // Parametrising our invocation.\\n   add:x:./*/data.update/*/values\\n      get-nodes:x:@.arguments/*/[1,1000]\\n   add:x:./*/data.update/*/where/*/and\\n      get-nodes:x:@.arguments/*/[0,1]\\n\\n   // Invoking our update slot.\\n   data.update\\n      database-type:sqlite\\n      table:Categories\\n      values\\n      where\\n         and\\n\\n   // Verifying record exists.\\n   if\\n      eq\\n         get-value:x:@data.update\\n         .:int:0\\n      .lambda\\n         response.status.set:404\\n         return\\n            result:Record not found\\n\\n   // Returning the correct status code.\\n   response.status.set:202\\n\\n   // Returning success to caller.\\n   unwrap:x:+/*\\n   return\\n      affected:x:@data.update\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create a Hyperlambda endpoint taking age and name, concatenates these, and returns the result with a greeting."},{"role":"assistant","content":".arguments\\n   name:string\\n   age:int\\nstrings.concat\\n   .:\"Hello \"\\n   get-value:x:@.arguments/*/name\\n   .:\", you are \"\\n   get-value:x:@.arguments/*/age\\n   .:\" years old\"\\nyield\\n   result:x:@strings.concat\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Creates a Hyperlambda endpoint to fetch all records from the 'item' table in the erp database."},{"role":"assistant","content":".arguments\\n\\n// Making sure the endpoint is publicly visible\\n.type:public\\ndata.connect:erp\\n\\n   // Selecting data.\\n   data.select:select * from item\\n\\n   // Returning results to caller.\\n   yield\\n      rows:x:@data.select/*\\n\\n// Save this code as for instance '/modules/erp/item.get.hl'\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"I've got a list of nodes in an existing list of nodes in [.data], please join all values and use ', ' as separator"},{"role":"assistant","content":"strings.join:x:@.data/*\\n   .:\", \"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create a CRUD endpoint returning employees from DBCustomers database. My database is SQLite"},{"role":"assistant","content":".arguments\\n.type:crud-read\\ndata.connect:DBCustomers\\n   database-type:sqlite\\n   data.read\\n      database-type:sqlite\\n      table:employees\\n   yield\\n      records:x:@data.read/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Generate an endpoint returning line_items from financial database. Add optional paging support and optional filtering on name"},{"role":"assistant","content":".arguments\\n   limit:long\\n   offset:long\\n   comments.name.eq:string\\n\\n// Type of endpoint\\n.type:crud-read\\n\\n// Opening up our database connection.\\ndata.connect:financial\\n\\n   // Parametrising our read invocation with filtering arguments.\\n   add:x:./*/data.read/*/where/*/and\\n      get-nodes:x:@.arguments/*/comments.name.eq\\n   add:x:./*/data.read\\n      get-nodes:x:@.arguments/*/limit\\n      get-nodes:x:@.arguments/*/offset\\n   data.read\\n      table:line_items\\n      where\\n         and\\n\\n   // Returning result of above read invocation to caller.\\n   yield\\n      result:x:@data.read/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create a slot that calculates fibonacci series up until 100"},{"role":"assistant","content":"slots.create:calculate_fibonacci_below_100\\n   .fibonacci_return\\n   .a:int:0\\n   .b:int:1\\n   while\\n      lt\\n         get-value:x:@.b\\n         .:int:100\\n      .lambda\\n\\n         // Compute next Fibonacci number\\n         .next.int\\n         set-value:x:@.next.int\\n            math.add\\n               get-value:x:@.a\\n               get-value:x:@.b\\n         if\\n            lt\\n               get-value:x:@.b\\n               .:int:100\\n            .lambda\\n               unwrap:x:+/*/*\\n               add:x:../*/.fibonacci_return\\n                  .\\n                     .:x:@.next.int\\n         set-value:x:@.a\\n            get-value:x:@.b\\n         set-value:x:@.b\\n            get-value:x:@.next.int\\n   yield\\n      numbers:x:@.fibonacci_return/*\\n\\n// To execute slot ==> execute:calculate_fibonacci_below_100\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"How do I find all nodes with the names being 'howdy' inside [.data] and join these with '|' separator?"},{"role":"assistant","content":".data\\n   howdy:Hello\\n   howdy:Howdy World\\n   greetings:Howdy partner\\n   phrases:Hi there\\nstrings.join:x:@.data/*/howdy\\n   .:|\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"What are lambda expressions?"},{"role":"assistant","content":"\\n/*\\n * Lambda expressions in Hyperlambda are used to reference any node within the currently executing graph object.\\n * They allow for dynamic access to nodes, enabling you to express relationships and hierarchies in the nodes effectively.\\n * They are similar to XPath expressions found in other technologies.\\n */\\n\\n// Example of a simple lambda expression referencing the [.person] node.\\n.person:John\\nset-value:x:@.person\\n   .:Jane\\n\\n// In this case, @.person is a lambda expression that points to the .person node, and the [set-value] slot changes its value.\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"How can I retrieve [foo]'s value when I have the following [.data] data segment?"},{"role":"assistant","content":".data\\n   node1\\n      node2\\n         node3\\n            foo:howdy\\nget-value:x:@.data/*/node1/*/node2/*/node3/*/foo\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Update the [foo] node's value to 'hello'"},{"role":"assistant","content":".data\\n   n1\\n      n2\\n         n3\\n            foo:howdy\\nset-value:x:@.data/*/n1/*/n2/*/n3/*/foo\\n   .:hello\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create Hyperlambda that sends an email to peter@microsoft.com informing him I'll be late for our meeting"},{"role":"assistant","content":"mail.smtp.send\\n   message\\n      to\\n         .\\n            name:Peter\\n            email:peter@microsoft.com\\n      subject:I will be late\\n      entity:text/plain\\n         content:Sorry Peter, but I will be late to our meeting\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"I need a Hyperlambda file that takes 5 arguments, being 5 emails. I want to send emails to all of these."},{"role":"assistant","content":".arguments\\n   email1:string\\n   email2:string\\n   email3:string\\n   email4:string\\n   email5:string\\nfor-each:x:@.arguments/*\\n\\n   // Unwrapping all expressions inside [mail.smtp.send]. This will unwrap [email] below\\n   unwrap:x:+/**\\n   mail.smtp.send\\n      message\\n         to\\n            .\\n               email:x:@.dp/#\\n         subject:Your subject here\\n         entity:text/plain\\n            content:Your body here\\nreturn\\n   result:OK\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"I want to create a log item for every 'content' row found in my 'system' database and its 'log_records' table"},{"role":"assistant","content":"data.connect:system\\n   data.read\\n      table:log_records\\n      columns\\n         content\\n   for-each:x:@data.select/*/*/content\\n      log.info:x:@.dp/#\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"I want to update my database and append \" - OBSOLETE\" for every 'content' column found in my 'system' database and its 'log_records' table. Primary key is 'id'. Do it manually, once for each record. Don't update all rows with one SQL."},{"role":"assistant","content":"data.connect:system\\n   data.read\\n      table:log_records\\n      columns\\n         id\\n         content\\n   for-each:x:@data.select/*\\n      strings.concat\\n         get-value:x:@.dp/#/*/content\\n         .:\" - OBSOLETE\"\\n      data.update\\n         table:log_records\\n         values\\n            content:x:@strings.concat\\n         where\\n            and\\n               id:x:@.dp/#/*/id\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create a scheduled task that logs \"Task was here\" that is scheduled to repeat once every 5 seconds"},{"role":"assistant","content":"tasks.create:log-task\\n   repeats:5.seconds\\n   .lambda\\n      log.info:Task was here\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Execute the task named 'create-backup'"},{"role":"assistant","content":"tasks.execute:create-backup\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Traverse node hierarchy and look for nodes with a name starting with 'n'. Then change their values to 'visited'."},{"role":"assistant","content":".result\\n.data\\n   n1:howdy\\n      n2:nope!\\n   some-node-1\\n      n3:\" world\"\\n         is-not-considered\\n\\n            // Considered since it starts with 'n' character\\n            nanna:\". \"\\n            n4:old-value\\nfor-each:x:@.data/**\\n   get-name:x:@.dp/#\\n   if\\n      strings.starts-with:x:@get-name\\n         .:n\\n      .lambda\\n         set-value:x:@.dp/#\\n            .:visited\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Exchange name with value, and value with name, in all nodes, for the following [.data] segment"},{"role":"assistant","content":".data\\n   n1:v1\\n      n2:v2\\n   n3:v3\\n      n4:v4\\n         n5:v5\\n   n6:v6\\nfor-each:x:@.data/**\\n   get-name:x:@.dp/#\\n   set-name:x:@.dp/#\\n      get-value:x:@.dp/#\\n   set-value:x:@.dp/#\\n      get-value:x:@get-name\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Show me Hyperlambda that lists all files from '/modules/chinook/', check if they're Hyperlambda files, and if yes, adds the file path to a [.result] node"},{"role":"assistant","content":".result\\nio.file.list:/modules/chinook/\\nfor-each:x:@io.file.list/*\\n   if\\n      strings.ends-with:x:@.dp/#\\n         .:.hl\\n      .lambda\\n         unwrap:x:+/*/*\\n         add:x:@.result\\n            .\\n               .:x:@.dp/#\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Generate Hyperlambda endpoint that returns a specified file to caller as raw text. If the file doesn't exist it should throw a 404 exception."},{"role":"assistant","content":".arguments\\n   file:string\\nif\\n   not\\n      io.file.exists:x:@.arguments/*/file\\n   .lambda\\n      throw:File not found\\n         status:int:404\\n         public:bool:true\\nio.file.load:x:@.arguments/*/file\\nresponse.headers.set\\n   Content-Type:text/plain\\nreturn-value:x:@io.file.load\\n\\n// Save this file for instance as '/modules/YOUR_MODULE/load-file.get.hl', and pass in file as a QUERY parameter\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Show me Hyperlambda endpoint that returns true if a file specified as an argument exists on the server."},{"role":"assistant","content":".arguments\\n   file:string\\nio.file.exists:x:@.arguments/*/file\\nyield\\n   exists:x:@io.file.exists\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create Hyperlambda file that returns true if a file specified as an argument exists on the server."},{"role":"assistant","content":".arguments\\n   file:string\\n   query:string\\nio.file.load:x:@.arguments/*/file\\nif\\n   strings.contains:x:@io.file.load\\n      .:x:@.arguments/*/query\\n   .lambda\\n      return\\n         result:bool:true\\nreturn\\n   result:bool:false\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create an endpoint taking a name argument, check the name, if it's 'Thomas' then return 'Hello boss', otherwise return 'Hello stranger'."},{"role":"assistant","content":".arguments\\n   name:string\\nif\\n   eq:x:@.arguments/*/name\\n      .:Thomas\\n   .lambda\\n      return\\n         result:Hello boss\\nreturn\\n   result:Hello stranger\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create an endpoint that check if the user is a grown up"},{"role":"assistant","content":".arguments\\n   age:int\\nif\\n   mt:x:@.arguments/*/age\\n      .:int:17\\n   .lambda\\n      return\\n         is_grownup:bool:true\\nreturn\\n   is_grownup:bool:false\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Hyperlambda file that takes a lambda objects as an argument, and exceutes the lambda object from within the file, once for each role that exists in the system."},{"role":"assistant","content":".arguments\\n   .execute:*\\n\\n// Retrieving roles from magic database\\ndata.connect:magic\\n   data.read\\n      table:roles\\n\\n   // Iterating through each role, executing [.execute] lambda object once for each role.\\n   for-each:x:@data.read/*\\n      unwrap:x:+/*\\n      invoke:x:@.arguments/*/.execute\\n         role:x:@.dp/#/*/name\\n\\n/*\\n * To execute the file, you can use something such as follows:\\n * \\n * io.file.execute:/modules/slett/foo.get.hl\\n * .execute\\n * \\n * // You will be getting the role in as an argument from the above Hyperlambda file here.\\n * log.info:x:@.arguments/*/role\\n */\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Multiply two numbers given as arguments and return the result to caller"},{"role":"assistant","content":".arguments\\n   arg1:int\\n   arg2:int\\n\\n// Making sure arguments are actually passed in, throwing exceptions if not.\\nvalidators.mandatory:x:@.arguments/*/arg1\\nvalidators.mandatory:x:@.arguments/*/arg2\\n\\n// Multiplication.\\nmath.multiply\\n   get-value:x:@.arguments/*/arg1\\n   get-value:x:@.arguments/*/arg2\\n\\n// Returning result to caller\\nyield\\n   result:x:@math.multiply\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Hyperlambda endpoint that connects to the specified database and returns all records from specified table."},{"role":"assistant","content":".arguments\\n   database:string\\n   table:string\\n\\n// Making sure argument was given\\nvalidators.mandatory:x:@.arguments/*/database\\nvalidators.mandatory:x:@.arguments/*/table\\n\\n// Checking if 'xyz' exists in string\\ndata.connect:x:@.arguments/*/database\\n   data.read\\n      table:x:@.arguments/*/table\\n   yield\\n      rows:x:@data.read/*\\n\\n// Save file as for instance '/modules/foo/bar.get.hl' which creates an HTTP GET endpoint\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Hyperlambda file / endpoint that counts occurrencise for a Distinct Keyword Search from hyperlambda table in fine-tune database.\\n\\nThis endpoint will return the number of records containing one or more of the keywords from the specified [query]."},{"role":"assistant","content":".arguments\\n\\n   // Mandatory query for records to search for\\n   query:string\\n\\n// Type of endpoint\\n.type:crud-count\\n\\n// Make sure the user has provided a query.\\nvalidators.mandatory:x:@.arguments/*/query\\n\\n// Split the user's query into individual keywords, separated by spaces.\\n.words\\nadd:x:@.words\\n   strings.split:x:@.arguments/*/query\\n      .:\" \"\\n\\n// Enforce lower characters for each keyword, and guard against SQL injection.\\n.no:int:0\\nfor-each:x:@.words/*\\n   set-value:x:@.dp/#\\n      strings.to-lower:x:@.dp/#\\n\\n// Specify which columns to search against.\\n.columns\\n   .:code\\n   .:prompt\\n\\n// Connect to the specified database.\\ndata.connect:[generic|fine-tune]\\n   database-type:sqlite\\n\\n   // Start building our SQL.\\n   .sql:select count(*) as count, (\\n\\n   // Dynamically create the full text by concatenating all columns we want to search.\\n   .fields\\n   for-each:x:@.columns/*\\n      strings.concat\\n         .:coalesce(\\n         get-value:x:@.dp/#\\n         .:\", '')\"\\n      unwrap:x:+/*/*\\n      add:x:@.fields\\n         .\\n            .:x:@strings.concat\\n   set-value:x:@.fields\\n      strings.join:x:@.fields/*\\n         .:\" || \"\\n   remove-nodes:x:@.fields/*\\n\\n   // Keyword density calculation\\n   .no:int:0\\n   for-each:x:@.words/*\\n\\n      // Adding SQL parameter.\\n      set-name:x:+/+/*/*\\n         strings.concat\\n            .:@p\\n            get-value:x:@.no\\n      unwrap:x:+/*/*\\n      add:x:@data.connect/*/data.select\\n         .\\n            .:x:@.dp/#\\n\\n      // Modifying our SQL.\\n      if\\n         eq:x:@.no\\n            .:int:0\\n         .lambda\\n\\n            // First keyword => no leading plus\\n            set-value:x:@.sql\\n               strings.concat:x:@.sql\\n                  get-value:x:@.sql\\n                  .:\" (length(\"\\n                  get-value:x:@.fields\\n                  .:) - length(replace(lower(\\n                  get-value:x:@.fields\\n                  .:), @p\\n                  get-value:x:@.no\\n                  .:\", ''))) / length(@p\"\\n                  get-value:x:@.no\\n                  .:)\\n      else\\n         set-value:x:@.sql\\n            strings.concat:x:@.sql\\n               get-value:x:@.sql\\n               .:\" + (length(\"\\n               get-value:x:@.fields\\n               .:) - length(replace(lower(\\n               get-value:x:@.fields\\n               .:), @p\\n               get-value:x:@.no\\n               .:\", ''))) / length(@p\"\\n               get-value:x:@.no\\n               .:)\\n      math.increment:x:@.no\\n   set-value:x:@.sql\\n      strings.concat:x:@.sql\\n         get-value:x:@.sql\\n         .:) * 1.0 / length(\\n         get-value:x:@.fields\\n         .:) as keyword_density, (\\n\\n   // Distinct keyword count => For each keyword, 1 if present, 0 if not.\\n   .no:int:0\\n   for-each:x:@.words/*\\n      if\\n         eq:x:@.no\\n            .:int:0\\n         .lambda\\n\\n            // First keyword => no leading plus\\n            set-value:x:@.sql\\n               strings.concat:x:@.sql\\n                  get-value:x:@.sql\\n                  .:\" CASE WHEN ((length(\"\\n                  get-value:x:@.fields\\n                  .:) - length(replace(lower(\\n                  get-value:x:@.fields\\n                  .:), @p\\n                  get-value:x:@.no\\n                  .:\", ''))) / length(@p\"\\n                  get-value:x:@.no\\n                  .:)) > 0 THEN 1 ELSE 0 END\\n      else\\n         set-value:x:@.sql\\n            strings.concat:x:@.sql\\n               get-value:x:@.sql\\n               .:\" + CASE WHEN ((length(\"\\n               get-value:x:@.fields\\n               .:) - length(replace(lower(\\n               get-value:x:@.fields\\n               .:), @p\\n               get-value:x:@.no\\n               .:\", ''))) / length(@p\"\\n               get-value:x:@.no\\n               .:)) > 0 THEN 1 ELSE 0 END\\n      math.increment:x:@.no\\n\\n   // Finalize \"keyword_count\".\\n   set-value:x:@.sql\\n      strings.concat:x:@.sql\\n         get-value:x:@.sql\\n         .:) as keyword_count\\n\\n   // Finish SELECT + WHERE\\n   set-value:x:@.sql\\n      strings.concat:x:@.sql\\n         get-value:x:@.sql\\n         .:\" from \"\\n         .:hyperlambda\\n         .:\" where keyword_count > 0\"\\n\\n   // Execute the SQL\\n   data.select:x:@.sql\\n      database-type:sqlite\\n\\n   // Remove helper fields if you don't want them in your final JSON\\n   remove-nodes:x:@data.select/*/*/keyword_density\\n   remove-nodes:x:@data.select/*/*/keyword_count\\n\\n   // Return the final result set\\n   return-nodes:x:@data.select/*/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Distinct Keyword Search from hyperlambda table in fine-tune database.\\n\\nThis endpoint will return only records containing one or more of the keywords from the specified [query],\\nsorting such that the best match is returned first.\\n\\nOptionally page your result sets with [limit] and [offset]."},{"role":"assistant","content":".arguments\\n\\n   // Mandatory query for records to search for\\n   query:string\\n\\n   // Optional number of records to return, defaults to 10 if not specified. Pass in -1 to return all records\\n   limit:long\\n\\n   // Optional offset into the dataset of where to start retrieving records\\n   offset:long\\n\\n// Type of endpoint\\n.type:crud-search\\n\\n// Make sure the user has provided a query.\\nvalidators.mandatory:x:@.arguments/*/query\\n\\n// Apply defaults if not specified.\\nvalidators.default:x:@.arguments\\n   limit:long:10\\n\\n// Split the user's query into individual keywords, separated by spaces.\\n.words\\nadd:x:@.words\\n   strings.split:x:@.arguments/*/query\\n      .:\" \"\\n\\n// Enforce lower characters for each keyword, and guard against SQL injection.\\n.no:int:0\\nfor-each:x:@.words/*\\n   set-value:x:@.dp/#\\n      strings.to-lower:x:@.dp/#\\n\\n// Specify which columns to search against.\\n.columns\\n   .:code\\n   .:prompt\\n\\n// Connect to the specified database.\\ndata.connect:[generic|fine-tune]\\n   database-type:sqlite\\n\\n   // Start building our SQL.\\n   .sql:select *, (\\n\\n   // 1) Dynamically create the full text by concatenating all columns we want to search.\\n   .fields\\n   for-each:x:@.columns/*\\n      strings.concat\\n         .:coalesce(\\n         get-value:x:@.dp/#\\n         .:\", '')\"\\n      unwrap:x:+/*/*\\n      add:x:@.fields\\n         .\\n            .:x:@strings.concat\\n   set-value:x:@.fields\\n      strings.join:x:@.fields/*\\n         .:\" || \"\\n   remove-nodes:x:@.fields/*\\n\\n   // 2) Keyword density calculation\\n   .no:int:0\\n   for-each:x:@.words/*\\n\\n      // Adding SQL parameter.\\n      set-name:x:+/+/*/*\\n         strings.concat\\n            .:@p\\n            get-value:x:@.no\\n      unwrap:x:+/*/*\\n      add:x:@data.connect/*/data.select\\n         .\\n            .:x:@.dp/#\\n\\n      // Modifying our SQL.\\n      if\\n         eq:x:@.no\\n            .:int:0\\n         .lambda\\n\\n            // First keyword => no leading plus\\n            set-value:x:@.sql\\n               strings.concat:x:@.sql\\n                  get-value:x:@.sql\\n                  .:\" (length(\"\\n                  get-value:x:@.fields\\n                  .:) - length(replace(lower(\\n                  get-value:x:@.fields\\n                  .:), @p\\n                  get-value:x:@.no\\n                  .:\", ''))) / length(@p\"\\n                  get-value:x:@.no\\n                  .:)\\n      else\\n         set-value:x:@.sql\\n            strings.concat:x:@.sql\\n               get-value:x:@.sql\\n               .:\" + (length(\"\\n               get-value:x:@.fields\\n               .:) - length(replace(lower(\\n               get-value:x:@.fields\\n               .:), @p\\n               get-value:x:@.no\\n               .:\", ''))) / length(@p\"\\n               get-value:x:@.no\\n               .:)\\n      math.increment:x:@.no\\n   set-value:x:@.sql\\n      strings.concat:x:@.sql\\n         get-value:x:@.sql\\n         .:) * 1.0 / length(\\n         get-value:x:@.fields\\n         .:) as keyword_density, (\\n\\n   // 3) Distinct keyword count => For each keyword, 1 if present, 0 if not.\\n   .no:int:0\\n   for-each:x:@.words/*\\n      if\\n         eq:x:@.no\\n            .:int:0\\n         .lambda\\n\\n            // First keyword => no leading plus\\n            set-value:x:@.sql\\n               strings.concat:x:@.sql\\n                  get-value:x:@.sql\\n                  .:\" CASE WHEN ((length(\"\\n                  get-value:x:@.fields\\n                  .:) - length(replace(lower(\\n                  get-value:x:@.fields\\n                  .:), @p\\n                  get-value:x:@.no\\n                  .:\", ''))) / length(@p\"\\n                  get-value:x:@.no\\n                  .:)) > 0 THEN 1 ELSE 0 END\\n      else\\n         set-value:x:@.sql\\n            strings.concat:x:@.sql\\n               get-value:x:@.sql\\n               .:\" + CASE WHEN ((length(\"\\n               get-value:x:@.fields\\n               .:) - length(replace(lower(\\n               get-value:x:@.fields\\n               .:), @p\\n               get-value:x:@.no\\n               .:\", ''))) / length(@p\"\\n               get-value:x:@.no\\n               .:)) > 0 THEN 1 ELSE 0 END\\n      math.increment:x:@.no\\n\\n   // Finalize \"keyword_count\".\\n   set-value:x:@.sql\\n      strings.concat:x:@.sql\\n         get-value:x:@.sql\\n         .:) as keyword_count\\n\\n   // 4) Finish SELECT + WHERE\\n   set-value:x:@.sql\\n      strings.concat:x:@.sql\\n         get-value:x:@.sql\\n         .:\" from \"\\n         .:hyperlambda\\n         .:\" where keyword_count > 0\"\\n\\n   // 5) Order by distinct keyword_count (higher means more distinct keywords), then keyword_density.\\n   set-value:x:@.sql\\n      strings.concat:x:@.sql\\n         get-value:x:@.sql\\n         .:\" order by keyword_count desc, keyword_density desc limit \"\\n         get-value:x:@.arguments/*/limit\\n\\n   // (Optional) offset => pagination\\n   if\\n      exists:x:@.arguments/*/offset\\n      .lambda\\n         set-value:x:@.sql\\n            strings.concat:x:@.sql\\n               get-value:x:@.sql\\n               .:\" offset \"\\n               get-value:x:@.arguments/*/offset\\n\\n   // Execute the SQL\\n   data.select:x:@.sql\\n      database-type:sqlite\\n\\n   // Remove helper fields if you don't want them in your final JSON\\n   remove-nodes:x:@data.select/*/*/keyword_density\\n   remove-nodes:x:@data.select/*/*/keyword_count\\n\\n   // Return the final result set\\n   return-nodes:x:@data.select/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns minimum, maximum, average or sum from your actor table in your sakila database with authorization and verbose filtering"},{"role":"assistant","content":".arguments\\n\\n   // Function to aggregate upon. Argument is mandatory and legal values are min, max, sum or avg\\n   aggregate_function:string\\n\\n   // Argument is mandatory and must be in the format of TABLE_NAME.COLUMN_NAME.\\n   aggregate_column:string\\n\\n   // Optional logical operator for filtering arguments, can be either 'or' or 'and'. Defaults to and.\\n   operator:string\\n   actor.actor_id.mt:long\\n   actor.actor_id.lt:long\\n   actor.actor_id.mteq:long\\n   actor.actor_id.lteq:long\\n   actor.actor_id.neq:long\\n   actor.actor_id.eq:long\\n   actor.first_name.like:string\\n   actor.first_name.mt:string\\n   actor.first_name.lt:string\\n   actor.first_name.mteq:string\\n   actor.first_name.lteq:string\\n   actor.first_name.neq:string\\n   actor.first_name.eq:string\\n   actor.last_name.like:string\\n   actor.last_name.mt:string\\n   actor.last_name.lt:string\\n   actor.last_name.mteq:string\\n   actor.last_name.lteq:string\\n   actor.last_name.neq:string\\n   actor.last_name.eq:string\\n   actor.last_update.mt:date\\n   actor.last_update.lt:date\\n   actor.last_update.mteq:date\\n   actor.last_update.lteq:date\\n   actor.last_update.neq:date\\n   actor.last_update.eq:date\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-aggregate\\n\\n// Sanity checking mandatory arguments.\\nvalidators.mandatory:x:@.arguments/*/aggregate_function\\nvalidators.mandatory:x:@.arguments/*/aggregate_column\\n\\n// Sanity checking name of aggregate function.\\nvalidators.enum:x:@.arguments/*/aggregate_function\\n   .:min\\n   .:max\\n   .:sum\\n   .:avg\\n\\n// Sanity checking agggregate column name.\\nvalidators.enum:x:@.arguments/*/aggregate_column\\n   .:actor.actor_id\\n   .:actor.first_name\\n   .:actor.last_name\\n   .:actor.last_update\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root,admin\\n\\n// Sanity checking invocation.\\nvalidators.enum:x:@.arguments/*/operator\\n   .:or\\n   .:and\\n\\n/*\\n * Checking if user supplied an [operator] argument, and if so\\n * changing the boolean operator for comparison operations.\\n */\\nif\\n   exists:x:@.arguments/*/operator\\n   .lambda\\n\\n      // User provided a boolean comparison [operator] argument.\\n      set-name:x:../*/data.connect/*/data.read/*/where/0\\n         get-value:x:@.arguments/*/operator\\n      remove-nodes:x:@.arguments/*/operator\\n\\n// Opening up our database connection.\\ndata.connect:[generic|sakila]\\n   database-type:sqlite\\n\\n   // Making sure we're using correct aggregate function.\\n   set-name:x:./*/data.read/*/columns/*/aggregate_functor\\n      strings.concat\\n         get-value:x:@.arguments/*/aggregate_function\\n         .:(\\n         get-value:x:@.arguments/*/aggregate_column\\n         .:)\\n\\n   // Removing aggregate arguments to simplify adding other arguments.\\n   remove-nodes:x:@.arguments/*/[0,2]\\n\\n   // Adding filtering arguments.\\n   add:x:+/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:sqlite\\n      table:actor\\n      columns\\n         aggregate_functor\\n            as:result\\n      where\\n         and\\n      limit:long:1\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Count unique and distinct items from your actor table in your sakila database with authorization and verbose filtering"},{"role":"assistant","content":".arguments\\n\\n   // Argument is mandatory and must be in the format of TABLE_NAME.COLUMN_NAME\\n   distinct_column:string\\n\\n   // Optional logical operator for filtering arguments, can be either 'or' or 'and'. Defaults to and.\\n   operator:string\\n   actor.actor_id.mt:long\\n   actor.actor_id.lt:long\\n   actor.actor_id.mteq:long\\n   actor.actor_id.lteq:long\\n   actor.actor_id.neq:long\\n   actor.actor_id.eq:long\\n   actor.first_name.like:string\\n   actor.first_name.mt:string\\n   actor.first_name.lt:string\\n   actor.first_name.mteq:string\\n   actor.first_name.lteq:string\\n   actor.first_name.neq:string\\n   actor.first_name.eq:string\\n   actor.last_name.like:string\\n   actor.last_name.mt:string\\n   actor.last_name.lt:string\\n   actor.last_name.mteq:string\\n   actor.last_name.lteq:string\\n   actor.last_name.neq:string\\n   actor.last_name.eq:string\\n   actor.last_update.mt:date\\n   actor.last_update.lt:date\\n   actor.last_update.mteq:date\\n   actor.last_update.lteq:date\\n   actor.last_update.neq:date\\n   actor.last_update.eq:date\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-count-distinct\\n\\n// Sanity checking that distinct column was passed in.\\nvalidators.mandatory:x:@.arguments/*/distinct_column\\n\\n// Sanity checking distinct column's name.\\nvalidators.enum:x:@.arguments/*/distinct_column\\n   .:actor.actor_id\\n   .:actor.first_name\\n   .:actor.last_name\\n   .:actor.last_update\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root,admin\\n\\n// Sanity checking invocation.\\nvalidators.enum:x:@.arguments/*/operator\\n   .:or\\n   .:and\\n\\n/*\\n * Checking if user supplied an [operator] argument, and if so\\n * changing the boolean operator for comparison operations.\\n */\\nif\\n   exists:x:@.arguments/*/operator\\n   .lambda\\n\\n      // User provided a boolean comparison [operator] argument.\\n      set-name:x:../*/data.connect/*/data.read/*/where/0\\n         get-value:x:@.arguments/*/operator\\n      remove-nodes:x:@.arguments/*/operator\\n\\n// Opening up our database connection.\\ndata.connect:[generic|sakila]\\n   database-type:sqlite\\n\\n   // Making sure we're using correct function.\\n   set-name:x:./*/data.read/*/columns/*/distinct_functor\\n      strings.concat\\n         .:\"count(distinct \"\\n         get-value:x:@.arguments/*/distinct_column\\n         .:)\\n\\n   // Removing distinct argument to simplify adding other arguments.\\n   remove-nodes:x:@.arguments/*/distinct_column\\n\\n   // Adding filtering arguments.\\n   add:x:+/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:sqlite\\n      table:actor\\n      columns\\n         distinct_functor\\n            as:count\\n      where\\n         and\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Counts items from your actor table in your sakila database with authorization and verbose filtering"},{"role":"assistant","content":".arguments\\n\\n   // Optional logical operator for filtering arguments, can be either 'or' or 'and'. Defaults to and.\\n   operator:string\\n   actor.actor_id.mt:long\\n   actor.actor_id.lt:long\\n   actor.actor_id.mteq:long\\n   actor.actor_id.lteq:long\\n   actor.actor_id.neq:long\\n   actor.actor_id.eq:long\\n   actor.first_name.like:string\\n   actor.first_name.mt:string\\n   actor.first_name.lt:string\\n   actor.first_name.mteq:string\\n   actor.first_name.lteq:string\\n   actor.first_name.neq:string\\n   actor.first_name.eq:string\\n   actor.last_name.like:string\\n   actor.last_name.mt:string\\n   actor.last_name.lt:string\\n   actor.last_name.mteq:string\\n   actor.last_name.lteq:string\\n   actor.last_name.neq:string\\n   actor.last_name.eq:string\\n   actor.last_update.mt:date\\n   actor.last_update.lt:date\\n   actor.last_update.mteq:date\\n   actor.last_update.lteq:date\\n   actor.last_update.neq:date\\n   actor.last_update.eq:date\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-count\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root,admin\\n\\n// Sanity checking invocation.\\nvalidators.enum:x:@.arguments/*/operator\\n   .:or\\n   .:and\\n\\n/*\\n * Checking if user supplied an [operator] argument, and if so\\n * changing the boolean operator for comparison operations.\\n */\\nif\\n   exists:x:@.arguments/*/operator\\n   .lambda\\n\\n      // User provided a boolean comparison [operator] argument.\\n      set-name:x:../*/data.connect/*/data.read/*/where/0\\n         get-value:x:@.arguments/*/operator\\n      remove-nodes:x:@.arguments/*/operator\\n\\n// Opening up our database connection.\\ndata.connect:[generic|sakila]\\n   database-type:sqlite\\n\\n   // Adding filtering arguments.\\n   add:x:+/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:sqlite\\n      table:actor\\n      columns\\n         count(*)\\n            as:count\\n      where\\n         and\\n      limit:long:1\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns unique and distinct values from your actor table in your sakila database with authorization and verbose filtering"},{"role":"assistant","content":".arguments\\n\\n   // Name of column to return unique and distinct values for. Argument is mandatory and must be in the format of TABLE_NAME.COLUMN_NAME\\n   distinct_column:string\\n\\n   // Number of records to return, defaults to 25 if not specified. Pass in -1 to return all records.\\n   limit:long\\n\\n   // Offset into the dataset of where to start retrieving records\\n   offset:long\\n\\n   // Fully qualified name of column to order by, must be in TABLE_NAME.COLUMN_NAME format\\n   order:string\\n\\n   // What direction to order, can be 'asc' or 'desc' implying ascending and descending\\n   direction:string\\n\\n   // Optional logical operator for filtering arguments, can be either 'or' or 'and'. Defaults to and.\\n   operator:string\\n   actor.actor_id.mt:long\\n   actor.actor_id.lt:long\\n   actor.actor_id.mteq:long\\n   actor.actor_id.lteq:long\\n   actor.actor_id.neq:long\\n   actor.actor_id.eq:long\\n   actor.first_name.like:string\\n   actor.first_name.mt:string\\n   actor.first_name.lt:string\\n   actor.first_name.mteq:string\\n   actor.first_name.lteq:string\\n   actor.first_name.neq:string\\n   actor.first_name.eq:string\\n   actor.last_name.like:string\\n   actor.last_name.mt:string\\n   actor.last_name.lt:string\\n   actor.last_name.mteq:string\\n   actor.last_name.lteq:string\\n   actor.last_name.neq:string\\n   actor.last_name.eq:string\\n   actor.last_update.mt:date\\n   actor.last_update.lt:date\\n   actor.last_update.mteq:date\\n   actor.last_update.lteq:date\\n   actor.last_update.neq:date\\n   actor.last_update.eq:date\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-distinct\\n\\n// Sanity checking that distinct column was passed in.\\nvalidators.mandatory:x:@.arguments/*/distinct_column\\n\\n// Sanity checking distinct column's name.\\nvalidators.enum:x:@.arguments/*/distinct_column\\n   .:actor.actor_id\\n   .:actor.first_name\\n   .:actor.last_name\\n   .:actor.last_update\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root,admin\\n\\n// Sanity checking invocation.\\nvalidators.enum:x:@.arguments/*/operator\\n   .:or\\n   .:and\\n\\n/*\\n * Checking if user supplied an [operator] argument, and if so\\n * changing the boolean operator for comparison operations.\\n */\\nif\\n   exists:x:@.arguments/*/operator\\n   .lambda\\n\\n      // User provided a boolean comparison [operator] argument.\\n      set-name:x:../*/data.connect/*/data.read/*/where/0\\n         get-value:x:@.arguments/*/operator\\n      remove-nodes:x:@.arguments/*/operator\\n\\n// Opening up our database connection.\\ndata.connect:[generic|sakila]\\n   database-type:sqlite\\n\\n   // Making sure we're using correct function.\\n   set-name:x:./*/data.read/*/columns/*/distinct_functor\\n      strings.concat\\n         .:distinct(\\n         get-value:x:@.arguments/*/distinct_column\\n         .:)\\n\\n   // Removing distinct argument to simplify adding other arguments.\\n   remove-nodes:x:@.arguments/*/distinct_column\\n\\n   // Adding [limit] and [offset] arguments\\n   add:x:./*/data.read\\n      get-nodes:x:@.arguments/*/limit\\n      get-nodes:x:@.arguments/*/offset\\n      get-nodes:x:@.arguments/*/order\\n      get-nodes:x:@.arguments/*/direction\\n   remove-nodes:x:@.arguments/*/order\\n   remove-nodes:x:@.arguments/*/direction\\n   remove-nodes:x:@.arguments/*/limit\\n   remove-nodes:x:@.arguments/*/offset\\n\\n   // Adding filtering arguments.\\n   add:x:+/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:sqlite\\n      table:actor\\n      columns\\n         distinct_functor\\n            as:.\\n      where\\n         and\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Distinct Keyword Search from actor table in sakila database.\\n\\nThis endpoint will return only records containing one or more of the keywords from the specified [query],\\nwith rows containing the most distinct matched keywords appearing first."},{"role":"assistant","content":".arguments\\n\\n   // Mandatory query for records to search for\\n   query:string\\n\\n   // Optional number of records to return, defaults to 10 if not specified. Pass in -1 to return all records\\n   limit:long\\n\\n   // Optional offset into the dataset of where to start retrieving records\\n   offset:long\\n\\n// Type of endpoint\\n.type:crud-search\\n\\n// Make sure the user has provided a query.\\nvalidators.mandatory:x:@.arguments/*/query\\n\\n// Apply defaults if not specified.\\nvalidators.default:x:@.arguments\\n   limit:long:10\\n\\n// Split the user's query into individual keywords, separated by spaces.\\n.words\\nadd:x:@.words\\n   strings.split:x:@.arguments/*/query\\n      .:\" \"\\n\\n// Enforce lower characters for each keyword, and guard against SQL injection.\\n.no:int:0\\nfor-each:x:@.words/*\\n   set-value:x:@.dp/#\\n      strings.to-lower:x:@.dp/#\\n\\n// Specify which columns to search against.\\n.columns\\n   .:first_name\\n   .:last_name\\n\\n// Connect to the specified database.\\ndata.connect:[generic|sakila]\\n   database-type:sqlite\\n\\n   // Start building our SQL.\\n   .sql:select *, (\\n\\n   // 1) Dynamically create the full text by concatenating all columns we want to search.\\n   .fields\\n   for-each:x:@.columns/*\\n      strings.concat\\n         .:coalesce(\\n         get-value:x:@.dp/#\\n         .:\", '')\"\\n      unwrap:x:+/*/*\\n      add:x:@.fields\\n         .\\n            .:x:@strings.concat\\n   set-value:x:@.fields\\n      strings.join:x:@.fields/*\\n         .:\" || \"\\n   remove-nodes:x:@.fields/*\\n\\n   // 2) Keyword density calculation\\n   .no:int:0\\n   for-each:x:@.words/*\\n\\n      // Adding SQL parameter.\\n      set-name:x:+/+/*/*\\n         strings.concat\\n            .:@p\\n            get-value:x:@.no\\n      unwrap:x:+/*/*\\n      add:x:@data.connect/*/data.select\\n         .\\n            .:x:@.dp/#\\n\\n      // Modifying our SQL.\\n      if\\n         eq:x:@.no\\n            .:int:0\\n         .lambda\\n\\n            // First keyword => no leading plus\\n            set-value:x:@.sql\\n               strings.concat:x:@.sql\\n                  get-value:x:@.sql\\n                  .:\" (length(\"\\n                  get-value:x:@.fields\\n                  .:) - length(replace(lower(\\n                  get-value:x:@.fields\\n                  .:), @p\\n                  get-value:x:@.no\\n                  .:\", ''))) / length(@p\"\\n                  get-value:x:@.no\\n                  .:)\\n      else\\n         set-value:x:@.sql\\n            strings.concat:x:@.sql\\n               get-value:x:@.sql\\n               .:\" + (length(\"\\n               get-value:x:@.fields\\n               .:) - length(replace(lower(\\n               get-value:x:@.fields\\n               .:), @p\\n               get-value:x:@.no\\n               .:\", ''))) / length(@p\"\\n               get-value:x:@.no\\n               .:)\\n      math.increment:x:@.no\\n   set-value:x:@.sql\\n      strings.concat:x:@.sql\\n         get-value:x:@.sql\\n         .:) * 1.0 / length(\\n         get-value:x:@.fields\\n         .:) as keyword_density, (\\n\\n   // 3) Distinct keyword count => For each keyword, 1 if present, 0 if not.\\n   .no:int:0\\n   for-each:x:@.words/*\\n      if\\n         eq:x:@.no\\n            .:int:0\\n         .lambda\\n\\n            // First keyword => no leading plus\\n            set-value:x:@.sql\\n               strings.concat:x:@.sql\\n                  get-value:x:@.sql\\n                  .:\" CASE WHEN ((length(\"\\n                  get-value:x:@.fields\\n                  .:) - length(replace(lower(\\n                  get-value:x:@.fields\\n                  .:), @p\\n                  get-value:x:@.no\\n                  .:\", ''))) / length(@p\"\\n                  get-value:x:@.no\\n                  .:)) > 0 THEN 1 ELSE 0 END\\n      else\\n         set-value:x:@.sql\\n            strings.concat:x:@.sql\\n               get-value:x:@.sql\\n               .:\" + CASE WHEN ((length(\"\\n               get-value:x:@.fields\\n               .:) - length(replace(lower(\\n               get-value:x:@.fields\\n               .:), @p\\n               get-value:x:@.no\\n               .:\", ''))) / length(@p\"\\n               get-value:x:@.no\\n               .:)) > 0 THEN 1 ELSE 0 END\\n      math.increment:x:@.no\\n\\n   // Finalize \"keyword_count\".\\n   set-value:x:@.sql\\n      strings.concat:x:@.sql\\n         get-value:x:@.sql\\n         .:) as keyword_count\\n\\n   // 4) Finish SELECT + WHERE\\n   set-value:x:@.sql\\n      strings.concat:x:@.sql\\n         get-value:x:@.sql\\n         .:\" from \"\\n         .:actor\\n         .:\" where keyword_count > 0\"\\n\\n   // 5) Order by distinct keyword_count (higher means more distinct keywords), then keyword_density.\\n   set-value:x:@.sql\\n      strings.concat:x:@.sql\\n         get-value:x:@.sql\\n         .:\" order by keyword_count desc, keyword_density desc limit \"\\n         get-value:x:@.arguments/*/limit\\n\\n   // (Optional) offset => pagination\\n   if\\n      exists:x:@.arguments/*/offset\\n      .lambda\\n         set-value:x:@.sql\\n            strings.concat:x:@.sql\\n               get-value:x:@.sql\\n               .:\" offset \"\\n               get-value:x:@.arguments/*/offset\\n\\n   // Execute the SQL\\n   data.select:x:@.sql\\n      database-type:sqlite\\n\\n   // Remove helper fields if you don't want them in your final JSON\\n   remove-nodes:x:@data.select/*/*/keyword_density\\n   remove-nodes:x:@data.select/*/*/keyword_count\\n\\n   // Return the final result set\\n   return-nodes:x:@data.select/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Delete one record from your actor table in your sakila database with authorization"},{"role":"assistant","content":".arguments\\n\\n   // Primary key of record to delete, mandatory argument\\n   actor_id:long\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-delete\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root,admin\\nvalidators.mandatory:x:@.arguments/*/actor_id\\n\\n// Opening up our database connection.\\ndata.connect:[generic|sakila]\\n   database-type:sqlite\\n\\n   // Parametrising our delete invocation.\\n   add:x:./*/data.delete/*/where/*/and\\n      get-nodes:x:@.arguments/*\\n\\n   // Deleting item from database.\\n   data.delete\\n      database-type:sqlite\\n      table:actor\\n      where\\n         and\\n\\n   // Returning result of above invocation to caller.\\n   unwrap:x:+/*\\n   return\\n      affected:x:@data.delete\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Read or list records from your actor table in your sakila database with authorization"},{"role":"assistant","content":".arguments\\n\\n   // Number of records to return, defaults to 25 if not specified. Pass in -1 to return all records.\\n   limit:long\\n\\n   // Offset into the dataset of where to start retrieving records\\n   offset:long\\n\\n   // Fully qualified name of column to order by, must be in TABLE_NAME.COLUMN_NAME format\\n   order:string\\n\\n   // What direction to order, can be 'asc' or 'desc' implying ascending and descending\\n   direction:string\\n\\n   // Optional logical operator for filtering arguments, can be either 'or' or 'and'. Defaults to and.\\n   operator:string\\n   actor.actor_id.mt:long\\n   actor.actor_id.lt:long\\n   actor.actor_id.mteq:long\\n   actor.actor_id.lteq:long\\n   actor.actor_id.neq:long\\n   actor.actor_id.eq:long\\n   actor.first_name.like:string\\n   actor.first_name.mt:string\\n   actor.first_name.lt:string\\n   actor.first_name.mteq:string\\n   actor.first_name.lteq:string\\n   actor.first_name.neq:string\\n   actor.first_name.eq:string\\n   actor.last_name.like:string\\n   actor.last_name.mt:string\\n   actor.last_name.lt:string\\n   actor.last_name.mteq:string\\n   actor.last_name.lteq:string\\n   actor.last_name.neq:string\\n   actor.last_name.eq:string\\n   actor.last_update.mt:date\\n   actor.last_update.lt:date\\n   actor.last_update.mteq:date\\n   actor.last_update.lteq:date\\n   actor.last_update.neq:date\\n   actor.last_update.eq:date\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-read\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root,admin\\n\\n// Sanity checking invocation.\\nvalidators.enum:x:@.arguments/*/operator\\n   .:or\\n   .:and\\n\\n/*\\n * Checking if user supplied an [operator] argument, and if so\\n * changing the boolean operator for comparison operations.\\n */\\nif\\n   exists:x:@.arguments/*/operator\\n   .lambda\\n\\n      // User provided a boolean comparison [operator] argument.\\n      set-name:x:../*/data.connect/*/data.read/*/where/0\\n         get-value:x:@.arguments/*/operator\\n      remove-nodes:x:@.arguments/*/operator\\n\\n// Opening up our database connection.\\ndata.connect:[generic|sakila]\\n   database-type:sqlite\\n\\n   // Parametrising our read invocation with ordering arguments if specified.\\n   add:x:./*/data.read\\n      get-nodes:x:@.arguments/*/order\\n      get-nodes:x:@.arguments/*/direction\\n   remove-nodes:x:@.arguments/*/order\\n   remove-nodes:x:@.arguments/*/direction\\n\\n   // Parametrising our read invocation with paging arguments if specified.\\n   add:x:./*/data.read\\n      get-nodes:x:@.arguments/*/limit\\n      get-nodes:x:@.arguments/*/offset\\n   remove-nodes:x:@.arguments/*/limit\\n   remove-nodes:x:@.arguments/*/offset\\n\\n   // Parametrising our read invocation with filtering arguments.\\n   add:x:./*/data.read/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:sqlite\\n      table:actor\\n      columns\\n         actor.actor_id\\n         actor.first_name\\n         actor.last_name\\n         actor.last_update\\n      where\\n         and\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create one record in your actor table in your sakila database with authorization"},{"role":"assistant","content":".arguments\\n\\n   // first_name column value\\n   first_name:string\\n\\n   // last_name column value\\n   last_name:string\\n\\n   // last_update column value\\n   last_update:date\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-create\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root,admin\\n\\n// Opening up database connection.\\ndata.connect:[generic|sakila]\\n   database-type:sqlite\\n\\n   // Parametrising our create invocation.\\n   add:x:./*/data.create/*/values\\n      get-nodes:x:@.arguments/*\\n\\n   // Creating our record.\\n   data.create\\n      database-type:sqlite\\n      table:actor\\n      return-id:bool:true\\n      values\\n\\n   // Returning the correct status code.\\n   response.status.set:201\\n\\n   // Returning result of above invocation to caller.\\n   unwrap:x:+/*\\n   return\\n      id:x:@data.create\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Update one record in your actor table in your sakila database with authorization"},{"role":"assistant","content":".arguments\\n\\n   // actor_id column value being primary key of record to update, mandatory argument\\n   actor_id:long\\n\\n   // first_name column's new value\\n   first_name:string\\n\\n   // last_name column's new value\\n   last_name:string\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-update\\n\\n// Sanity checking invocation, making sure primary key(s) are specified.\\nvalidators.mandatory:x:@.arguments/*/actor_id\\n\\n// Verifying user is authorized to access endpoint.\\nauth.ticket.verify:root,admin\\n\\n// Opening up our database connection.\\ndata.connect:[generic|sakila]\\n   database-type:sqlite\\n\\n   // Parametrising our invocation.\\n   add:x:./*/data.update/*/values\\n      get-nodes:x:@.arguments/*/[1,1000]\\n   add:x:./*/data.update/*/where/*/and\\n      get-nodes:x:@.arguments/*/[0,1]\\n\\n   // Invoking our update slot.\\n   data.update\\n      database-type:sqlite\\n      table:actor\\n      values\\n      where\\n         and\\n\\n   // Verifying record exists.\\n   if\\n      eq\\n         get-value:x:@data.update\\n         .:int:0\\n      .lambda\\n         response.status.set:404\\n         return\\n            result:Record not found\\n\\n   // Returning the correct status code.\\n   response.status.set:202\\n\\n   // Returning success to caller.\\n   unwrap:x:+/*\\n   return\\n      affected:x:@data.update\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns minimum, maximum, average or sum from your address table in your sakila database without authorization"},{"role":"assistant","content":".arguments\\n\\n   // Function to aggregate upon. Argument is mandatory and legal values are min, max, sum or avg\\n   aggregate_function:string\\n\\n   // Argument is mandatory and must be in the format of TABLE_NAME.COLUMN_NAME.\\n   aggregate_column:string\\n\\n   // Optional logical operator for filtering arguments, can be either 'or' or 'and'. Defaults to and.\\n   operator:string\\n   address.address_id.mt:long\\n   address.address_id.lt:long\\n   address.address_id.mteq:long\\n   address.address_id.lteq:long\\n   address.address_id.neq:long\\n   address.address_id.eq:long\\n   address.address.like:string\\n   address.address.mt:string\\n   address.address.lt:string\\n   address.address.mteq:string\\n   address.address.lteq:string\\n   address.address.neq:string\\n   address.address.eq:string\\n   address.address2.like:string\\n   address.address2.mt:string\\n   address.address2.lt:string\\n   address.address2.mteq:string\\n   address.address2.lteq:string\\n   address.address2.neq:string\\n   address.address2.eq:string\\n   address.district.like:string\\n   address.district.mt:string\\n   address.district.lt:string\\n   address.district.mteq:string\\n   address.district.lteq:string\\n   address.district.neq:string\\n   address.district.eq:string\\n   address.city_id.mt:long\\n   address.city_id.lt:long\\n   address.city_id.mteq:long\\n   address.city_id.lteq:long\\n   address.city_id.neq:long\\n   address.city_id.eq:long\\n   address.postal_code.like:string\\n   address.postal_code.mt:string\\n   address.postal_code.lt:string\\n   address.postal_code.mteq:string\\n   address.postal_code.lteq:string\\n   address.postal_code.neq:string\\n   address.postal_code.eq:string\\n   address.phone.like:string\\n   address.phone.mt:string\\n   address.phone.lt:string\\n   address.phone.mteq:string\\n   address.phone.lteq:string\\n   address.phone.neq:string\\n   address.phone.eq:string\\n   address.last_update.mt:date\\n   address.last_update.lt:date\\n   address.last_update.mteq:date\\n   address.last_update.lteq:date\\n   address.last_update.neq:date\\n   address.last_update.eq:date\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-aggregate\\n\\n// Sanity checking mandatory arguments.\\nvalidators.mandatory:x:@.arguments/*/aggregate_function\\nvalidators.mandatory:x:@.arguments/*/aggregate_column\\n\\n// Sanity checking name of aggregate function.\\nvalidators.enum:x:@.arguments/*/aggregate_function\\n   .:min\\n   .:max\\n   .:sum\\n   .:avg\\n\\n// Sanity checking agggregate column name.\\nvalidators.enum:x:@.arguments/*/aggregate_column\\n   .:address.address_id\\n   .:address.address\\n   .:address.address2\\n   .:address.district\\n   .:address.city_id\\n   .:address.postal_code\\n   .:address.phone\\n   .:address.last_update\\n\\n// Sanity checking invocation.\\nvalidators.enum:x:@.arguments/*/operator\\n   .:or\\n   .:and\\n\\n/*\\n * Checking if user supplied an [operator] argument, and if so\\n * changing the boolean operator for comparison operations.\\n */\\nif\\n   exists:x:@.arguments/*/operator\\n   .lambda\\n\\n      // User provided a boolean comparison [operator] argument.\\n      set-name:x:../*/data.connect/*/data.read/*/where/0\\n         get-value:x:@.arguments/*/operator\\n      remove-nodes:x:@.arguments/*/operator\\n\\n// Opening up our database connection.\\ndata.connect:[generic|sakila]\\n   database-type:sqlite\\n\\n   // Making sure we're using correct aggregate function.\\n   set-name:x:./*/data.read/*/columns/*/aggregate_functor\\n      strings.concat\\n         get-value:x:@.arguments/*/aggregate_function\\n         .:(\\n         get-value:x:@.arguments/*/aggregate_column\\n         .:)\\n\\n   // Removing aggregate arguments to simplify adding other arguments.\\n   remove-nodes:x:@.arguments/*/[0,2]\\n\\n   // Adding filtering arguments.\\n   add:x:+/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:sqlite\\n      table:address\\n      columns\\n         aggregate_functor\\n            as:result\\n      where\\n         and\\n      limit:long:1\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Count unique and distinct items from your address table in your sakila database without authorization"},{"role":"assistant","content":".arguments\\n\\n   // Argument is mandatory and must be in the format of TABLE_NAME.COLUMN_NAME\\n   distinct_column:string\\n\\n   // Optional logical operator for filtering arguments, can be either 'or' or 'and'. Defaults to and.\\n   operator:string\\n   address.address_id.mt:long\\n   address.address_id.lt:long\\n   address.address_id.mteq:long\\n   address.address_id.lteq:long\\n   address.address_id.neq:long\\n   address.address_id.eq:long\\n   address.address.like:string\\n   address.address.mt:string\\n   address.address.lt:string\\n   address.address.mteq:string\\n   address.address.lteq:string\\n   address.address.neq:string\\n   address.address.eq:string\\n   address.address2.like:string\\n   address.address2.mt:string\\n   address.address2.lt:string\\n   address.address2.mteq:string\\n   address.address2.lteq:string\\n   address.address2.neq:string\\n   address.address2.eq:string\\n   address.district.like:string\\n   address.district.mt:string\\n   address.district.lt:string\\n   address.district.mteq:string\\n   address.district.lteq:string\\n   address.district.neq:string\\n   address.district.eq:string\\n   address.city_id.mt:long\\n   address.city_id.lt:long\\n   address.city_id.mteq:long\\n   address.city_id.lteq:long\\n   address.city_id.neq:long\\n   address.city_id.eq:long\\n   address.postal_code.like:string\\n   address.postal_code.mt:string\\n   address.postal_code.lt:string\\n   address.postal_code.mteq:string\\n   address.postal_code.lteq:string\\n   address.postal_code.neq:string\\n   address.postal_code.eq:string\\n   address.phone.like:string\\n   address.phone.mt:string\\n   address.phone.lt:string\\n   address.phone.mteq:string\\n   address.phone.lteq:string\\n   address.phone.neq:string\\n   address.phone.eq:string\\n   address.last_update.mt:date\\n   address.last_update.lt:date\\n   address.last_update.mteq:date\\n   address.last_update.lteq:date\\n   address.last_update.neq:date\\n   address.last_update.eq:date\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-count-distinct\\n\\n// Sanity checking that distinct column was passed in.\\nvalidators.mandatory:x:@.arguments/*/distinct_column\\n\\n// Sanity checking distinct column's name.\\nvalidators.enum:x:@.arguments/*/distinct_column\\n   .:address.address_id\\n   .:address.address\\n   .:address.address2\\n   .:address.district\\n   .:address.city_id\\n   .:address.postal_code\\n   .:address.phone\\n   .:address.last_update\\n\\n// Sanity checking invocation.\\nvalidators.enum:x:@.arguments/*/operator\\n   .:or\\n   .:and\\n\\n/*\\n * Checking if user supplied an [operator] argument, and if so\\n * changing the boolean operator for comparison operations.\\n */\\nif\\n   exists:x:@.arguments/*/operator\\n   .lambda\\n\\n      // User provided a boolean comparison [operator] argument.\\n      set-name:x:../*/data.connect/*/data.read/*/where/0\\n         get-value:x:@.arguments/*/operator\\n      remove-nodes:x:@.arguments/*/operator\\n\\n// Opening up our database connection.\\ndata.connect:[generic|sakila]\\n   database-type:sqlite\\n\\n   // Making sure we're using correct function.\\n   set-name:x:./*/data.read/*/columns/*/distinct_functor\\n      strings.concat\\n         .:\"count(distinct \"\\n         get-value:x:@.arguments/*/distinct_column\\n         .:)\\n\\n   // Removing distinct argument to simplify adding other arguments.\\n   remove-nodes:x:@.arguments/*/distinct_column\\n\\n   // Adding filtering arguments.\\n   add:x:+/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:sqlite\\n      table:address\\n      columns\\n         distinct_functor\\n            as:count\\n      where\\n         and\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns unique and distinct values from your address table in your sakila database without authorization"},{"role":"assistant","content":".arguments\\n\\n   // Name of column to return unique and distinct values for. Argument is mandatory and must be in the format of TABLE_NAME.COLUMN_NAME\\n   distinct_column:string\\n\\n   // Number of records to return, defaults to 25 if not specified. Pass in -1 to return all records.\\n   limit:long\\n\\n   // Offset into the dataset of where to start retrieving records\\n   offset:long\\n\\n   // Fully qualified name of column to order by, must be in TABLE_NAME.COLUMN_NAME format\\n   order:string\\n\\n   // What direction to order, can be 'asc' or 'desc' implying ascending and descending\\n   direction:string\\n\\n   // Optional logical operator for filtering arguments, can be either 'or' or 'and'. Defaults to and.\\n   operator:string\\n   address.address_id.mt:long\\n   address.address_id.lt:long\\n   address.address_id.mteq:long\\n   address.address_id.lteq:long\\n   address.address_id.neq:long\\n   address.address_id.eq:long\\n   address.address.like:string\\n   address.address.mt:string\\n   address.address.lt:string\\n   address.address.mteq:string\\n   address.address.lteq:string\\n   address.address.neq:string\\n   address.address.eq:string\\n   address.address2.like:string\\n   address.address2.mt:string\\n   address.address2.lt:string\\n   address.address2.mteq:string\\n   address.address2.lteq:string\\n   address.address2.neq:string\\n   address.address2.eq:string\\n   address.district.like:string\\n   address.district.mt:string\\n   address.district.lt:string\\n   address.district.mteq:string\\n   address.district.lteq:string\\n   address.district.neq:string\\n   address.district.eq:string\\n   address.city_id.mt:long\\n   address.city_id.lt:long\\n   address.city_id.mteq:long\\n   address.city_id.lteq:long\\n   address.city_id.neq:long\\n   address.city_id.eq:long\\n   address.postal_code.like:string\\n   address.postal_code.mt:string\\n   address.postal_code.lt:string\\n   address.postal_code.mteq:string\\n   address.postal_code.lteq:string\\n   address.postal_code.neq:string\\n   address.postal_code.eq:string\\n   address.phone.like:string\\n   address.phone.mt:string\\n   address.phone.lt:string\\n   address.phone.mteq:string\\n   address.phone.lteq:string\\n   address.phone.neq:string\\n   address.phone.eq:string\\n   address.last_update.mt:date\\n   address.last_update.lt:date\\n   address.last_update.mteq:date\\n   address.last_update.lteq:date\\n   address.last_update.neq:date\\n   address.last_update.eq:date\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-distinct\\n\\n// Sanity checking that distinct column was passed in.\\nvalidators.mandatory:x:@.arguments/*/distinct_column\\n\\n// Sanity checking distinct column's name.\\nvalidators.enum:x:@.arguments/*/distinct_column\\n   .:address.address_id\\n   .:address.address\\n   .:address.address2\\n   .:address.district\\n   .:address.city_id\\n   .:address.postal_code\\n   .:address.phone\\n   .:address.last_update\\n\\n// Sanity checking invocation.\\nvalidators.enum:x:@.arguments/*/operator\\n   .:or\\n   .:and\\n\\n/*\\n * Checking if user supplied an [operator] argument, and if so\\n * changing the boolean operator for comparison operations.\\n */\\nif\\n   exists:x:@.arguments/*/operator\\n   .lambda\\n\\n      // User provided a boolean comparison [operator] argument.\\n      set-name:x:../*/data.connect/*/data.read/*/where/0\\n         get-value:x:@.arguments/*/operator\\n      remove-nodes:x:@.arguments/*/operator\\n\\n// Opening up our database connection.\\ndata.connect:[generic|sakila]\\n   database-type:sqlite\\n\\n   // Making sure we're using correct function.\\n   set-name:x:./*/data.read/*/columns/*/distinct_functor\\n      strings.concat\\n         .:distinct(\\n         get-value:x:@.arguments/*/distinct_column\\n         .:)\\n\\n   // Removing distinct argument to simplify adding other arguments.\\n   remove-nodes:x:@.arguments/*/distinct_column\\n\\n   // Adding [limit] and [offset] arguments\\n   add:x:./*/data.read\\n      get-nodes:x:@.arguments/*/limit\\n      get-nodes:x:@.arguments/*/offset\\n      get-nodes:x:@.arguments/*/order\\n      get-nodes:x:@.arguments/*/direction\\n   remove-nodes:x:@.arguments/*/order\\n   remove-nodes:x:@.arguments/*/direction\\n   remove-nodes:x:@.arguments/*/limit\\n   remove-nodes:x:@.arguments/*/offset\\n\\n   // Adding filtering arguments.\\n   add:x:+/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:sqlite\\n      table:address\\n      columns\\n         distinct_functor\\n            as:.\\n      where\\n         and\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns minimum, maximum, average, sum or count from your address table in your sakila database grouped by a column without authorization"},{"role":"assistant","content":".arguments\\n\\n   // Mandatory argument being column to group by and must be in the format of TABLE_NAME.COLUMN_NAME\\n   group_column:string\\n\\n   // Number of records to return, defaults to 25 if not specified. Pass in -1 to return all records.\\n   limit:long\\n\\n   // Offset into the dataset of where to start retrieving records\\n   offset:long\\n\\n   // Fully qualified name of column to order by, must be in TABLE_NAME.COLUMN_NAME format\\n   order:string\\n\\n   // What direction to order, can be 'asc' or 'desc' implying ascending and descending\\n   direction:string\\n\\n   // Function to aggregate upon. Argument is mandatory and legal values are min, max, sum, avg or count\\n   aggregate_function:string\\n\\n   // Argument is mandatory and must be in the format of TABLE_NAME.COLUMN_NAME.\\n   aggregate_column:string\\n\\n   // Optional logical operator for filtering arguments, can be either 'or' or 'and'. Defaults to and.\\n   operator:string\\n   address.address_id.mt:long\\n   address.address_id.lt:long\\n   address.address_id.mteq:long\\n   address.address_id.lteq:long\\n   address.address_id.neq:long\\n   address.address_id.eq:long\\n   address.address.like:string\\n   address.address.mt:string\\n   address.address.lt:string\\n   address.address.mteq:string\\n   address.address.lteq:string\\n   address.address.neq:string\\n   address.address.eq:string\\n   address.address2.like:string\\n   address.address2.mt:string\\n   address.address2.lt:string\\n   address.address2.mteq:string\\n   address.address2.lteq:string\\n   address.address2.neq:string\\n   address.address2.eq:string\\n   address.district.like:string\\n   address.district.mt:string\\n   address.district.lt:string\\n   address.district.mteq:string\\n   address.district.lteq:string\\n   address.district.neq:string\\n   address.district.eq:string\\n   address.city_id.mt:long\\n   address.city_id.lt:long\\n   address.city_id.mteq:long\\n   address.city_id.lteq:long\\n   address.city_id.neq:long\\n   address.city_id.eq:long\\n   address.postal_code.like:string\\n   address.postal_code.mt:string\\n   address.postal_code.lt:string\\n   address.postal_code.mteq:string\\n   address.postal_code.lteq:string\\n   address.postal_code.neq:string\\n   address.postal_code.eq:string\\n   address.phone.like:string\\n   address.phone.mt:string\\n   address.phone.lt:string\\n   address.phone.mteq:string\\n   address.phone.lteq:string\\n   address.phone.neq:string\\n   address.phone.eq:string\\n   address.last_update.mt:date\\n   address.last_update.lt:date\\n   address.last_update.mteq:date\\n   address.last_update.lteq:date\\n   address.last_update.neq:date\\n   address.last_update.eq:date\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-group\\n\\n// Sanity checking mandatory arguments.\\nvalidators.mandatory:x:@.arguments/*/group_column\\nvalidators.mandatory:x:@.arguments/*/aggregate_function\\nvalidators.mandatory:x:@.arguments/*/aggregate_column\\n\\n// Sanity checking name of aggregate function.\\nvalidators.enum:x:@.arguments/*/aggregate_function\\n   .:min\\n   .:max\\n   .:sum\\n   .:avg\\n   .:count\\n\\n// Sanity checking group column.\\nvalidators.enum:x:@.arguments/*/group_column\\n   .:address.address_id\\n   .:address.address\\n   .:address.address2\\n   .:address.district\\n   .:address.city_id\\n   .:address.postal_code\\n   .:address.phone\\n   .:address.last_update\\n\\n// Sanity checking agggregate column name.\\nvalidators.enum:x:@.arguments/*/aggregate_column\\n   .:address.address_id\\n   .:address.address\\n   .:address.address2\\n   .:address.district\\n   .:address.city_id\\n   .:address.postal_code\\n   .:address.phone\\n   .:address.last_update\\n\\n// Sanity checking invocation.\\nvalidators.enum:x:@.arguments/*/operator\\n   .:or\\n   .:and\\n\\n/*\\n * Checking if user supplied an [operator] argument, and if so\\n * changing the boolean operator for comparison operations.\\n */\\nif\\n   exists:x:@.arguments/*/operator\\n   .lambda\\n\\n      // User provided a boolean comparison [operator] argument.\\n      set-name:x:../*/data.connect/*/data.read/*/where/0\\n         get-value:x:@.arguments/*/operator\\n      remove-nodes:x:@.arguments/*/operator\\n\\n// Opening up our database connection.\\ndata.connect:[generic|sakila]\\n   database-type:sqlite\\n\\n   // Making sure we're using the correct group column\\n   set-name:x:@data.connect/*/data.read/*/group/*/group_column\\n      get-value:x:@.arguments/*/group_column\\n\\n   // Making sure we return group column as a part of the result\\n   set-name:x:+/*/*\\n      get-value:x:@.arguments/*/group_column\\n   insert-before:x:@data.connect/*/data.read/*/columns/0\\n      .\\n         group_column\\n\\n   // Changing name of aggregate column returned to caller.\\n   set-value:x:@data.connect/*/data.read/*/columns/1/*/as\\n      get-value:x:@.arguments/*/aggregate_function\\n\\n   // Removing group column to simplify adding other arguments\\n   remove-nodes:x:@.arguments/*/group_column\\n\\n   // Adding paging arguments\\n   add:x:@data.connect/*/data.read\\n      get-nodes:x:@.arguments/*/limit\\n      get-nodes:x:@.arguments/*/offset\\n   remove-nodes:x:@.arguments/*/limit\\n   remove-nodes:x:@.arguments/*/offset\\n\\n   // Parametrising our read invocation with ordering arguments if specified.\\n   add:x:./*/data.read\\n      get-nodes:x:@.arguments/*/order\\n      get-nodes:x:@.arguments/*/direction\\n   remove-nodes:x:@.arguments/*/order\\n   remove-nodes:x:@.arguments/*/direction\\n\\n   // Making sure we're using correct aggregate function.\\n   set-name:x:./*/data.read/*/columns/*/aggregate_functor\\n      strings.concat\\n         get-value:x:@.arguments/*/aggregate_function\\n         .:(\\n         get-value:x:@.arguments/*/aggregate_column\\n         .:)\\n\\n   // Removing aggregate arguments to simplify adding other arguments.\\n   remove-nodes:x:@.arguments/*/[0,2]\\n\\n   // Adding filtering arguments.\\n   add:x:+/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:sqlite\\n      table:address\\n      columns\\n         aggregate_functor\\n            as:result\\n      where\\n         and\\n      group\\n         group_column\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Distinct Keyword Search from address table in sakila database without authorization.\\n\\nThis endpoint will return only records containing one or more of the keywords from the specified [query],\\nwith rows containing the most distinct matched keywords appearing first."},{"role":"assistant","content":".arguments\\n\\n   // Mandatory query for records to search for\\n   query:string\\n\\n   // Optional number of records to return, defaults to 10 if not specified. Pass in -1 to return all records\\n   limit:long\\n\\n   // Optional offset into the dataset of where to start retrieving records\\n   offset:long\\n\\n// Type of endpoint\\n.type:crud-search\\n\\n// Make sure the user has provided a query.\\nvalidators.mandatory:x:@.arguments/*/query\\n\\n// Apply defaults if not specified.\\nvalidators.default:x:@.arguments\\n   limit:long:10\\n\\n// Split the user's query into individual keywords, separated by spaces.\\n.words\\nadd:x:@.words\\n   strings.split:x:@.arguments/*/query\\n      .:\" \"\\n\\n// Enforce lower characters for each keyword, and guard against SQL injection.\\n.no:int:0\\nfor-each:x:@.words/*\\n   set-value:x:@.dp/#\\n      strings.to-lower:x:@.dp/#\\n\\n// Specify which columns to search against.\\n.columns\\n   .:address\\n   .:address2\\n   .:district\\n   .:postal_code\\n   .:phone\\n\\n// Connect to the specified database.\\ndata.connect:[generic|sakila]\\n   database-type:sqlite\\n\\n   // Start building our SQL.\\n   .sql:select *, (\\n\\n   // 1) Dynamically create the full text by concatenating all columns we want to search.\\n   .fields\\n   for-each:x:@.columns/*\\n      strings.concat\\n         .:coalesce(\\n         get-value:x:@.dp/#\\n         .:\", '')\"\\n      unwrap:x:+/*/*\\n      add:x:@.fields\\n         .\\n            .:x:@strings.concat\\n   set-value:x:@.fields\\n      strings.join:x:@.fields/*\\n         .:\" || \"\\n   remove-nodes:x:@.fields/*\\n\\n   // 2) Keyword density calculation\\n   .no:int:0\\n   for-each:x:@.words/*\\n\\n      // Adding SQL parameter.\\n      set-name:x:+/+/*/*\\n         strings.concat\\n            .:@p\\n            get-value:x:@.no\\n      unwrap:x:+/*/*\\n      add:x:@data.connect/*/data.select\\n         .\\n            .:x:@.dp/#\\n\\n      // Modifying our SQL.\\n      if\\n         eq:x:@.no\\n            .:int:0\\n         .lambda\\n\\n            // First keyword => no leading plus\\n            set-value:x:@.sql\\n               strings.concat:x:@.sql\\n                  get-value:x:@.sql\\n                  .:\" (length(\"\\n                  get-value:x:@.fields\\n                  .:) - length(replace(lower(\\n                  get-value:x:@.fields\\n                  .:), @p\\n                  get-value:x:@.no\\n                  .:\", ''))) / length(@p\"\\n                  get-value:x:@.no\\n                  .:)\\n      else\\n         set-value:x:@.sql\\n            strings.concat:x:@.sql\\n               get-value:x:@.sql\\n               .:\" + (length(\"\\n               get-value:x:@.fields\\n               .:) - length(replace(lower(\\n               get-value:x:@.fields\\n               .:), @p\\n               get-value:x:@.no\\n               .:\", ''))) / length(@p\"\\n               get-value:x:@.no\\n               .:)\\n      math.increment:x:@.no\\n   set-value:x:@.sql\\n      strings.concat:x:@.sql\\n         get-value:x:@.sql\\n         .:) * 1.0 / length(\\n         get-value:x:@.fields\\n         .:) as keyword_density, (\\n\\n   // 3) Distinct keyword count => For each keyword, 1 if present, 0 if not.\\n   .no:int:0\\n   for-each:x:@.words/*\\n      if\\n         eq:x:@.no\\n            .:int:0\\n         .lambda\\n\\n            // First keyword => no leading plus\\n            set-value:x:@.sql\\n               strings.concat:x:@.sql\\n                  get-value:x:@.sql\\n                  .:\" CASE WHEN ((length(\"\\n                  get-value:x:@.fields\\n                  .:) - length(replace(lower(\\n                  get-value:x:@.fields\\n                  .:), @p\\n                  get-value:x:@.no\\n                  .:\", ''))) / length(@p\"\\n                  get-value:x:@.no\\n                  .:)) > 0 THEN 1 ELSE 0 END\\n      else\\n         set-value:x:@.sql\\n            strings.concat:x:@.sql\\n               get-value:x:@.sql\\n               .:\" + CASE WHEN ((length(\"\\n               get-value:x:@.fields\\n               .:) - length(replace(lower(\\n               get-value:x:@.fields\\n               .:), @p\\n               get-value:x:@.no\\n               .:\", ''))) / length(@p\"\\n               get-value:x:@.no\\n               .:)) > 0 THEN 1 ELSE 0 END\\n      math.increment:x:@.no\\n\\n   // Finalize \"keyword_count\".\\n   set-value:x:@.sql\\n      strings.concat:x:@.sql\\n         get-value:x:@.sql\\n         .:) as keyword_count\\n\\n   // 4) Finish SELECT + WHERE\\n   set-value:x:@.sql\\n      strings.concat:x:@.sql\\n         get-value:x:@.sql\\n         .:\" from \"\\n         .:address\\n         .:\" where keyword_count > 0\"\\n\\n   // 5) Order by distinct keyword_count (higher means more distinct keywords), then keyword_density.\\n   set-value:x:@.sql\\n      strings.concat:x:@.sql\\n         get-value:x:@.sql\\n         .:\" order by keyword_count desc, keyword_density desc limit \"\\n         get-value:x:@.arguments/*/limit\\n\\n   // (Optional) offset => pagination\\n   if\\n      exists:x:@.arguments/*/offset\\n      .lambda\\n         set-value:x:@.sql\\n            strings.concat:x:@.sql\\n               get-value:x:@.sql\\n               .:\" offset \"\\n               get-value:x:@.arguments/*/offset\\n\\n   // Execute the SQL\\n   data.select:x:@.sql\\n      database-type:sqlite\\n\\n   // Remove helper fields if you don't want them in your final JSON\\n   remove-nodes:x:@data.select/*/*/keyword_density\\n   remove-nodes:x:@data.select/*/*/keyword_count\\n\\n   // Return the final result set\\n   return-nodes:x:@data.select/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Delete one record from your address table in your sakila database without authorization. Log invocation"},{"role":"assistant","content":".arguments\\n\\n   // Primary key of record to delete, mandatory argument\\n   address_id:long\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-delete\\n\\n// Logging invocation.\\nauth.ticket.get\\nlambda2hyper:x:@.arguments/*\\nlog.info:sakila.address entry deleted\\n   username:x:@auth.ticket.get\\n   arguments:x:@lambda2hyper\\nvalidators.mandatory:x:@.arguments/*/address_id\\n\\n// Opening up our database connection.\\ndata.connect:[generic|sakila]\\n   database-type:sqlite\\n\\n   // Parametrising our delete invocation.\\n   add:x:./*/data.delete/*/where/*/and\\n      get-nodes:x:@.arguments/*\\n\\n   // Deleting item from database.\\n   data.delete\\n      database-type:sqlite\\n      table:address\\n      where\\n         and\\n\\n   // Returning result of above invocation to caller.\\n   unwrap:x:+/*\\n   return\\n      affected:x:@data.delete\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Read or list records from your address table in your sakila database without authorization"},{"role":"assistant","content":".arguments\\n\\n   // Number of records to return, defaults to 25 if not specified. Pass in -1 to return all records.\\n   limit:long\\n\\n   // Offset into the dataset of where to start retrieving records\\n   offset:long\\n\\n   // Fully qualified name of column to order by, must be in TABLE_NAME.COLUMN_NAME format\\n   order:string\\n\\n   // What direction to order, can be 'asc' or 'desc' implying ascending and descending\\n   direction:string\\n\\n   // Optional logical operator for filtering arguments, can be either 'or' or 'and'. Defaults to and.\\n   operator:string\\n   address.address_id.mt:long\\n   address.address_id.lt:long\\n   address.address_id.mteq:long\\n   address.address_id.lteq:long\\n   address.address_id.neq:long\\n   address.address_id.eq:long\\n   address.address.like:string\\n   address.address.mt:string\\n   address.address.lt:string\\n   address.address.mteq:string\\n   address.address.lteq:string\\n   address.address.neq:string\\n   address.address.eq:string\\n   address.address2.like:string\\n   address.address2.mt:string\\n   address.address2.lt:string\\n   address.address2.mteq:string\\n   address.address2.lteq:string\\n   address.address2.neq:string\\n   address.address2.eq:string\\n   address.district.like:string\\n   address.district.mt:string\\n   address.district.lt:string\\n   address.district.mteq:string\\n   address.district.lteq:string\\n   address.district.neq:string\\n   address.district.eq:string\\n   address.city_id.mt:long\\n   address.city_id.lt:long\\n   address.city_id.mteq:long\\n   address.city_id.lteq:long\\n   address.city_id.neq:long\\n   address.city_id.eq:long\\n   address.postal_code.like:string\\n   address.postal_code.mt:string\\n   address.postal_code.lt:string\\n   address.postal_code.mteq:string\\n   address.postal_code.lteq:string\\n   address.postal_code.neq:string\\n   address.postal_code.eq:string\\n   address.phone.like:string\\n   address.phone.mt:string\\n   address.phone.lt:string\\n   address.phone.mteq:string\\n   address.phone.lteq:string\\n   address.phone.neq:string\\n   address.phone.eq:string\\n   address.last_update.mt:date\\n   address.last_update.lt:date\\n   address.last_update.mteq:date\\n   address.last_update.lteq:date\\n   address.last_update.neq:date\\n   address.last_update.eq:date\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-read\\n\\n// Sanity checking invocation.\\nvalidators.enum:x:@.arguments/*/operator\\n   .:or\\n   .:and\\n\\n/*\\n * Checking if user supplied an [operator] argument, and if so\\n * changing the boolean operator for comparison operations.\\n */\\nif\\n   exists:x:@.arguments/*/operator\\n   .lambda\\n\\n      // User provided a boolean comparison [operator] argument.\\n      set-name:x:../*/data.connect/*/data.read/*/where/0\\n         get-value:x:@.arguments/*/operator\\n      remove-nodes:x:@.arguments/*/operator\\n\\n// Opening up our database connection.\\ndata.connect:[generic|sakila]\\n   database-type:sqlite\\n\\n   // Parametrising our read invocation with ordering arguments if specified.\\n   add:x:./*/data.read\\n      get-nodes:x:@.arguments/*/order\\n      get-nodes:x:@.arguments/*/direction\\n   remove-nodes:x:@.arguments/*/order\\n   remove-nodes:x:@.arguments/*/direction\\n\\n   // Parametrising our read invocation with paging arguments if specified.\\n   add:x:./*/data.read\\n      get-nodes:x:@.arguments/*/limit\\n      get-nodes:x:@.arguments/*/offset\\n   remove-nodes:x:@.arguments/*/limit\\n   remove-nodes:x:@.arguments/*/offset\\n\\n   // Parametrising our read invocation with filtering arguments.\\n   add:x:./*/data.read/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:sqlite\\n      table:address\\n      columns\\n         address.address_id\\n         address.address\\n         address.address2\\n         address.district\\n         address.city_id\\n         address.postal_code\\n         address.phone\\n         address.last_update\\n      where\\n         and\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create one record in your address table in your sakila database without authorization. Log invocation"},{"role":"assistant","content":".arguments\\n\\n   // address column value\\n   address:string\\n\\n   // address2 column value\\n   address2:string\\n\\n   // district column value\\n   district:string\\n\\n   // city_id column value\\n   city_id:long\\n\\n   // postal_code column value\\n   postal_code:string\\n\\n   // phone column value\\n   phone:string\\n\\n   // last_update column value\\n   last_update:date\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-create\\n\\n// Columns with custom handling as we generate a frontend\\n.handling\\n   phone:phone\\n\\n// Logging invocation.\\nauth.ticket.get\\nlambda2hyper:x:@.arguments/*\\nlog.info:sakila.address entry created\\n   username:x:@auth.ticket.get\\n   arguments:x:@lambda2hyper\\n\\n// Opening up database connection.\\ndata.connect:[generic|sakila]\\n   database-type:sqlite\\n\\n   // Parametrising our create invocation.\\n   add:x:./*/data.create/*/values\\n      get-nodes:x:@.arguments/*\\n\\n   // Creating our record.\\n   data.create\\n      database-type:sqlite\\n      table:address\\n      return-id:bool:true\\n      values\\n\\n   // Returning the correct status code.\\n   response.status.set:201\\n\\n   // Returning result of above invocation to caller.\\n   unwrap:x:+/*\\n   return\\n      id:x:@data.create\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Update one record in your address table in your sakila database without authorization. Log invocation"},{"role":"assistant","content":".arguments\\n\\n   // address_id column value being primary key of record to update, mandatory argument\\n   address_id:long\\n\\n   // address column's new value\\n   address:string\\n\\n   // district column's new value\\n   district:string\\n\\n   // city_id column's new value\\n   city_id:long\\n\\n   // phone column's new value\\n   phone:string\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-update\\n\\n// Columns with custom handling as we generate a frontend\\n.handling\\n   phone:phone\\n\\n// Sanity checking invocation, making sure primary key(s) are specified.\\nvalidators.mandatory:x:@.arguments/*/address_id\\n\\n// Logging invocation.\\nauth.ticket.get\\nlambda2hyper:x:@.arguments/*\\nlog.info:sakila.address entry updated\\n   username:x:@auth.ticket.get\\n   arguments:x:@lambda2hyper\\n\\n// Opening up our database connection.\\ndata.connect:[generic|sakila]\\n   database-type:sqlite\\n\\n   // Parametrising our invocation.\\n   add:x:./*/data.update/*/values\\n      get-nodes:x:@.arguments/*/[1,1000]\\n   add:x:./*/data.update/*/where/*/and\\n      get-nodes:x:@.arguments/*/[0,1]\\n\\n   // Invoking our update slot.\\n   data.update\\n      database-type:sqlite\\n      table:address\\n      values\\n      where\\n         and\\n\\n   // Verifying record exists.\\n   if\\n      eq\\n         get-value:x:@data.update\\n         .:int:0\\n      .lambda\\n         response.status.set:404\\n         return\\n            result:Record not found\\n\\n   // Returning the correct status code.\\n   response.status.set:202\\n\\n   // Returning success to caller.\\n   unwrap:x:+/*\\n   return\\n      affected:x:@data.update\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Count unique and distinct items from your category table in your sakila database without authorization"},{"role":"assistant","content":".arguments\\n\\n   // Argument is mandatory and must be in the format of TABLE_NAME.COLUMN_NAME\\n   distinct_column:string\\n\\n   // Optional logical operator for filtering arguments, can be either 'or' or 'and'. Defaults to and.\\n   operator:string\\n   category.category_id.mt:long\\n   category.category_id.lt:long\\n   category.category_id.mteq:long\\n   category.category_id.lteq:long\\n   category.category_id.neq:long\\n   category.category_id.eq:long\\n   category.name.like:string\\n   category.name.mt:string\\n   category.name.lt:string\\n   category.name.mteq:string\\n   category.name.lteq:string\\n   category.name.neq:string\\n   category.name.eq:string\\n   category.last_update.mt:date\\n   category.last_update.lt:date\\n   category.last_update.mteq:date\\n   category.last_update.lteq:date\\n   category.last_update.neq:date\\n   category.last_update.eq:date\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-count-distinct\\n\\n// Sanity checking that distinct column was passed in.\\nvalidators.mandatory:x:@.arguments/*/distinct_column\\n\\n// Sanity checking distinct column's name.\\nvalidators.enum:x:@.arguments/*/distinct_column\\n   .:category.category_id\\n   .:category.name\\n   .:category.last_update\\n\\n// Sanity checking invocation.\\nvalidators.enum:x:@.arguments/*/operator\\n   .:or\\n   .:and\\n\\n/*\\n * Checking if user supplied an [operator] argument, and if so\\n * changing the boolean operator for comparison operations.\\n */\\nif\\n   exists:x:@.arguments/*/operator\\n   .lambda\\n\\n      // User provided a boolean comparison [operator] argument.\\n      set-name:x:../*/data.connect/*/data.read/*/where/0\\n         get-value:x:@.arguments/*/operator\\n      remove-nodes:x:@.arguments/*/operator\\n\\n// Opening up our database connection.\\ndata.connect:[generic|sakila]\\n   database-type:sqlite\\n\\n   // Making sure we're using correct function.\\n   set-name:x:./*/data.read/*/columns/*/distinct_functor\\n      strings.concat\\n         .:\"count(distinct \"\\n         get-value:x:@.arguments/*/distinct_column\\n         .:)\\n\\n   // Removing distinct argument to simplify adding other arguments.\\n   remove-nodes:x:@.arguments/*/distinct_column\\n\\n   // Adding filtering arguments.\\n   add:x:+/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:sqlite\\n      table:category\\n      columns\\n         distinct_functor\\n            as:count\\n      where\\n         and\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Counts items from your category table in your sakila database without authorization"},{"role":"assistant","content":".arguments\\n\\n   // Optional logical operator for filtering arguments, can be either 'or' or 'and'. Defaults to and.\\n   operator:string\\n   category.category_id.mt:long\\n   category.category_id.lt:long\\n   category.category_id.mteq:long\\n   category.category_id.lteq:long\\n   category.category_id.neq:long\\n   category.category_id.eq:long\\n   category.name.like:string\\n   category.name.mt:string\\n   category.name.lt:string\\n   category.name.mteq:string\\n   category.name.lteq:string\\n   category.name.neq:string\\n   category.name.eq:string\\n   category.last_update.mt:date\\n   category.last_update.lt:date\\n   category.last_update.mteq:date\\n   category.last_update.lteq:date\\n   category.last_update.neq:date\\n   category.last_update.eq:date\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-count\\n\\n// Sanity checking invocation.\\nvalidators.enum:x:@.arguments/*/operator\\n   .:or\\n   .:and\\n\\n/*\\n * Checking if user supplied an [operator] argument, and if so\\n * changing the boolean operator for comparison operations.\\n */\\nif\\n   exists:x:@.arguments/*/operator\\n   .lambda\\n\\n      // User provided a boolean comparison [operator] argument.\\n      set-name:x:../*/data.connect/*/data.read/*/where/0\\n         get-value:x:@.arguments/*/operator\\n      remove-nodes:x:@.arguments/*/operator\\n\\n// Opening up our database connection.\\ndata.connect:[generic|sakila]\\n   database-type:sqlite\\n\\n   // Adding filtering arguments.\\n   add:x:+/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:sqlite\\n      table:category\\n      columns\\n         count(*)\\n            as:count\\n      where\\n         and\\n      limit:long:1\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns unique and distinct values from your category table in your sakila database without authorization"},{"role":"assistant","content":".arguments\\n\\n   // Name of column to return unique and distinct values for. Argument is mandatory and must be in the format of TABLE_NAME.COLUMN_NAME\\n   distinct_column:string\\n\\n   // Number of records to return, defaults to 25 if not specified. Pass in -1 to return all records.\\n   limit:long\\n\\n   // Offset into the dataset of where to start retrieving records\\n   offset:long\\n\\n   // Fully qualified name of column to order by, must be in TABLE_NAME.COLUMN_NAME format\\n   order:string\\n\\n   // What direction to order, can be 'asc' or 'desc' implying ascending and descending\\n   direction:string\\n\\n   // Optional logical operator for filtering arguments, can be either 'or' or 'and'. Defaults to and.\\n   operator:string\\n   category.category_id.mt:long\\n   category.category_id.lt:long\\n   category.category_id.mteq:long\\n   category.category_id.lteq:long\\n   category.category_id.neq:long\\n   category.category_id.eq:long\\n   category.name.like:string\\n   category.name.mt:string\\n   category.name.lt:string\\n   category.name.mteq:string\\n   category.name.lteq:string\\n   category.name.neq:string\\n   category.name.eq:string\\n   category.last_update.mt:date\\n   category.last_update.lt:date\\n   category.last_update.mteq:date\\n   category.last_update.lteq:date\\n   category.last_update.neq:date\\n   category.last_update.eq:date\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-distinct\\n\\n// Sanity checking that distinct column was passed in.\\nvalidators.mandatory:x:@.arguments/*/distinct_column\\n\\n// Sanity checking distinct column's name.\\nvalidators.enum:x:@.arguments/*/distinct_column\\n   .:category.category_id\\n   .:category.name\\n   .:category.last_update\\n\\n// Sanity checking invocation.\\nvalidators.enum:x:@.arguments/*/operator\\n   .:or\\n   .:and\\n\\n/*\\n * Checking if user supplied an [operator] argument, and if so\\n * changing the boolean operator for comparison operations.\\n */\\nif\\n   exists:x:@.arguments/*/operator\\n   .lambda\\n\\n      // User provided a boolean comparison [operator] argument.\\n      set-name:x:../*/data.connect/*/data.read/*/where/0\\n         get-value:x:@.arguments/*/operator\\n      remove-nodes:x:@.arguments/*/operator\\n\\n// Opening up our database connection.\\ndata.connect:[generic|sakila]\\n   database-type:sqlite\\n\\n   // Making sure we're using correct function.\\n   set-name:x:./*/data.read/*/columns/*/distinct_functor\\n      strings.concat\\n         .:distinct(\\n         get-value:x:@.arguments/*/distinct_column\\n         .:)\\n\\n   // Removing distinct argument to simplify adding other arguments.\\n   remove-nodes:x:@.arguments/*/distinct_column\\n\\n   // Adding [limit] and [offset] arguments\\n   add:x:./*/data.read\\n      get-nodes:x:@.arguments/*/limit\\n      get-nodes:x:@.arguments/*/offset\\n      get-nodes:x:@.arguments/*/order\\n      get-nodes:x:@.arguments/*/direction\\n   remove-nodes:x:@.arguments/*/order\\n   remove-nodes:x:@.arguments/*/direction\\n   remove-nodes:x:@.arguments/*/limit\\n   remove-nodes:x:@.arguments/*/offset\\n\\n   // Adding filtering arguments.\\n   add:x:+/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:sqlite\\n      table:category\\n      columns\\n         distinct_functor\\n            as:.\\n      where\\n         and\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns minimum, maximum, average, sum or count from your category table in your sakila database grouped by a column without authorization"},{"role":"assistant","content":".arguments\\n\\n   // Mandatory argument being column to group by and must be in the format of TABLE_NAME.COLUMN_NAME\\n   group_column:string\\n\\n   // Number of records to return, defaults to 25 if not specified. Pass in -1 to return all records.\\n   limit:long\\n\\n   // Offset into the dataset of where to start retrieving records\\n   offset:long\\n\\n   // Fully qualified name of column to order by, must be in TABLE_NAME.COLUMN_NAME format\\n   order:string\\n\\n   // What direction to order, can be 'asc' or 'desc' implying ascending and descending\\n   direction:string\\n\\n   // Function to aggregate upon. Argument is mandatory and legal values are min, max, sum, avg or count\\n   aggregate_function:string\\n\\n   // Argument is mandatory and must be in the format of TABLE_NAME.COLUMN_NAME.\\n   aggregate_column:string\\n\\n   // Optional logical operator for filtering arguments, can be either 'or' or 'and'. Defaults to and.\\n   operator:string\\n   category.category_id.mt:long\\n   category.category_id.lt:long\\n   category.category_id.mteq:long\\n   category.category_id.lteq:long\\n   category.category_id.neq:long\\n   category.category_id.eq:long\\n   category.name.like:string\\n   category.name.mt:string\\n   category.name.lt:string\\n   category.name.mteq:string\\n   category.name.lteq:string\\n   category.name.neq:string\\n   category.name.eq:string\\n   category.last_update.mt:date\\n   category.last_update.lt:date\\n   category.last_update.mteq:date\\n   category.last_update.lteq:date\\n   category.last_update.neq:date\\n   category.last_update.eq:date\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-group\\n\\n// Sanity checking mandatory arguments.\\nvalidators.mandatory:x:@.arguments/*/group_column\\nvalidators.mandatory:x:@.arguments/*/aggregate_function\\nvalidators.mandatory:x:@.arguments/*/aggregate_column\\n\\n// Sanity checking name of aggregate function.\\nvalidators.enum:x:@.arguments/*/aggregate_function\\n   .:min\\n   .:max\\n   .:sum\\n   .:avg\\n   .:count\\n\\n// Sanity checking group column.\\nvalidators.enum:x:@.arguments/*/group_column\\n   .:category.category_id\\n   .:category.name\\n   .:category.last_update\\n\\n// Sanity checking agggregate column name.\\nvalidators.enum:x:@.arguments/*/aggregate_column\\n   .:category.category_id\\n   .:category.name\\n   .:category.last_update\\n\\n// Sanity checking invocation.\\nvalidators.enum:x:@.arguments/*/operator\\n   .:or\\n   .:and\\n\\n/*\\n * Checking if user supplied an [operator] argument, and if so\\n * changing the boolean operator for comparison operations.\\n */\\nif\\n   exists:x:@.arguments/*/operator\\n   .lambda\\n\\n      // User provided a boolean comparison [operator] argument.\\n      set-name:x:../*/data.connect/*/data.read/*/where/0\\n         get-value:x:@.arguments/*/operator\\n      remove-nodes:x:@.arguments/*/operator\\n\\n// Opening up our database connection.\\ndata.connect:[generic|sakila]\\n   database-type:sqlite\\n\\n   // Making sure we're using the correct group column\\n   set-name:x:@data.connect/*/data.read/*/group/*/group_column\\n      get-value:x:@.arguments/*/group_column\\n\\n   // Making sure we return group column as a part of the result\\n   set-name:x:+/*/*\\n      get-value:x:@.arguments/*/group_column\\n   insert-before:x:@data.connect/*/data.read/*/columns/0\\n      .\\n         group_column\\n\\n   // Changing name of aggregate column returned to caller.\\n   set-value:x:@data.connect/*/data.read/*/columns/1/*/as\\n      get-value:x:@.arguments/*/aggregate_function\\n\\n   // Removing group column to simplify adding other arguments\\n   remove-nodes:x:@.arguments/*/group_column\\n\\n   // Adding paging arguments\\n   add:x:@data.connect/*/data.read\\n      get-nodes:x:@.arguments/*/limit\\n      get-nodes:x:@.arguments/*/offset\\n   remove-nodes:x:@.arguments/*/limit\\n   remove-nodes:x:@.arguments/*/offset\\n\\n   // Parametrising our read invocation with ordering arguments if specified.\\n   add:x:./*/data.read\\n      get-nodes:x:@.arguments/*/order\\n      get-nodes:x:@.arguments/*/direction\\n   remove-nodes:x:@.arguments/*/order\\n   remove-nodes:x:@.arguments/*/direction\\n\\n   // Making sure we're using correct aggregate function.\\n   set-name:x:./*/data.read/*/columns/*/aggregate_functor\\n      strings.concat\\n         get-value:x:@.arguments/*/aggregate_function\\n         .:(\\n         get-value:x:@.arguments/*/aggregate_column\\n         .:)\\n\\n   // Removing aggregate arguments to simplify adding other arguments.\\n   remove-nodes:x:@.arguments/*/[0,2]\\n\\n   // Adding filtering arguments.\\n   add:x:+/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:sqlite\\n      table:category\\n      columns\\n         aggregate_functor\\n            as:result\\n      where\\n         and\\n      group\\n         group_column\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Distinct Keyword Search from category table in sakila database without authorization.\\n\\nThis endpoint will return only records containing one or more of the keywords from the specified [query],\\nwith rows containing the most distinct matched keywords appearing first."},{"role":"assistant","content":".arguments\\n\\n   // Mandatory query for records to search for\\n   query:string\\n\\n   // Optional number of records to return, defaults to 10 if not specified. Pass in -1 to return all records\\n   limit:long\\n\\n   // Optional offset into the dataset of where to start retrieving records\\n   offset:long\\n\\n// Type of endpoint\\n.type:crud-search\\n\\n// Make sure the user has provided a query.\\nvalidators.mandatory:x:@.arguments/*/query\\n\\n// Apply defaults if not specified.\\nvalidators.default:x:@.arguments\\n   limit:long:10\\n\\n// Split the user's query into individual keywords, separated by spaces.\\n.words\\nadd:x:@.words\\n   strings.split:x:@.arguments/*/query\\n      .:\" \"\\n\\n// Enforce lower characters for each keyword, and guard against SQL injection.\\n.no:int:0\\nfor-each:x:@.words/*\\n   set-value:x:@.dp/#\\n      strings.to-lower:x:@.dp/#\\n\\n// Specify which columns to search against.\\n.columns\\n   .:name\\n\\n// Connect to the specified database.\\ndata.connect:[generic|sakila]\\n   database-type:sqlite\\n\\n   // Start building our SQL.\\n   .sql:select *, (\\n\\n   // 1) Dynamically create the full text by concatenating all columns we want to search.\\n   .fields\\n   for-each:x:@.columns/*\\n      strings.concat\\n         .:coalesce(\\n         get-value:x:@.dp/#\\n         .:\", '')\"\\n      unwrap:x:+/*/*\\n      add:x:@.fields\\n         .\\n            .:x:@strings.concat\\n   set-value:x:@.fields\\n      strings.join:x:@.fields/*\\n         .:\" || \"\\n   remove-nodes:x:@.fields/*\\n\\n   // 2) Keyword density calculation\\n   .no:int:0\\n   for-each:x:@.words/*\\n\\n      // Adding SQL parameter.\\n      set-name:x:+/+/*/*\\n         strings.concat\\n            .:@p\\n            get-value:x:@.no\\n      unwrap:x:+/*/*\\n      add:x:@data.connect/*/data.select\\n         .\\n            .:x:@.dp/#\\n\\n      // Modifying our SQL.\\n      if\\n         eq:x:@.no\\n            .:int:0\\n         .lambda\\n\\n            // First keyword => no leading plus\\n            set-value:x:@.sql\\n               strings.concat:x:@.sql\\n                  get-value:x:@.sql\\n                  .:\" (length(\"\\n                  get-value:x:@.fields\\n                  .:) - length(replace(lower(\\n                  get-value:x:@.fields\\n                  .:), @p\\n                  get-value:x:@.no\\n                  .:\", ''))) / length(@p\"\\n                  get-value:x:@.no\\n                  .:)\\n      else\\n         set-value:x:@.sql\\n            strings.concat:x:@.sql\\n               get-value:x:@.sql\\n               .:\" + (length(\"\\n               get-value:x:@.fields\\n               .:) - length(replace(lower(\\n               get-value:x:@.fields\\n               .:), @p\\n               get-value:x:@.no\\n               .:\", ''))) / length(@p\"\\n               get-value:x:@.no\\n               .:)\\n      math.increment:x:@.no\\n   set-value:x:@.sql\\n      strings.concat:x:@.sql\\n         get-value:x:@.sql\\n         .:) * 1.0 / length(\\n         get-value:x:@.fields\\n         .:) as keyword_density, (\\n\\n   // 3) Distinct keyword count => For each keyword, 1 if present, 0 if not.\\n   .no:int:0\\n   for-each:x:@.words/*\\n      if\\n         eq:x:@.no\\n            .:int:0\\n         .lambda\\n\\n            // First keyword => no leading plus\\n            set-value:x:@.sql\\n               strings.concat:x:@.sql\\n                  get-value:x:@.sql\\n                  .:\" CASE WHEN ((length(\"\\n                  get-value:x:@.fields\\n                  .:) - length(replace(lower(\\n                  get-value:x:@.fields\\n                  .:), @p\\n                  get-value:x:@.no\\n                  .:\", ''))) / length(@p\"\\n                  get-value:x:@.no\\n                  .:)) > 0 THEN 1 ELSE 0 END\\n      else\\n         set-value:x:@.sql\\n            strings.concat:x:@.sql\\n               get-value:x:@.sql\\n               .:\" + CASE WHEN ((length(\"\\n               get-value:x:@.fields\\n               .:) - length(replace(lower(\\n               get-value:x:@.fields\\n               .:), @p\\n               get-value:x:@.no\\n               .:\", ''))) / length(@p\"\\n               get-value:x:@.no\\n               .:)) > 0 THEN 1 ELSE 0 END\\n      math.increment:x:@.no\\n\\n   // Finalize \"keyword_count\".\\n   set-value:x:@.sql\\n      strings.concat:x:@.sql\\n         get-value:x:@.sql\\n         .:) as keyword_count\\n\\n   // 4) Finish SELECT + WHERE\\n   set-value:x:@.sql\\n      strings.concat:x:@.sql\\n         get-value:x:@.sql\\n         .:\" from \"\\n         .:category\\n         .:\" where keyword_count > 0\"\\n\\n   // 5) Order by distinct keyword_count (higher means more distinct keywords), then keyword_density.\\n   set-value:x:@.sql\\n      strings.concat:x:@.sql\\n         get-value:x:@.sql\\n         .:\" order by keyword_count desc, keyword_density desc limit \"\\n         get-value:x:@.arguments/*/limit\\n\\n   // (Optional) offset => pagination\\n   if\\n      exists:x:@.arguments/*/offset\\n      .lambda\\n         set-value:x:@.sql\\n            strings.concat:x:@.sql\\n               get-value:x:@.sql\\n               .:\" offset \"\\n               get-value:x:@.arguments/*/offset\\n\\n   // Execute the SQL\\n   data.select:x:@.sql\\n      database-type:sqlite\\n\\n   // Remove helper fields if you don't want them in your final JSON\\n   remove-nodes:x:@data.select/*/*/keyword_density\\n   remove-nodes:x:@data.select/*/*/keyword_count\\n\\n   // Return the final result set\\n   return-nodes:x:@data.select/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Delete one record from your category table in your sakila database without authorization. Log invocation."},{"role":"assistant","content":".arguments\\n\\n   // Primary key of record to delete, mandatory argument\\n   category_id:long\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-delete\\n\\n// Logging invocation.\\nauth.ticket.get\\nlambda2hyper:x:@.arguments/*\\nlog.info:sakila.category entry deleted\\n   username:x:@auth.ticket.get\\n   arguments:x:@lambda2hyper\\nvalidators.mandatory:x:@.arguments/*/category_id\\n\\n// Opening up our database connection.\\ndata.connect:[generic|sakila]\\n   database-type:sqlite\\n\\n   // Parametrising our delete invocation.\\n   add:x:./*/data.delete/*/where/*/and\\n      get-nodes:x:@.arguments/*\\n\\n   // Deleting item from database.\\n   data.delete\\n      database-type:sqlite\\n      table:category\\n      where\\n         and\\n\\n   // Publishing socket message.\\n   add:x:./*/sockets.signal/*/args\\n      get-nodes:x:@.arguments/*\\n   sockets.signal:sakila.category.delete\\n      args\\n\\n   // Returning result of above invocation to caller.\\n   unwrap:x:+/*\\n   return\\n      affected:x:@data.delete\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Read or list records from your category table in your sakila database without authorization"},{"role":"assistant","content":".arguments\\n\\n   // Number of records to return, defaults to 25 if not specified. Pass in -1 to return all records.\\n   limit:long\\n\\n   // Offset into the dataset of where to start retrieving records\\n   offset:long\\n\\n   // Fully qualified name of column to order by, must be in TABLE_NAME.COLUMN_NAME format\\n   order:string\\n\\n   // What direction to order, can be 'asc' or 'desc' implying ascending and descending\\n   direction:string\\n\\n   // Optional logical operator for filtering arguments, can be either 'or' or 'and'. Defaults to and.\\n   operator:string\\n   category.category_id.mt:long\\n   category.category_id.lt:long\\n   category.category_id.mteq:long\\n   category.category_id.lteq:long\\n   category.category_id.neq:long\\n   category.category_id.eq:long\\n   category.name.like:string\\n   category.name.mt:string\\n   category.name.lt:string\\n   category.name.mteq:string\\n   category.name.lteq:string\\n   category.name.neq:string\\n   category.name.eq:string\\n   category.last_update.mt:date\\n   category.last_update.lt:date\\n   category.last_update.mteq:date\\n   category.last_update.lteq:date\\n   category.last_update.neq:date\\n   category.last_update.eq:date\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-read\\n\\n// Sanity checking invocation.\\nvalidators.enum:x:@.arguments/*/operator\\n   .:or\\n   .:and\\n\\n/*\\n * Checking if user supplied an [operator] argument, and if so\\n * changing the boolean operator for comparison operations.\\n */\\nif\\n   exists:x:@.arguments/*/operator\\n   .lambda\\n\\n      // User provided a boolean comparison [operator] argument.\\n      set-name:x:../*/data.connect/*/data.read/*/where/0\\n         get-value:x:@.arguments/*/operator\\n      remove-nodes:x:@.arguments/*/operator\\n\\n// Opening up our database connection.\\ndata.connect:[generic|sakila]\\n   database-type:sqlite\\n\\n   // Parametrising our read invocation with ordering arguments if specified.\\n   add:x:./*/data.read\\n      get-nodes:x:@.arguments/*/order\\n      get-nodes:x:@.arguments/*/direction\\n   remove-nodes:x:@.arguments/*/order\\n   remove-nodes:x:@.arguments/*/direction\\n\\n   // Parametrising our read invocation with paging arguments if specified.\\n   add:x:./*/data.read\\n      get-nodes:x:@.arguments/*/limit\\n      get-nodes:x:@.arguments/*/offset\\n   remove-nodes:x:@.arguments/*/limit\\n   remove-nodes:x:@.arguments/*/offset\\n\\n   // Parametrising our read invocation with filtering arguments.\\n   add:x:./*/data.read/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:sqlite\\n      table:category\\n      columns\\n         category.category_id\\n         category.name\\n         category.last_update\\n      where\\n         and\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Update one record in your category table in your sakila database without authorization. Log invocation."},{"role":"assistant","content":".arguments\\n\\n   // category_id column value being primary key of record to update, mandatory argument\\n   category_id:long\\n\\n   // name column's new value\\n   name:string\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-update\\n\\n// Sanity checking invocation, making sure primary key(s) are specified.\\nvalidators.mandatory:x:@.arguments/*/category_id\\n\\n// Logging invocation.\\nauth.ticket.get\\nlambda2hyper:x:@.arguments/*\\nlog.info:sakila.category entry updated\\n   username:x:@auth.ticket.get\\n   arguments:x:@lambda2hyper\\n\\n// Opening up our database connection.\\ndata.connect:[generic|sakila]\\n   database-type:sqlite\\n\\n   // Parametrising our invocation.\\n   add:x:./*/data.update/*/values\\n      get-nodes:x:@.arguments/*/[1,1000]\\n   add:x:./*/data.update/*/where/*/and\\n      get-nodes:x:@.arguments/*/[0,1]\\n\\n   // Invoking our update slot.\\n   data.update\\n      database-type:sqlite\\n      table:category\\n      values\\n      where\\n         and\\n\\n   // Verifying record exists.\\n   if\\n      eq\\n         get-value:x:@data.update\\n         .:int:0\\n      .lambda\\n         response.status.set:404\\n         return\\n            result:Record not found\\n\\n   // Returning the correct status code.\\n   response.status.set:202\\n\\n   // Publishing socket message.\\n   add:x:./*/sockets.signal/*/args\\n      get-nodes:x:@.arguments/*\\n   sockets.signal:sakila.category.put\\n      args\\n\\n   // Returning success to caller.\\n   unwrap:x:+/*\\n   return\\n      affected:x:@data.update\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns minimum, maximum, average or sum from your city table in your sakila database without authorization and reCAPTCHA and HTTP cache"},{"role":"assistant","content":".arguments\\n\\n   // Function to aggregate upon. Argument is mandatory and legal values are min, max, sum or avg\\n   aggregate_function:string\\n\\n   // Argument is mandatory and must be in the format of TABLE_NAME.COLUMN_NAME.\\n   aggregate_column:string\\n   recaptcha:string\\n   city.city_id.eq:long\\n   city.city.like:string\\n   city.city.eq:string\\n   city.country_id.eq:long\\n   city.last_update.eq:date\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-aggregate\\n\\n// Sanity checking mandatory arguments.\\nvalidators.mandatory:x:@.arguments/*/aggregate_function\\nvalidators.mandatory:x:@.arguments/*/aggregate_column\\n\\n// Sanity checking name of aggregate function.\\nvalidators.enum:x:@.arguments/*/aggregate_function\\n   .:min\\n   .:max\\n   .:sum\\n   .:avg\\n\\n// Sanity checking agggregate column name.\\nvalidators.enum:x:@.arguments/*/aggregate_column\\n   .:city.city_id\\n   .:city.city\\n   .:city.country_id\\n   .:city.last_update\\n\\n// Adding Cache-Control HTTP header.\\nresponse.headers.set\\n   Cache-Control:private, max-age=500\\n\\n// Checking reCAPTCHA value if backend is configured with reCAPTCHA configuration settings.\\nconfig.get:\"magic:auth:recaptcha:key\"\\nconfig.get:\"magic:auth:recaptcha:secret\"\\nif\\n   and\\n      neq:x:@config.get\\n         .\\n      neq:x:@config.get\\n         .:\\n      neq:x:@config.get/@config.get\\n         .\\n      neq:x:@config.get/@config.get\\n         .:\\n   .lambda\\n\\n      // reCAPTCHA configuration settings found.\\n      validators.mandatory:x:@.arguments/*/recaptcha\\n      validators.recaptcha:x:@.arguments/*/recaptcha/[0,1]\\n         site-key:x:@config.get/@config.get\\n         secret:x:@config.get\\n         min:decimal:0.3\\n\\n// To remove reCAPTCHA value preventing it from being used as an argument further down in file.\\nremove-nodes:x:@.arguments/*/recaptcha/[0,1]\\n\\n// Opening up our database connection.\\ndata.connect:[generic|sakila]\\n   database-type:sqlite\\n\\n   // Making sure we're using correct aggregate function.\\n   set-name:x:./*/data.read/*/columns/*/aggregate_functor\\n      strings.concat\\n         get-value:x:@.arguments/*/aggregate_function\\n         .:(\\n         get-value:x:@.arguments/*/aggregate_column\\n         .:)\\n\\n   // Removing aggregate arguments to simplify adding other arguments.\\n   remove-nodes:x:@.arguments/*/[0,2]\\n   add:x:+/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:sqlite\\n      table:city\\n      columns\\n         aggregate_functor\\n            as:result\\n      where\\n         and\\n      limit:long:1\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Count unique and distinct items from your city table in your sakila database without authorization but with reCAPTCHA"},{"role":"assistant","content":".arguments\\n\\n   // Argument is mandatory and must be in the format of TABLE_NAME.COLUMN_NAME\\n   distinct_column:string\\n   recaptcha:string\\n   city.city_id.eq:long\\n   city.city.like:string\\n   city.city.eq:string\\n   city.country_id.eq:long\\n   city.last_update.eq:date\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-count-distinct\\n\\n// Sanity checking that distinct column was passed in.\\nvalidators.mandatory:x:@.arguments/*/distinct_column\\n\\n// Sanity checking distinct column's name.\\nvalidators.enum:x:@.arguments/*/distinct_column\\n   .:city.city_id\\n   .:city.city\\n   .:city.country_id\\n   .:city.last_update\\n\\n// Adding Cache-Control HTTP header.\\nresponse.headers.set\\n   Cache-Control:private, max-age=500\\n\\n// Checking reCAPTCHA value if backend is configured with reCAPTCHA configuration settings.\\nconfig.get:\"magic:auth:recaptcha:key\"\\nconfig.get:\"magic:auth:recaptcha:secret\"\\nif\\n   and\\n      neq:x:@config.get\\n         .\\n      neq:x:@config.get\\n         .:\\n      neq:x:@config.get/@config.get\\n         .\\n      neq:x:@config.get/@config.get\\n         .:\\n   .lambda\\n\\n      // reCAPTCHA configuration settings found.\\n      validators.mandatory:x:@.arguments/*/recaptcha\\n      validators.recaptcha:x:@.arguments/*/recaptcha/[0,1]\\n         site-key:x:@config.get/@config.get\\n         secret:x:@config.get\\n         min:decimal:0.3\\n\\n// To remove reCAPTCHA value preventing it from being used as an argument further down in file.\\nremove-nodes:x:@.arguments/*/recaptcha/[0,1]\\n\\n// Opening up our database connection.\\ndata.connect:[generic|sakila]\\n   database-type:sqlite\\n\\n   // Making sure we're using correct function.\\n   set-name:x:./*/data.read/*/columns/*/distinct_functor\\n      strings.concat\\n         .:\"count(distinct \"\\n         get-value:x:@.arguments/*/distinct_column\\n         .:)\\n\\n   // Removing distinct argument to simplify adding other arguments.\\n   remove-nodes:x:@.arguments/*/distinct_column\\n   add:x:+/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:sqlite\\n      table:city\\n      columns\\n         distinct_functor\\n            as:count\\n      where\\n         and\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Counts items from your city table in your sakila database"},{"role":"assistant","content":".arguments\\n   recaptcha:string\\n   city.city_id.eq:long\\n   city.city.like:string\\n   city.city.eq:string\\n   city.country_id.eq:long\\n   city.last_update.eq:date\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-count\\n\\n// Adding Cache-Control HTTP header.\\nresponse.headers.set\\n   Cache-Control:private, max-age=500\\n\\n// Checking reCAPTCHA value if backend is configured with reCAPTCHA configuration settings.\\nconfig.get:\"magic:auth:recaptcha:key\"\\nconfig.get:\"magic:auth:recaptcha:secret\"\\nif\\n   and\\n      neq:x:@config.get\\n         .\\n      neq:x:@config.get\\n         .:\\n      neq:x:@config.get/@config.get\\n         .\\n      neq:x:@config.get/@config.get\\n         .:\\n   .lambda\\n\\n      // reCAPTCHA configuration settings found.\\n      validators.mandatory:x:@.arguments/*/recaptcha\\n      validators.recaptcha:x:@.arguments/*/recaptcha/[0,1]\\n         site-key:x:@config.get/@config.get\\n         secret:x:@config.get\\n         min:decimal:0.3\\n\\n// To remove reCAPTCHA value preventing it from being used as an argument further down in file.\\nremove-nodes:x:@.arguments/*/recaptcha/[0,1]\\n\\n// Opening up our database connection.\\ndata.connect:[generic|sakila]\\n   database-type:sqlite\\n   add:x:+/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:sqlite\\n      table:city\\n      columns\\n         count(*)\\n            as:count\\n      where\\n         and\\n      limit:long:1\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns unique and distinct values from your city table in your sakila database"},{"role":"assistant","content":".arguments\\n\\n   // Name of column to return unique and distinct values for. Argument is mandatory and must be in the format of TABLE_NAME.COLUMN_NAME\\n   distinct_column:string\\n\\n   // Number of records to return, defaults to 25 if not specified. Pass in -1 to return all records.\\n   limit:long\\n\\n   // Offset into the dataset of where to start retrieving records\\n   offset:long\\n\\n   // Fully qualified name of column to order by, must be in TABLE_NAME.COLUMN_NAME format\\n   order:string\\n\\n   // What direction to order, can be 'asc' or 'desc' implying ascending and descending\\n   direction:string\\n   recaptcha:string\\n   city.city_id.eq:long\\n   city.city.like:string\\n   city.city.eq:string\\n   city.country_id.eq:long\\n   city.last_update.eq:date\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-distinct\\n\\n// Sanity checking that distinct column was passed in.\\nvalidators.mandatory:x:@.arguments/*/distinct_column\\n\\n// Sanity checking distinct column's name.\\nvalidators.enum:x:@.arguments/*/distinct_column\\n   .:city.city_id\\n   .:city.city\\n   .:city.country_id\\n   .:city.last_update\\n\\n// Adding Cache-Control HTTP header.\\nresponse.headers.set\\n   Cache-Control:private, max-age=500\\n\\n// Checking reCAPTCHA value if backend is configured with reCAPTCHA configuration settings.\\nconfig.get:\"magic:auth:recaptcha:key\"\\nconfig.get:\"magic:auth:recaptcha:secret\"\\nif\\n   and\\n      neq:x:@config.get\\n         .\\n      neq:x:@config.get\\n         .:\\n      neq:x:@config.get/@config.get\\n         .\\n      neq:x:@config.get/@config.get\\n         .:\\n   .lambda\\n\\n      // reCAPTCHA configuration settings found.\\n      validators.mandatory:x:@.arguments/*/recaptcha\\n      validators.recaptcha:x:@.arguments/*/recaptcha/[0,1]\\n         site-key:x:@config.get/@config.get\\n         secret:x:@config.get\\n         min:decimal:0.3\\n\\n// To remove reCAPTCHA value preventing it from being used as an argument further down in file.\\nremove-nodes:x:@.arguments/*/recaptcha/[0,1]\\n\\n// Opening up our database connection.\\ndata.connect:[generic|sakila]\\n   database-type:sqlite\\n\\n   // Making sure we're using correct function.\\n   set-name:x:./*/data.read/*/columns/*/distinct_functor\\n      strings.concat\\n         .:distinct(\\n         get-value:x:@.arguments/*/distinct_column\\n         .:)\\n\\n   // Removing distinct argument to simplify adding other arguments.\\n   remove-nodes:x:@.arguments/*/distinct_column\\n\\n   // Adding [limit] and [offset] arguments\\n   add:x:./*/data.read\\n      get-nodes:x:@.arguments/*/limit\\n      get-nodes:x:@.arguments/*/offset\\n      get-nodes:x:@.arguments/*/order\\n      get-nodes:x:@.arguments/*/direction\\n   remove-nodes:x:@.arguments/*/order\\n   remove-nodes:x:@.arguments/*/direction\\n   remove-nodes:x:@.arguments/*/limit\\n   remove-nodes:x:@.arguments/*/offset\\n   add:x:+/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:sqlite\\n      table:city\\n      columns\\n         distinct_functor\\n            as:.\\n      where\\n         and\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns minimum, maximum, average, sum or count from your city table in your sakila database grouped by a column"},{"role":"assistant","content":".arguments\\n\\n   // Mandatory argument being column to group by and must be in the format of TABLE_NAME.COLUMN_NAME\\n   group_column:string\\n\\n   // Number of records to return, defaults to 25 if not specified. Pass in -1 to return all records.\\n   limit:long\\n\\n   // Offset into the dataset of where to start retrieving records\\n   offset:long\\n\\n   // Fully qualified name of column to order by, must be in TABLE_NAME.COLUMN_NAME format\\n   order:string\\n\\n   // What direction to order, can be 'asc' or 'desc' implying ascending and descending\\n   direction:string\\n\\n   // Function to aggregate upon. Argument is mandatory and legal values are min, max, sum, avg or count\\n   aggregate_function:string\\n\\n   // Argument is mandatory and must be in the format of TABLE_NAME.COLUMN_NAME.\\n   aggregate_column:string\\n   recaptcha:string\\n   city.city_id.eq:long\\n   city.city.like:string\\n   city.city.eq:string\\n   city.country_id.eq:long\\n   city.last_update.eq:date\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-group\\n\\n// Sanity checking mandatory arguments.\\nvalidators.mandatory:x:@.arguments/*/group_column\\nvalidators.mandatory:x:@.arguments/*/aggregate_function\\nvalidators.mandatory:x:@.arguments/*/aggregate_column\\n\\n// Sanity checking name of aggregate function.\\nvalidators.enum:x:@.arguments/*/aggregate_function\\n   .:min\\n   .:max\\n   .:sum\\n   .:avg\\n   .:count\\n\\n// Sanity checking group column.\\nvalidators.enum:x:@.arguments/*/group_column\\n   .:city.city_id\\n   .:city.city\\n   .:city.country_id\\n   .:city.last_update\\n\\n// Sanity checking agggregate column name.\\nvalidators.enum:x:@.arguments/*/aggregate_column\\n   .:city.city_id\\n   .:city.city\\n   .:city.country_id\\n   .:city.last_update\\n\\n// Adding Cache-Control HTTP header.\\nresponse.headers.set\\n   Cache-Control:private, max-age=500\\n\\n// Checking reCAPTCHA value if backend is configured with reCAPTCHA configuration settings.\\nconfig.get:\"magic:auth:recaptcha:key\"\\nconfig.get:\"magic:auth:recaptcha:secret\"\\nif\\n   and\\n      neq:x:@config.get\\n         .\\n      neq:x:@config.get\\n         .:\\n      neq:x:@config.get/@config.get\\n         .\\n      neq:x:@config.get/@config.get\\n         .:\\n   .lambda\\n\\n      // reCAPTCHA configuration settings found.\\n      validators.mandatory:x:@.arguments/*/recaptcha\\n      validators.recaptcha:x:@.arguments/*/recaptcha/[0,1]\\n         site-key:x:@config.get/@config.get\\n         secret:x:@config.get\\n         min:decimal:0.3\\n\\n// To remove reCAPTCHA value preventing it from being used as an argument further down in file.\\nremove-nodes:x:@.arguments/*/recaptcha/[0,1]\\n\\n// Opening up our database connection.\\ndata.connect:[generic|sakila]\\n   database-type:sqlite\\n\\n   // Making sure we're using the correct group column\\n   set-name:x:@data.connect/*/data.read/*/group/*/group_column\\n      get-value:x:@.arguments/*/group_column\\n\\n   // Making sure we return group column as a part of the result\\n   set-name:x:+/*/*\\n      get-value:x:@.arguments/*/group_column\\n   insert-before:x:@data.connect/*/data.read/*/columns/0\\n      .\\n         group_column\\n\\n   // Changing name of aggregate column returned to caller.\\n   set-value:x:@data.connect/*/data.read/*/columns/1/*/as\\n      get-value:x:@.arguments/*/aggregate_function\\n\\n   // Removing group column to simplify adding other arguments\\n   remove-nodes:x:@.arguments/*/group_column\\n\\n   // Adding paging arguments\\n   add:x:@data.connect/*/data.read\\n      get-nodes:x:@.arguments/*/limit\\n      get-nodes:x:@.arguments/*/offset\\n   remove-nodes:x:@.arguments/*/limit\\n   remove-nodes:x:@.arguments/*/offset\\n\\n   // Parametrising our read invocation with ordering arguments if specified.\\n   add:x:./*/data.read\\n      get-nodes:x:@.arguments/*/order\\n      get-nodes:x:@.arguments/*/direction\\n   remove-nodes:x:@.arguments/*/order\\n   remove-nodes:x:@.arguments/*/direction\\n\\n   // Making sure we're using correct aggregate function.\\n   set-name:x:./*/data.read/*/columns/*/aggregate_functor\\n      strings.concat\\n         get-value:x:@.arguments/*/aggregate_function\\n         .:(\\n         get-value:x:@.arguments/*/aggregate_column\\n         .:)\\n\\n   // Removing aggregate arguments to simplify adding other arguments.\\n   remove-nodes:x:@.arguments/*/[0,2]\\n   add:x:+/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:sqlite\\n      table:city\\n      columns\\n         aggregate_functor\\n            as:result\\n      where\\n         and\\n      group\\n         group_column\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Distinct Keyword Search from city table in sakila database.\\n\\nThis endpoint will return only records containing one or more of the keywords from the specified [query],\\nwith rows containing the most distinct matched keywords appearing first."},{"role":"assistant","content":".arguments\\n\\n   // Mandatory query for records to search for\\n   query:string\\n\\n   // Optional number of records to return, defaults to 10 if not specified. Pass in -1 to return all records\\n   limit:long\\n\\n   // Optional offset into the dataset of where to start retrieving records\\n   offset:long\\n\\n// Type of endpoint\\n.type:crud-search\\n\\n// Make sure the user has provided a query.\\nvalidators.mandatory:x:@.arguments/*/query\\n\\n// Apply defaults if not specified.\\nvalidators.default:x:@.arguments\\n   limit:long:10\\n\\n// Split the user's query into individual keywords, separated by spaces.\\n.words\\nadd:x:@.words\\n   strings.split:x:@.arguments/*/query\\n      .:\" \"\\n\\n// Enforce lower characters for each keyword, and guard against SQL injection.\\n.no:int:0\\nfor-each:x:@.words/*\\n   set-value:x:@.dp/#\\n      strings.to-lower:x:@.dp/#\\n\\n// Specify which columns to search against.\\n.columns\\n   .:city\\n\\n// Connect to the specified database.\\ndata.connect:[generic|sakila]\\n   database-type:sqlite\\n\\n   // Start building our SQL.\\n   .sql:select *, (\\n\\n   // 1) Dynamically create the full text by concatenating all columns we want to search.\\n   .fields\\n   for-each:x:@.columns/*\\n      strings.concat\\n         .:coalesce(\\n         get-value:x:@.dp/#\\n         .:\", '')\"\\n      unwrap:x:+/*/*\\n      add:x:@.fields\\n         .\\n            .:x:@strings.concat\\n   set-value:x:@.fields\\n      strings.join:x:@.fields/*\\n         .:\" || \"\\n   remove-nodes:x:@.fields/*\\n\\n   // 2) Keyword density calculation\\n   .no:int:0\\n   for-each:x:@.words/*\\n\\n      // Adding SQL parameter.\\n      set-name:x:+/+/*/*\\n         strings.concat\\n            .:@p\\n            get-value:x:@.no\\n      unwrap:x:+/*/*\\n      add:x:@data.connect/*/data.select\\n         .\\n            .:x:@.dp/#\\n\\n      // Modifying our SQL.\\n      if\\n         eq:x:@.no\\n            .:int:0\\n         .lambda\\n\\n            // First keyword => no leading plus\\n            set-value:x:@.sql\\n               strings.concat:x:@.sql\\n                  get-value:x:@.sql\\n                  .:\" (length(\"\\n                  get-value:x:@.fields\\n                  .:) - length(replace(lower(\\n                  get-value:x:@.fields\\n                  .:), @p\\n                  get-value:x:@.no\\n                  .:\", ''))) / length(@p\"\\n                  get-value:x:@.no\\n                  .:)\\n      else\\n         set-value:x:@.sql\\n            strings.concat:x:@.sql\\n               get-value:x:@.sql\\n               .:\" + (length(\"\\n               get-value:x:@.fields\\n               .:) - length(replace(lower(\\n               get-value:x:@.fields\\n               .:), @p\\n               get-value:x:@.no\\n               .:\", ''))) / length(@p\"\\n               get-value:x:@.no\\n               .:)\\n      math.increment:x:@.no\\n   set-value:x:@.sql\\n      strings.concat:x:@.sql\\n         get-value:x:@.sql\\n         .:) * 1.0 / length(\\n         get-value:x:@.fields\\n         .:) as keyword_density, (\\n\\n   // 3) Distinct keyword count => For each keyword, 1 if present, 0 if not.\\n   .no:int:0\\n   for-each:x:@.words/*\\n      if\\n         eq:x:@.no\\n            .:int:0\\n         .lambda\\n\\n            // First keyword => no leading plus\\n            set-value:x:@.sql\\n               strings.concat:x:@.sql\\n                  get-value:x:@.sql\\n                  .:\" CASE WHEN ((length(\"\\n                  get-value:x:@.fields\\n                  .:) - length(replace(lower(\\n                  get-value:x:@.fields\\n                  .:), @p\\n                  get-value:x:@.no\\n                  .:\", ''))) / length(@p\"\\n                  get-value:x:@.no\\n                  .:)) > 0 THEN 1 ELSE 0 END\\n      else\\n         set-value:x:@.sql\\n            strings.concat:x:@.sql\\n               get-value:x:@.sql\\n               .:\" + CASE WHEN ((length(\"\\n               get-value:x:@.fields\\n               .:) - length(replace(lower(\\n               get-value:x:@.fields\\n               .:), @p\\n               get-value:x:@.no\\n               .:\", ''))) / length(@p\"\\n               get-value:x:@.no\\n               .:)) > 0 THEN 1 ELSE 0 END\\n      math.increment:x:@.no\\n\\n   // Finalize \"keyword_count\".\\n   set-value:x:@.sql\\n      strings.concat:x:@.sql\\n         get-value:x:@.sql\\n         .:) as keyword_count\\n\\n   // 4) Finish SELECT + WHERE\\n   set-value:x:@.sql\\n      strings.concat:x:@.sql\\n         get-value:x:@.sql\\n         .:\" from \"\\n         .:city\\n         .:\" where keyword_count > 0\"\\n\\n   // 5) Order by distinct keyword_count (higher means more distinct keywords), then keyword_density.\\n   set-value:x:@.sql\\n      strings.concat:x:@.sql\\n         get-value:x:@.sql\\n         .:\" order by keyword_count desc, keyword_density desc limit \"\\n         get-value:x:@.arguments/*/limit\\n\\n   // (Optional) offset => pagination\\n   if\\n      exists:x:@.arguments/*/offset\\n      .lambda\\n         set-value:x:@.sql\\n            strings.concat:x:@.sql\\n               get-value:x:@.sql\\n               .:\" offset \"\\n               get-value:x:@.arguments/*/offset\\n\\n   // Execute the SQL\\n   data.select:x:@.sql\\n      database-type:sqlite\\n\\n   // Remove helper fields if you don't want them in your final JSON\\n   remove-nodes:x:@data.select/*/*/keyword_density\\n   remove-nodes:x:@data.select/*/*/keyword_count\\n\\n   // Return the final result set\\n   return-nodes:x:@data.select/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Read or list records from your city table in your sakila database"},{"role":"assistant","content":".arguments\\n\\n   // Number of records to return, defaults to 25 if not specified. Pass in -1 to return all records.\\n   limit:long\\n\\n   // Offset into the dataset of where to start retrieving records\\n   offset:long\\n\\n   // Fully qualified name of column to order by, must be in TABLE_NAME.COLUMN_NAME format\\n   order:string\\n\\n   // What direction to order, can be 'asc' or 'desc' implying ascending and descending\\n   direction:string\\n   recaptcha:string\\n   city.city_id.eq:long\\n   city.city.like:string\\n   city.city.eq:string\\n   city.country_id.eq:long\\n   city.last_update.eq:date\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-read\\n\\n// Adding Cache-Control HTTP header.\\nresponse.headers.set\\n   Cache-Control:private, max-age=500\\n\\n// Checking reCAPTCHA value if backend is configured with reCAPTCHA configuration settings.\\nconfig.get:\"magic:auth:recaptcha:key\"\\nconfig.get:\"magic:auth:recaptcha:secret\"\\nif\\n   and\\n      neq:x:@config.get\\n         .\\n      neq:x:@config.get\\n         .:\\n      neq:x:@config.get/@config.get\\n         .\\n      neq:x:@config.get/@config.get\\n         .:\\n   .lambda\\n\\n      // reCAPTCHA configuration settings found.\\n      validators.mandatory:x:@.arguments/*/recaptcha\\n      validators.recaptcha:x:@.arguments/*/recaptcha/[0,1]\\n         site-key:x:@config.get/@config.get\\n         secret:x:@config.get\\n         min:decimal:0.3\\n\\n// To remove reCAPTCHA value preventing it from being used as an argument further down in file.\\nremove-nodes:x:@.arguments/*/recaptcha/[0,1]\\n\\n// Opening up our database connection.\\ndata.connect:[generic|sakila]\\n   database-type:sqlite\\n\\n   // Parametrising our read invocation with ordering arguments if specified.\\n   add:x:./*/data.read\\n      get-nodes:x:@.arguments/*/order\\n      get-nodes:x:@.arguments/*/direction\\n   remove-nodes:x:@.arguments/*/order\\n   remove-nodes:x:@.arguments/*/direction\\n\\n   // Parametrising our read invocation with paging arguments if specified.\\n   add:x:./*/data.read\\n      get-nodes:x:@.arguments/*/limit\\n      get-nodes:x:@.arguments/*/offset\\n   remove-nodes:x:@.arguments/*/limit\\n   remove-nodes:x:@.arguments/*/offset\\n\\n   // Parametrising our read invocation with filtering arguments.\\n   add:x:./*/data.read/*/where/*\\n      get-nodes:x:@.arguments/*\\n\\n   // Reading data from database.\\n   data.read\\n      database-type:sqlite\\n      table:city\\n      columns\\n         city.city_id\\n         city.city\\n         city.country_id\\n         city.last_update\\n      where\\n         and\\n\\n   // Returning result of above read invocation to caller.\\n   return-nodes:x:@data.read/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Create one record in your city table in your sakila database"},{"role":"assistant","content":".arguments\\n   recaptcha:string\\n\\n   // city column value\\n   city:string\\n\\n   // country_id column value\\n   country_id:long\\n\\n   // last_update column value\\n   last_update:date\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-create\\n\\n// Checking reCAPTCHA value if backend is configured with reCAPTCHA configuration settings.\\nconfig.get:\"magic:auth:recaptcha:key\"\\nconfig.get:\"magic:auth:recaptcha:secret\"\\nif\\n   and\\n      neq:x:@config.get\\n         .\\n      neq:x:@config.get\\n         .:\\n      neq:x:@config.get/@config.get\\n         .\\n      neq:x:@config.get/@config.get\\n         .:\\n   .lambda\\n\\n      // reCAPTCHA configuration settings found.\\n      validators.mandatory:x:@.arguments/*/recaptcha\\n      validators.recaptcha:x:@.arguments/*/recaptcha/[0,1]\\n         site-key:x:@config.get/@config.get\\n         secret:x:@config.get\\n         min:decimal:0.3\\n\\n// To remove reCAPTCHA value preventing it from being used as an argument further down in file.\\nremove-nodes:x:@.arguments/*/recaptcha/[0,1]\\n\\n// Opening up database connection.\\ndata.connect:[generic|sakila]\\n   database-type:sqlite\\n\\n   // Parametrising our create invocation.\\n   add:x:./*/data.create/*/values\\n      get-nodes:x:@.arguments/*\\n\\n   // Creating our record.\\n   data.create\\n      database-type:sqlite\\n      table:city\\n      return-id:bool:true\\n      values\\n\\n   // Returning the correct status code.\\n   response.status.set:201\\n\\n   // Returning result of above invocation to caller.\\n   unwrap:x:+/*\\n   return\\n      id:x:@data.create\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Update one record in your city table in your sakila database"},{"role":"assistant","content":".arguments\\n   recaptcha:string\\n\\n   // city_id column value being primary key of record to update, mandatory argument\\n   city_id:long\\n\\n   // city column's new value\\n   city:string\\n\\n   // country_id column's new value\\n   country_id:long\\n\\n// Meta data description for endpoint\\n\\n// Type of endpoint\\n.type:crud-update\\n\\n// Sanity checking invocation, making sure primary key(s) are specified.\\nvalidators.mandatory:x:@.arguments/*/city_id\\n\\n// Checking reCAPTCHA value if backend is configured with reCAPTCHA configuration settings.\\nconfig.get:\"magic:auth:recaptcha:key\"\\nconfig.get:\"magic:auth:recaptcha:secret\"\\nif\\n   and\\n      neq:x:@config.get\\n         .\\n      neq:x:@config.get\\n         .:\\n      neq:x:@config.get/@config.get\\n         .\\n      neq:x:@config.get/@config.get\\n         .:\\n   .lambda\\n\\n      // reCAPTCHA configuration settings found.\\n      validators.mandatory:x:@.arguments/*/recaptcha\\n      validators.recaptcha:x:@.arguments/*/recaptcha/[0,1]\\n         site-key:x:@config.get/@config.get\\n         secret:x:@config.get\\n         min:decimal:0.3\\n\\n// To remove reCAPTCHA value preventing it from being used as an argument further down in file.\\nremove-nodes:x:@.arguments/*/recaptcha/[0,1]\\n\\n// Opening up our database connection.\\ndata.connect:[generic|sakila]\\n   database-type:sqlite\\n\\n   // Parametrising our invocation.\\n   add:x:./*/data.update/*/values\\n      get-nodes:x:@.arguments/*/[1,1000]\\n   add:x:./*/data.update/*/where/*/and\\n      get-nodes:x:@.arguments/*/[0,1]\\n\\n   // Invoking our update slot.\\n   data.update\\n      database-type:sqlite\\n      table:city\\n      values\\n      where\\n         and\\n\\n   // Verifying record exists.\\n   if\\n      eq\\n         get-value:x:@data.update\\n         .:int:0\\n      .lambda\\n         response.status.set:404\\n         return\\n            result:Record not found\\n\\n   // Returning the correct status code.\\n   response.status.set:202\\n\\n   // Returning success to caller.\\n   unwrap:x:+/*\\n   return\\n      affected:x:@data.update\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Counts usage of slots in our training material\\n\\nReturns all slots, and how many times each slot is mentioned in training material"},{"role":"assistant","content":".arguments\\n.type:public\\n\\n// Used as buffer to hold result.\\n.result\\n\\n// Fetching vocabulary of server.\\nvocabulary\\n\\n// Iterating through each slot\\nfor-each:x:@vocabulary/*\\n\\n   // Executing file that actually counts how many instances we can find of slot.\\n   execute-file:/modules/fine-tune-hyperlambda/api/hyperlambda-search-count.get.hl\\n      query:x:@.dp/#\\n\\n   // Adding result of above invocation to [.result] folder.\\n   set-name:x:+/+/*/*\\n      get-value:x:@.dp/#\\n   unwrap:x:+/*/*\\n   add:x:@.result\\n      .\\n         .:x:@execute-file/*/count\\n\\n// Sorting result.\\nsort:x:@.result/*\\n   if\\n      lt:x:@.lhs/#\\n         get-value:x:@.rhs/#\\n      .lambda\\n         set-value:x:@.result\\n            .:int:-1\\n   else-if\\n      mt:x:@.lhs/#\\n         get-value:x:@.rhs/#\\n      .lambda\\n         set-value:x:@.result\\n            .:int:1\\n   else\\n      set-value:x:@.result\\n         .:int:0\\n\\n// Returning result to caller.\\nreturn-nodes:x:@sort/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Creates JSONL training data for all data we've got in our database\\n\\nYou have to manually download the data after generating it."},{"role":"assistant","content":".arguments\\n.type:public\\n\\n// Buffer for snippets.\\n.result:\\n\\n// Buffer for validation snippets.\\n.validation:\\n\\n// Counter to ensure every 8th record becomes a validation snippet and not a training snippet.\\n.no:int:0\\n\\n// Retrieving all snippets.\\ndata.connect:fine-tune\\n   data.select:select * from hyperlambda\\n\\n   // Iterating through snippets to generate training data.\\n   for-each:x:@data.select/*\\n\\n      // Generating training record, starting with prompt.\\n      .prompt\\n      set-value:x:@.prompt\\n         get-value:x:@.dp/#/*/prompt\\n\\n      // Then completion.\\n      .completion\\n      set-value:x:@.completion\\n         get-value:x:@.dp/#/*/code\\n\\n      // Replacing CR and LF characters.\\n      set-value:x:@.prompt\\n         strings.replace:x:@.prompt\\n            .:\"\\n\"\\n            .:\"\\\\n\"\\n      set-value:x:@.prompt\\n         strings.replace:x:@.prompt\\n            .:\"\\r\"\\n      set-value:x:@.completion\\n         strings.replace:x:@.completion\\n            .:\"\\n\"\\n            .:\"\\\\n\"\\n      set-value:x:@.completion\\n         strings.replace:x:@.completion\\n            .:\"\\r\"\\n      unwrap:x:+/**\\n      .data\\n         messages\\n            .\\n               role:system\\n               content:You are a Hyperlambda coding assistant. Respond with Hyperlambda code.\\n            .\\n               role:user\\n               content:x:@.prompt\\n            .\\n               role:assistant\\n               content:x:@.completion\\n\\n      // Adding training data to above [.result].\\n      if\\n         eq\\n            math.modulo:x:@.no\\n               .:int:8\\n            .:int:0\\n         .lambda\\n            set-value:x:@.validation\\n               strings.concat\\n                  get-value:x:@.validation\\n                  lambda2json:x:@.data/*\\n                  .:\"\\n\"\\n      else\\n         set-value:x:@.result\\n            strings.concat\\n               get-value:x:@.result\\n               lambda2json:x:@.data/*\\n               .:\"\\n\"\\n      math.increment:x:@.no\\n\\n// Saving files.\\nio.file.save:/modules/fine-tune-hyperlambda/training-material.jsonl\\n   get-value:x:@.result\\nio.file.save:/modules/fine-tune-hyperlambda/training-material-validation.jsonl\\n   get-value:x:@.validation\\n\\n// Returning result to caller.\\nreturn\\n   result:Success\\n   message:\"Your training data can be found in '/modules/fine-tune/training-material.jsonl'\"\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Creates training data and inserts into fine-tuning database such that it can be exported later.\\n\\nIf this function returns nothing, we are done, and we have generated training data for every single Hyperlambda file in your cloudlet."},{"role":"assistant","content":".arguments\\n\\n   // Mandatory argument being file number to generate training data for. When listing Hyperlambda files, this will generate training data for the nth file listed, allowing us to loop for as long as have have additional files, incrementing the file-no argument for each iteration.\\n   file-no:int\\n\\n// By making the Hyperlambda file public we can use it as an AI function.\\n.type:public\\n\\n// Listing files recursively.\\nio.file.list-recursively:/\\n\\n// Pruning out everything but Hyperlambda files.\\n.file\\nfor-each:x:@io.file.list-recursively/*\\n   if\\n      strings.ends-with:x:@.dp/#\\n         .:.hl\\n      .lambda\\n         unwrap:x:+/*/*\\n         add:x:@.file\\n            .\\n               .:x:@.dp/#\\n\\n// Checking if we've dealt with all files.\\nif\\n   mt\\n      get-value:x:@.arguments/*/file-no\\n      get-count:x:@.file/*\\n   .lambda\\n      return\\n         result:There are no more files, you have handled all files.\\n\\n// Loading nth file.\\n.hyperlambda\\nstrings.concat\\n   .:@.file/\\n   get-value:x:@.arguments/*/file-no\\nset-x:x:+\\n   convert:x:@strings.concat\\n      type:x\\nio.file.load\\n\\n// Returning Hyperlambda file to caller.\\nyield\\n   hyperlambda:x:@io.file.load\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Inserts training data into database\\n\\nSaves training data for using to fine-tune an LLM."},{"role":"assistant","content":".arguments\\n\\n   // Mandatory prompt used to generate specified Hyperlambda\\n   prompt:string\\n\\n   // Mandatory reference to Hyperlambda file.\\n   file-no:int\\n\\n// Public files can be used as AI functions in machine learning types.\\n.type:public\\n\\n// Getting Hyperlambda.\\nexecute-file:/modules/fine-tune/workflows/create-training-data.hl\\n   file-no:x:@.arguments/*/file-no\\n\\n// Inserting item.\\ndata.connect:fine-tune\\n   data.create\\n      table:hyperlambda\\n      values\\n         prompt:x:@.arguments/*/prompt\\n         code:x:@execute-file/*/hyperlambda\\n\\n// Returning success.\\nreturn\\n   result:success\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Hyperlambda endpoint taking arguments. This SQL query selects media types and their aggregate counts, ordering the results by count in descending order, filtered by a specified name pattern.\\n\\nThe SQL code is executed within a SQLite database connection to the Chinook database. It performs an inner join between the MediaType and Track tables to count the occurrences of each media type. The query filters media types based on a provided pattern using the LIKE operator, groups the results by MediaTypeId, and orders them by the count of tracks associated with each media type in descending order. This allows users to retrieve media type information and their usage frequency, filtered by a specific name pattern, from the Chinook database.\\n\\nAll arguments are mandatory."},{"role":"assistant","content":".arguments\\n   filter:string\\n\\n// Connecting to database.\\ndata.connect:chinook\\n   database-type:sqlite\\n\\n   // Parametrizing [data.select].\\n   add:x:./*/data.select\\n      get-nodes:x:@.arguments/*\\n\\n   // Executing [data.select] slot with our SQL.\\n   data.select:\"\\n/*\\n * Selects media types and aggregate of counts, and orders by count descending.\\n * Make sure you select the chinook database before execxuting the script.\\n */\\nselect mt.Name, count(mt.MediaTypeId) as Amount \\n  from MediaType mt\\n    inner join Track t on mt.MediaTypeId = t.MediaTypeId\\n  where mt.Name like @filter\\n  group by mt.MediaTypeId\\n  order by Amount desc;\\n\"\\n      database-type:sqlite\\n\\n   // Returning a result of above invocation to caller.\\n   return-nodes:x:@data.select/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"This file returns all companies that the specified director is associated with\\n\\ndirector_id is an integer and a mandatory object"},{"role":"assistant","content":".arguments\\n   director_id:long\\n   limit:long\\n   offset:long\\n\\n// Opening database connection.\\ndata.connect:[finovo|finovo]\\n   database-type:pgsql\\n\\n   // Reading from directors.\\n   data.select:\"\\nselect d1.org_number, b.company_name, d1.role_name\\n   from directors d1\\n      inner join basic b on b.org_number = d1.org_number\\n      inner join directors d2 on d1.director_nbr = d2.director_nbr\\n   where d2.director_id = @id and d1.org_number != d2.org_number\\n   limit @limit offset @offset\"\\n      database-type:pgsql\\n      @id:x:@.arguments/*/director_id\\n      @limit:x:@.arguments/*/limit\\n      @offset:x:@.arguments/*/offset\\n   if\\n      mte\\n         get-count:x:@data.select/*\\n         .:int:10\\n      .lambda\\n\\n         // Making sure we inform caller that there might exist additional companies.\\n         add:x:@data.connect/*/yield\\n            .\\n               notice:The director is probably associated with more companies\\n   yield\\n      companies:x:@data.select/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns the company with the specified org. number.\\n\\nThis function will return company information such as the address, founding date, status, activity description, etc."},{"role":"assistant","content":".arguments\\n   org_number:string\\n.type:public\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/org_number\\nset-value:x:@.arguments/*/org_number\\n   strings.replace-not-of:x:@.arguments/*/org_number\\n      .:0123456789\\n      .:\\nvalidators.string:x:@.arguments/*/org_number\\n   min:10\\n   max:10\\n\\n// Connecting to database.\\ndata.connect:[finovo|finovo]\\n   database-type:pgsql\\n\\n   // Retrieving items.\\n   data.read\\n      database-type:pgsql\\n      table:basic\\n      columns\\n         org_number\\n         complete_ef_pnr\\n         company_name\\n         post_co_street\\n         post_street\\n         post_zipcode\\n         post_town\\n         post_community_code\\n         post_community_name\\n         post_region_code\\n         post_region_name\\n         registered_co_street\\n         registered_street\\n         registered_zipcode\\n         registered_town\\n         registered_community_code\\n         registered_community_name\\n         registered_region_code\\n         registered_region_name\\n         visiting_street\\n         visiting_zipcode\\n         visiting_town\\n         visiting_community_code\\n         visiting_community_name\\n         visiting_region_code\\n         visiting_region_name\\n         phone_number\\n         fax_number\\n         status_date\\n         status_code\\n         status_text_high\\n         status_text_detailed\\n         orgnr_status_affected\\n         company_formed_date\\n         registration_date\\n         deregistration_date\\n         legalgroup_code\\n         legalgroup_text\\n         f_tax_reg\\n         f_tax_yes_no\\n         f_tax_reg_spec\\n         f_tax_start_date\\n         f_tax_end_date\\n         f_tax_dereg_reason_code\\n         moms_reg\\n         moms_yes_no\\n         moms_start_date\\n         moms_end_date\\n         sni_code\\n         sni_text\\n         accountant_reservation\\n         date_accountant_reservation\\n         number_of_units\\n         top_director_name\\n         top_director_function\\n         turnover_interval\\n         nbr_employees_interval\\n      where\\n         and\\n            legalgroup_code.eq:AB\\n            org_number.eq:x:@.arguments/*/org_number\\n\\n   // Checking if we've got data.\\n   if\\n      not-exists:x:@data.read/*\\n      .lambda\\n         return\\n            result:No results were found\\n\\n   // Making sure we return basic company information.\\n   add:x:../*/return-nodes/*/basic\\n      get-nodes:x:@data.read/*\\n\\n   // Retrieving items.\\n   data.read\\n      database-type:pgsql\\n      table:activity_text\\n      columns\\n         sequence\\n         activity_text\\n      where\\n         and\\n            org_number.eq:x:@.arguments/*/org_number\\n\\n   // Making sure we return activity_text information, but only if existing\\n   if\\n      exists:x:@data.read/*\\n      .lambda\\n\\n         // Making sure we return activity_text information.\\n         add:x:+/*/*\\n            get-nodes:x:@data.read/*\\n         add:x:../*/return-nodes\\n            .\\n               activity_text\\n\\n   // Retrieving items.\\n   data.read\\n      database-type:pgsql\\n      table:accountant_comments\\n      columns\\n         account_period_start\\n         account_period_end\\n         account_not_approved_code\\n         accountant_comment_code\\n         accountant_comment_text\\n         other_accountant_comment\\n      where\\n         and\\n            accountant_comment_text.neq:\\n            accountant_comment_text.neq\\n            org_number.eq:x:@.arguments/*/org_number\\n\\n   // Making sure we return accountant_comments information, but only if existing\\n   if\\n      exists:x:@data.read/*\\n      .lambda\\n\\n         // Making sure we return accountant_comments information.\\n         add:x:+/*/*\\n            get-nodes:x:@data.read/*\\n         add:x:../*/return-nodes\\n            .\\n               accountant_comment\\n\\n   // Retrieving items.\\n   data.read\\n      database-type:pgsql\\n      table:company_sign\\n      columns\\n         company_sign_text\\n      where\\n         and\\n            org_number.eq:x:@.arguments/*/org_number\\n      order:sequence\\n\\n   // Making sure we return company_sign information, but only if existing\\n   if\\n      exists:x:@data.read/*\\n      .lambda\\n\\n         // Making sure we return company_sign information.\\n         add:x:+/*/*\\n            get-nodes:x:@data.read/*\\n         add:x:../*/return-nodes\\n            .\\n               company_sign\\n\\n   // Retrieving items.\\n   data.read\\n      database-type:pgsql\\n      table:group_structure\\n      columns\\n         company_name\\n         company_country_code\\n         company_country_name\\n         owned_percent\\n         company_level\\n         closest_group_mother_orgnumber\\n         group_mother_orgnumber\\n         date_last_group_struct_update\\n      where\\n         and\\n            org_number.eq:x:@.arguments/*/org_number\\n\\n   // Making sure we return company_sign information, but only if existing\\n   if\\n      exists:x:@data.read/*\\n      .lambda\\n\\n         // Making sure we return company_sign information.\\n         add:x:+/*/*\\n            get-nodes:x:@data.read/*\\n         add:x:../*/return-nodes\\n            .\\n               group_structure\\n\\n   // Figuring out who is the actual owner of the company\\n   execute:finovo.get-actual-owner\\n      org_number:x:@.arguments/*/org_number\\n   if\\n      exists:x:@execute/*\\n      .lambda\\n\\n         // We have an actual owner of the company.\\n         add:x:../*/return-nodes\\n            .\\n               actual_owners\\n         for-each:x:@execute/*\\n            unwrap:x:+/*/*/*\\n            add:x:../*/return-nodes/*/actual_owners\\n               .\\n                  .\\n                     name:x:@.dp/#/*/name\\n                     ownership:x:@.dp/#/*/ownership\\n                     control_text:x:@.dp/#/*/control_text\\n                     director_id:x:@.dp/#/*/director_id\\nreturn-nodes\\n   basic\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns the directors for a specific account or company"},{"role":"assistant","content":".arguments\\n   org_number:string\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/org_number\\nset-value:x:@.arguments/*/org_number\\n   strings.replace-not-of:x:@.arguments/*/org_number\\n      .:0123456789\\n      .:\\nvalidators.string:x:@.arguments/*/org_number\\n   min:10\\n   max:10\\n\\n// Connecting to database.\\ndata.connect:[finovo|finovo]\\n   database-type:pgsql\\n\\n   // Retrieving items.\\n   data.read\\n      database-type:pgsql\\n      table:directors\\n      columns\\n         director_id\\n         org_number\\n         from_date\\n         to_date\\n         complete_ef_pnr\\n         first_name\\n         given_name\\n         middle_name\\n         last_name\\n         director_name\\n         gender\\n         role_name\\n         director_home_co_address\\n         director_home_street\\n         director_home_zipcode\\n         director_home_town\\n         director_home_community_code\\n         director_home_community\\n         director_home_region_code\\n         director_home_region\\n         director_home_country_code\\n         director_home_country\\n      where\\n         and\\n            org_number.eq:x:@.arguments/*/org_number\\n\\n   // Making sure we return company information related to the account.\\n   add:x:../*/return-nodes/*/directors\\n      get-nodes:x:@data.read/*\\n\\n// Returning result to caller.\\nreturn-nodes\\n   directors\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Gets a company\\n\\nWill return the company with the specified name."},{"role":"assistant","content":".arguments\\n   query:string\\n.type:public\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/query\\n\\n// Connecting to database.\\ndata.connect:[finovo|finovo]\\n   database-type:pgsql\\n\\n   // Retrieving items.\\n   data.read\\n      database-type:pgsql\\n      table:basic\\n      columns\\n         org_number\\n         company_name\\n      where\\n         and\\n            legalgroup_code.eq:AB\\n            company_name.ilike:x:@.arguments/*/query\\n      limit:1\\n\\n   // Checking we've got data.\\n   if\\n      not-exists:x:@data.read/*\\n      .lambda\\n         return\\n            result:No results were found\\n\\n   // Returning result to caller.\\n   return-nodes:x:@data.read/*/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns financial information about a company."},{"role":"assistant","content":".arguments\\n   org_number:string\\n   columns\\n.type:public\\n\\n// Decorating function invocation.\\nfor-each:x:@.arguments/*/columns/*\\n\\n   /*\\n    * Sanity checking column name to avoid SQL injection attacks.\\n    * \\n    * This makes sure we only handle columns existing in the following [.cols] segment.\\n    */\\n   .cols\\n      .:kr_return_on_capital_percent\\n      .:kr_return_on_cap_emp_percent\\n      .:kr_avg_debt_eq_ratio_percent\\n      .:kr_risk_buffer\\n      .:kr_ebitda\\n      .:kr_ebitida_margin_percent\\n      .:kr_interest_coverage_ebitda\\n      .:kr_ret_on_tot_cap_ebitda_perc\\n      .:kr_ret_on_working_capital_perc\\n      .:kr_degree_of_debt_intr_bearing\\n      .:kr_operating_margin_percent\\n      .:kr_profit_margin_percent\\n      .:kr_gross_profit_margin_percent\\n      .:kr_turnover_per_employee\\n      .:kr_solidity_percent\\n      .:kr_capital_turnover_times\\n      .:kr_working_capital\\n      .:kr_opp_prof_totnet_oppinc_perc\\n      .:kr_quick_ratio_percent\\n      .:kr_change_in_turnover_percent\\n      .:kr_opp_result_num_of_employees\\n      .:kr_cost_per_employee\\n      .:kr_change_in_num_of_employees\\n      .:kr_inventories_turnover_perc\\n      .:kr_accounts_rec_turnover_perc\\n      .:kr_liquid_assets_turnover_perc\\n      .:kr_current_liab_turnover_perc\\n      .:kr_degree_of_debt\\n      .:kr_rate_of_return_times\\n      .:kr_return_on_op_capital\\n      .:kr_risk_buffer_on_op_cap_perc\\n      .:kr_inventory_turnover_times\\n      .:kr_du_pont_model_percent\\n      .:pl_net_operating_income\\n      .:pl_net_sales\\n      .:pl_cost_of_sold_goods\\n      .:pl_gross_profit_loss\\n      .:pl_selling_expenses\\n      .:pl_admin_costs\\n      .:pl_research_and_dev_costs\\n      .:pl_change_invent_work_prog\\n      .:pl_work_perf_own_use_capital\\n      .:pl_raw_mat_and_cons\\n      .:pl_goods_for_resale\\n      .:pl_personal_costs\\n      .:pl_depr_and_write_downs\\n      .:pl_item_affect_compare\\n      .:pl_other_opp_income\\n      .:pl_other_opp_expenses\\n      .:pl_other_ext_costs\\n      .:pl_operating_result\\n      .:pl_result_participation_group\\n      .:pl_fin_int_group_inc\\n      .:pl_ext_interest_inc\\n      .:pl_interest_exp_int\\n      .:pl_interest_exp_ext\\n      .:pl_other_fin_inc\\n      .:pl_other_fin_costs\\n      .:pl_prof_loss_after_fin_items\\n      .:pl_extraordinary_inc\\n      .:pl_extraordinary_exp\\n      .:pl_group_contrib\\n      .:pl_shareholder_contrib\\n      .:pl_other_appropriations\\n      .:pl_tax\\n      .:pl_minority_intrest_and_prof\\n      .:pl_net_profit_loss\\n      .:bs_subscribed_capital_unpaid\\n      .:bs_capt_exp_for_res_and_dev\\n      .:bs_patents\\n      .:bs_goodwill\\n      .:bs_other_intangible_ass\\n      .:bs_total_intangible_assets\\n      .:bs_land_build\\n      .:bs_plant_machine\\n      .:bs_equip_tools_fix_and_fit\\n      .:bs_machines_inventory\\n      .:bs_other_tang_ass_non_dep\\n      .:bs_other_mat_depreciation\\n      .:bs_total_tangible_assets\\n      .:bs_group_share\\n      .:bs_acc_recieve_corp_group\\n      .:bs_loan_co_owners\\n      .:bs_other_fin_assets\\n      .:bs_total_financial_assets\\n      .:bs_tot_fix_assets\\n      .:bs_work_on_contract\\n      .:bs_inventories\\n      .:bs_total_inventories\\n      .:bs_accounts_receivable_trade\\n      .:bs_acc_recieve_group\\n      .:bs_other_acc_recieve\\n      .:bs_total_accounts_receivable\\n      .:bs_short_investments\\n      .:bs_cash_and_bank_balances\\n      .:bs_other_cur_assets\\n      .:bs_total_turnover_assets\\n      .:bs_tot_assets\\n      .:bs_issued_share_capital\\n      .:bs_share_premium_reserve\\n      .:bs_revaluation_reserve\\n      .:bs_other_stockholder_equity\\n      .:bs_profit_loss_brought_fwd\\n      .:bs_group_contribution\\n      .:bs_shareholder_contribution\\n      .:bs_net_profit_loss\\n      .:bs_total_dividens_capacity\\n      .:bs_tot_equity\\n      .:bs_untaxed_reserves\\n      .:bs_minority_interests\\n      .:bs_provisions\\n      .:bs_lt_bond_loan\\n      .:bs_lt_liab_to_credit_instit\\n      .:bs_lt_liab_group_ass_comp\\n      .:bs_other_long_term_liab\\n      .:bs_tot_long_term_debts\\n      .:bs_liab_credit_inst\\n      .:bs_acc_pay_trade\\n      .:bs_st_liab_group_ass_comp\\n      .:bs_other_short_term_liab\\n      .:bs_tot_current_liabilities\\n      .:bs_tot_equity_and_liab\\n      .:n_months\\n      .:n_account_currency_info\\n      .:n_no_employees\\n      .:n_account_shortage\\n      .:n_account_shortage_text\\n      .:n_salary_board\\n      .:n_tantiem_board\\n      .:n_employee_salary\\n      .:n_perf_bonus_to_oth_employees\\n      .:n_payroll_overhead\\n      .:n_floating_charge\\n      .:n_real_estate_mortgage\\n      .:n_other_collateral\\n      .:n_tot_collateral\\n      .:n_conditional_equity\\n      .:n_other_contingent_liab\\n      .:n_tot_contingent_liab\\n      .:n_dividend\\n      .:n_accepted_bank_overdraft\\n      .:n_not_used_bank_overdraft\\n      .:n_net_interest_finance\\n      .:n_agreed_severance_pay\\n      .:n_accountant_obligation\\n      .:n_type_of_statement\\n      .:n_depr_goods\\n      .:n_depr_sales\\n      .:n_depr_admin\\n      .:n_depr_rod\\n      .:n_depr_other\\n      .:n_depr_unspec\\n   if\\n      exists:x:\"@.cols/*/\\\"={@.dp/#}\\\"\"\\n      .lambda\\n\\n         // Adding column to slot invocation.\\n         set-name:x:+/*/*\\n            get-value:x:@.dp/#\\n         add:x:../*/execute/*/columns\\n            .\\n               foo\\n\\n// Invoking helper slot.\\nexecute:finovo.accounts.get-data\\n   org_number:x:@.arguments/*/org_number\\n   columns\\n      date_from\\n      date_to\\nreturn-nodes:x:-/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns parent company from specified org number.\\n\\nReturns the company the specified org number is owned by."},{"role":"assistant","content":".arguments\\n   org_number:string\\n.type:public\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/org_number\\nset-value:x:@.arguments/*/org_number\\n   strings.replace-not-of:x:@.arguments/*/org_number\\n      .:0123456789\\n      .:\\n\\n// Connecting to database.\\ndata.connect:[finovo|finovo]\\n   database-type:pgsql\\n\\n   // Retrieving items.\\n   data.read\\n      database-type:pgsql\\n      table:group_structure\\n      columns\\n         group_mother_orgnumber\\n      where\\n         and\\n            org_number.eq:x:@.arguments/*/org_number\\n      limit:-1\\n\\n   // Verifying the company has a parent company.\\n   if\\n      not-exists:x:@data.read/*\\n      .lambda\\n         return\\n            result:\"This company doesn't have any parent company\"\\n\\n   // Returning result to caller.\\n   return-nodes:x:@data.read/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns subsidiary companies from specified org number.\\n\\nReturns all companies the specified org number company owns, either partially or completely."},{"role":"assistant","content":".arguments\\n   org_number:string\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/org_number\\nset-value:x:@.arguments/*/org_number\\n   strings.replace-not-of:x:@.arguments/*/org_number\\n      .:0123456789\\n      .:\\n\\n// Connecting to database.\\ndata.connect:[finovo|finovo]\\n   database-type:pgsql\\n\\n   // Retrieving items.\\n   data.read\\n      database-type:pgsql\\n      table:group_structure\\n      columns\\n         org_number\\n         company_name\\n         company_country_name\\n         owned_percent\\n      where\\n         and\\n            group_mother_orgnumber.eq:x:@.arguments/*/org_number\\n            org_number.neq:x:@.arguments/*/org_number\\n      limit:-1\\n\\n   // Verifying the company has subsidiaries.\\n   if\\n      not-exists:x:@data.read/*\\n      .lambda\\n         return\\n            result:\"This company doesn't have any subsidiaries\"\\n\\n   // Returning result to caller.\\n   return-nodes:x:@data.read/*\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Ensures our system messages are updated during deployments."},{"role":"assistant","content":"\\n// Listing all system messages we've got.\\nio.file.list:/modules/finovo/system-messages/\\n\\n// Opening up database connection.\\ndata.connect:magic\\n\\n   // Looping through each system message and updating our machine learning type accordingly.\\n   for-each:x:@io.file.list/*\\n\\n      // Loading file.\\n      io.file.load:x:@.dp/#\\n\\n      // Finding type name\\n      .type\\n      strings.split:x:@.dp/#\\n         .:/\\n      strings.split:x:-/0/-\\n         .:.\\n      set-value:x:@.type\\n         get-value:x:@strings.split/0\\n\\n      // Updating type name's system message.\\n      data.update\\n         table:ml_types\\n         values\\n            system_message:x:@io.file.load\\n         where\\n            and\\n               type.eq:x:@.type\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Common helper slot to return the specified [columns] from accounts/group_accounts, matching\\nthe specified [org_number]."},{"role":"assistant","content":"slots.create:finovo.accounts.get-data\\n\\n   // Sanity checking invocation.\\n   validators.mandatory:x:@.arguments/*/org_number\\n   set-value:x:@.arguments/*/org_number\\n      strings.replace-not-of:x:@.arguments/*/org_number\\n         .:0123456789\\n         .:\\n   validators.string:x:@.arguments/*/org_number\\n      min:10\\n      max:10\\n\\n   // Connecting to database.\\n   data.connect:[finovo|finovo]\\n      database-type:pgsql\\n\\n      // Trying group accounts.\\n      add:x:+/*/columns\\n         get-nodes:x:@.arguments/*/columns/*\\n      data.read\\n         database-type:pgsql\\n         table:group_accounts\\n         columns\\n         where\\n            and\\n               org_number.eq:x:@.arguments/*/org_number\\n               or\\n                  n_account_shortage_text.eq:\\n                  n_account_shortage_text.eq\\n\\n      // Checking if we've got data.\\n      if\\n         not-exists:x:@data.read/*\\n         .lambda\\n\\n            // Trying accounts.\\n            add:x:+/*/columns\\n               get-nodes:x:@.arguments/*/columns/*\\n            data.read\\n               database-type:pgsql\\n               table:accounts\\n               columns\\n               where\\n                  and\\n                     org_number.eq:x:@.arguments/*/org_number\\n\\n            // Checking if we've got data.\\n            if\\n               not-exists:x:@data.read/*\\n               .lambda\\n\\n                  // No data.\\n                  return\\n                     result:No results were found\\n            else\\n\\n               // Making sure we return company information related to the account.\\n               add:x:../*/return-nodes\\n                  get-nodes:x:@data.read/*\\n      else\\n\\n         // Making sure we return company information related to the account.\\n         add:x:../*/return-nodes\\n            get-nodes:x:@data.read/*\\n\\n   // Returning result to caller.\\n   return-nodes\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns the actual owner of the company with the specified [org_number]"},{"role":"assistant","content":"slots.create:finovo.get-actual-owner\\n\\n   // Sanity checking invocation.\\n   validators.mandatory:x:@.arguments/*/org_number\\n\\n   // Buffer for XML.\\n   .xml:\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\\n<soap:Envelope xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xmlns:xsd=\\\"http://www.w3.org/2001/XMLSchema\\\" xmlns:soap=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\">\\n  <soap:Body>\\n    <GetDataBySecure xmlns=\\\"https://webservice.creditsafe.se/getdata/\\\">\\n      <GetData_Request>\\n        <account>\\n          <UserName>FINOVOIN</UserName>\\n          <Password>RitaM@rion5</Password>\\n          <Language>EN</Language>\\n        </account>\\n        <Block_Name>FINOVO_C_VH</Block_Name>\\n        <SearchNumber>{org_number}</SearchNumber>\\n      </GetData_Request>\\n    </GetDataBySecure>\\n  </soap:Body>\\n</soap:Envelope>\"\\n   set-value:x:@.xml\\n      strings.replace:x:@.xml\\n         .:{org_number}\\n         get-value:x:@.arguments/*/org_number\\n   http.post:\"https://webservice.creditsafe.se/getdata/getdata.asmx\"\\n      headers\\n         Content-Type:text/xml; charset=utf-8\\n      payload:x:@.xml\\n   if\\n      eq:x:@http.post\\n         .:int:200\\n      .lambda\\n\\n         // We have an actual owner object.\\n         xml2lambda:x:@http.post/*/content\\n\\n         // Retrieving \"director_id\" from database, if existing.\\n         data.connect:[finovo|finovo]\\n            database-type:pgsql\\n\\n            // Iterating through each actual owner from API.\\n            for-each:x:@xml2lambda/**/GetDataBySecureResponse/*/GetDataBySecureResult/**/BENEFICIAL_OWNER\\n               if\\n                  exists:x:\"@.dp/#/*/NAME/*/\\\\#text\"\\n                  .lambda\\n\\n                     // This is an actual beneficial owner as returned from the API, checking if we've got PNR.\\n                     .pnr\\n                     if\\n                        and\\n                           exists:x:\"@.dp/#/*/PNR/*/\\\\#text\"\\n                           neq:x:\"@.dp/#/*/PNR/*/\\\\#text\"\\n                              .:\\n                        .lambda\\n\\n                           // We've got a PNR (Social Security ID) for the owner.\\n                           data.read\\n                              database-type:pgsql\\n                              table:directors\\n                              columns\\n                                 director_id\\n                              where\\n                                 and\\n                                    director_pnr.eq:x:\"@.dp/#/*/PNR/*/\\\\#text\"\\n                                    org_number.eq:x:@.arguments/*/org_number\\n                              order:director_pnr\\n                              director:asc\\n                           add:x:@.pnr\\n                              get-nodes:x:@data.read/0/*\\n\\n                     // Making sure we return the beneficial owner to the caller.\\n                     add:x:+/+/*/*\\n                        get-nodes:x:@.pnr/*\\n                     unwrap:x:+/*/*/*\\n                     add:x:@.lambda/@.lambda/*/return-nodes\\n                        .\\n                           .\\n                              name:x:\"@.dp/#/*/NAME/*/\\\\#text\"\\n                              ownership:x:\"@.dp/#/*/OWNER_EXTENT_TEXT/*/\\\\#text\"\\n                              control_text:x:\"@.dp/#/*/CONTROL_TEXT/*/\\\\#text\"\\n         return-nodes\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns a grouped chart image to caller.\\n\\nValues is a mandatory comma separated list of values."},{"role":"assistant","content":".arguments:*\\n.type:public\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/legend\\n\\n// Creating our individual bars.\\n.bars\\nfor-each:x:@.arguments/*\\n   get-name:x:@.dp/#\\n   if\\n      not\\n         strings.starts-with:x:@get-name\\n            .:legend\\n      .lambda\\n\\n         // Adding primary node for bar.\\n         set-name:x:+/*/*\\n            get-value:x:@get-name\\n         add:x:@.bars\\n            .\\n               .\\n\\n         // Adding values for individual cells.\\n         add:x:@.bars/0/-\\n            strings.split:x:@.dp/#\\n               .:,\\n\\n// Creating our legend.\\nadd:x:../*/image.chart/*/legend\\n   strings.split:x:@.arguments/*/legend\\n      .:,\\n\\n// Parametrizing [image.chart] invocation.\\nadd:x:../*/image.chart/*/bars\\n   get-nodes:x:@.bars/*\\nimage.chart:grouped\\n   width:800\\n   height:500\\n   bars\\n   legend\\n\\n// Applying correct HTTP header.\\nresponse.headers.set\\n   Content-Type:image/png\\n\\n// Returning chart to caller.\\nreturn:x:@image.chart\\n"}]}
{"messages":[{"role":"system","content":"You are a Hyperlambda coding assistant. Respond with Hyperlambda code."},{"role":"user","content":"Returns a stacked chart image to caller.\\n\\nValues is a mandatory comma separated list of values."},{"role":"assistant","content":".arguments:*\\n.type:public\\n\\n// Sanity checking invocation.\\nvalidators.mandatory:x:@.arguments/*/legend\\n\\n// Creating our individual bars.\\n.bars\\nfor-each:x:@.arguments/*\\n   get-name:x:@.dp/#\\n   if\\n      not\\n         strings.starts-with:x:@get-name\\n            .:legend\\n      .lambda\\n\\n         // Adding primary node for bar.\\n         set-name:x:+/*/*\\n            get-value:x:@get-name\\n         add:x:@.bars\\n            .\\n               .\\n\\n         // Adding values for individual cells.\\n         add:x:@.bars/0/-\\n            strings.split:x:@.dp/#\\n               .:,\\n\\n// Creating our legend.\\nadd:x:../*/image.chart/*/legend\\n   strings.split:x:@.arguments/*/legend\\n      .:,\\n\\n// Parametrizing [image.chart] invocation.\\nadd:x:../*/image.chart/*/bars\\n   get-nodes:x:@.bars/*\\nimage.chart:stacked\\n   width:800\\n   height:500\\n   bars\\n   legend\\n\\n// Applying correct HTTP header.\\nresponse.headers.set\\n   Content-Type:image/png\\n\\n// Returning chart to caller.\\nreturn:x:@image.chart\\n"}]}
