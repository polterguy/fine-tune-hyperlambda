
/*
 * 1. [strings.concat] joins together a series of string fragments and expressions into a single string, building a SQL CASE WHEN expression for counting occurrences of a substring.
 * 2. [get-value] fetches values from the [.sql], [.fields], and [.no] nodes, inserting their contents into the correct places within the concatenated SQL.
 * 3. The static string segments define SQL syntax, including CASE, WHEN, length(), replace(), lower(), and placeholders for dynamic values like @p and indices.
 * 
 * Use cases:
 * - Dynamically create a SQL conditional expression to check if a given substring appears at least once in a specific field.
 * - Construct parameterized SQL queries for text analytics, like highlighting or filtering results based on content frequency.
 * - Generate complex SQL statements in a maintainable way by assembling them from reusable node values and fragments.
 * - Support multi-column or multi-pattern search logic by referencing different [.fields] and [.no] nodes in the assembly process.
 */
strings.concat:x:@.sql
   get-value:x:@.sql
   .:" CASE WHEN ((length("
   get-value:x:@.fields
   .:) - length(replace(lower(
   get-value:x:@.fields
   .:), @p
   get-value:x:@.no
   .:", ''))) / length(@p"
   get-value:x:@.no
   .:)) > 0 THEN 1 ELSE 0 END
