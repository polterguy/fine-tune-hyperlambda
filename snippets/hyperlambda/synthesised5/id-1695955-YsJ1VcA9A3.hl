
/*
 * 1. [if] checks if the value of [.no] is exactly 0, executing its child nodes only if the condition is met.
 * 2. [eq] performs an equality comparison between the value at `:x:@.no` and the integer 0.
 * 3. [set-value] assigns a new value to [.sql], which is generated by concatenating multiple string fragments and values together.
 * 4. [strings.concat] builds a complex SQL expression by joining the current value of [.sql], dynamic field references from [.fields], values of [.no], and several string fragments to form a CASE WHEN SQL clause.
 * 5. [get-value] fetches values from [.sql], [.fields], and [.no] at several points to dynamically construct the SQL query expression.
 * 
 * Use Cases:
 * - Dynamically building a SQL CASE WHEN clause that counts the occurrences of a substring in a field, only if [.no] is 0.
 * - Creating a conditional SQL expression for advanced text search or analytics in a query generation workflow.
 * - Used within a loop or switch statement to generate part of a SQL query depending on the value of [.no].
 * - Useful for code that programmatically constructs SQL CASE statements for field comparison or text matching.
 */
if
   eq:x:@.no
      .:int:0
   .lambda
      set-value:x:@.sql
         strings.concat:x:@.sql
            get-value:x:@.sql
            .:" CASE WHEN ((length("
            get-value:x:@.fields
            .:) - length(replace(lower(
            get-value:x:@.fields
            .:), @p
            get-value:x:@.no
            .:", ''))) / length(@p"
            get-value:x:@.no
            .:)) > 0 THEN 1 ELSE 0 END
