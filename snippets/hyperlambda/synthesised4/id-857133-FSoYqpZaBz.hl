
/*
 * This Hyperlambda code processes a search query to generate a SQL statement that retrieves data from a SQLite database. It validates and sets default values for input arguments, splits the query into words, and constructs SQL to calculate keyword density and count in specified columns. The SQL orders results by keyword count and density, applying limits and offsets if provided, and returns the selected data after removing temporary calculation fields.
 * 
 * 1. [.arguments] - Declares input arguments for the lambda.
 * 2. [validators.mandatory] - Ensures the 'query' argument is provided.
 * 3. [validators.default] - Sets default values for unspecified arguments.
 * 4. [.words] - Splits the query into individual words.
 * 5. [for-each] - Iterates over words to convert them to lowercase.
 * 6. [.columns] - Specifies database columns to search.
 * 7. [data.connect] - Establishes a connection to the SQLite database.
 * 8. [.sql] - Constructs the SQL query string.
 * 9. [strings.concat] - Builds parts of the SQL query.
 * 10. [unwrap] - Evaluates expressions for SQL construction.
 * 11. [math.increment] - Increments a counter for parameter naming.
 * 12. [if] - Conditional logic for SQL string construction.
 * 13. [data.select] - Executes the constructed SQL query.
 * 14. [remove-nodes] - Cleans up temporary fields from the result.
 * 15. [return-nodes] - Returns the final result set.
 */
hyper2lambda
   .arguments
      query:string
      limit:long
      offset:long
   validators.mandatory:x:@.arguments/*/query
   validators.default:x:@.arguments
      limit:long:10
   .words
   add:x:@.words
      strings.split:x:@.arguments/*/query
         .:" "
   .no:int:0
   for-each:x:@.words/*
      set-value:x:@.dp/#
         strings.to-lower:x:@.dp/#
   .columns
      .:CustomerID
      .:ShipName
      .:ShipAddress
      .:ShipCity
      .:ShipRegion
      .:ShipPostalCode
      .:ShipCountry
   data.connect:[generic|northwind]
      database-type:sqlite
      .sql:select *, (
      .fields
      for-each:x:@.columns/*
         strings.concat
            .:coalesce(
            get-value:x:@.dp/#
            .:", '')"
         unwrap:x:+/*/*
         add:x:@.fields
            .
               .:x:@strings.concat
      set-value:x:@.fields
         strings.join:x:@.fields/*
            .:" || "
      remove-nodes:x:@.fields/*
      .no:int:0
      for-each:x:@.words/*
         set-name:x:+/+/*/*
            strings.concat
               .:@p
               get-value:x:@.no
         unwrap:x:+/*/*
         add:x:@data.connect/*/data.select
            .
               .:x:@.dp/#
         if
            eq:x:@.no
               .:int:0
            .lambda
               set-value:x:@.sql
                  strings.concat:x:@.sql
                     get-value:x:@.sql
                     .:" (length("
                     get-value:x:@.fields
                     .:) - length(replace(lower(
                     get-value:x:@.fields
                     .:), @p
                     get-value:x:@.no
                     .:", ''))) / length(@p"
                     get-value:x:@.no
                     .:)
         else
            set-value:x:@.sql
               strings.concat:x:@.sql
                  get-value:x:@.sql
                  .:" + (length("
                  get-value:x:@.fields
                  .:) - length(replace(lower(
                  get-value:x:@.fields
                  .:), @p
                  get-value:x:@.no
                  .:", ''))) / length(@p"
                  get-value:x:@.no
                  .:)
         math.increment:x:@.no
      set-value:x:@.sql
         strings.concat:x:@.sql
            get-value:x:@.sql
            .:) * 1.0 / length(
            get-value:x:@.fields
            .:) as keyword_density, (
      .no:int:0
      for-each:x:@.words/*
         if
            eq:x:@.no
               .:int:0
            .lambda
               set-value:x:@.sql
                  strings.concat:x:@.sql
                     get-value:x:@.sql
                     .:" CASE WHEN ((length("
                     get-value:x:@.fields
                     .:) - length(replace(lower(
                     get-value:x:@.fields
                     .:), @p
                     get-value:x:@.no
                     .:", ''))) / length(@p"
                     get-value:x:@.no
                     .:)) > 0 THEN 1 ELSE 0 END
         else
            set-value:x:@.sql
               strings.concat:x:@.sql
                  get-value:x:@.sql
                  .:" + CASE WHEN ((length("
                  get-value:x:@.fields
                  .:) - length(replace(lower(
                  get-value:x:@.fields
                  .:), @p
                  get-value:x:@.no
                  .:", ''))) / length(@p"
                  get-value:x:@.no
                  .:)) > 0 THEN 1 ELSE 0 END
         math.increment:x:@.no
      set-value:x:@.sql
         strings.concat:x:@.sql
            get-value:x:@.sql
            .:) as keyword_count
      set-value:x:@.sql
         strings.concat:x:@.sql
            get-value:x:@.sql
            .:" from "
            .:Orders
            .:" where keyword_count > 0"
      set-value:x:@.sql
         strings.concat:x:@.sql
            get-value:x:@.sql
            .:" order by keyword_count desc, keyword_density desc limit "
            get-value:x:@.arguments/*/limit
      if
         exists:x:@.arguments/*/offset
         .lambda
            set-value:x:@.sql
               strings.concat:x:@.sql
                  get-value:x:@.sql
                  .:" offset "
                  get-value:x:@.arguments/*/offset
      data.select:x:@.sql
         database-type:sqlite
      remove-nodes:x:@data.select/*/*/keyword_density
      remove-nodes:x:@data.select/*/*/keyword_count
      return-nodes:x:@data.select/*
