
// This Hyperlambda code dynamically constructs an SQL "CREATE TABLE" statement based on provided arguments, including primary and foreign keys, and executes it against a specified database. It verifies mandatory arguments and supports different database types like MySQL, SQLite, PostgreSQL, and MSSQL. The code also allows generating the SQL statement without execution for debugging purposes. Key slots include [validators.mandatory] for argument validation, [strings.concat] for SQL string construction, and [data.connect] for database connection.
hyper2lambda
   .arguments
      databaseType:string
      connectionString:string
      databaseName:string
      args
         name:string
         table1:string
         table2:string
         table1pk
            .
               name:string
               type:string
               length:int
         table2pk
            .
               name:string
               type:string
               length:int
      generate:bool
   auth.ticket.verify:root
   validators.mandatory:x:@.arguments/*/connectionString
   validators.mandatory:x:@.arguments/*/databaseName
   validators.mandatory:x:@.arguments/*/args
   validators.mandatory:x:@.arguments/*/databaseType
   validators.enum:x:@.arguments/*/databaseType
      .:mysql
      .:sqlite
      .:pgsql
      .:mssql
   .sql
   set-value:x:@.sql
      strings.concat
         .:"create table "
         get-value:x:@.arguments/*/args/*/name
         .:(
   .first:bool:true
   .pk:
   .fk:
   for-each:x:@.arguments/*/args/*/table1pk/*
      if:x:@.first
         set-value:x:@.first
            .:bool:false
         set-value:x:@.sql
            strings.concat
               get-value:x:@.sql
               .:@"
  "
      else
         set-value:x:@.sql
            strings.concat
               get-value:x:@.sql
               .:@",
  "
      set-value:x:@.sql
         strings.concat
            get-value:x:@.sql
            get-value:x:@.dp/#/*/name
            .:" "
            get-value:x:@.dp/#/*/type
      if
         and
            exists:x:@.dp/#/*/length
            not-null:x:@.dp/#/*/length
         .lambda
            set-value:x:@.sql
               strings.concat
                  get-value:x:@.sql
                  .:(
                  get-value:x:@.dp/#/*/length
                  .:)
      if
         neq:x:@.arguments/*/databaseType
            .:mysql
         .lambda
            set-value:x:@.sql
               strings.concat
                  get-value:x:@.sql
                  .:" references "
                  get-value:x:@.arguments/*/args/*/table1
                  .:" ("
                  get-value:x:@.dp/#/*/name
                  .:)
      else
         set-value:x:@.fk
            strings.concat
               get-value:x:@.fk
               .:@",
 foreign key ("
               get-value:x:@.dp/#/*/name
               .:") references "
               get-value:x:@.arguments/*/args/*/table1
               .:" ("
               get-value:x:@.dp/#/*/name
               .:)
      set-value:x:@.pk
         strings.concat
            get-value:x:@.pk
            get-value:x:@.dp/#/*/name
            .:,
   for-each:x:@.arguments/*/args/*/table2pk/*
      if:x:@.first
         set-value:x:@.first
            .:bool:false
         set-value:x:@.sql
            strings.concat
               get-value:x:@.sql
               .:@"
  "
      else
         set-value:x:@.sql
            strings.concat
               get-value:x:@.sql
               .:@",
  "
      set-value:x:@.sql
         strings.concat
            get-value:x:@.sql
            get-value:x:@.dp/#/*/name
            .:" "
            get-value:x:@.dp/#/*/type
      if
         and
            exists:x:@.dp/#/*/length
            not-null:x:@.dp/#/*/length
         .lambda
            set-value:x:@.sql
               strings.concat
                  get-value:x:@.sql
                  .:(
                  get-value:x:@.dp/#/*/length
                  .:)
      if
         neq:x:@.arguments/*/databaseType
            .:mysql
         .lambda
            set-value:x:@.sql
               strings.concat
                  get-value:x:@.sql
                  .:" references "
                  get-value:x:@.arguments/*/args/*/table2
                  .:" ("
                  get-value:x:@.dp/#/*/name
                  .:)
      else
         set-value:x:@.fk
            strings.concat
               get-value:x:@.fk
               .:@",
 foreign key ("
               get-value:x:@.dp/#/*/name
               .:") references "
               get-value:x:@.arguments/*/args/*/table2
               .:" ("
               get-value:x:@.dp/#/*/name
               .:)
      set-value:x:@.pk
         strings.concat
            get-value:x:@.pk
            get-value:x:@.dp/#/*/name
            .:,
   strings.trim:x:@.pk
      .:,
   set-value:x:@.sql
      strings.concat
         get-value:x:@.sql
         .:@",
  primary key("
         get-value:x:@strings.trim
         .:)
   set-value:x:@.sql
      strings.concat
         get-value:x:@.sql
         get-value:x:@.fk
         .:);
   if:x:@.arguments/*/generate
      unwrap:x:+/*
      return
         sql:x:@.sql
   strings.concat
      .:[
      get-value:x:@.arguments/*/connectionString
      .:|
      get-value:x:@.arguments/*/databaseName
      .:]
   data.connect:x:-
      database-type:x:@.arguments/*/databaseType
      data.execute:x:@.sql
         database-type:x:@.arguments/*/databaseType
   strings.concat
      .:magic.sql.databases.
      get-value:x:@.arguments/*/databaseType
      :.
      get-value:x:@.arguments/*/connectionString
   cache.set:x:-
   unwrap:x:+/*
   return
      result:success
      sql:x:@.sql
