
// This Hyperlambda code processes input Hyperlambda files and dynamically generates candidate expressions. It verifies user authentication, loads and parses Hyperlambda files, and identifies nodes to create candidate expressions for execution. It checks for complex return objects, issuing warnings if automatic expression creation is not possible, and returns input and candidate expressions with any warnings.
hyper2lambda
   .arguments
      action-file:string
      hyperlambda:string
   auth.ticket.verify:root
   load-file:x:@.arguments/*/action-file
   hyper2lambda:x:@load-file
   add:x:./*/return/*/input
      get-nodes:x:@hyper2lambda/*/.arguments/*
   hyper2lambda:x:@.arguments/*/hyperlambda
   .warning
   for-each:x:@hyper2lambda/*
      .node-name
      set-value:x:@.node-name
         get-name:x:@.dp/#
      if
         or
            strings.starts-with:x:@.node-name
               .:.
            and
               eq:x:@.node-name
                  .:execute
               exists:x:@.dp/#/*/name
               exists:x:@.dp/#/*/filename
         .lambda
            if
               eq:x:@.node-name
                  .:execute
               .lambda
                  load-file:x:@.dp/#/*/filename
                  hyper2lambda:x:@load-file
                  if
                     and
                        exists:x:@hyper2lambda/**/[yield|return|return-nodes]
                        not-exists:x:@hyper2lambda/**/[yield|return|return-nodes]/*
                     .lambda
                        .x
                        set-value:x:@.x
                           strings.concat
                              .:--/execute/=
                              get-value:x:@.dp/#/*/name
                              .:/*
                        if
                           not-exists:x:../*/return/*/candidates/*/*/expression/={@.x}
                           .lambda
                              unwrap:x:+/*/*/*
                              add:x:../*/return/*/candidates
                                 .
                                    .
                                       name:x:@.x
                                       expression:x:@.x
                                       complete:bool:false
                  else
                     for-each:x:@hyper2lambda/**/[yield|return|return-nodes]/*
                        if
                           exists:x:@.dp/#/*
                           .lambda
                              set-value:x:@.warning
                                 .:Warning, some of your actions, and/or arguments, are returning complex objects, and we cannot automatically create candidate expressions for these. You will have to manually edit some of your expressions if you want to reference these nodes in your actions.
                        .x
                        set-value:x:@.x
                           strings.concat
                              .:--/execute/=
                              get-value:x:@.dp/@.dp/#/*/name
                              .:/*/
                              get-name:x:@.dp/#
                        if
                           not-exists:x:../*/return/*/candidates/*/*/expression/={@.x}
                           .lambda
                              unwrap:x:+/*/*/*
                              add:x:../*/return/*/candidates
                                 .
                                    .
                                       name:x:@.x
                                       expression:x:@.x
                                       complete:bool:true
            else
               for-each:x:@.dp/#/*
                  if
                     exists:x:@.dp/#/*
                     .lambda
                        set-value:x:@.warning
                           .:Warning, some of your actions, and/or arguments, are returning complex objects, and we cannot automatically create candidate expressions for these. You will have to manually edit some of your expressions if you want to reference these nodes in your actions.
                  .x
                  set-value:x:@.x
                     strings.concat
                        .:@
                        get-value:x:@.node-name
                        .:/*/
                        get-name:x:@.dp/#
                  if
                     not-exists:x:../*/return/*/candidates/*/*/expression/={@.x}
                     .lambda
                        unwrap:x:+/*/*/*
                        add:x:../*/return/*/candidates
                           .
                              .
                                 name:x:@.x
                                 expression:x:@.x
                                 complete:bool:true
               if
                  not-null:x:@.dp/#
                  .lambda
                     .x
                     set-value:x:@.x
                        strings.concat
                           .:@
                           get-value:x:@.node-name
                     if
                        not-exists:x:../*/return/*/candidates/*/*/expression/={@.x}
                        .lambda
                           unwrap:x:+/*/*/*
                           add:x:../*/return/*/candidates
                              .
                                 .
                                    name:x:@.x
                                    expression:x:@.x
                                    complete:bool:true
   if
      not-null:x:@.warning
      .lambda
         unwrap:x:+/*/*
         add:x:../*/return
            .
               warning:x:@.warning
   return
      input
      candidates
