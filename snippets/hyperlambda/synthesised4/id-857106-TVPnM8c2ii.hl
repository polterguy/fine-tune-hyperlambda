
// This Hyperlambda code defines a function that processes a query string to perform a keyword search on an SQLite database. It splits the query into words, converts them to lowercase, and constructs a dynamic SQL query to calculate keyword density and count. The SQL query is executed against the "Employees" table, with results ordered by keyword count and density, and supports pagination through limit and offset arguments. The function returns the search results, excluding the keyword density and count from the final output.
hyper2lambda
   .arguments
      query:string
      limit:long
      offset:long
   validators.mandatory:x:@.arguments/*/query
   validators.default:x:@.arguments
      limit:long:10
   .words
   add:x:@.words
      strings.split:x:@.arguments/*/query
         .:" "
   .no:int:0
   for-each:x:@.words/*
      set-value:x:@.dp/#
         strings.to-lower:x:@.dp/#
   .columns
      .:LastName
      .:FirstName
      .:Title
      .:TitleOfCourtesy
      .:Address
      .:City
      .:Region
      .:PostalCode
      .:Country
      .:HomePhone
      .:Extension
      .:Photo
      .:Notes
      .:PhotoPath
   data.connect:[generic|northwind]
      database-type:sqlite
      .sql:select *, (
      .fields
      for-each:x:@.columns/*
         strings.concat
            .:coalesce(
            get-value:x:@.dp/#
            .:", '')"
         unwrap:x:+/*/*
         add:x:@.fields
            .
               .:x:@strings.concat
      set-value:x:@.fields
         strings.join:x:@.fields/*
            .:" || "
      remove-nodes:x:@.fields/*
      .no:int:0
      for-each:x:@.words/*
         set-name:x:+/+/*/*
            strings.concat
               .:@p
               get-value:x:@.no
         unwrap:x:+/*/*
         add:x:@data.connect/*/data.select
            .
               .:x:@.dp/#
         if
            eq:x:@.no
               .:int:0
            .lambda
               set-value:x:@.sql
                  strings.concat:x:@.sql
                     get-value:x:@.sql
                     .:" (length("
                     get-value:x:@.fields
                     .:) - length(replace(lower(
                     get-value:x:@.fields
                     .:), @p
                     get-value:x:@.no
                     .:", ''))) / length(@p"
                     get-value:x:@.no
                     .:)
         else
            set-value:x:@.sql
               strings.concat:x:@.sql
                  get-value:x:@.sql
                  .:" + (length("
                  get-value:x:@.fields
                  .:) - length(replace(lower(
                  get-value:x:@.fields
                  .:), @p
                  get-value:x:@.no
                  .:", ''))) / length(@p"
                  get-value:x:@.no
                  .:)
         math.increment:x:@.no
      set-value:x:@.sql
         strings.concat:x:@.sql
            get-value:x:@.sql
            .:) * 1.0 / length(
            get-value:x:@.fields
            .:) as keyword_density, (
      .no:int:0
      for-each:x:@.words/*
         if
            eq:x:@.no
               .:int:0
            .lambda
               set-value:x:@.sql
                  strings.concat:x:@.sql
                     get-value:x:@.sql
                     .:" CASE WHEN ((length("
                     get-value:x:@.fields
                     .:) - length(replace(lower(
                     get-value:x:@.fields
                     .:), @p
                     get-value:x:@.no
                     .:", ''))) / length(@p"
                     get-value:x:@.no
                     .:)) > 0 THEN 1 ELSE 0 END
         else
            set-value:x:@.sql
               strings.concat:x:@.sql
                  get-value:x:@.sql
                  .:" + CASE WHEN ((length("
                  get-value:x:@.fields
                  .:) - length(replace(lower(
                  get-value:x:@.fields
                  .:), @p
                  get-value:x:@.no
                  .:", ''))) / length(@p"
                  get-value:x:@.no
                  .:)) > 0 THEN 1 ELSE 0 END
         math.increment:x:@.no
      set-value:x:@.sql
         strings.concat:x:@.sql
            get-value:x:@.sql
            .:) as keyword_count
      set-value:x:@.sql
         strings.concat:x:@.sql
            get-value:x:@.sql
            .:" from "
            .:Employees
            .:" where keyword_count > 0"
      set-value:x:@.sql
         strings.concat:x:@.sql
            get-value:x:@.sql
            .:" order by keyword_count desc, keyword_density desc limit "
            get-value:x:@.arguments/*/limit
      if
         exists:x:@.arguments/*/offset
         .lambda
            set-value:x:@.sql
               strings.concat:x:@.sql
                  get-value:x:@.sql
                  .:" offset "
                  get-value:x:@.arguments/*/offset
      data.select:x:@.sql
         database-type:sqlite
      remove-nodes:x:@data.select/*/*/keyword_density
      remove-nodes:x:@data.select/*/*/keyword_count
      return-nodes:x:@data.select/*
