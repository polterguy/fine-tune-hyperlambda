
// This Hyperlambda code connects to a SQLite database and retrieves metadata about a specified table's columns using the [sqlite.connect] and [sqlite.select] slots. It iterates over each column, determining attributes like nullability, primary key status, and whether the column is auto-incremented. The code also maps SQLite data types to Hyperlambda types using a [switch] statement, and constructs a detailed node structure for each column, which is then returned. Key slots include [sqlite.connect], [sqlite.select], [for-each], [if], [switch], and [add].
sqlite.connect:x:@.connection
   strings.concat
      .:"pragma table_info('"
      get-value:x:@.arguments/*/table
      .:"')"
   sqlite.select:x:@strings.concat
   for-each:x:@sqlite.select/*
      unwrap:x:+/*/*
      .tmp
         ""
            name:x:@.dp/#/*/name
            db:x:@.dp/#/*/type
      if
         eq
            get-value:x:@.dp/#/*/notnull
            .:long:1
         .lambda
            add:x:@.tmp/*
               .
                  nullable:bool:false
      else
         add:x:@.tmp/*
            .
               nullable:bool:true
      if
         eq
            get-value:x:@.dp/#/*/pk
            .:long:0
         .lambda
            add:x:@.tmp/*
               .
                  primary:bool:false
      else
         add:x:@.tmp/*
            .
               primary:bool:true
      if
         and
            not
               eq
                  get-value:x:@.dp/#/*/dflt_value
                  .:
            not
               eq
                  get-value:x:@.dp/#/*/dflt_value
                  .
         .lambda
            add:x:@.tmp/*
               .
                  automatic:bool:true
      else
         add:x:@.tmp/*
            .
               automatic:bool:false
         strings.to-lower:x:@.dp/#/*/type
         if
            and
               eq:x:@strings.to-lower
                  .:integer
               eq:x:@.dp/#/*/pk
                  .:long:1
            .lambda
               sqlite.select:"select 1 from sqlite_master where type = 'table' and name = @table and sql like '%AUTOINCREMENT%'"
                  @table:x:@.arguments/*/table
               if
                  exists:x:@sqlite.select/*/*
                  .lambda
                     set-value:x:@.tmp/*/*/automatic
                        .:bool:true
      .type
      strings.regex-replace:x:@.dp/#/*/type
         .:"\\([0-9,]+\\)"
         .:
      strings.replace:x:@strings.regex-replace
         .:" unsigned"
         .:
      strings.to-lower:x:@strings.replace
      switch:x:@strings.to-lower
         case:int
         case:integer
         case:tinyint
         case:smallint
         case:mediumint
         case:bigint
         case:big int
         case:int 2
         case:int 8
            set-value:x:@.type
               .:long
         case:timestamp
         case:date
         case:datetime
            set-value:x:@.type
               .:date
         case:numeric
         case:decimal
            set-value:x:@.type
               .:decimal
         case:real
         case:double
         case:float
         case:double precision
            set-value:x:@.type
               .:double
         case:character
         case:varchar
         case:varying character
         case:nchar
         case:native character
         case:nvarchar
         case:text
         case:clob
         case:char
         case:blob sub_type text
            set-value:x:@.type
               .:string
         case:boolean
            set-value:x:@.type
               .:bool
         default
            set-value:x:@.type
               .:string
      unwrap:x:+/*/*
      add:x:@.tmp/*
         .
            hl:x:@.type
      add:x:../*/sqlite.connect/*/return-nodes
         get-nodes:x:@.tmp/*
   return-nodes
