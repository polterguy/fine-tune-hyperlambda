
/*
 * /*
 *  * This Hyperlambda code processes a set of API endpoint definitions, dynamically constructing an OpenAPI (Swagger) specification based on input conditions and arguments. It evaluates conditions to determine the inclusion of nodes, modifies descriptions, and constructs URL paths and operation IDs. It also handles different HTTP verbs, generating appropriate request parameters or request bodies based on the verb type.
 *  *
 *  * 1. [if] - Evaluates complex conditions to determine if the subsequent lambda should execute.
 *  * 2. [and] - Combines multiple conditions that must all be true.
 *  * 3. [neq] - Checks if the type is not "internal".
 *  * 4. [or] - Combines conditions where at least one must be true.
 *  * 5. [eq] - Checks if the system argument is true.
 *  * 6. [strings.starts-with] - Checks if the path starts with "magic/modules/".
 *  * 7. [not-exists] - Checks if the filter argument does not exist.
 *  * 8. [null] - Checks if the filter argument is null.
 *  * 9. [strings.contains] - Checks if the path contains the filter value.
 *  * 10. [.lambda] - Executes the following nodes if conditions are met.
 *  * 11. [.exists] - Initializes a boolean flag to false.
 *  * 12. [for-each] - Iterates over paths to check for existence.
 *  * 13. [if] - Checks if the current path matches a specific pattern.
 *  * 14. [set-value] - Sets the exists flag to true if a match is found.
 *  * 15. [.buffer] - Initializes a buffer for constructing API details.
 *  * 16. [if] - Checks if the description exists and is longer than 300 characters.
 *  * 17. [set-value] - Truncates the description if it is too long.
 *  * 18. [set-name] - Sets the name of the verb node.
 *  * 19. [switch] - Handles different HTTP verbs (post, put, patch).
 *  * 20. [unwrap] - Unwraps nodes for further processing.
 *  * 21. [insert-after] - Inserts nodes after a specified node.
 *  * 22. [set-name] - Sets the name of the URL node.
 *  * 23. [strings.split] - Splits the path into components.
 *  * 24. [set-value] - Constructs the operationId using path components.
 *  * 25. [if] - Checks if the verb is get or delete.
 *  * 26. [add] - Adds parameters for get and delete requests.
 *  * 27. [for-each] - Iterates over input nodes to construct parameters.
 *  * 28. [if] - Checks if the type is not "*".
 *  * 29. [.arg] - Initializes an argument node.
 *  * 30. [set-value] - Sets the name and type of the argument.
 *  * 31. [switch] - Maps types to OpenAPI types.
 *  * 32. [if] - Checks if a description exists for the argument.
 *  * 33. [unwrap] - Unwraps nodes for further processing.
 *  * 34. [insert-after] - Inserts description after the name node.
 *  * 35. [add] - Adds argument nodes to the parameters.
 *  * 36. [else] - Handles non-get/delete verbs by constructing a request body.
 *  * 37. [.body] - Initializes a requestBody node.
 *  * 38. [for-each] - Iterates over input nodes to construct properties.
 *  * 39. [if] - Checks if a property does not exist in the schema.
 *  * 40. [.prop] - Initializes a property node.
 *  * 41. [set-value] - Sets the type of the property.
 *  * 42. [set-name] - Sets the name of the property.
 *  * 43. [if] - Checks if a description exists for the property.
 *  * 44. [unwrap] - Unwraps nodes for further processing.
 *  * 45. [add] - Adds description to the property.
 *  * 46. [add] - Adds property nodes to the schema.
 *  * 47. [if] - Checks if properties exist in the schema.
 *  * 48. [add] - Adds requestBody nodes to the buffer.
 *  * 49. [if] - Checks if parameters do not exist.
 *  * 50. [remove-nodes] - Removes parameters if they do not exist.
 *  * 51. [if] - Checks if the exists flag is true.
 *  * 52. [strings.concat] - Constructs a path string.
 *  * 53. [add] - Adds nodes to the result paths.
 *  * 54. [else] - Handles the case where the exists flag is false.
 *  * 55. [add] - Adds buffer nodes to the result.
 *  */
 */
if
   and
      neq:x:@.dp/#/*/type
         .:internal
      or
         eq:x:@.arguments/*/system
            .:bool:true
         strings.starts-with:x:@.dp/#/*/path
            .:magic/modules/
      or
         not-exists:x:@.arguments/*/filter
         null:x:@.arguments/*/filter
         strings.contains:x:@.dp/#/*/path
            get-value:x:@.arguments/*/filter
   .lambda
      .exists:bool:false
      for-each:x:@.result/*/paths/*
         if
            eq
               get-name:x:@.dp/#
               strings.concat
                  .:/
                  get-value:x:@for-each/@.dp/#/*/path
            .lambda
               set-value:x:@.exists
                  .:bool:true
      .buffer
         url
            verb
               operationId
               description
      if
         and
            exists:x:@.dp/#/*/description
            mt
               strings.length:x:@.dp/#/*/description
               .:int:300
         .lambda
            set-value:x:@.dp/#/*/description
               strings.substring:x:@.dp/#/*/description
                  .:int:0
                  .:int:300
      set-value:x:@.buffer/*/url/*/verb/*/description
         get-value:x:@.dp/#/*/description
      set-name:x:@.buffer/*/url/*/verb
         get-value:x:@.dp/#/*/verb
      switch:x:@.dp/#/*/verb
         case:post
         case:put
         case:patch
            unwrap:x:+/*/*/*
            insert-after:x:@.buffer/*/*/*/operationId
               .
                  consumes
                     .:x:@.dp/#/*/consumes
                  produces
                     .:application/json
      set-name:x:@.buffer/*/url
         strings.concat
            .:/
            get-value:x:@.dp/#/*/path
      strings.split:x:@.dp/#/*/path
         .:/
      set-value:x:@.buffer/*/*/*/operationId
         strings.concat
            get-value:x:@.dp/#/*/verb
            .:_
            get-value:x:@strings.split/0/-/-
            .:_
            get-value:x:@strings.split/0/-
      if
         or
            eq:x:@.dp/#/*/verb
               .:get
            eq:x:@.dp/#/*/verb
               .:delete
         .lambda
            add:x:@.buffer/*/*
               .
                  parameters
            for-each:x:@.dp/#/*/input/*
               if
                  neq:x:@.dp/#/*/type
                     .:*
                  .lambda
                     .arg
                        name
                        in:query
                        schema
                           type
                     set-value:x:@.arg/*/name
                        get-value:x:@.dp/#/*/name
                     switch:x:@.dp/#/*/type
                        case:short
                        case:ushort
                        case:int
                        case:uint
                        case:long
                        case:ulong
                           set-value:x:@.arg/*/schema/*/type
                              .:integer
                        case:float
                        case:double
                        case:decimal
                           set-value:x:@.arg/*/schema/*/type
                              .:number
                        case:bool
                           set-value:x:@.arg/*/schema/*/type
                              .:boolean
                        default
                           set-value:x:@.arg/*/schema/*/type
                              .:string
                     if
                        exists:x:@.dp/#/*/description
                        .lambda
                           unwrap:x:+/*/*
                           insert-after:x:@.arg/*/name
                              .
                                 description:x:@.dp/#/*/description
                     add:x:+/*/*
                        get-nodes:x:@.arg/*
                     add:x:@.buffer/*/*/*/parameters
                        .
                           .
      else
         .body
            requestBody
               content
                  application/json
                     schema
                        type:object
                        properties
         for-each:x:@.dp/#/*/input/*
            if
               not-exists:x:"@.body/*/requestBody/*/content/*/*/schema/*/properties/*/\"{@.dp/#/*/name}\""
               .lambda
                  .prop
                     name
                        type
                  set-value:x:@.prop/*/*/type
                     get-value:x:@.dp/#/*/type
                  set-name:x:@.prop/*
                     get-value:x:@.dp/#/*/name
                  if
                     exists:x:@.dp/#/*/description
                     .lambda
                        unwrap:x:+/*/*
                        add:x:@.prop/*
                           .
                              description:x:@.dp/#/*/description
                  add:x:@.body/*/requestBody/*/content/*/*/schema/*/properties
                     get-nodes:x:@.prop/*
         if
            exists:x:@.body/*/requestBody/*/content/*/*/schema/*/properties
            .lambda
               add:x:+/*
                  get-nodes:x:@.body/*
               add:x:@.buffer/*/*
                  .
      if
         not-exists:x:@.buffer/*/*/*/parameters/*
         .lambda
            remove-nodes:x:@.buffer/*/*/*/parameters
      if:x:@.exists
         strings.concat
            .:/
            get-value:x:@.dp/#/*/path
         add:x:@.result/*/paths/*/{@strings.concat}
            get-nodes:x:@.buffer/*/*
      else
         add:x:+/*
            get-nodes:x:@.buffer/*
         add:x:@.result/*/paths
            .
