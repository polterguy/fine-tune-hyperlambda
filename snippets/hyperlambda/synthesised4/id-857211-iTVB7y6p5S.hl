
/*
 * This Hyperlambda code defines a function that constructs and executes a SQL query to search for documents based on keyword density and count. It takes a query string, limit, and offset as arguments, splits the query into words, and constructs a SQL statement to calculate keyword density and count for each document. The results are ordered by keyword count and density, and limited by the specified limit and offset. The function returns the selected data after removing the keyword density and count from the results.
 * 
 * 1. [hyper2lambda] - Entry point for the function, defining the arguments and initializing the process.
 * 2. [.arguments] - Declares the input arguments: query, limit, and offset.
 * 3. [validators.mandatory] - Ensures the query argument is provided.
 * 4. [validators.default] - Sets a default value for the limit argument if not provided.
 * 5. [.words] - Initializes a list to store the split query words.
 * 6. [add] - Splits the query string into words and adds them to the list.
 * 7. [.no] - Initializes a counter for iterating over words.
 * 8. [for-each] - Iterates over each word, converting it to lowercase.
 * 9. [.columns] - Specifies the columns to be used in the SQL query.
 * 10. [data.connect] - Establishes a connection to the database.
 * 11. [.sql] - Begins constructing the SQL query string.
 * 12. [.fields] - Initializes a list to store SQL field expressions.
 * 13. [for-each] - Iterates over columns to construct SQL field expressions.
 * 14. [set-value] - Constructs the SQL field expressions and joins them.
 * 15. [remove-nodes] - Clears the fields list after use.
 * 16. [.no] - Re-initializes the counter for the next iteration.
 * 17. [for-each] - Iterates over words to construct SQL keyword density calculation.
 * 18. [if] - Constructs SQL for the first word differently than subsequent words.
 * 19. [math.increment] - Increments the counter.
 * 20. [set-value] - Finalizes the SQL keyword density calculation.
 * 21. [.no] - Re-initializes the counter for the next iteration.
 * 22. [for-each] - Iterates over words to construct SQL keyword count calculation.
 * 23. [if] - Constructs SQL for the first word differently than subsequent words.
 * 24. [math.increment] - Increments the counter.
 * 25. [set-value] - Finalizes the SQL keyword count calculation.
 * 26. [set-value] - Completes the SQL query with table name and conditions.
 * 27. [set-value] - Adds ordering and limit to the SQL query.
 * 28. [if] - Adds offset to the SQL query if provided.
 * 29. [data.select] - Executes the constructed SQL query.
 * 30. [remove-nodes] - Removes keyword density and count from the results.
 * 31. [return-nodes] - Returns the final selected data.
 */
hyper2lambda
   .arguments
      query:string
      limit:long
      offset:long
   validators.mandatory:x:@.arguments/*/query
   validators.default:x:@.arguments
      limit:long:10
   .words
   add:x:@.words
      strings.split:x:@.arguments/*/query
         .:" "
   .no:int:0
   for-each:x:@.words/*
      set-value:x:@.dp/#
         strings.to-lower:x:@.dp/#
   .columns
      .:title
      .:file_path
   data.connect:[generic|crm]
      database-type:sqlite
      .sql:select *, (
      .fields
      for-each:x:@.columns/*
         strings.concat
            .:coalesce(
            get-value:x:@.dp/#
            .:", '')"
         unwrap:x:+/*/*
         add:x:@.fields
            .
               .:x:@strings.concat
      set-value:x:@.fields
         strings.join:x:@.fields/*
            .:" || "
      remove-nodes:x:@.fields/*
      .no:int:0
      for-each:x:@.words/*
         set-name:x:+/+/*/*
            strings.concat
               .:@p
               get-value:x:@.no
         unwrap:x:+/*/*
         add:x:@data.connect/*/data.select
            .
               .:x:@.dp/#
         if
            eq:x:@.no
               .:int:0
            .lambda
               set-value:x:@.sql
                  strings.concat:x:@.sql
                     get-value:x:@.sql
                     .:" (length("
                     get-value:x:@.fields
                     .:) - length(replace(lower(
                     get-value:x:@.fields
                     .:), @p
                     get-value:x:@.no
                     .:", ''))) / length(@p"
                     get-value:x:@.no
                     .:)
         else
            set-value:x:@.sql
               strings.concat:x:@.sql
                  get-value:x:@.sql
                  .:" + (length("
                  get-value:x:@.fields
                  .:) - length(replace(lower(
                  get-value:x:@.fields
                  .:), @p
                  get-value:x:@.no
                  .:", ''))) / length(@p"
                  get-value:x:@.no
                  .:)
         math.increment:x:@.no
      set-value:x:@.sql
         strings.concat:x:@.sql
            get-value:x:@.sql
            .:) * 1.0 / length(
            get-value:x:@.fields
            .:) as keyword_density, (
      .no:int:0
      for-each:x:@.words/*
         if
            eq:x:@.no
               .:int:0
            .lambda
               set-value:x:@.sql
                  strings.concat:x:@.sql
                     get-value:x:@.sql
                     .:" CASE WHEN ((length("
                     get-value:x:@.fields
                     .:) - length(replace(lower(
                     get-value:x:@.fields
                     .:), @p
                     get-value:x:@.no
                     .:", ''))) / length(@p"
                     get-value:x:@.no
                     .:)) > 0 THEN 1 ELSE 0 END
         else
            set-value:x:@.sql
               strings.concat:x:@.sql
                  get-value:x:@.sql
                  .:" + CASE WHEN ((length("
                  get-value:x:@.fields
                  .:) - length(replace(lower(
                  get-value:x:@.fields
                  .:), @p
                  get-value:x:@.no
                  .:", ''))) / length(@p"
                  get-value:x:@.no
                  .:)) > 0 THEN 1 ELSE 0 END
         math.increment:x:@.no
      set-value:x:@.sql
         strings.concat:x:@.sql
            get-value:x:@.sql
            .:) as keyword_count
      set-value:x:@.sql
         strings.concat:x:@.sql
            get-value:x:@.sql
            .:" from "
            .:documents
            .:" where keyword_count > 0"
      set-value:x:@.sql
         strings.concat:x:@.sql
            get-value:x:@.sql
            .:" order by keyword_count desc, keyword_density desc limit "
            get-value:x:@.arguments/*/limit
      if
         exists:x:@.arguments/*/offset
         .lambda
            set-value:x:@.sql
               strings.concat:x:@.sql
                  get-value:x:@.sql
                  .:" offset "
                  get-value:x:@.arguments/*/offset
      data.select:x:@.sql
         database-type:sqlite
      remove-nodes:x:@data.select/*/*/keyword_density
      remove-nodes:x:@data.select/*/*/keyword_count
      return-nodes:x:@data.select/*
