
// This Hyperlambda code iterates over nodes in the [hyper2lambda] collection, checking each node's name and performing conditional logic based on its name and existence of certain children nodes. It uses [for-each] to loop through nodes, [if] and [or] for conditional checks, and [set-value] to modify node values. The code dynamically constructs expressions and adds them to a [candidates] collection, handling cases where nodes return complex objects with warnings.
for-each:x:@hyper2lambda/*
   .node-name
   set-value:x:@.node-name
      get-name:x:@.dp/#
   if
      or
         strings.starts-with:x:@.node-name
            .:.
         and
            eq:x:@.node-name
               .:execute
            exists:x:@.dp/#/*/name
            exists:x:@.dp/#/*/filename
      .lambda
         if
            eq:x:@.node-name
               .:execute
            .lambda
               load-file:x:@.dp/#/*/filename
               hyper2lambda:x:@load-file
               if
                  and
                     exists:x:@hyper2lambda/**/[yield|return|return-nodes]
                     not-exists:x:@hyper2lambda/**/[yield|return|return-nodes]/*
                  .lambda
                     .x
                     set-value:x:@.x
                        strings.concat
                           .:--/execute/=
                           get-value:x:@.dp/#/*/name
                           .:/*
                     if
                        not-exists:x:../*/return/*/candidates/*/*/expression/={@.x}
                        .lambda
                           unwrap:x:+/*/*/*
                           add:x:../*/return/*/candidates
                              .
                                 .
                                    name:x:@.x
                                    expression:x:@.x
                                    complete:bool:false
               else
                  for-each:x:@hyper2lambda/**/[yield|return|return-nodes]/*
                     if
                        exists:x:@.dp/#/*
                        .lambda
                           set-value:x:@.warning
                              .:Warning, some of your actions, and/or arguments, are returning complex objects, and we cannot automatically create candidate expressions for these. You will have to manually edit some of your expressions if you want to reference these nodes in your actions.
                     .x
                     set-value:x:@.x
                        strings.concat
                           .:--/execute/=
                           get-value:x:@.dp/@.dp/#/*/name
                           .:/*/
                           get-name:x:@.dp/#
                     if
                        not-exists:x:../*/return/*/candidates/*/*/expression/={@.x}
                        .lambda
                           unwrap:x:+/*/*/*
                           add:x:../*/return/*/candidates
                              .
                                 .
                                    name:x:@.x
                                    expression:x:@.x
                                    complete:bool:true
         else
            for-each:x:@.dp/#/*
               if
                  exists:x:@.dp/#/*
                  .lambda
                     set-value:x:@.warning
                        .:Warning, some of your actions, and/or arguments, are returning complex objects, and we cannot automatically create candidate expressions for these. You will have to manually edit some of your expressions if you want to reference these nodes in your actions.
               .x
               set-value:x:@.x
                  strings.concat
                     .:@
                     get-value:x:@.node-name
                     .:/*/
                     get-name:x:@.dp/#
               if
                  not-exists:x:../*/return/*/candidates/*/*/expression/={@.x}
                  .lambda
                     unwrap:x:+/*/*/*
                     add:x:../*/return/*/candidates
                        .
                           .
                              name:x:@.x
                              expression:x:@.x
                              complete:bool:true
            if
               not-null:x:@.dp/#
               .lambda
                  .x
                  set-value:x:@.x
                     strings.concat
                        .:@
                        get-value:x:@.node-name
                  if
                     not-exists:x:../*/return/*/candidates/*/*/expression/={@.x}
                     .lambda
                        unwrap:x:+/*/*/*
                        add:x:../*/return/*/candidates
                           .
                              .
                                 name:x:@.x
                                 expression:x:@.x
                                 complete:bool:true
