
// This Hyperlambda code creates a SQL query to search for keywords in a SQLite database table called "activities" and ranks results based on keyword density and count. It takes "query", "limit", and "offset" as arguments, splits the query into words, and constructs a dynamic SQL statement using these words. The SQL query calculates keyword density and count for each record, orders the results by these metrics, and applies pagination using the "limit" and "offset" arguments. The final result set is returned after removing intermediate calculation fields.
hyper2lambda
   .arguments
      query:string
      limit:long
      offset:long
   validators.mandatory:x:@.arguments/*/query
   validators.default:x:@.arguments
      limit:long:10
   .words
   add:x:@.words
      strings.split:x:@.arguments/*/query
         .:" "
   .no:int:0
   for-each:x:@.words/*
      set-value:x:@.dp/#
         strings.to-lower:x:@.dp/#
   .columns
      .:type
      .:notes
   data.connect:[generic|crm]
      database-type:sqlite
      .sql:select *, (
      .fields
      for-each:x:@.columns/*
         strings.concat
            .:coalesce(
            get-value:x:@.dp/#
            .:", '')"
         unwrap:x:+/*/*
         add:x:@.fields
            .
               .:x:@strings.concat
      set-value:x:@.fields
         strings.join:x:@.fields/*
            .:" || "
      remove-nodes:x:@.fields/*
      .no:int:0
      for-each:x:@.words/*
         set-name:x:+/+/*/*
            strings.concat
               .:@p
               get-value:x:@.no
         unwrap:x:+/*/*
         add:x:@data.connect/*/data.select
            .
               .:x:@.dp/#
         if
            eq:x:@.no
               .:int:0
            .lambda
               set-value:x:@.sql
                  strings.concat:x:@.sql
                     get-value:x:@.sql
                     .:" (length("
                     get-value:x:@.fields
                     .:) - length(replace(lower(
                     get-value:x:@.fields
                     .:), @p
                     get-value:x:@.no
                     .:", ''))) / length(@p"
                     get-value:x:@.no
                     .:)
         else
            set-value:x:@.sql
               strings.concat:x:@.sql
                  get-value:x:@.sql
                  .:" + (length("
                  get-value:x:@.fields
                  .:) - length(replace(lower(
                  get-value:x:@.fields
                  .:), @p
                  get-value:x:@.no
                  .:", ''))) / length(@p"
                  get-value:x:@.no
                  .:)
         math.increment:x:@.no
      set-value:x:@.sql
         strings.concat:x:@.sql
            get-value:x:@.sql
            .:) * 1.0 / length(
            get-value:x:@.fields
            .:) as keyword_density, (
      .no:int:0
      for-each:x:@.words/*
         if
            eq:x:@.no
               .:int:0
            .lambda
               set-value:x:@.sql
                  strings.concat:x:@.sql
                     get-value:x:@.sql
                     .:" CASE WHEN ((length("
                     get-value:x:@.fields
                     .:) - length(replace(lower(
                     get-value:x:@.fields
                     .:), @p
                     get-value:x:@.no
                     .:", ''))) / length(@p"
                     get-value:x:@.no
                     .:)) > 0 THEN 1 ELSE 0 END
         else
            set-value:x:@.sql
               strings.concat:x:@.sql
                  get-value:x:@.sql
                  .:" + CASE WHEN ((length("
                  get-value:x:@.fields
                  .:) - length(replace(lower(
                  get-value:x:@.fields
                  .:), @p
                  get-value:x:@.no
                  .:", ''))) / length(@p"
                  get-value:x:@.no
                  .:)) > 0 THEN 1 ELSE 0 END
         math.increment:x:@.no
      set-value:x:@.sql
         strings.concat:x:@.sql
            get-value:x:@.sql
            .:) as keyword_count
      set-value:x:@.sql
         strings.concat:x:@.sql
            get-value:x:@.sql
            .:" from "
            .:activities
            .:" where keyword_count > 0"
      set-value:x:@.sql
         strings.concat:x:@.sql
            get-value:x:@.sql
            .:" order by keyword_count desc, keyword_density desc limit "
            get-value:x:@.arguments/*/limit
      if
         exists:x:@.arguments/*/offset
         .lambda
            set-value:x:@.sql
               strings.concat:x:@.sql
                  get-value:x:@.sql
                  .:" offset "
                  get-value:x:@.arguments/*/offset
      data.select:x:@.sql
         database-type:sqlite
      remove-nodes:x:@data.select/*/*/keyword_density
      remove-nodes:x:@data.select/*/*/keyword_count
      return-nodes:x:@data.select/*
