
// This Hyperlambda code defines a dynamic slot [magic.ai.functions.invoke] that validates and processes function invocations. It ensures mandatory arguments are present, trims and checks the format of the invocation string, and interacts with a database to verify function existence. The code handles JSON payloads, loads and executes Hyperlambda files, and logs successful invocations. It also manages session, user, and type data, and yields results including JSON and workflow information. Key slots include [slots.create], [validators.mandatory], [strings.trim], [if], [data.connect], [json2lambda], [load-file], [hyper2lambda], [execute-file], and [yield].
hyper2lambda
   slots.create:magic.ai.functions.invoke
      validators.mandatory:x:@.arguments/*/type
      validators.mandatory:x:@.arguments/*/invocation
      set-value:x:@.arguments/*/invocation
         strings.trim:x:@.arguments/*/invocation
      if
         not
            strings.starts-with:x:@.arguments/*/invocation
               .:FUNCTION_INVOCATION
         .lambda
            throw:Malformatted function invocation
               status:int:400
               public:bool:true
      .file
      strings.split:x:@.arguments/*/invocation
         .:[
      strings.split:x:@strings.split/1
         .:]
      set-value:x:@.file
         get-value:x:@strings.split/0
      data.connect:[generic|magic]
         strings.concat
            :%FUNCTION_INVOCATION[
            get-value:x:@.file
            .:]%
         strings.concat
            :"FUNCTION_INVOCATION ==> "
            get-value:x:@.file
         data.scalar:select count(*) from ml_training_snippets where type = @type and (meta = @meta or completion like @completion)
            @type:x:@.arguments/*/type
            @meta:x:@strings.concat
            @completion:x:@strings.concat/@strings.concat
         if
            eq:x:@data.scalar
               .:long:0
            .lambda
               data.scalar:select count(*) from ml_types where type = @type and system_message like @func
                  @type:x:@.arguments/*/type
                  @func:x:@strings.concat/@strings.concat
               if
                  eq:x:@data.scalar
                     .:long:0
                  .lambda
                     throw:"That function doesn't exist on type"
                        public:bool:true
                        status:int:400
      .json
      if
         strings.contains:x:@.arguments/*/invocation
            .:":"
         .lambda
            strings.split:x:@.arguments/*/invocation
               .:":"
            remove-nodes:x:@strings.split/0
            set-value:x:@.json
               strings.join:x:@strings.split/*
                  .:":"
            if
               neq:x:@.json
                  .:
               .lambda
                  json2lambda:x:@.json
                  remove-nodes:x:@json2lambda/*/_session
                  remove-nodes:x:@json2lambda/*/_user-id
                  remove-nodes:x:@json2lambda/*/_type
                  add:x:../*/execute-file
                     get-nodes:x:@json2lambda/*
      load-file:x:@.file
      hyper2lambda:x:@load-file
      if
         exists:x:@hyper2lambda/*/.arguments/*/_session/=string
         .lambda
            unwrap:x:+/*/*
            add:x:../*/execute-file
               .
                  _session:x:@.arguments/*/session
      if
         exists:x:@hyper2lambda/*/.arguments/*/_user-id/=string
         .lambda
            unwrap:x:+/*/*
            add:x:../*/execute-file
               .
                  _user-id:x:@.arguments/*/user-id
      if
         exists:x:@hyper2lambda/*/.arguments/*/_extra/=string
         .lambda
            unwrap:x:+/*/*
            add:x:../*/execute-file
               .
                  _extra:x:@.arguments/*/extra
      if
         exists:x:@hyper2lambda/*/.arguments/*/_type/=string
         .lambda
            unwrap:x:+/*/*
            add:x:../*/execute-file
               .
                  _type:x:@.arguments/*/type
      execute-file:x:@.file
      log.info:Function invocation succeeded
         type:x:@.arguments/*/type
         function-file:x:@.file
      strings.split:x:@.file
         .:/
      strings.split:x:@strings.split/0/-
         .:.
      remove-nodes:x:@strings.split/0/-
      strings.join:x:@strings.split/*
         .:.
      add:x:./*/yield/*/result
         get-nodes:x:@execute-file/*
      yield
         json:x:@.json
         workflow:x:@strings.join
         result
