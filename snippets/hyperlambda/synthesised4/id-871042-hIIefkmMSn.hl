
/*
 * // This Hyperlambda code dynamically generates SQL scripts for different database types based on the provided database type argument. It supports MySQL, SQLite, and PostgreSQL, and constructs SQL statements to create tables, optionally including foreign key checks for MySQL. The code iterates over a list of tables and retrieves their creation SQL, concatenating results into a final script. The generated SQL is returned as a result.
 * // 1. [data.connect] - Establishes a database connection using the specified database type.
 * // 2. [switch] - Determines the database type and executes corresponding logic for SQL generation.
 * // 3. [case:mysql] - Handles SQL generation for MySQL, including optional database creation and foreign key checks.
 * // 4. [if] - Checks if full SQL generation is required, including database creation and foreign key settings.
 * // 5. [for-each] - Iterates over table names to generate SQL for each table.
 * // 6. [data.select] - Executes SQL to retrieve table creation statements.
 * // 7. [case:sqlite] - Handles SQL generation for SQLite, retrieving SQL from the sqlite_master table.
 * // 8. [case:pgsql] - Handles SQL generation for PostgreSQL, creating table SQL without sequences and indexes.
 * // 9. [unwrap] - Evaluates expressions and concatenates the final SQL script.
 * // 10. [return] - Returns the generated SQL script as the result.
 */
data.connect:x:-
   database-type:x:@.arguments/*/databaseType
   switch:x:@.arguments/*/databaseType
      case:mysql
         .result
         set-value:x:@.result
            strings.concat
               .:@"/*
 * Automatically generated by Magic.
 */
"
         if:x:@.arguments/*/full
            set-value:x:@.result
               strings.concat
                  get-value:x:@.result
                  .:"create database "
                  get-value:x:@.arguments/*/databaseName
                  .:@";
use "
                  get-value:x:@.arguments/*/databaseName
                  .:@";
set foreign_key_checks = 0;

"
         for-each:x:@.arguments/*/tables/*
            .sql
            set-value:x:@.sql
               strings.concat
                  .:"show create table "
                  get-value:x:@.dp/#
            data.select:x:@.sql
               database-type:x:@.arguments/*/databaseType
            set-value:x:@.result
               strings.concat
                  get-value:x:@.result
                  get-value:x:@data.select/*/1
                  .:@";

"
         if:x:@.arguments/*/full
            set-value:x:@.result
               strings.concat
                  get-value:x:@.result
                  .:@"SET foreign_key_checks = 1;
"
         unwrap:x:+/*
         return
            result:x:@.result
      case:sqlite
         .result
         set-value:x:@.result
            strings.concat
               .:@"/*
 * Automatically generated by Magic.
 */
"
         for-each:x:@.arguments/*/tables/*
            .sql
            set-value:x:@.sql
               strings.concat
                  .:"select sql from sqlite_master where type in ('table') and name = @name"
            data.select:x:@.sql
               database-type:x:@.arguments/*/databaseType
               name:x:@.dp/#
            set-value:x:@.result
               strings.concat
                  get-value:x:@.result
                  get-value:x:@data.select/*/*/sql
                  .:@";

"
         unwrap:x:+/*
         return
            result:x:@.result
      case:pgsql
         .result
         set-value:x:@.result
            strings.concat
               .:@"/*
 * Automatically generated by Magic.
 *
 * NOTICE! Sequences and indexes are NOT included.
 */
"
         for-each:x:@.arguments/*/tables/*
            .sql
            set-value:x:@.sql
               strings.concat
                  .:"\nselect 'create table ' || pc.relname || E'(\\n' ||\n   string_agg('  ' || pa.attname || ' ' || pg_catalog.format_type(pa.atttypid, pa.atttypmod) ||\n   coalesce(' default ' || (\n      select pg_catalog.pg_get_expr(d.adbin, d.adrelid)\n         from pg_catalog.pg_attrdef d\n         where d.adrelid = pa.attrelid and d.adnum = pa.attnum and pa.atthasdef), '') || ' ' ||\n              case pa.attnotnull\n                  when true then 'not null'\n                  else 'null'\n              end, E',\\n') ||\n   coalesce((select E',\\n' || string_agg('  constraint ' || pc1.conname || ' ' ||\n      pg_get_constraintdef(pc1.oid), E',\\n' order by pc1.conindid)\n            from pg_constraint pc1\n            where pc1.conrelid = pa.attrelid), '') ||\n   E'\\n);' as sql\nfrom pg_catalog.pg_attribute pa\njoin pg_catalog.pg_class pc\n    on pc.oid = pa.attrelid and pc.relname = @name\njoin pg_catalog.pg_namespace pn\n    on pn.oid = pc.relnamespace and pn.nspname = 'public'\nwhere pa.attnum > 0\n    and not pa.attisdropped\ngroup by pn.nspname, pc.relname, pa.attrelid;"
            data.select:x:@.sql
               database-type:x:@.arguments/*/databaseType
               name:x:@.dp/#
            set-value:x:@.result
               strings.concat
                  get-value:x:@.result
                  get-value:x:@data.select/*/*/sql
                  .:@"

"
         unwrap:x:+/*
         return
            result:x:@.result
