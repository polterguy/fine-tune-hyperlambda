
/*
 * // This Hyperlambda code iterates through nodes and checks for complex objects, generating candidate expressions for them if they don't already exist. It uses conditional logic to handle different scenarios and constructs expressions dynamically based on node names.
 * // 1. [else] - Executes the following block if previous conditions are false.
 * // 2. [for-each] - Iterates over each child node of the referenced node.
 * // 3. [if] - Checks if the current node has children.
 * // 4. [exists] - Determines if the current node has children.
 * // 5. [set-value] - Sets a warning message if complex objects are found.
 * // 6. [.x] - Temporary node for constructing expressions.
 * // 7. [strings.concat] - Concatenates strings to form an expression.
 * // 8. [get-value] - Retrieves the value of the node name.
 * // 9. [get-name] - Gets the name of the current node.
 * // 10. [if] - Checks if a candidate expression already exists.
 * // 11. [not-exists] - Determines if a candidate expression is missing.
 * // 12. [unwrap] - Evaluates expressions and adds nodes dynamically.
 * // 13. [add] - Adds a new candidate expression if it doesn't exist.
 * // 14. [not-null] - Checks if the current node is not null.
 * // 15. [set-value] - Constructs a simple expression for non-complex objects.
 * // 16. [if] - Checks if a simple candidate expression already exists.
 * // 17. [not-exists] - Determines if a simple candidate expression is missing.
 * // 18. [unwrap] - Evaluates expressions and adds nodes dynamically.
 * // 19. [add] - Adds a new simple candidate expression if it doesn't exist.
 */
else
   for-each:x:@.dp/#/*
      if
         exists:x:@.dp/#/*
         .lambda
            set-value:x:@.warning
               .:Warning, some of your actions, and/or arguments, are returning complex objects, and we cannot automatically create candidate expressions for these. You will have to manually edit some of your expressions if you want to reference these nodes in your actions.
      .x
      set-value:x:@.x
         strings.concat
            .:@
            get-value:x:@.node-name
            .:/*/
            get-name:x:@.dp/#
      if
         not-exists:x:../*/return/*/candidates/*/*/expression/={@.x}
         .lambda
            unwrap:x:+/*/*/*
            add:x:../*/return/*/candidates
               .
                  .
                     name:x:@.x
                     expression:x:@.x
                     complete:bool:true
   if
      not-null:x:@.dp/#
      .lambda
         .x
         set-value:x:@.x
            strings.concat
               .:@
               get-value:x:@.node-name
         if
            not-exists:x:../*/return/*/candidates/*/*/expression/={@.x}
            .lambda
               unwrap:x:+/*/*/*
               add:x:../*/return/*/candidates
                  .
                     .
                        name:x:@.x
                        expression:x:@.x
                        complete:bool:true
