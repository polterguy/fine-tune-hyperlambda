
// This Hyperlambda code processes nodes based on their names and conditions, generating expressions for candidate nodes. It checks if a node's name starts with a dot or equals "execute", and if certain nodes exist, it loads files and converts them to lambda objects. It handles complex objects by issuing warnings and creates expressions for nodes, ensuring uniqueness by checking for existing expressions before adding new candidates. The code uses slots like [if], [or], [and], [exists], [for-each], and [strings.concat] to perform these operations.
if
   or
      strings.starts-with:x:@.node-name
         .:.
      and
         eq:x:@.node-name
            .:execute
         exists:x:@.dp/#/*/name
         exists:x:@.dp/#/*/filename
   .lambda
      if
         eq:x:@.node-name
            .:execute
         .lambda
            load-file:x:@.dp/#/*/filename
            hyper2lambda:x:@load-file
            if
               and
                  exists:x:@hyper2lambda/**/[yield|return|return-nodes]
                  not-exists:x:@hyper2lambda/**/[yield|return|return-nodes]/*
               .lambda
                  .x
                  set-value:x:@.x
                     strings.concat
                        .:--/execute/=
                        get-value:x:@.dp/#/*/name
                        .:/*
                  if
                     not-exists:x:../*/return/*/candidates/*/*/expression/={@.x}
                     .lambda
                        unwrap:x:+/*/*/*
                        add:x:../*/return/*/candidates
                           .
                              .
                                 name:x:@.x
                                 expression:x:@.x
                                 complete:bool:false
            else
               for-each:x:@hyper2lambda/**/[yield|return|return-nodes]/*
                  if
                     exists:x:@.dp/#/*
                     .lambda
                        set-value:x:@.warning
                           .:Warning, some of your actions, and/or arguments, are returning complex objects, and we cannot automatically create candidate expressions for these. You will have to manually edit some of your expressions if you want to reference these nodes in your actions.
                  .x
                  set-value:x:@.x
                     strings.concat
                        .:--/execute/=
                        get-value:x:@.dp/@.dp/#/*/name
                        .:/*/
                        get-name:x:@.dp/#
                  if
                     not-exists:x:../*/return/*/candidates/*/*/expression/={@.x}
                     .lambda
                        unwrap:x:+/*/*/*
                        add:x:../*/return/*/candidates
                           .
                              .
                                 name:x:@.x
                                 expression:x:@.x
                                 complete:bool:true
      else
         for-each:x:@.dp/#/*
            if
               exists:x:@.dp/#/*
               .lambda
                  set-value:x:@.warning
                     .:Warning, some of your actions, and/or arguments, are returning complex objects, and we cannot automatically create candidate expressions for these. You will have to manually edit some of your expressions if you want to reference these nodes in your actions.
            .x
            set-value:x:@.x
               strings.concat
                  .:@
                  get-value:x:@.node-name
                  .:/*/
                  get-name:x:@.dp/#
            if
               not-exists:x:../*/return/*/candidates/*/*/expression/={@.x}
               .lambda
                  unwrap:x:+/*/*/*
                  add:x:../*/return/*/candidates
                     .
                        .
                           name:x:@.x
                           expression:x:@.x
                           complete:bool:true
         if
            not-null:x:@.dp/#
            .lambda
               .x
               set-value:x:@.x
                  strings.concat
                     .:@
                     get-value:x:@.node-name
               if
                  not-exists:x:../*/return/*/candidates/*/*/expression/={@.x}
                  .lambda
                     unwrap:x:+/*/*/*
                     add:x:../*/return/*/candidates
                        .
                           .
                              name:x:@.x
                              expression:x:@.x
                              complete:bool:true
