
/*
 * This Hyperlambda code generates SQL statements for creating tables in different database types (MySQL, SQLite, PostgreSQL) based on the provided arguments. It uses a switch-case structure to handle different database types, constructs SQL queries to retrieve table creation scripts, and concatenates these scripts into a result string. The code also includes optional handling for full database creation in MySQL, and returns the generated SQL as a result.
 * 
 * 1. [data.connect] - Establishes a connection to the database.
 * 2. [switch] - Determines the database type and executes corresponding logic.
 * 3. [case:mysql] - Handles SQL generation for MySQL.
 * 4. [set-value] - Concatenates strings to build SQL queries and results.
 * 5. [if] - Checks conditions to optionally include additional SQL statements.
 * 6. [for-each] - Iterates over tables to generate SQL for each.
 * 7. [data.select] - Executes SQL to retrieve table creation scripts.
 * 8. [unwrap] - Evaluates and executes expressions.
 * 9. [return] - Returns the generated SQL result.
 * 10. [case:sqlite] - Handles SQL generation for SQLite.
 * 11. [case:pgsql] - Handles SQL generation for PostgreSQL.
 */
data.connect:x:-
   database-type:x:@.arguments/*/databaseType
   switch:x:@.arguments/*/databaseType
      case:mysql
         .result
         set-value:x:@.result
            strings.concat
               .:@"/*
 * Automatically generated by Magic.
 */
"
         if:x:@.arguments/*/full
            set-value:x:@.result
               strings.concat
                  get-value:x:@.result
                  .:"create database "
                  get-value:x:@.arguments/*/databaseName
                  .:@";
use "
                  get-value:x:@.arguments/*/databaseName
                  .:@";
set foreign_key_checks = 0;

"
         for-each:x:@.arguments/*/tables/*
            .sql
            set-value:x:@.sql
               strings.concat
                  .:"show create table "
                  get-value:x:@.dp/#
            data.select:x:@.sql
               database-type:x:@.arguments/*/databaseType
            set-value:x:@.result
               strings.concat
                  get-value:x:@.result
                  get-value:x:@data.select/*/1
                  .:@";

"
         if:x:@.arguments/*/full
            set-value:x:@.result
               strings.concat
                  get-value:x:@.result
                  .:@"SET foreign_key_checks = 1;
"
         unwrap:x:+/*
         return
            result:x:@.result
      case:sqlite
         .result
         set-value:x:@.result
            strings.concat
               .:@"/*
 * Automatically generated by Magic.
 */
"
         for-each:x:@.arguments/*/tables/*
            .sql
            set-value:x:@.sql
               strings.concat
                  .:"select sql from sqlite_master where type in ('table') and name = @name"
            data.select:x:@.sql
               database-type:x:@.arguments/*/databaseType
               name:x:@.dp/#
            set-value:x:@.result
               strings.concat
                  get-value:x:@.result
                  get-value:x:@data.select/*/*/sql
                  .:@";

"
         unwrap:x:+/*
         return
            result:x:@.result
      case:pgsql
         .result
         set-value:x:@.result
            strings.concat
               .:@"/*
 * Automatically generated by Magic.
 *
 * NOTICE! Sequences and indexes are NOT included.
 */
"
         for-each:x:@.arguments/*/tables/*
            .sql
            set-value:x:@.sql
               strings.concat
                  .:"\nselect 'create table ' || pc.relname || E'(\\n' ||\n   string_agg('  ' || pa.attname || ' ' || pg_catalog.format_type(pa.atttypid, pa.atttypmod) ||\n   coalesce(' default ' || (\n      select pg_catalog.pg_get_expr(d.adbin, d.adrelid)\n         from pg_catalog.pg_attrdef d\n         where d.adrelid = pa.attrelid and d.adnum = pa.attnum and pa.atthasdef), '') || ' ' ||\n              case pa.attnotnull\n                  when true then 'not null'\n                  else 'null'\n              end, E',\\n') ||\n   coalesce((select E',\\n' || string_agg('  constraint ' || pc1.conname || ' ' ||\n      pg_get_constraintdef(pc1.oid), E',\\n' order by pc1.conindid)\n            from pg_constraint pc1\n            where pc1.conrelid = pa.attrelid), '') ||\n   E'\\n);' as sql\nfrom pg_catalog.pg_attribute pa\njoin pg_catalog.pg_class pc\n    on pc.oid = pa.attrelid and pc.relname = @name\njoin pg_catalog.pg_namespace pn\n    on pn.oid = pc.relnamespace and pn.nspname = 'public'\nwhere pa.attnum > 0\n    and not pa.attisdropped\ngroup by pn.nspname, pc.relname, pa.attrelid;"
            data.select:x:@.sql
               database-type:x:@.arguments/*/databaseType
               name:x:@.dp/#
            set-value:x:@.result
               strings.concat
                  get-value:x:@.result
                  get-value:x:@data.select/*/*/sql
                  .:@"

"
         unwrap:x:+/*
         return
            result:x:@.result
