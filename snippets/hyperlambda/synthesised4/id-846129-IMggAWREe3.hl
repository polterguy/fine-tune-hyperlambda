
// This Hyperlambda code defines a dynamic slot [magic.ai.functions.invoke] that validates and processes function invocations based on a specified type and invocation string. It checks for proper formatting, retrieves and processes associated data from a database, and manages JSON payloads. The slot ensures necessary session and user information are included before executing a file associated with the function. It logs successful invocations and yields the result, JSON payload, and workflow path. Key slots include [validators.mandatory] for argument validation, [strings.split] and [strings.join] for string manipulation, [data.scalar] for database queries, and [execute-file] for executing the function file.
slots.create:magic.ai.functions.invoke
   validators.mandatory:x:@.arguments/*/type
   validators.mandatory:x:@.arguments/*/invocation
   set-value:x:@.arguments/*/invocation
      strings.trim:x:@.arguments/*/invocation
   if
      not
         strings.starts-with:x:@.arguments/*/invocation
            .:FUNCTION_INVOCATION
      .lambda
         throw:Malformatted function invocation
            status:int:400
            public:bool:true
   .file
   strings.split:x:@.arguments/*/invocation
      .:[
   strings.split:x:@strings.split/1
      .:]
   set-value:x:@.file
      get-value:x:@strings.split/0
   data.connect:[generic|magic]
      strings.concat
         :%FUNCTION_INVOCATION[
         get-value:x:@.file
         .:]%
      strings.concat
         :"FUNCTION_INVOCATION ==> "
         get-value:x:@.file
      data.scalar:select count(*) from ml_training_snippets where type = @type and (meta = @meta or completion like @completion)
         @type:x:@.arguments/*/type
         @meta:x:@strings.concat
         @completion:x:@strings.concat/@strings.concat
      if
         eq:x:@data.scalar
            .:long:0
         .lambda
            data.scalar:select count(*) from ml_types where type = @type and system_message like @func
               @type:x:@.arguments/*/type
               @func:x:@strings.concat/@strings.concat
            if
               eq:x:@data.scalar
                  .:long:0
               .lambda
                  throw:"That function doesn't exist on type"
                     public:bool:true
                     status:int:400
   .json
   if
      strings.contains:x:@.arguments/*/invocation
         .:":"
      .lambda
         strings.split:x:@.arguments/*/invocation
            .:":"
         remove-nodes:x:@strings.split/0
         set-value:x:@.json
            strings.join:x:@strings.split/*
               .:":"
         if
            neq:x:@.json
               .:
            .lambda
               json2lambda:x:@.json
               remove-nodes:x:@json2lambda/*/_session
               remove-nodes:x:@json2lambda/*/_user-id
               remove-nodes:x:@json2lambda/*/_type
               add:x:../*/execute-file
                  get-nodes:x:@json2lambda/*
   load-file:x:@.file
   hyper2lambda:x:@load-file
   if
      exists:x:@hyper2lambda/*/.arguments/*/_session/=string
      .lambda
         unwrap:x:+/*/*
         add:x:../*/execute-file
            .
               _session:x:@.arguments/*/session
   if
      exists:x:@hyper2lambda/*/.arguments/*/_user-id/=string
      .lambda
         unwrap:x:+/*/*
         add:x:../*/execute-file
            .
               _user-id:x:@.arguments/*/user-id
   if
      exists:x:@hyper2lambda/*/.arguments/*/_extra/=string
      .lambda
         unwrap:x:+/*/*
         add:x:../*/execute-file
            .
               _extra:x:@.arguments/*/extra
   if
      exists:x:@hyper2lambda/*/.arguments/*/_type/=string
      .lambda
         unwrap:x:+/*/*
         add:x:../*/execute-file
            .
               _type:x:@.arguments/*/type
   execute-file:x:@.file
   log.info:Function invocation succeeded
      type:x:@.arguments/*/type
      function-file:x:@.file
   strings.split:x:@.file
      .:/
   strings.split:x:@strings.split/0/-
      .:.
   remove-nodes:x:@strings.split/0/-
   strings.join:x:@strings.split/*
      .:.
   add:x:./*/yield/*/result
      get-nodes:x:@execute-file/*
   yield
      json:x:@.json
      workflow:x:@strings.join
      result
