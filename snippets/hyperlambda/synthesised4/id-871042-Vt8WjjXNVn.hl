
// This Hyperlambda code iterates over a list of tables specified in [.arguments] and generates SQL statements to create each table by querying PostgreSQL system catalogs. It constructs the SQL for creating tables, including columns and constraints, using [strings.concat] and stores it in [.sql]. Then, it executes the generated SQL with [data.select] using the specified database type and table name, appending the results to [.result] with [set-value]. The process ensures that the SQL statements are dynamically generated and executed for each table in the list.
for-each:x:@.arguments/*/tables/*
   .sql
   set-value:x:@.sql
      strings.concat
         .:"\nselect 'create table ' || pc.relname || E'(\\n' ||\n   string_agg('  ' || pa.attname || ' ' || pg_catalog.format_type(pa.atttypid, pa.atttypmod) ||\n   coalesce(' default ' || (\n      select pg_catalog.pg_get_expr(d.adbin, d.adrelid)\n         from pg_catalog.pg_attrdef d\n         where d.adrelid = pa.attrelid and d.adnum = pa.attnum and pa.atthasdef), '') || ' ' ||\n              case pa.attnotnull\n                  when true then 'not null'\n                  else 'null'\n              end, E',\\n') ||\n   coalesce((select E',\\n' || string_agg('  constraint ' || pc1.conname || ' ' ||\n      pg_get_constraintdef(pc1.oid), E',\\n' order by pc1.conindid)\n            from pg_constraint pc1\n            where pc1.conrelid = pa.attrelid), '') ||\n   E'\\n);' as sql\nfrom pg_catalog.pg_attribute pa\njoin pg_catalog.pg_class pc\n    on pc.oid = pa.attrelid and pc.relname = @name\njoin pg_catalog.pg_namespace pn\n    on pn.oid = pc.relnamespace and pn.nspname = 'public'\nwhere pa.attnum > 0\n    and not pa.attisdropped\ngroup by pn.nspname, pc.relname, pa.attrelid;"
   data.select:x:@.sql
      database-type:x:@.arguments/*/databaseType
      name:x:@.dp/#
   set-value:x:@.result
      strings.concat
         get-value:x:@.result
         get-value:x:@data.select/*/*/sql
         .:@"

"
