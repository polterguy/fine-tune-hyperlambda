
/*
 * This endpoint performs an aggregation (min, max, sum, or avg) on a selected column 
 * in the 'Doctors' table of a hospital database, optionally filtered by a variety of 
 * dynamic conditions.
 *
 * The [.arguments] node defines:
 * - [aggregate_function], a **mandatory** parameter specifying which aggregation to perform 
 *   (must be one of: 'min', 'max', 'sum', or 'avg').
 * - [aggregate_column], a **mandatory** fully qualified column name (e.g., 'Doctors.DoctorID') 
 *   that indicates which field to aggregate.
 * - A set of **optional filtering arguments** such as 'Doctors.Specialty.like' or 
 *   'Doctors.Email.eq' that allow callers to narrow the scope of the aggregation.
 *
 * The [validators.mandatory] slots ensure that both [aggregate_function] and 
 * [aggregate_column] are supplied.
 *
 * The [validators.enum] slots validate that:
 * - [aggregate_function] is one of the permitted functions: 'min', 'max', 'sum', or 'avg'.
 * - [aggregate_column] is an approved column from the 'Doctors' table, ensuring both 
 *   structural and security integrity.
 *
 * The [response.headers.set] slot sets 'Cache-Control' to allow public caching of the 
 * response for 300 seconds, improving performance for repeat queries.
 *
 * The [auth.ticket.verify] slot ensures that only users with roles 'admin', 'guest', or 'root' 
 * are authorized to invoke this endpoint.
 *
 * The [data.connect] slot opens a connection to the 'hospital' database using the 
 * 'sqlite' engine and the 'generic' connector.
 *
 * Within the database connection context:
 * - The [set-name] slot dynamically constructs an aggregate expression such as 
 *   'avg(Doctors.DoctorID)' using [strings.concat], assigning it to a new node named 
 *   [aggregate_functor] inside the [columns] node of the upcoming [data.read] call.
 *
 * - The [remove-nodes] slot strips out the now-handled [aggregate_function] and 
 *   [aggregate_column] arguments to streamline the argument structure before filtering.
 *
 * - The [add] slot dynamically injects any remaining filtering arguments into the [where] 
 *   clause of the SQL query. These filtering parameters are **optional** and their presence 
 *   is detected at runtimeâ€”this enables **dynamic filtering** based on whatever arguments 
 *   the client provides. If no filters are given, the query will return an aggregate 
 *   computed over all records.
 *
 * The [data.read] slot executes the query against the 'Doctors' table:
 * - It includes the dynamically constructed [aggregate_functor] in the [columns] node, 
 *   aliased as [result].
 * - The [where] clause is initialized with an empty [and] node and dynamically populated 
 *   only if any filters are provided.
 * - The [limit] is set to 1 since the result is a single aggregated value.
 *
 * Finally, the [return-nodes] slot extracts and returns the resulting aggregate value 
 * to the client.
 */
.arguments

   // Function to aggregate upon. Argument is mandatory and legal values are min, max, sum or avg
   aggregate_function:string

   // Argument is mandatory and must be in the format of TABLE_NAME.COLUMN_NAME.
   aggregate_column:string
   Doctors.DoctorID.eq:long
   Doctors.FirstName.like:string
   Doctors.FirstName.eq:string
   Doctors.LastName.like:string
   Doctors.LastName.eq:string
   Doctors.Specialty.like:string
   Doctors.Specialty.eq:string
   Doctors.PhoneNumber.like:string
   Doctors.PhoneNumber.eq:string
   Doctors.Email.like:string
   Doctors.Email.eq:string

// Sanity checking mandatory arguments.
validators.mandatory:x:@.arguments/*/aggregate_function
validators.mandatory:x:@.arguments/*/aggregate_column

// Sanity checking name of aggregate function.
validators.enum:x:@.arguments/*/aggregate_function
   .:min
   .:max
   .:sum
   .:avg

// Sanity checking agggregate column name.
validators.enum:x:@.arguments/*/aggregate_column
   .:Doctors.DoctorID
   .:Doctors.FirstName
   .:Doctors.LastName
   .:Doctors.Specialty
   .:Doctors.PhoneNumber
   .:Doctors.Email

// Adding Cache-Control HTTP header.
response.headers.set
   Cache-Control:public, max-age=300

// Verifying user is authorized to access endpoint.
auth.ticket.verify:admin,guest,root

// Opening up our database connection.
data.connect:[generic|hospital]
   database-type:sqlite

   // Making sure we're using correct aggregate function.
   set-name:x:./*/data.read/*/columns/*/aggregate_functor
      strings.concat
         get-value:x:@.arguments/*/aggregate_function
         .:(
         get-value:x:@.arguments/*/aggregate_column
         .:)

   // Removing aggregate arguments to simplify adding other arguments.
   remove-nodes:x:@.arguments/*/[0,2]
   add:x:./*/data.read/*/where/*
      get-nodes:x:@.arguments/*

   // Reading data from database.
   data.read
      database-type:sqlite
      table:Doctors
      columns
         aggregate_functor
            as:result
      where
         and
      limit:long:1

   // Returning result of above read invocation to caller.
   return-nodes:x:@data.read/*/*
