
// Update the session cache only if the [.arguments/*/session] node exists and is not null. If [.result] is not null and not empty, unwrap the next content node and add an assistant message with that content to the [.session] node. If [.new-prompt] is not null and not empty, unwrap the next content node and add a system message with that content to the [.session] node. Then copy all session messages to a [.cache-session] node, set [.tmp] to the value of [.fixed], and while [.tmp] is greater than zero, remove the oldest message from [.cache-session] and decrement [.tmp]. Serialize all messages in [.cache-session] into a format suitable for storage using [lambda2hyper], and finally save the result in the cache using the session ID as the key, the session timeout as expiration, and the serialized session data as the value.
if
   and
      exists:x:@.arguments/*/session
      not-null:x:@.arguments/*/session
   .lambda
      if
         and
            not-null:x:@.result
            neq:x:@.result
               .:
         .lambda
            unwrap:x:+/*/*/*/content
            add:x:@.session
               .
                  .
                     role:assistant
                     content:x:@.result
      if
         and
            not-null:x:@.new-prompt
            neq:x:@.new-prompt
               .:
         .lambda
            unwrap:x:+/*/*/*/content
            add:x:@.session
               .
                  .
                     role:system
                     content:x:@.new-prompt
      .cache-session
      add:x:@.cache-session
         get-nodes:x:@.session/*
      .tmp
      set-value:x:@.tmp
         get-value:x:@.fixed
      while
         mt:x:@.tmp
            .:int:0
         .lambda
            remove-nodes:x:@.cache-session/0
            math.decrement:x:@.tmp
      lambda2hyper:x:@.cache-session/*
      cache.set:x:@.arguments/*/session
         expiration:x:@.arguments/*/session_timeout
         value:x:@lambda2hyper
