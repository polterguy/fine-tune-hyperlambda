
// Check if a node named [cached] exists as a child of the [signal] node. If it does, then further check if the [supervised] node exists as a child of the [.arguments] node, is not null, and equals the integer value 1 after conversion. If all these conditions are met, create a record in the ml_requests table using [data.connect:[generic|magic]] with values from [.arguments] and the cached value. Finally, unwrap the next sibling node, and return a result with the value of [cached] from the [signal] node, the finish_reason as "cached", and stream as false.
if
   exists:x:@signal/*/cached
   .lambda
      if
         and
            exists:x:@.arguments/*/supervised
            not-null:x:@.arguments/*/supervised
            eq
               convert:x:@.arguments/*/supervised
                  type:int
               .:int:1
         .lambda
            data.connect:[generic|magic]
               data.create
                  table:ml_requests
                  values
                     type:x:@.arguments/*/type
                     prompt:x:@.arguments/*/prompt
                     completion:x:@signal/*/cached
                     finish_reason:cached
                     session:x:@.arguments/*/session
                     user_id:x:@.arguments/*/user_id
                     referrer:x:@.arguments/*/referrer
      unwrap:x:+/*
      return
         result:x:@signal/*/cached
         finish_reason:cached
         stream:bool:false
