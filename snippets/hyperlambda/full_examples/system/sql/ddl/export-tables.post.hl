
/*
 * This HTTP endpoint exports one or more tables as DDL (CREATE TABLE) statements from a given database.
 *
 * # Arguments:
 * - [databaseType]: Enum. Required. Supported values include 'mysql', 'sqlite', and 'pgsql'.
 * - [connectionString]: Required. Connection string to the database.
 * - [databaseName]: Required. Name of the database.
 * - [tables]: Required. List of table names to export.
 * - [full]: Optional boolean. If true, the result will include database-level setup like "create database" and toggle for foreign key checks.
 *
 * # Features:
 * - Supports MySQL, SQLite, and PostgreSQL dialects.
 * - Uses the correct introspection SQL queries per vendor to generate DDL.
 * - Outputs DDL as raw SQL to caller, including foreign key and constraint definitions (where supported).
 * - Includes consistent file header for traceability: "Automatically generated by Magic".
 * - For MySQL and SQLite, uses native "SHOW CREATE TABLE" and "sqlite_master".
 * - For PostgreSQL, reconstructs DDL from system catalog tables with column definitions and constraints.
 * - Conditionally includes "create database" and foreign key constraint toggles if [full] is true.
 *
 * # Returns:
 * A [result] string containing all DDL statements separated by line breaks and comments.
 *
 * # Security:
 * - Requires a [root] ticket via [auth.ticket.verify].
 */
.arguments
   databaseType:string
   connectionString:string
   databaseName:string
   tables
      .:*
   full:bool

// Ensures user is authorized to access endpoint.
auth.ticket.verify:root

// Sanity checking invocation.
validators.mandatory:x:@.arguments/*/connectionString
validators.mandatory:x:@.arguments/*/databaseName
validators.mandatory:x:@.arguments/*/tables
validators.mandatory:x:@.arguments/*/databaseType
validators.enum:x:@.arguments/*/databaseType
   .:mysql
   .:sqlite
   .:pgsql

// Creating our database connection.
strings.concat
   .:[
   get-value:x:@.arguments/*/connectionString
   .:|
   get-value:x:@.arguments/*/databaseName
   .:]
data.connect:x:-
   database-type:x:@.arguments/*/databaseType

   // Creating our correct SQL according to [databaseType].
   switch:x:@.arguments/*/databaseType

      case:mysql

         .result
         set-value:x:@.result
            strings.concat
               .:"/*\r\n * Automatically generated by Magic.\r\n */\r\n"
         if:x:@.arguments/*/full
            set-value:x:@.result
               strings.concat
                  get-value:x:@.result
                  .:"create database "
                  get-value:x:@.arguments/*/databaseName
                  .:";\r\nuse "
                  get-value:x:@.arguments/*/databaseName
                  .:";\r\nset foreign_key_checks = 0;\r\n\r\n"
         for-each:x:@.arguments/*/tables/*
            .sql
            set-value:x:@.sql
               strings.concat
                  .:"show create table "
                  get-value:x:@.dp/#
            data.select:x:@.sql
               database-type:x:@.arguments/*/databaseType
            set-value:x:@.result
               strings.concat
                  get-value:x:@.result
                  get-value:x:@data.select/*/1
                  .:";\r\n\r\n"
         if:x:@.arguments/*/full
            set-value:x:@.result
               strings.concat
                  get-value:x:@.result
                  .:"SET foreign_key_checks = 1;\r\n"
         unwrap:x:+/*
         return
            result:x:@.result

      case:sqlite

         .result
         set-value:x:@.result
            strings.concat
               .:"/*\r\n * Automatically generated by Magic.\r\n */\r\n"
         for-each:x:@.arguments/*/tables/*
            .sql
            set-value:x:@.sql
               strings.concat
                  .:"select sql from sqlite_master where type in ('table') and name = @name"
            data.select:x:@.sql
               database-type:x:@.arguments/*/databaseType
               name:x:@.dp/#
            set-value:x:@.result
               strings.concat
                  get-value:x:@.result
                  get-value:x:@data.select/*/*/sql
                  .:";\r\n\r\n"
         unwrap:x:+/*
         return
            result:x:@.result

      case:pgsql

         .result
         set-value:x:@.result
            strings.concat
               .:"/*\r\n * Automatically generated by Magic.\r\n *\r\n * NOTICE! Sequences and indexes are NOT included.\r\n */\r\n"
         for-each:x:@.arguments/*/tables/*
            .sql
            set-value:x:@.sql
               strings.concat
                  .:@"
select 'create table ' || pc.relname || E'(\n' ||
   string_agg('  ' || pa.attname || ' ' || pg_catalog.format_type(pa.atttypid, pa.atttypmod) ||
   coalesce(' default ' || (
      select pg_catalog.pg_get_expr(d.adbin, d.adrelid)
         from pg_catalog.pg_attrdef d
         where d.adrelid = pa.attrelid and d.adnum = pa.attnum and pa.atthasdef), '') || ' ' ||
              case pa.attnotnull
                  when true then 'not null'
                  else 'null'
              end, E',\n') ||
   coalesce((select E',\n' || string_agg('  constraint ' || pc1.conname || ' ' ||
      pg_get_constraintdef(pc1.oid), E',\n' order by pc1.conindid)
            from pg_constraint pc1
            where pc1.conrelid = pa.attrelid), '') ||
   E'\n);' as sql
from pg_catalog.pg_attribute pa
join pg_catalog.pg_class pc
    on pc.oid = pa.attrelid and pc.relname = @name
join pg_catalog.pg_namespace pn
    on pn.oid = pc.relnamespace and pn.nspname = 'public'
where pa.attnum > 0
    and not pa.attisdropped
group by pn.nspname, pc.relname, pa.attrelid;"
            data.select:x:@.sql
               database-type:x:@.arguments/*/databaseType
               name:x:@.dp/#
            set-value:x:@.result
               strings.concat
                  get-value:x:@.result
                  get-value:x:@data.select/*/*/sql
                  .:"\r\n\r\n"
         unwrap:x:+/*
         return
            result:x:@.result
