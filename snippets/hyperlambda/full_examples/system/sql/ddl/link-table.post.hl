
/*
 * This Hyperlambda HTTP endpoint dynamically creates a many-to-many link table in a SQL database.
 * 
 * 1. [.arguments]
 *    - Accepts the database type, connection string, database name, and the link table schema including PK columns from [table1] and [table2].
 *    - Supports an optional [generate] argument to return the DDL SQL without executing it.
 *
 * 2. [auth.ticket.verify]
 *    - Ensures only users with [root] privileges can invoke this endpoint.
 *
 * 3. [validators.mandatory], [validators.enum]
 *    - Validates that essential inputs like [databaseType], [connectionString], and [args] are present and legal.
 *
 * 4. [.sql], [.pk], [.fk], [.first]
 *    - Constructs the SQL DDL string by:
 *      - Declaring each primary key column from both tables.
 *      - Including optional foreign key references (if not MySQL).
 *      - Composing a [primary key(...)] constraint combining all PKs.
 *
 * 5. [generate]
 *    - If [generate] is true, returns the composed SQL to the client without executing it.
 *
 * 6. [data.connect], [data.execute]
 *    - Executes the generated SQL to create the link table in the target database.
 *    - Clears any cached metadata for the given connection to refresh schema state.
 *
 * 7. [return]
 *    - Returns a success response with the raw SQL statement for audit or debugging purposes.
 *
 * This endpoint is ideal for auto-generating normalized relational schemas when defining join/link tables in dynamic database modeling tools.
 */
.arguments
   databaseType:string
   connectionString:string
   databaseName:string
   args
      name:string
      table1:string
      table2:string
      table1pk
         .
            name:string
            type:string
            length:int
      table2pk
         .
            name:string
            type:string
            length:int
   generate:bool

// Ensures user is authorized to access endpoint.
auth.ticket.verify:root

// Sanity checking invocation.
validators.mandatory:x:@.arguments/*/connectionString
validators.mandatory:x:@.arguments/*/databaseName
validators.mandatory:x:@.arguments/*/args
validators.mandatory:x:@.arguments/*/databaseType
validators.enum:x:@.arguments/*/databaseType
   .:mysql
   .:sqlite
   .:pgsql
   .:mssql

// Creating our DDL SQL.
.sql

// Create table DDL.
set-value:x:@.sql
   strings.concat
      .:"create table "
      get-value:x:@.arguments/*/args/*/name
      .:"("

// Looping through primary keys in table1.
.first:bool:true
.pk:
.fk:
for-each:x:@.arguments/*/args/*/table1pk/*

   // Checking if this is our first column or not.
   if:x:@.first
      set-value:x:@.first
         .:bool:false
      set-value:x:@.sql
         strings.concat
            get-value:x:@.sql
            .:"\r\n  "
   else
      set-value:x:@.sql
         strings.concat
            get-value:x:@.sql
            .:",\r\n  "

   // Adding column name and type.
   set-value:x:@.sql
      strings.concat
         get-value:x:@.sql
         get-value:x:@.dp/#/*/name
         .:" "
         get-value:x:@.dp/#/*/type

   // Checking if type has a length.
   if
      and
         exists:x:@.dp/#/*/length
         not-null:x:@.dp/#/*/length
      .lambda
         set-value:x:@.sql
            strings.concat
               get-value:x:@.sql
               .:(
               get-value:x:@.dp/#/*/length
               .:)

   // Adding references constraint for column if not MySQL.
   if
      neq:x:@.arguments/*/databaseType
         .:mysql
      .lambda
         set-value:x:@.sql
            strings.concat
               get-value:x:@.sql
               .:" references "
               get-value:x:@.arguments/*/args/*/table1
               .:" ("
               get-value:x:@.dp/#/*/name
               .:")"
   else
      set-value:x:@.fk
         strings.concat
            get-value:x:@.fk
            .:",\r\n foreign key ("
            get-value:x:@.dp/#/*/name
            .:") references "
            get-value:x:@.arguments/*/args/*/table1
            .:" ("
            get-value:x:@.dp/#/*/name
            .:)

   // Storing primary key's name.
   set-value:x:@.pk
      strings.concat
         get-value:x:@.pk
         get-value:x:@.dp/#/*/name
         .:,

// Looping through primary keys in table2.
for-each:x:@.arguments/*/args/*/table2pk/*

   // Checking if this is our first column or not.
   if:x:@.first
      set-value:x:@.first
         .:bool:false
      set-value:x:@.sql
         strings.concat
            get-value:x:@.sql
            .:"\r\n  "
   else
      set-value:x:@.sql
         strings.concat
            get-value:x:@.sql
            .:",\r\n  "

   // Adding column name and type.
   set-value:x:@.sql
      strings.concat
         get-value:x:@.sql
         get-value:x:@.dp/#/*/name
         .:" "
         get-value:x:@.dp/#/*/type

   // Checking if type has a length.
   if
      and
         exists:x:@.dp/#/*/length
         not-null:x:@.dp/#/*/length
      .lambda
         set-value:x:@.sql
            strings.concat
               get-value:x:@.sql
               .:(
               get-value:x:@.dp/#/*/length
               .:)

   // Adding references constraint for column if not MySQL.
   if
      neq:x:@.arguments/*/databaseType
         .:mysql
      .lambda
         set-value:x:@.sql
            strings.concat
               get-value:x:@.sql
               .:" references "
               get-value:x:@.arguments/*/args/*/table2
               .:" ("
               get-value:x:@.dp/#/*/name
               .:")"
   else
      set-value:x:@.fk
         strings.concat
            get-value:x:@.fk
            .:",\r\n foreign key ("
            get-value:x:@.dp/#/*/name
            .:") references "
            get-value:x:@.arguments/*/args/*/table2
            .:" ("
            get-value:x:@.dp/#/*/name
            .:)

   // Storing primary key's name.
   set-value:x:@.pk
      strings.concat
         get-value:x:@.pk
         get-value:x:@.dp/#/*/name
         .:,

// Adding primary key to table.
strings.trim:x:@.pk
   .:,

set-value:x:@.sql
   strings.concat
      get-value:x:@.sql
      .:",\r\n  primary key("
      get-value:x:@strings.trim
      .:)

// Adding closing paranthesis and semi colon.
set-value:x:@.sql
   strings.concat
      get-value:x:@.sql
      get-value:x:@.fk
      .:");"

// Checking if caller only wants to generate SQL statement.
if:x:@.arguments/*/generate
   unwrap:x:+/*
   return
      sql:x:@.sql

// Creating our database connection and executing our SQL.
strings.concat
   .:[
   get-value:x:@.arguments/*/connectionString
   .:|
   get-value:x:@.arguments/*/databaseName
   .:]
data.connect:x:-
   database-type:x:@.arguments/*/databaseType
   data.execute:x:@.sql
      database-type:x:@.arguments/*/databaseType

// Flushing database cache.
strings.concat
   .:magic.sql.databases.
   get-value:x:@.arguments/*/databaseType
   :.
   get-value:x:@.arguments/*/connectionString
cache.set:x:-

// Returning result to caller.
unwrap:x:+/*
return
   result:success
   sql:x:@.sql

