
/*
 * This Hyperlambda slot dynamically lists all columns in a PostgreSQL table.
 *
 * 1. [slots.create:magic.db.pgsql.columns]
 *    * Declares a dynamic slot named [magic.db.pgsql.columns].

 * 2. [validators.mandatory:x:@.arguments/*/database], [validators.mandatory:x:@.arguments/*/table]
 *    * Validates that the [database] and [table] arguments are provided.

 * 3. [.connection]
 *    * Constructs the database connection string dynamically using either a custom [connection-string]
 *      argument or defaults to the [generic] connection string with the specified [database].

 * 4. [pgsql.connect:x:@.connection]
 *    * Establishes a connection to the PostgreSQL database using the constructed connection string.

 * 5. [pgsql.select]
 *    * Executes a raw SQL query against the [information_schema.columns] and [key_column_usage] tables to
 *      retrieve metadata for each column of the specified [table], including:
 *       - [column_name]
 *       - [is_nullable]
 *       - [data_type]
 *       - [column_default]
 *       - [is_pk] (if the column is part of the primary key)

 * 6. [for-each]
 *    * Iterates over the returned column rows to normalize and structure the metadata into a common format.

 * 7. [.tmp]
 *    * Constructs a new node with the following metadata for each column:
 *       - [name]: Column name
 *       - [db]: Database-specific column type
 *       - [nullable]: Whether the column is nullable
 *       - [primary]: Whether the column is part of the primary key
 *       - [automatic]: Whether the column has a default value
 *       - [hl]: Mapped Hyperlambda type, such as [int], [bool], [date], etc.

 * 8. [strings.regex-replace], [strings.replace]
 *    * Normalizes PostgreSQL-specific data types by removing suffixes such as [unsigned], time zone descriptors, etc.

 * 9. [switch:x:@strings.replace]
 *    * Maps PostgreSQL column types to corresponding Hyperlambda types using a switch-case pattern.

 * 10. [add]
 *     * Adds the processed metadata for each column into the final return list.

 * 11. [return-nodes]
 *     * Returns the list of columns and their normalized metadata to the caller.
 *
 *
 * **Use cases:**
 * * Used in data modeling tools or admin panels to introspect PostgreSQL table schemas.
 * * Automatically generate forms, filters, or CRUD endpoints based on column metadata.
 * * Ideal for integrations where database introspection is necessary for scaffolding frontend/backend code.
 */
slots.create:magic.db.pgsql.columns

   // Sanity checking invocation.
   validators.mandatory:x:@.arguments/*/database
   validators.mandatory:x:@.arguments/*/table

   // Opens up our connection
   .connection:[postgres]
   if
      and
         not
            eq
               get-value:x:@.arguments/*/connection-string
               .
         not
            eq
               get-value:x:@.arguments/*/connection-string
               .:
      .lambda
         set-value:x:@.connection
            strings.concat
               .:[
               get-value:x:@.arguments/*/connection-string
               .:|
               get-value:x:@.arguments/*/database
               .:]
   else
      set-value:x:@.connection
         strings.concat
            .:[generic|
            get-value:x:@.arguments/*/database
            .:]
   pgsql.connect:x:@.connection

      // Making sure we support table names with special characters.
      strings.concat
         .:@"
select c.column_name, c.is_nullable, c.data_type, c.column_default, exists(
   select *
      from information_schema.key_column_usage kcu  
         join information_schema.table_constraints tc on tc.constraint_name = kcu.constraint_name 
      where tc.constraint_type = 'PRIMARY KEY' and
         kcu.table_name = @table and 
         c.column_name = kcu.column_name and c.table_name = kcu.table_name
   ) as is_pk
   from information_schema.columns c
   where c.table_name = @table and c.table_catalog = @database order by is_pk desc, c.column_name asc"
      pgsql.select:x:@strings.concat
         @table:x:@.arguments/*/table
         @database:x:@.arguments/*/database

      /*
       * Creating our return value, by projecting it into
       * a generic form, that does not rely upon PostgreSQL's syntactic
       * details.
       */
      for-each:x:@pgsql.select/*
         unwrap:x:+/*/*
         .tmp
            ""
               name:x:@.dp/#/*/column_name
               db:x:@.dp/#/*/data_type

         // Checking if column is nullable.
         if
            eq
               get-value:x:@.dp/#/*/is_nullable
               .:NO
            .lambda
               add:x:@.tmp/*
                  .
                     nullable:bool:false
         else
            add:x:@.tmp/*
               .
                  nullable:bool:true

         // Checking if column is a part of the primary key.
         if
            get-value:x:@.dp/#/*/is_pk
            .lambda
               add:x:@.tmp/*
                  .
                     primary:bool:true
         else
            add:x:@.tmp/*
               .
                  primary:bool:false

         // Checking if column has a default value.
         if
            and
               not
                  eq
                     get-value:x:@.dp/#/*/column_default
                     .:
               not
                  eq
                     get-value:x:@.dp/#/*/column_default
                     .
            .lambda
               add:x:@.tmp/*
                  .
                     automatic:bool:true
         else
            add:x:@.tmp/*
               .
                  automatic:bool:false

         /*
          * Figuring our which Hyperlambda type to project
          * its database type to.
          */
         .type

         // Anything BUT booleans.
         strings.regex-replace:x:@.dp/#/*/data_type
            .:" \\([0-9,]+\\)"
            .:
         strings.regex-replace:x:@strings.regex-replace
            .:" \\[[0-9,]+\\]"
            .:
         strings.replace:x:@strings.regex-replace
            .:" unsigned"
            .:
         strings.replace:x:@strings.replace
            .:" without time zone"
            .:
         strings.replace:x:@strings.replace
            .:" with time zone"
            .:
         switch:x:@strings.replace

            // Everything transformed into date values.
            case:smallserial
            case:serial
            case:smallint
               set-value:x:@.type
                  .:int

            // Everything transformed into date values.
            case:timestamp
               set-value:x:@.type
                  .:date

            // Everything transformed into decimal values.
            case:numeric
            case:decimal
            case:real
            case:money
               set-value:x:@.type
                  .:decimal

            // Everything transformed into double.
            case:double precision
               set-value:x:@.type
                  .:double

            // Everything transformed into integer long values.
            case:integer
            case:bigint
            case:bigserial
            case:interval
               set-value:x:@.type
                  .:long

            // Everything transformed into string values.
            case:string
            case:bit
            case:bit varying
            case:character
            case:character varying
            case:json
            case:text
            case:xml
               set-value:x:@.type
                  .:string

            // Everything transformed into boolean values.
            case:boolean
               set-value:x:@.type
                  .:bool

            // Default/special cases.
            default
               if
                  strings.starts-with:x:@strings.replace
                     .:enum
                  .lambda

                     // Enum type
                     set-value:x:@.type
                        .:string
               else

                  // Defaulting to string type.
                  set-value:x:@.type
                     .:string

         // Adding Hyperlambda type to [.tmp] above.
         unwrap:x:+/*/*
         add:x:@.tmp/*
            .
               hl:x:@.type

         // Adding [.tmp] to [return-nodes] below.
         add:x:../*/pgsql.connect/*/return-nodes
            get-nodes:x:@.tmp/*

      // Returning results to caller.
      return-nodes
