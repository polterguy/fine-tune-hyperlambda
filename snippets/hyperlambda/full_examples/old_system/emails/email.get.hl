
/*
 * This Hyperlambda snippet defines an HTTP API endpoint that returns the root user's email address.
 *
 * 1. [auth.ticket.verify:root]
 *    * Ensures that only users with the [root] role can access the endpoint.

 * 2. [signal:magic.crypto.get-server-public-key]
 *    * Retrieves the serverâ€™s public key, which includes its [fingerprint].
 *    * This key was generated when the system was first set up, and is used to look up root credentials.

 * 3. [data.connect:[generic|magic]]
 *    * Opens a connection to the [magic] database using the [generic] connection string.

 * 4. [data.read]
 *    * Performs a SELECT operation from the [crypto_keys] table.
 *    * Filters records to those where the [fingerprint] matches the server's public key.
 *    * Returns the [email] and [subject] columns.

 * 5. [unwrap:x:+/*]
 *    * Moves the returned data to the root level so it can be returned properly.

 * 6. [return]
 *    * Returns two values to the caller:
 *       - [email]: The root user's registered email.
 *       - [name]: The [subject] of the cryptographic key, typically the full name of the admin.
 *
 *
 * Use cases:
 * * Used for displaying the server admin email in settings or profile sections.
 * * Useful for validating ownership or verifying root setup.
 * * Can be extended for auditing or notification purposes where contact info is required.
 */

// Ensures user is authorized to access endpoint.
auth.ticket.verify:root

/*
 * Notice, the only place we actually store the email address is when the
 * user sets up the system, and generates a server key pair. Hence, we need
 * to retrieve the public key for the server, then retrieve the key declaration
 * matching that from our public keys in the database, and return that email
 * address to the caller.
 */
signal:magic.crypto.get-server-public-key

// Opening up our database connection.
data.connect:[generic|magic]

   /*
    * Reading email address from crypto_keys matching fingerprint of public key
    * retrieved above.
    */
   data.read
      table:crypto_keys
      columns
         email
         subject
      where
         and
            fingerprint.eq:x:@signal/*/fingerprint

   // Returning result to caller.
   unwrap:x:+/*
   return
      email:x:@data.read/*/*/email
      name:x:@data.read/*/*/subject
