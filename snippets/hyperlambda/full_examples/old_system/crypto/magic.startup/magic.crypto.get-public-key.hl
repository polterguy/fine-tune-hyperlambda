
/*
 * This Hyperlambda snippet creates a dynamic slot named [magic.crypto.get-public-key] that returns a public RSA key and its associated [vocabulary].
 *
 * 1. [slots.create:magic.crypto.get-public-key]
 *    * Declares a new dynamic slot that will retrieve a public key and its authorized vocabulary from a database, based on a given fingerprint.
 *
 * 2. [validators.mandatory]
 *    * Ensures that the [fingerprint] argument is provided before proceeding.
 *
 * 3. [data.connect:magic]
 *    * Opens a database connection using the [magic] named connection string.
 *
 * 4. [data.select]
 *    * Executes a raw SQL query to fetch the following columns from the [crypto_keys] table:
 *      - [id]: The internal identifier of the key record.
 *      - [content] (aliased as [public_key]): The actual public RSA key.
 *      - [domain]: Associated domain of the key.
 *      - [email]: Email address associated with the key.
 *      - [vocabulary]: Whitelisted slots/functions associated with the key.
 *      - [enabled]: Flag indicating if the key is enabled (true or 1).
 *    * Filters the results using the provided [fingerprint] argument.
 *
 * 5. [if not exists:x:./././0/0]
 *    * Checks whether the query returned any result.
 *    * If not, throws a descriptive error indicating the public key was not found.
 *
 * 6. [if not or eq ...]
 *    * Verifies that the key is enabled.
 *    * Accepts both [bool:true] and [long:1] for backward compatibility.
 *    * Throws if the key is disabled.
 *
 * 7. [add] (first)
 *    * Adds fields to the return node from the selected row, including [id], [public_key], [domain], [email], and [enabled].
 *
 * 8. [add] (second)
 *    * Converts the [vocabulary] string into a lambda node using [hyper2lambda], which allows only the whitelisted slots to be executed later.
 *
 * 9. [return] / [vocabulary]
 *    * Ensures the return includes a node named [vocabulary] that contains the lambda representation of the allowed vocabulary for the key.
 *
 * Use cases:
 * * Validating a public key for signed API calls.
 * * Fetching runtime authorization data tied to specific RSA keys.
 * * Enabling dynamic function execution while enforcing strict access controls.
 */
slots.create:magic.crypto.get-public-key

   // Sanity checking invocation.
   validators.mandatory:x:@.arguments/*/fingerprint

   /*
    * Selecting key and vocabulary from database,
    * according to the specified fingerprint.
    * 
    * Notice, key needs to be enabled in order to be returned.
    */
   data.connect:magic
      data.select:select id, content as public_key, domain, email, vocabulary, enabled from crypto_keys where fingerprint = @fingerprint
         @fingerprint:x:@.arguments/*/fingerprint

      // Verifying key exists in database.
      if
         not
            exists:x:./././0/0
         .lambda

            // Public key doesn't exist in database.
            strings.concat
               .:"Public key with fingerprint of '"
               get-value:x:@.arguments/*/fingerprint
               .:"' does not exist"
            throw:x:@strings.concat

      // Verifying key is enabled.
      if
         not
            or
               eq
                  get-value:x:@data.select/*/*/enabled
                  .:bool:true
               eq
                  get-value:x:@data.select/*/*/enabled
                  .:long:1
         .lambda

            // Public key is disabled.
            strings.concat
               .:"Public key with fingerprint of '"
               get-value:x:@.arguments/*/fingerprint
               .:"' is disabled"
            throw:x:@strings.concat

      // Returning result of database invocation to caller.
      add:x:./*/return
         get-nodes:x:@data.select/*/*/id
         get-nodes:x:@data.select/*/*/public_key
         get-nodes:x:@data.select/*/*/domain
         get-nodes:x:@data.select/*/*/email
         get-nodes:x:@data.select/*/*/enabled
      add:x:./*/return/*/vocabulary
         hyper2lambda:x:@data.select/*/*/vocabulary
      return
         vocabulary
