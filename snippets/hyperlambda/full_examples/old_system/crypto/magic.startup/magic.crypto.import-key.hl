
/*
 * This Hyperlambda slot, [magic.crypto.import-key], securely imports a new RSA public key into the system, ensuring it is unique and optionally associates it with a user.
 *
 * 1. [slots.create]
 *    * Declares the slot [magic.crypto.import-key], making it available for invocation from other parts of the system.
 *
 * 2. [crypto.fingerprint]
 *    * Computes a unique fingerprint of the RSA public key passed in [content], used for validation and indexing.
 *
 * 3. [.enabled]
 *    * Defaults to `false`, but will be overwritten if caller supplies an explicit [enabled] value in the arguments.
 *
 * 4. [data.connect]
 *    * Opens a connection to the [magic] database to interact with tables like [crypto_keys] and [users_crypto_keys].
 *
 * 5. [data.read]
 *    * Verifies whether the public key already exists in the [crypto_keys] table using the computed fingerprint.
 *    * If a match is found, a [throw] halts the process, preventing duplicate imports.
 *
 * 6. [data.create]
 *    * If the key is new, it gets inserted into the [crypto_keys] table with its associated metadata (subject, domain, etc.).
 *    * The [vocabulary] column defines which slots this key is permitted to execute when invoking signed HTTP payloads.
 *
 * 7. [exists] and [data.create]
 *    * If a [username] is passed, a relationship is established between the user and the imported key in the [users_crypto_keys] table.
 *
 * Use cases:
 * * Importing third-party public RSA keys for digitally signed request handling.
 * * Controlling slot access and authorization at the key level via a secure vocabulary system.
 * * Associating keys with users for accountability and access tracking in cryptographic operations.
 */
slots.create:magic.crypto.import-key

   // Figuring out key's fingerprint.
   crypto.fingerprint:x:@.arguments/*/content

   /*
    * Checking if caller supplied en enabled argument,
    * at which point we use it, instead of defaulting its
    * value to false.
    */
   .enabled:bool:false
   if
      exists:x:@.arguments/*/enabled
      .lambda
         set-value:x:@.enabled
            get-value:x:@.arguments/*/enabled

   // Importing key into database.
   data.connect:magic

      // Checking if key exists in database from before.
      data.read
         table:crypto_keys
         where
            and
               fingerprint.eq:x:@crypto.fingerprint
      if
         exists:x:@data.read/*/*
         .lambda

            // Oops, key already exists in database.
            throw:Key has already been imported
               public:true
               status:400

      // Inserting key into database.
      data.create
         table:crypto_keys
         values
            subject:x:@.arguments/*/subject
            email:x:@.arguments/*/email
            domain:x:@.arguments/*/domain
            type:RSA
            fingerprint:x:@crypto.fingerprint
            content:x:@.arguments/*/content
            enabled:x:@.enabled
            vocabulary:@"add
return
get-nodes
vocabulary
slots.vocabulary
"

      // Checking if caller provided a username, and if, creating association.
      if
         exists:x:@.arguments/*/username
         .lambda

            // Creating association between user and key.
            data.create
               table:users_crypto_keys
               values
                  username:x:@.arguments/*/username
                  key_id:x:@data.create/@data.create
