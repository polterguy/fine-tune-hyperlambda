
/*
 * Implements a secure cryptographic authentication mechanism using signed payloads and public key infrastructure (PKI).
 *
 * 1. [.arguments]
 *    - Accepts a [challenge] string, which is expected to be a signed payload.
 *
 * 2. [crypto.get-key]
 *    - Extracts the fingerprint of the public key used to sign the challenge.
 *    - This allows lookup of the key in the [crypto_keys] table to ensure validity and trust.
 *
 * 3. [data.read] (first)
 *    - Reads the [crypto_keys] table to retrieve the actual public key content and key ID matching the extracted fingerprint.
 *    - Ensures the key is enabled before proceeding.
 *
 * 4. [crypto.verify]
 *    - Verifies the signature of the [challenge] using the previously retrieved public key content.
 *    - If the signature is invalid, an exception is thrown and processing stops.
 *
 * 5. [cache.get]
 *    - Ensures that the challenge corresponds to a known valid session marker ("VALID") to mitigate replay attacks.
 *    - If it does not match, the process is aborted with an HTTP 401 Unauthorized error.
 *
 * 6. [data.read] (second)
 *    - Uses the verified key ID to find the associated username from the [users_crypto_keys] mapping table.
 *
 * 7. [signal:magic.auth.authenticate]
 *    - Issues a JWT token for the associated user without checking password credentials (passwordless auth).
 *
 * 8. [cache.set]
 *    - Invalidates the challenge key in cache to enforce one-time use and prevent replay attacks.
 *
 * 9. [return]
 *    - Returns the JWT token to the caller under the [result] node.
 *
 * This logic provides a stateless authentication system using cryptographically signed payloads and enforces strict one-time use guarantees.
 */
.arguments
   challenge:string

// Retrieving public key used to sign challenge payload.
crypto.get-key:x:@.arguments/*/challenge

// Logging
log.info:Cryptography challenge for authenticating submitted
   key:x:@crypto.get-key

// Opening up database connection.
data.connect:magic

   // Retrieving public key's used to cryptographically sign payload.
   data.read
      table:crypto_keys
      columns
         content
         id
      where
         and
            fingerprint.eq:x:@crypto.get-key
            enabled:bool:true

   /*
    * Verifying challenge was correctly signed with the key retrieved above.
    * 
    * This part will throw an exception unless the signature is good.
    */
   crypto.verify:x:@.arguments/*/challenge
      public-key:x:@data.read/*/*/content

   /*
    * Ensuring the payload that was cryptographically signed still exists
    * in memory cache.
    */
   cache.get:x:@crypto.verify
   if
      not
         eq
            get-value:x:@cache.get
            .:VALID
      .lambda

         // Challenge has expired.
         throw:Access denied
            public:true
            status:401

   // Looking up user associated with public key.
   data.read
      table:users_crypto_keys
      columns
         username
      where
         and
            key_id.eq:x:@data.read/@data.read/*/*/id

   // Creating a JWT token for the above user.
   unwrap:x:+/*/username
   signal:magic.auth.authenticate
      check-password:bool:false
      username:x:@data.read/*/*/username

   // Clearing challenge out of memory cache to avoid replay attacks.
   cache.set:x:@crypto.verify

   // Returning JWT token to caller.
   unwrap:x:+/*
   return
      result:x:@signal/*/ticket
